@@@
1
00:00:02,240 --> 00:00:14,660
Discourse will give you a perspective of software engineering from someone who has been involved in software development for over 20 years. Let's start with the main reasons you should consider a software development as a profession.

2
00:00:15,350 --> 00:00:30,350
Reason number one, the job outlook and salaries are fantastic. Software development is an exciting and rewarding field. You can get paid really well. And the job security is exceptional as we rely more and more on technology.

3
00:00:30,650 --> 00:00:41,660
The need for software systems is on the rise, and companies are consistently looking for developers. Reason number two. The job is rewarding on many levels.

4
00:00:42,670 --> 00:00:56,110
Employers are willing to pay higher starting salaries and provide various job perks, such as flexible working hours, remote work and free access to online courses to attract and retain the most talented people.

5
00:00:56,320 --> 00:01:07,630
Competitive tech companies also offer free catered lunches, laptops and cell phones, gym memberships, stock purchase plans and generous employee benefit packages.

6
00:01:08,960 --> 00:01:24,890
Reason number three, you will never get bored. If you enjoy learning and trying out new things, software development will fit you like a glove. New programming languages are emerging and software libraries and frameworks are being published frequently.

7
00:01:25,430 --> 00:01:37,490
You can learn Python in one month and pick up C++ in the next month as a developer. You will keep updating your scores and discover new techniques that will help you write better, more efficient code.

8
00:01:37,970 --> 00:01:47,660
There is always something to learn in software development, and the best part you will get to solve non-trivial problems and build software systems from scratch.

9
00:01:48,530 --> 00:02:00,020
Now is the perfect time if you want to switch careers into software engineering. I created this course to help you make the transition. The course contains a ton of practical knowledge.

10
00:02:00,560 --> 00:02:10,280
I reveal behind the scenes secrets about software development and the everyday life of a programmer. In addition, I teach you essential coding skills using Python.


@@@
1
00:00:02,266 --> 00:00:14,733
There are some widespread misconceptions about software development. Some of them are so subtle that you won�t realize the truth till you spend some time in this industry.

2
00:00:14,733 --> 00:00:32,766
Myth#1: You Need a Computer Science Degree While a CS-degree is nice-to-have, it is not required to work as a software developer. Learning to program is not an opportunity exclusive to formal institutions.

3
00:00:32,766 --> 00:00:45,333
Nowadays there are plenty of online resources where you can learn to program. Some may prefer in-person programming: boot camps and private programming coaches.

4
00:00:45,333 --> 00:01:05,333
Online courses are usually less expensive than boot camps, whereas in-person teaching has the advantage of live human interaction. Myth#2: It�s Too Late to Start Age has nothing to do with making a career switch into technology.

5
00:01:05,333 --> 00:01:17,766
All you need to succeed is the drive, willingness to learn and work ethic. At coding boot camps, you�ll see students of all ages and with various backgrounds.

6
00:01:17,766 --> 00:01:38,733
Some may have little to no programming experience. Your success in the classroom and after graduation is directly related to the work you put in. It goes without saying that one who has no programming experience should start with the basics, and gradually learn more advanced topics.

7
00:01:38,733 --> 00:01:54,733
Myth#3: You Need to Be a Math Genius A good programmer needs strong problem-solving skills, logic and a lot of patience. However, serious math skills are rarely required.

8
00:01:54,733 --> 00:02:13,266
You should familiarize yourself with some core algorithms and data structures. Other than that, you�ll usually do just fine with basic algebra unless you work on special projects which require sophisticated algorithms and advanced math.

9
00:02:13,266 --> 00:02:27,566
Myth#4: You Need to Learn the Best Programming Language Now, the reality is that you can't compare programming languages. At least, not without providing more context.

10
00:02:27,566 --> 00:02:47,533
First, you should be clear about your goals. Say you want to become an iOS developer. Then, you shouldn�t start learning Ruby. Swift or Objective-C is the way to go! Besides, if you start from scratch, the programming language doesn't really matter.

11
00:02:47,533 --> 00:02:59,966
You can pick any modern language to learn the fundamentals of programming. Once you master those basics, learning a new programming language won�t be a challenge anymore.

12
00:02:59,966 --> 00:03:17,266
Myth#5: You Are Done Learning In certain professions, you can gather the required expertise over the first couple of months or years. After that, you�ll do fine without having to learn new stuff.

13
00:03:17,266 --> 00:03:32,233
Well, this isn't true for software development. Technology is rapidly evolving, and you have to keep your knowledge up-to-date. New programming languages appear while others fade to dust.

14
00:03:32,233 --> 00:03:53,033
Popular frameworks and SDKs become obsolete overnight. Well-known hardware or software platforms suddenly disappear, and new ones emerge. If you choose software development, be open and prepared to learn new technologies and programming languages consistently.

15
00:03:53,033 --> 00:04:05,900
Some words of advice: The road to becoming a good software developer is long and bumpy. You�ll need time and patience, but the outcome is definitely worth it.


@@@
1
00:00:02,000 --> 00:00:15,266
Now that we broke the stereotypes about becoming a programmer, let�s debunk some software development myths. Myth#1: Software development means writing a lot of source code.

2
00:00:15,266 --> 00:00:32,933
Indeed, typing code is important. Yet, there are plenty of other activities involved in the software development process. Just to list a few: - Meetings they may eat up a significant portion of a software developer�s workday.

3
00:00:32,933 --> 00:00:47,900
Whether we like it or not, meetings will happen. Team habits, company culture, the chosen methodology and various other factors can influence the length and the frequency of meetings.

4
00:00:47,900 --> 00:01:03,900
Communication - you�ll need to respond to emails, phone calls, messages on Slack, Skype and so on. Also, Agile methodologies require a fair amount of communication between team members.

5
00:01:03,900 --> 00:01:20,033
Software quality assurance. What that actually means is that you�ll have to implement and execute all kinds of tests - for example unit tests, performance tests, usability tests and so on.

6
00:01:20,033 --> 00:01:32,566
Documentation Writing and reviewing documents is also an integral part of a software developer�s work. For instance, you�ll need to document your code.

7
00:01:32,566 --> 00:01:50,233
it may sound boring at first, but code comments - if done right - are one of the most useful resources produced by developers for developers. Trying to find out what a code actually does can become a daunting task if there are zero comments.

8
00:01:50,233 --> 00:02:06,866
As your job responsibilities grow, you�ll need to write various technical documents like developer guides or design documents. I�m going to talk in more detail about some of these activities in the upcoming lectures.

9
00:02:06,866 --> 00:02:24,933
Myth#2: Customers Know What They Want. The truth is usually exactly the opposite. Most customers have only a vague vision of their product. And if you�re not aware of this fact, you�ll learn it the hard way.

10
00:02:24,933 --> 00:02:45,133
Here�s an example to illustrate what I mean - it�s an actual job posting from Upwork: �Looking to create the next big social media platform for IOS and Android� While this is quite an extreme example, be prepared to meet similar customers and project descriptions.

11
00:02:45,133 --> 00:02:57,933
How should you handle situations like this? There are some simple rules that may help: - Create draft plans and visual mockups of the product before actually creating it.

12
00:02:57,933 --> 00:03:15,900
By doing so, you�ll save a lot of time, energy and frustration. - Have frequent checkpoints, reviews with the customer. Involving the customer early on ensures that the software evolves as they originally envisioned it.

13
00:03:15,900 --> 00:03:29,933
Even if there were serious misunderstandings, you only have to throw away the work done since the last review. - Be honest. Many factors can influence the original deadline or budget.

14
00:03:29,933 --> 00:03:43,266
Unexpected issues, technical debt, sudden shortage in resources are not uncommon. Yet customers may be unaware of them, so the sooner you let them know, the better.

15
00:03:43,266 --> 00:03:58,300
Myth#3: Software Can Be Estimated Accurately. Software estimations are essential since the both customer, and the development team must make decisions based on it.

16
00:03:58,300 --> 00:04:10,300
Predictions are usually only accurate when making near-term forecasts. Unfortunately, in the case of software projects, we are asked for long-term estimations.

17
00:04:10,300 --> 00:04:36,100
Although everybody admits that estimations are inaccurate, we�ll suffer the consequences of missing our deadlines. These consequences include, but are not limited to: - Loss of credibility - Frustration, internal team friction - Poor morale, particularly when the team has to work excessive hours to meet a delivery.

18
00:04:36,100 --> 00:04:52,500
- Low-quality software - if developers sacrifice quality to complete the job. - And even project failure when estimations are consistently off, and the customer has completely lost faith in your team's ability to deliver.

19
00:04:52,500 --> 00:05:06,300
Myth#4: The Mythical Man Month The "Mythical Man-Month" represents the idea that adding people to a development team makes it more efficient in a linear fashion.

20
00:05:06,300 --> 00:05:22,833
In fact, adding more programmers to a project falling behind schedule delays the project even further. Why is that? Complex projects cannot be split into discrete tasks that can be worked on without communication.

21
00:05:22,833 --> 00:05:40,633
With every newly added developer, the communication overhead increases. Also, the newcomers need time to learn about the project. Thus, they�ll ask their more insightful colleagues, who in turn will spend less time developing the product.

22
00:05:40,633 --> 00:05:52,366
All these add up and consume an even larger quantity of the available time. The output of the team decreases further with every newly added programmer.


@@@
1
00:00:02,000 --> 00:00:16,833
Let�s check out which are the most frequent activities involved in the process of creating software products. Collect and analyze requirements Requirements can come from a customer, a colleague, or from another team.

2
00:00:16,833 --> 00:00:30,400
Depending on the stakeholder, requirements can be well-defined, vague, or utterly misleading. If a need is well understood, chances are the client eventually receives what they wanted.

3
00:00:30,400 --> 00:00:43,300
Validate ideas, perform feasibility studies Regardless of whether all requirements are well-defined and crystal clear, some may be impossible to implement.

4
00:00:43,300 --> 00:01:01,633
Technology constraints, lack of expertise, resource issues and other unforeseen problems may prevent us from delivering the product. Thus, it is imperative to double-check whether we can achieve what the stakeholders expected.

5
00:01:01,633 --> 00:01:14,533
Define the architecture The architecture of a software product or system is its blueprint. It defines the static structures and the interactions between the components.

6
00:01:14,533 --> 00:01:24,433
Creating prototypes and doing proof of concept work is sometimes also required, especially if the team has no prior experience with the given technology.

7
00:01:24,433 --> 00:01:38,100
Implement & test The implementation phase should also involve writing unit tests and sample applications. Thorough testing ensures that severe bugs don�t slip through.

8
00:01:38,100 --> 00:02:00,400
Testing is a crucial part of the development process. Nobody can guarantee quality without validating the software. Create documents and guides For software products, there can be many types of documents: design documents, test scenario descriptions, user guides, API documentation, just to name a few.

9
00:02:00,400 --> 00:02:20,633
Not all software projects require all of them, and the type of documentation also depends on the development methodology of choice. Release, Support and Maintenance Once the software is tested and ready for release, there are still a lot of other things to watch out for.

10
00:02:20,633 --> 00:02:31,800
Depending on the product, there may be marketing, packaging and distribution related tasks. Resources should be allocated for support and maintenance.

11
00:02:31,800 --> 00:02:44,800
No software is completely bug-free. Besides, customers may ask for improvements and enhancements. Now, the bottom line is this: A developer needs to handle various tasks.


@@@
1
00:00:02,000 --> 00:00:22,633
You wouldn�t start cooking a meal without a recipe. Similarly, the development of a software product also requires some sort of step-by-step plan. The process which describes the steps needed to build the software from start to finish is what we call software development methodology.

2
00:00:22,633 --> 00:00:36,033
Like cooking a meal without a recipe, ad-hoc software development leads to problems. Without a plan the software quality will suffer, deadlines won�t be met and costs will get out of control.

3
00:00:36,033 --> 00:00:55,266
Thus, every software development company or startup uses a development process. Over time, many different methodologies have been invented. Since projects have different needs, choosing the right approach is not always an easy decision to be made.

4
00:00:55,266 --> 00:01:14,733
In the upcoming lectures, we�re going to talk about the plan-driven Waterfall model and the change-friendly Agile approach. Here�s a formal definition: A software development methodology describes how to organize the activities involved in the software development process.

5
00:01:14,733 --> 00:01:28,566
To summarize: software development methodologies are collections of best practices. By applying these practices, your project will go smoother and you�ll increase the chance of completing it.


@@@
1
00:00:02,000 --> 00:00:22,433
The Waterfall is a linear model. It defines development steps or phases. You start executing one step, complete it and then start the next one. This approach gives us a steady, downward order - hence the name "Waterfall." The development process flows in cascades.

2
00:00:22,433 --> 00:00:33,600
Each development phase requires the previous one to be completed. Let�s talk a bit about these phases. First, we collect and analyze the requirements.

3
00:00:33,600 --> 00:00:47,933
The expected functionality of the future application must be clarified with the stakeholders. All the details must be documented thoroughly. This very first phase is probably the most important one.

4
00:00:47,933 --> 00:00:58,900
When done right, the Waterfall model will produce the expected outcome. After collecting and analyzing the requirements, we can proceed to the next phase.

5
00:00:58,900 --> 00:01:13,233
Here�s where we define the overall design of our software. Defining the architecture is like creating the blueprint for a building. Thus, the design should be as clear and detailed as possible.

6
00:01:13,233 --> 00:01:59,233
The bottom line is this: the team should be able to implement the product based on this plan. We should address questions like: "Which packages or components will form our system?" "What are the fundamental types of each component?" "How do these types interact with each other to achieve the required functionality?" "Is our software secure?" "How about performance?" "How does our software respond to errors?" "How do we handle edge cases?" "Should we extend our system in the future?" "Which third-party components do we use?" And the list can grow or shrink depending on the requirements we defined in the previous phase.

7
00:01:59,233 --> 00:02:11,233
The implementation comes next. The software development phase is usually divided into smaller units. Each unit is then implemented and tested by developers.

8
00:02:11,233 --> 00:02:24,366
Once the development phase is completed, the product undergoes the verification phase. During this step, the software is evaluated based on predefined criteria.

9
00:02:24,366 --> 00:02:40,933
We must check whether the product provides the functionality we agreed on. Tests are executed to ensure that the software works as expected. We test for functional, performance, security and usability issues.

10
00:02:40,933 --> 00:02:56,933
Detected problems are recorded and fixed. The process goes on until all severe bugs are fixed. The verification phase may also bring to surface deeper bugs and critical issues that may affect the planned release.

11
00:02:56,933 --> 00:03:10,100
As soon as the testing phase completes and the given version is delivered, the software enters the maintenance phase. By definition, the maintenance phase is about fixing smaller bugs.

12
00:03:10,100 --> 00:03:28,100
But more often than not, it may also include functional enhancements. The client may come up with new requirements that involve substantial changes. You may feel tempted to squeeze in �just one more patch� in the maintenance phase.

13
00:03:28,100 --> 00:03:46,666
Now, this is usually a bad idea. In this case, we need to set up a new waterfall project and repeat all the steps. The Waterfall model is used for life-control, medical and military systems.

14
00:03:46,666 --> 00:04:02,833
This model requires us to clarify all the requirements and create a detailed plan upfront. We can use the Waterfall if all requirements are precisely defined and won�t change over time.

15
00:04:02,833 --> 00:04:18,966
The Waterfall has received some well-deserved criticism for its inability to respond to changes. Due to its linear structure, new requirements can�t be considered at later phases of the development process.

16
00:04:18,966 --> 00:04:33,466
If the client changes their mind frequently, or our design misses essential aspects, we�re going to hit problems during development or testing. In such cases, we should follow a different approach.


@@@
1
00:00:02,000 --> 00:00:19,166
In this clip, we're going to talk about the pros and cons of the Waterfall model. Let�s first see the benefits of using the Waterfall. This model requires clarity on almost every detail before writing a single line of code.

2
00:00:19,166 --> 00:00:38,033
This approach has a huge benefit. The detailed design document leaves no room for misunderstandings. In order to come up with a detailed design, the architect has to perform a thorough analysis on all the features and requirements for the given the software product.

3
00:00:38,033 --> 00:00:55,100
While this can be challenging and time-consuming, it has the benefits of spotting most of the issues that otherwise may appear later. By identifying the problems early on, we can reduce redesign and bug-fix costs at later stages.

4
00:00:55,100 --> 00:01:07,766
Note however, that no methodology can guarantee bug-free software. The other benefit of having a detailed, up-to-date design document is that information is not lost.

5
00:01:07,766 --> 00:01:20,566
The team setup usually changes over time. Imagine what happened if the senior architect, who was in charge to oversee the entire software project, suddenly leaves the company.

6
00:01:20,566 --> 00:01:40,033
If all the knowledge were only in his head, those who take over the project would have to reverse-engineer the project based on the source code. For large, complex projects this may take up to several weeks! The Waterfall Model is not well-suited for abrupt changes.

7
00:01:40,033 --> 00:01:53,033
It is based on the assumption that both the requirements and the design can be defined at early stages. This can lead to carving in stone some assumptions which may become obsolete later on.

8
00:01:53,033 --> 00:02:07,633
The customer may change their mind and ask for new features that do not fit well in the original set of features. A customer who precisely knows what they want is every software professional�s dream to come true.

9
00:02:07,633 --> 00:02:27,000
Unfortunately, this rarely happens in real life. Deciphering what the�customers really want can be more challenging than you�d imagine. Therefore, coming up with a precise and clear set of requirements is time consuming and even impossible in some cases.

10
00:02:27,000 --> 00:02:43,233
If the requirements cannot be clarified within a certain amount of time, an Agile methodology may be a better choice. Another caveat of the Waterfall model is the big initial investment that is required to create a detailed design.

11
00:02:43,233 --> 00:02:59,000
Up to 40% of the overall development time may be spent on architecture definition early in the software development cycle. Besides, the development can't go in parallel with the design definition work.

12
00:02:59,000 --> 00:03:13,866
Now that we know the pros and the cons of the Waterfall model, let�s see what kind of projects is it best suited for. If you know quite exactly what has to be built, then you can safely rely on the Waterfall model.

13
00:03:13,866 --> 00:03:31,033
All the pros we brought up will make your life easier. You can�t go wrong with the Waterfall if you have a product that is firm and stable. Typically mature or legacy projects which have a stable feature set fall into this category.

14
00:03:31,033 --> 00:03:53,433
Go for the Waterfall model if the likelihood of unexpected feature requests is low. If the environment your software is using or relying on - like the platform, the SDK, the hardware, follows a stable, predictable path, and every information is available, then you can�t go wrong with the Waterfall.

15
00:03:53,433 --> 00:04:16,531
For the Waterfall to work, preconditions must be met. This includes the capability to clarify vague requirements ability to write detailed design documents, in-depth understanding and knowledge of UML and design patterns, quality-awareness and willingness to write clean code based on a design document.


@@@
1
00:00:01,966 --> 00:00:17,500
Agile is a relatively new approach to software project management. It all began with the agile manifesto in 2001. This manifesto was an attempt to end the proliferation of methodologies that had developed.

2
00:00:17,500 --> 00:00:31,533
The agile manifesto defines four values. Individuals and interactions over the processes and tools. This doesn't mean that we won't use processes and tools in agile projects.

3
00:00:31,533 --> 00:00:48,600
We still need tools and processes, but they shouldn�t prevent us from implementing the required features or changes. Instead of enforcing people to follow a rigid process, we basically implement a process that�s adaptive and responds to changes.

4
00:00:48,600 --> 00:01:02,933
Working software over comprehensive documentation. This doesn't mean that agile projects don't use documentation at all. We should create documentation where it provides value.

5
00:01:02,933 --> 00:01:13,966
There�s no need to create extensive documentation just for the sake of it. Customer collaboration over contract negotiation. Don't get this wrong either.

6
00:01:13,966 --> 00:01:29,500
Agile projects also require contracts to manage customer expectations about costs and schedules. But unlike for plan driven projects, there is a spirit of partnership between the development team and the customer.

7
00:01:29,500 --> 00:01:41,500
Due to the somewhat uncertain nature of agile projects, both parties acknowledge that some requirements and details may need to be redefined or clarified further as the project progresses.

8
00:01:41,500 --> 00:01:58,666
It goes without saying that this kind of partnership requires collaboration and trust. Responding to change over following a plan. Agile is different from plan-driven approaches, and provides more flexibility compared to the Waterfall model.

9
00:01:58,666 --> 00:02:09,833
The major difference is that agile welcomes changes even at the later phases of the development cycle. Some planning is also required for agile projects.

10
00:02:09,833 --> 00:02:27,033
But, we don't try to come up with a detailed plan for the entire project prior to starting any development activities. As a consequence we're not blocked until all the requirements are clarified and each and every question gets answered.

11
00:02:27,033 --> 00:02:43,166
Now let's talk about how an Agile approach solves the problem we saw with the Waterfall. The main idea behind Agile is that we can deliver functional software iteratively instead of delivering the entire project all at once.

12
00:02:43,166 --> 00:02:58,333
The work is broken up into shorter chunks called sprints. The Sprint is usually two to four weeks long. At the end of each sprint the team should provide something that's an improvement over the previous sprint�s outcome.

13
00:02:58,333 --> 00:03:14,500
This interactive approach provides an opportunity to frequently review the product that�s being developed. Stakeholders have a chance to evaluate the software and provide their feedback early on rather than waiting for the final product to be delivered.

14
00:03:14,500 --> 00:03:29,100
These frequent checkpoints are super useful as they ensure that the project evolves in the right direction. Unlike the waterfall, agile methodologies do not separate testing from development.

15
00:03:29,100 --> 00:03:45,200
Testing is tightly integrated with development and the entire team owns the responsibility for the quality of the product. Also involving the business users in the development process stands at the core of agile approaches.

16
00:03:45,200 --> 00:03:57,500
There�s a strong relationship between the project team and the stakeholders and business users. This model works best in situations where the requirements can't be defined upfront.

17
00:03:57,500 --> 00:04:13,400
Agile is a good fit for software projects that are depending on many uncertain factors and changes are to be expected. One of the big benefits of this collaborative model is that it usually leads to higher customer satisfaction.

18
00:04:13,400 --> 00:04:29,600
Also, team members will likely be more motivated by engaging customers directly. Note that Agile is not a methodology but rather a way of thinking defined by the Agile Manifesto values and principles.


@@@
1
00:00:02,000 --> 00:00:17,966
Let�s talk about the pros and cons of the Agile approach. The Agile Model takes an iterative approach to development with regular feedback intervals. This makes it possible to consistently produce quick results.

2
00:00:17,966 --> 00:00:30,866
These quick iterations give the team the ability to adapt to new requirements or market changes quickly. Obviously abrupt changes need more effort than subtle ones.

3
00:00:30,866 --> 00:00:46,066
Customers are usually happy for being involved in the software development process. Although this may have additional costs, the benefits are high. The customer can track and influence the evolution of the software product.

4
00:00:46,066 --> 00:00:58,300
This guarantees that less amount of work must be thrown away or rolled back if some requirements are misunderstood. Agility doesn�t come without some drawbacks and pitfalls, though.

5
00:00:58,300 --> 00:01:12,733
Estimations are often a guess-work. For large, complex software products, it is challenging to estimate the required time and effort, especially at the beginning of the software development lifecycle.

6
00:01:12,733 --> 00:01:25,166
Often, numbers are given based on individual gut-feeling estimates. Customer involvement and close collaboration between team members is time-consuming.

7
00:01:25,166 --> 00:01:43,033
Besides, team members should have the willingness and skills to properly communicate with the customer and with each other. Members of agile teams should be experienced enough in order to quickly adapt to changes and to be capable of taking the required decisions.

8
00:01:43,033 --> 00:01:57,033
So, both professional and soft-skills are needed. Although embracing changes stands at the core of the Agile model, frequent and abrupt changes can affect the team�s morale and productivity.

9
00:01:57,033 --> 00:02:14,333
The project can easily get off-track if the customer can�t clarify what they want. Too little documentation can lead to maintenance, communication and knowledge sharing issues - especially if key members leave the team.

10
00:02:14,333 --> 00:02:26,333
With all that said, Agile Software Development is well-suited for projects where: - Requirements are incomplete or can't be clearly defined at early stages of development.

11
00:02:26,333 --> 00:02:39,466
- Scope can change frequently This can happen for various reasons, for example, due to technology/hardware changes, or because the client is undecided.

12
00:02:39,466 --> 00:02:58,866
- Clients must be integrated in the software development process For example, the customer triggers some features as they progress with their own product - Technology is unknown or not well-documented, and requires a lot of experimenting, proof-of-concept work.

13
00:02:58,866 --> 00:03:13,033
Customers rarely have the required technical background to precisely define what they want from a software product. Therefore, for many project situations, the advantages of agile development outweigh the disadvantages.


@@@
1
00:00:01,900 --> 00:00:15,266
Waterfall is usually perceived as rigid and bureaucratic compared to Agile methodologies. However, both have their place. There are cases where a plan driven methodology won�t work.

2
00:00:15,266 --> 00:00:27,966
If the level of uncertainty is high and not all questions can be answered right away, then you should probably choose an agile methodology. For other projects, a waterfall-like approach will be a better fit.

3
00:00:27,966 --> 00:00:41,333
And actually waterfall is still widely used. Let me give you some examples. When developing a weapons control system, the requirements should be clarified in advance and need to be stable.

4
00:00:41,333 --> 00:00:54,033
Changing the requirements midway would increase the costs considerably - and these kinds of projects are expensive anyway. A Waterfall approach makes perfect sense in this case.

5
00:00:54,033 --> 00:01:06,766
And here�s another example from Upwork: �Looking to create the next big social media platform for IOS and Android� Now, coming up with a detailed plan based on assumptions wouldn�t make sense.

6
00:01:06,766 --> 00:01:16,433
The description is vague and the customer won�t be able to describe precisely what they need. This high level of uncertainty calls for an agile approach.

7
00:01:16,433 --> 00:01:31,533
Creating �the next big social network� will require multiple iterations. So, to sum it up: You should use the Waterfall when you know what the final product should be, and clients can�t change the scope of the project.

8
00:01:31,533 --> 00:01:44,632
Agile methodologies should be used when there�s a lot of uncertainty involved, the requirements are vague or rapidly changing and clients can�t precisely describe what the end-product should do or look like.


@@@
1
00:00:02,000 --> 00:00:16,800
Welcome to another section. In this section, I’m going to talk about two popular agile frameworks: Scrum and Kanban. Let’s start with Scrum. In this episode, I’ll walk you through the basic concepts of Scrum.

2
00:00:16,800 --> 00:00:30,533
In the upcoming episodes, we’ll dig into more details. Alright, so what’s SCRUM? The term “Scrum” comes from Rugby. It’s a method of restarting the play that involves players packing closely together.

3
00:00:30,533 --> 00:00:44,100
This collaborative model works well also in the software industry. Scrum was introduced in software development with the goal to create a simple, straightforward framework for completing complex projects.

4
00:00:44,100 --> 00:00:59,866
Here’s the formal definition: Scrum is a way to organize team work around agile principles. The work is organized in short, sustainable bursts of activity called sprints. A sprint is usually 2 weeks long.

5
00:00:59,866 --> 00:01:13,133
The sprints should not be longer than 2-3 weeks. Keeping the sprint short ensures that the project
is evolving in the right direction. Longer sprints increase the chance that work must be undone.

6
00:01:13,133 --> 00:01:27,733
We’ll talk more about the sprint in the next episode. Scrum is an Agile framework. Therefore, for each sprint, plenty of time is allocated for communication, planning and review activities.

7
00:01:27,733 --> 00:01:39,733
Scrum Teams. A Scrum Team typically consists of around five to nine people. Less than 5 people may not have enough variety of skills to complete all tasks.

8
00:01:39,733 --> 00:02:00,033
More than nine team members will cause communication overhead. And trust me, I have proof for that. Scrum Team Roles. There are three distinct roles in Scrum: Product Owner, Scrum Master, and Team Member The Product Owner. The product owner represents the customer.

9
00:02:00,033 --> 00:02:11,433
Her duty is to clarify what the client really wants. As I mentioned already: Depending on their background, customers may not be able to define precisely what they want.

10
00:02:11,433 --> 00:02:33,766
It is not uncommon to hear: "We need an iPad app for our web shop." Backend, REST API? What's that? I don’t care, just build that iPad app for me! The product owner is in charge to make sure that the customer gets what he really needs, and the team understands what they have to build.

11
00:02:33,766 --> 00:02:46,700
The Product Owner holds the vision of the product. What that means is that she communicates a lot with the client. She clarifies and documents the client’s needs and expectations about the software product.

12
00:02:46,700 --> 00:03:01,100
The product owner also owns the product backlog. She’s responsible for prioritizing the user stories in the product backlog. User stories are used to describe product features from the user’s perspective.

13
00:03:01,100 --> 00:03:14,766
The product owner creates the acceptance criteria for the backlog items. This is basically a checklist which defines what has to be completed in order to mark a backlog item finished.

14
00:03:14,766 --> 00:03:26,333
The list usually contains criteria related to software quality, like for example unit test coverage, performance tests, requirements related to documentation and so on.

15
00:03:26,333 --> 00:03:39,866
The product owner should be able to clarify questions coming from the team. She’s the bridge between the team and the client, so she knows a lot of details about the expected feature set and eventual changes.

16
00:03:39,866 --> 00:03:55,766
Remember, this is an agile framework. Nothing is carved in stone and things might change quickly. A product owner must inform the team about upcoming changes, deviations from the original plan and new features in a timely manner.

17
00:03:55,766 --> 00:04:08,133
The Scrum Master. The Scrum Master acts as a coach and coordinates work within the team. The Scrum master is a peer position, except it has different responsibilities.

18
00:04:08,133 --> 00:04:26,766
He is not a ‘boss’ by any means - although this is misinterpreted in many cases. His roles: Facilitator The scrum master is constantly available to help the team in removing any blockers or impediments that are preventing them from doing their work.

19
00:04:26,766 --> 00:04:44,766
Guardian. The Scrum master acts as a guardian, so that unimportant, disturbing events do not reach the team. Coach. The Scrum Master is responsible for guiding the team to higher levels of self-organization, cohesiveness and performance.

20
00:04:44,766 --> 00:04:59,266
Scrum expert and advisor The Scrum Master helps the team in applying scrum and agile practices. Team Members Scrum team members have complete authority over how project goals are achieved.

21
00:04:59,266 --> 00:05:13,466
This also means responsibility and assumes that each member has the required know-how and the capability to take decisions. Team member roles: Team members provide and own the estimates.

22
00:05:13,466 --> 00:05:30,533
The product owner is responsible for clarifying and prioritizing the user stories. If a user story is unclear, it cannot be subject to estimation. How could you tell the amount of work needed to complete a task if you don’t understand the task?

23
00:05:30,533 --> 00:05:42,300
Yet, it is not uncommon that we must provide estimates based on gut-feelings - which usually doesn’t end well. The team members define how to do the work.

24
00:05:42,300 --> 00:06:00,166
Nobody outside the team shall interfere with that. The team completes user stories. This activity involves development, writing of unit tests, testing, fixing bugs, writing documentation, DevOps activities and so on.

25
00:06:00,166 --> 00:06:14,533
The team self-organizes to get the work done. If they need to talk, they can organize ad-hoc meetings. Or sit together and do some pair-programming. Conduct code reviews or discuss design alternatives.

26
00:06:14,533 --> 00:06:35,933
A Scrum team does not need a manager to organize meetings. They should be able to decide whether such a discussion is required. The Scrum team is cross-functional, therefore it does not include exclusively developers. In a Scrum team, we’ll typically see developers, designers, testers and DevOps engineers.

27
00:06:35,933 --> 00:06:53,566
DevOps engineers are responsible for software deployment, build infrastructure and network operations. Alright, so these were the basics of Scrum. In the next episode I’m going to show you how the actual work is organized in Scrum.


@@@
1
00:00:02,000 --> 00:00:14,166
Alright, so let�s talk about how actual work is organized and done in Scrum. In Scrum, we work in sprints. The sprint is a 2-3 week long development cycle.

2
00:00:14,166 --> 00:00:26,566
A project consists of multiple sprints. For example, if a software system took three months to be completed, that means about six sprints. The sprint stands at the heart of Scrum.

3
00:00:26,566 --> 00:00:37,166
Sprints follow each other without interruption until the project is finished. Each sprint starts with a planning phase, followed by development related activities.

4
00:00:37,166 --> 00:00:47,433
At the end of the sprint, there is a sprint review. The team shows what they�ve achieved during the sprint. And the customers can provide their feedback about the product.

5
00:00:47,433 --> 00:01:07,666
Finally, there is a retrospective meeting. This is where the team discusses what went wrong and what went well during the sprint. Although a good Scrum team is consistently looking for improvement opportunities, the retrospective meeting is a dedicated opportunity to reflect on how the team is doing and for finding ways to improve.


@@@
1
00:00:02,000 --> 00:00:18,800
Each sprint starts with a sprint planning. The planning actually consists of two parts: the first one is about understanding the sprint goals. The second meeting is about breaking down the sprint goals to manageable units of work and providing estimations.

2
00:00:18,800 --> 00:00:29,900
During the sprint goal meeting, the product owner discusses the sprint goals with the scrum team. The product owner tells what she’d like to see completed by the end of the sprint.

3
00:00:29,900 --> 00:00:41,833
She shares a list of prioritized topics - usually user stories - with the team. The team and the scrum master can ask questions and collaborate with the product owner to come to a good understanding of the sprint goals.

4
00:00:41,833 --> 00:00:53,533
If the goals are clear, the team can continue with the sprint estimation meeting. The product owner does not have to join this meeting. By now she should’ve clarified everything with the team.

5
00:00:53,533 --> 00:01:05,800
During the effort estimation meeting, the team breaks down the user stories into smaller units of work called backlog items. A backlog item must be small enough to be completed within a sprint.

6
00:01:05,800 --> 00:01:18,366
Then, each backlog item is decomposed into smaller tasks. The task is the smallest unit of work. Any arbitrary team member can pick up a task and work on it independently.

7
00:01:18,366 --> 00:01:33,500
The tasks of a backlog item may or may not depend on each other. It is important to highlight the dependencies between tasks. Obviously, you can’t start working on a task if the ones it depends on are still pending.

8
00:01:33,500 --> 00:01:43,333
After estimating the prioritized list of backlog items, it should become quite clear whether all or only a subset of the backlogs fit in the given sprint.

9
00:01:43,333 --> 00:02:04,166
The team shall only commit to the amount of work that can be completed without compromising on the quality of the end result. There is even a term called “line of commitment” which is actually a horizontal line that separates the backlog items that did not fit in the current sprint from backlog items the team committed to deliver.

10
00:02:04,166 --> 00:02:15,366
Now, I’d like to emphasize one of the basic concepts of Scrum: Only the people who do the actual work know the effort it takes to complete what they committed to.

11
00:02:15,366 --> 00:02:26,200
Nobody outside the team shall modify the sprint backlog nor put pressure on the team to do more work than originally planned. The sprint backlog shall not be changed during the sprint.

12
00:02:26,200 --> 00:02:35,933
This doesn’t mean that unforeseen, serious issues must not be fixed. A good Scrum team always allocates a buffer for bug-fixes and other, unplanned issues.

13
00:02:35,933 --> 00:02:46,033
However, new backlogs must not be accepted during the sprint. If suddenly new requests pop up, it’s the responsibility of the product owner to prioritize them accordingly.

14
00:02:46,033 --> 00:02:56,900
Urgent feature requests can then be added to the list of backlog items and discussed during the next planning. Finally, I’d like to add that the sprint planning should be time-boxed.

15
00:02:56,900 --> 00:03:12,566
The sprint goal setting meeting must not be longer than one hour. And the sprint estimation meeting should not exceed sixty minutes either. If the team needs substantially more time to provide the estimates, chances are that the backlogs are not clear enough.

16
00:03:12,566 --> 00:03:24,133
Which in turn means that the goal setting meeting did not reach its goal. (pun intended). Now you know quite a bit about sprint planning. Next, I’m going to talk about the sprint.


@@@
1
00:00:02,000 --> 00:00:18,100
Once the planning is over, the team can start working on the backlog items. Each day of the sprint starts with a brief meeting called �Daily Scrum�. It is also called stand-up, as everyone should stand - which contributes to keeping this meeting short.

2
00:00:18,100 --> 00:00:32,333
How short? It depends on the team size, but shall not exceed twenty minutes. So, what�s the daily scrum about? Each team member answers three questions: - What did I work on yesterday?

3
00:00:32,333 --> 00:00:44,300
- What am I going to work on today? - Were there any issues or blockers that prevented me from doing my work? To keep the meeting short, only answer these three questions.


@@@
1
00:00:02,000 --> 00:00:12,366
Sprint reviews mark the end of each sprint. It is also called Demo, as it is the opportunity for the team to showcase what they�ve achieved in the sprint.

2
00:00:12,366 --> 00:00:23,200
The sprint review is where the stakeholders have the chance to inspect the product, and see how it evolves. The customers can provide direct feedback about the product being developed.

3
00:00:23,200 --> 00:00:37,666
Actually, the main purpose of the review meeting is to trigger a conversation between the team and the stakeholders. The product owner collects the findings of the review meeting and creates new product backlogs if needed.

4
00:00:37,666 --> 00:00:53,633
A sprint review shall not be longer than one hour per sprint week. If a sprint is two weeks long, the sprint review would be maximum two hours long. The Scrum methodology keeps the frequency and the length of meetings at a practical minimum.

5
00:00:53,633 --> 00:01:10,000
Agile is all about communication, yet useless meetings should be avoided. The retrospective. The final Scrum ceremony is the retrospective meeting. The aim of the retrospective is to improve the performance of the team.

6
00:01:10,000 --> 00:01:21,000
Team members address the following questions: - What went well during the sprint? - What could�ve gone better? - What could be improved in the next sprint?

7
00:01:21,000 --> 00:01:36,666
Ideally, the team identifies one improvement that can be implemented effectively immediately. Let me give you a real-life example. During such a retrospective, somebody brought up that our central build server has become very sluggish.

8
00:01:36,666 --> 00:01:50,433
This affected the productivity of the entire team, as we had to wait for the build server whenever we submitted a code change. The build server had to validate the new change by building the software after a code change occured.

9
00:01:50,433 --> 00:02:09,833
And the time it took to receive a green signal from the build server has been consistently increasing. A short chat with our DevOps engineer revealed the core problem: as it turned out, the server was not only building the software after each code change, but it also ran *all* unit tests.

10
00:02:09,833 --> 00:02:27,566
Some of these tests were very time-consuming, so no wonder that the server became laggy. After spotting the core problem, finding the solution was only a matter of minutes: We re-configured the build server to run the lengthy unit tests once every night.

11
00:02:27,566 --> 00:02:39,000
The results were automatically e-mailed to each team member. This brought a measurable boost to the overall team performance - and saved some money on electric bills, too.

12
00:02:39,000 --> 00:02:54,966
By now, you should have a good understanding of Scrum. Agile methodologies and Scrum are quite widespread nowadays, so you�ll probably find this knowledge useful when you start working in the industry - which I hope is going to happen soon if you�re not already there.

13
00:02:54,966 --> 00:03:04,699
In the next lecture, I�m going to talk about the burn-down chart - which represents an easy, intuitive approach to graphically track the progress of the Scrum team.


@@@
1
00:00:02,469 --> 00:00:44,700
The Kanban system was first used by Toyota to improve the efficiency of mass producing cars. The system can be applied successfully to creating software products. Producing cars consists of several processes where parts get created and handed over to the next process. If any process produces more parts than what could be used by the next production step, the excess must be stored. Stocking large amounts of unused parts result in inventory issues, inconsistencies and creation of waste. To solve this problem, Toyota created a quick response production plan, which harmonizes inventory levels with actual consumption.

2
00:00:44,740 --> 00:01:01,760
The idea was borrowed from supermarkets. A supermarket stocks the items needed by its customers based on when they are requested and in the amount needed. The customer goes to the supermarket when he needs the given products, and retrieves them in the amount required.

3
00:01:01,930 --> 00:01:15,670
If a product is overbought, the supermarket adapts by increasing the available amount of that product. On the other hand, if customers don't buy a product, the supermarket won't order more from its suppliers.

4
00:01:15,670 --> 00:01:28,390
This simple pull system avoids overproduction, waste and excessive inventory. Making only what and when is needed, in the required amount needs coordination between processes.

5
00:01:28,630 --> 00:01:44,930
Toyoda employed Kanban signs to communicate to a preceding process which parts have been used. New parts are produced on demand. This approach is also called "just-in-time." Kanban can also be applied to software.

6
00:01:44,930 --> 00:02:05,570
The process of developing software can be thought of as a pipeline. Feature requests are entering the pipeline on one end, and improved software is emerging from the other end. A bottleneck in the pipeline restricts flow; the throughput of the entire pipeline is limited to the performance of the bottleneck.

7
00:02:05,570 --> 00:02:20,910
Here's an example. If developers are only able to implement three features per development cycle, whereas the customer submits five feature requests each sprint, the throughput of the pipeline will be limited to three.


@@@
1
00:00:02,270 --> 00:00:14,110
Kanban uses a big board to visualize pending work and the current capacity assigned to the given development phase. Each column represents a phase in the development cycle.

2
00:00:14,200 --> 00:00:26,870
The cards represent work items as they flow through the development cycle. On the top of each column, there's a number representing the limits on the number of cards allowed for given phase.

3
00:00:26,890 --> 00:00:40,600
Limiting the amount of work in progress at each step in the process prevents overproduction and reveals bottlenecks on the go. There are different ways to layout Kanban boards. Feel free to adapt them to your needs.

4
00:00:40,600 --> 00:00:54,790
The simplest form has a "ToDo," "Doing" and "Done" setup, which will work nicely for one-person or straightforward projects. For more complex projects and team setup, you'll need more details.

5
00:00:54,840 --> 00:01:09,580
A typical board to cover the needs of such a setup is shown below. Note that some columns are split into "Doing" and "Done." Cards which are moved to the "Done" column can be pulled by the next phase.

6
00:01:09,620 --> 00:01:20,000
Cards are moving from "Doing" to "Done," freeing up slots in the "Doing" column. Based on the available capacity, new cards can be pulled by the given process.


@@@
1
00:00:04,970 --> 00:00:22,390
If you're new to programming, you should watch this course from start to finish. The class follows a linear path. Therefore, I'd suggest you go through every section, as skipping any parts of this material may make other parts of the course difficult to understand.

2
00:00:22,400 --> 00:00:43,420
Here's a brief roadmap of what's covered in the upcoming chapters. We start by clarifying some fundamental programming related concepts. Then, I'll give you instructions to set up the development environment required to follow and implement the coding examples. In the following chapters, we're going to delve into programming.

3
00:00:43,460 --> 00:00:55,240
We start with the basics and gradually build up the knowledge required to understand more advanced programming concepts. Throughout this course, I'll be using Python code examples.

4
00:00:55,370 --> 00:01:13,320
These examples are straightforward, and I explain everything thoroughly. Entering the code and running it yourself is the most efficient way to learn the presented concepts. You may make some mistakes as you type the code, but don't worry! The more you practice coding, the easier it becomes.


@@@
1
00:00:04,420 --> 00:00:25,710
Coding or programming is telling a computer what to do. It works by typing commands in a specific order. Every computer program consists of sequences of commands. Your mail app, the web browser, Facebook, Whats App, the games on your phone - each of them is a set of instructions.

2
00:00:25,990 --> 00:00:47,110
These instructions tell the computer to perform specific tasks, like multiplying two numbers, opening a file or making your computer beep. Some programs consist of only a few instructions, while more complex ones may contain hundreds of thousands or even millions of instructions.

3
00:00:47,350 --> 00:00:59,580
To understand how programming works, let's imagine that you want to cook an omelet. You've never cooked before, so what do you do? You start by searching for "how to cook an omelet" on the Internet.

4
00:00:59,620 --> 00:01:13,710
Then, you pick a website or a video that provides step by step instructions for cooking your meal. That's precisely how computer programs work. Programmers break down complex tasks into simple, individual steps.

5
00:01:13,960 --> 00:01:45,920
The order of these steps is critical. Just like in the case of a recipe, you'll get completely different results if you mix up the instructions. Let's assume that we can use the following instructions to navigate on a map: Move Forward, "Turn Left," and "Turn Right." Next, we built two sequences using these commands. First sequence: Move Forward, Turn Left, Move Forward, Turn Right, Move Forward.

6
00:01:49,710 --> 00:02:05,130
Second sequence: Turn Right, Move Forward, Move Forward, Turn Left, Move Forward. As you can see, the order of commands does indeed make a huge difference.

7
00:02:05,130 --> 00:02:22,750
The computer does what you tell it to do, even if the instructions do not make sense. For example, you could create the following sequence of commands, and the machine would blindly execute them: Move Forward, Move Forward, Move Forward.

8
00:02:35,530 --> 00:02:55,090
Programming mistakes may cause crashes, data corruption, performance issues, or even hardware failures. A programmer needs to know what instructions to use to achieve a particular functionality, what are the implications of using specific features or resources and how to detect and fix software bugs.


@@@
1
00:00:04,640 --> 00:00:17,120
By now you've probably got an idea of what programming is: giving directions to computers in the form of sequences of instructions. We provide these instructions using programming languages.

2
00:00:17,160 --> 00:00:34,030
When we say programming language, we usually refer to high-level programming languages like Python, Swift, C++, Java, or C#. Each programming language consists of a set of keywords and some rules for instructing the computer what to do.

3
00:00:34,070 --> 00:00:46,960
It's like the vocabulary and the grammatical rules in the case of human languages. The following code snippets look differently, yet they both convert from Fahrenheit to Celsius degrees.

4
00:00:47,070 --> 00:01:03,660
The first is a Sinclair basic program and this one is Python code. Don't worry about the syntax for now. I just wanted to show you that we can use two completely different programming languages to implement the same functionality.

5
00:01:03,680 --> 00:01:20,740
How is that even possible? Does the computer understand so many programming languages? The short answer is No. The computer, or rather its CPU - the central processing unit - can only execute machine language instructions.

6
00:01:20,990 --> 00:01:36,030
The machine code isn't something you want to use to write programs. You'd need to enter numbers instead of humanly readable instructions. Forget statements like "print" or "format," because the CPU only understand numbers.

7
00:01:36,350 --> 00:01:51,490
Besides, the machine code is hardware specific: machine language instructions that work on a CPU won't work on another model. Therefore, we need to use machine instructions that can be understood by each hardware we're targeting.

8
00:01:51,530 --> 00:02:05,900
Scary, right? But no worries! That's why high-level programming languages exist. When we execute our high-level code, it goes through a series of transformations, and eventually, the machine code gets generated.

9
00:02:06,170 --> 00:02:17,710
At this point, our program can run on the computer. Nowadays, developers don't need to look into machine code. Just make sure that your code makes sense, and it has no flaws.


@@@
1
00:00:03,530 --> 00:00:15,840
The biggest challenge when creating this course was choosing a programming language. My first thought was to pick Swift. Swift is a modern programming language, and it has a straightforward syntax.

2
00:00:15,840 --> 00:00:29,420
The code written in Swift is easy to read, and it's perfect for beginners, given all the tools Apple provide. Besides, its open-source. So, why did I pick another programming language?

3
00:00:29,460 --> 00:00:43,880
The main reason is this: Swift is native to Apple. Therefore, it's perfect for those who own a Mac. You can even use it on Linux. However, there is no proper way to compile swift on Windows yet.

4
00:00:45,720 --> 00:01:05,570
I also considered Java. Java has been around since 1995, but it's still trendy. The TIOBE programming community index ranked Java as the most popular programming language at the time of creating this course. Java is a cross-platform, interpreted language.

5
00:01:05,570 --> 00:01:17,900
It was designed to run with the help of a Java Virtual Machine on any platform. That is, you could start programming in Java regardless if you are on a Mac, Linux or a Windows system.

6
00:01:17,900 --> 00:01:29,960
Eventually, I decided to use Python. Here's why. Python is easy to pick up, and you can learn the basics of programming quickly. Let's have a look at an example written in Java.

7
00:01:32,830 --> 00:01:45,880
And here's the same code implemented using Python. Now. which version feels more natural? Python is one of the easiest programming languages out there.

8
00:01:45,880 --> 00:02:02,210
Python is a high-level programming language that has gained massive popularity among data scientists, AI and machine learning researchers who want to get their job done quickly. I'm confident that Python will fast track your journey into the world of programming.


@@@
1
00:00:02,710 --> 00:00:22,090
Setting up Python on your computer. Let us begin by checking if Python 3 is installed and properly configured on your computer. I'll be using Python 3 in this course, so I recommend you install it, too. If you're using Mac OS or Linux, you've probably got Python already installed on your system.

2
00:00:22,220 --> 00:01:06,820
You can check if you have Python 3 on your computer by opening a terminal window. On Windows, start the program called "cmd." If you're on a Mac or a Linux system launch the "terminal" program. You should get a window with a command line prompt. Next, type the following command in the terminal: "python3 --version" As you can see, I have the right version on my Mac. If you get some error message in the console, try typing "python --version" If you still get an error, that means that that Python is not installed on your system.

3
00:01:06,820 --> 00:01:41,790
I show you how to install Python 3 in a moment. Now, if you're a Mac user, then the chances are that you have the original 2.7 series of Python. 2.7 is the original, older version of Python. Although it's still getting bug fixes, it's not actively developed anymore. So, if you don't have Python 3 on your computer, you should install it from the official website. Visit the python.org website in your favorite browser. Hover your mouse over the "Downloads" menu.

4
00:01:41,870 --> 00:02:14,240
The link in the dropdown defaults to the version of your operating system, but you can also select your platform manually. Download the latest version of the Python 3 release. After the download is ready, launch the installer and follow the instructions to complete your Python installation. Check if your installation succeeded by running the following command in the terminal: "python3 --version" Next, we're going to install and configure our development environment.


@@@
1
00:00:03,890 --> 00:00:16,490
Now that you have Python 3 installed on your machine, let's try it out. If you're on Windows, start the program called "cmd." On a Mac or a Linux system launch the "Terminal" program.

2
00:00:17,220 --> 00:01:07,490
Next, type the following command in the terminal: "python3" This command starts at the interactive Python language shell, also known as Read-Evaluate-Print-Loop, in short, REPL. A Read-Evaluate-Print-Loop, also termed an interactive top-level or language shell, is a simple, interactive computer programming environment that takes single user inputs - that is, single expressions -, evaluates them, and returns the result to the user. A program written in a REPL environment is executed piece wise. The Python shell executes the Python instructions we write. It reads the input entered by users, evaluates the code we typed, and prints the results so we can see the response.

3
00:01:07,900 --> 00:01:25,300
Then, it loops back to the first step. Now, let's do some basic math. We can add two or more numbers. Let's try, for example, two plus two or two plus three plus five.

4
00:01:25,300 --> 00:01:59,340
We can also subtract numbers: 120 minus 3.14. Or multiply them: 17 times six. Divide: 64 divided by 8 or 129 divided by 98. We can even raise a number to a power: 5 squared which should be 25 - right. The Python shell can also evaluate multiple operations.

5
00:01:59,340 --> 00:02:12,330
Python follows the order of operations when evaluating math expressions. We can quit the shell any time by typing exit. We'll talk about the parenthesis stuff later in the course.

6
00:02:12,330 --> 00:02:22,980
Now we're back to our command line. What if I'd like to go back and work a bit on my code? If I open a new REPL it will start everything from scratch.

7
00:02:22,980 --> 00:02:34,890
There is no way to go back and continue where we left off. REPL can be used to try out simple snippets of code. However, it's not the right solution if we want to edit or reuse our code.


@@@
1
00:00:04,530 --> 00:00:16,530
The interactive Python language shell, the REPL can be used to quickly type and try out a couple of lines of code. However, there are a lot of things that the Python Shell can't do for you.

2
00:00:16,560 --> 00:00:28,130
For example, you can't go back to the previous line if you want to change something quickly. There is no code completion or syntax highlighting, and you can't save your session to a file.

3
00:00:28,140 --> 00:00:37,950
Code completion is a feature that speeds up the process of writing code. As we start typing the code, the code completion engine comes up with a list of potential candidates.

4
00:00:38,720 --> 00:00:57,480
Besides speeding up software development, code completion reduces the number of mistakes and typos, and we have to memorize fewer keywords, function names, and so on. Syntax highlighting improves the readability of our code by using different colors and fonts to highlight categories of terms.

5
00:00:57,480 --> 00:01:10,800
This in turn reduces the time required to figure out what the source code does. Code completion and syntax highlighting are available in text editors and integrated development environments, also known as IDEs.

6
00:01:11,580 --> 00:01:23,900
A code editor is a code centric text editor that provides syntax highlighting and can save or open source files, but it won't execute your code lines. For example, Atom is such a code editor.

7
00:01:24,000 --> 00:01:36,560
IDEs are more powerful, in that they let you execute and test the code you wrote. There are many IDEs that can work with Python. In this course, I'll be using Visual Studio Code.

8
00:01:36,750 --> 00:01:55,780
It's a versatile IDE that's available for Windows, Mac OS and Linux. You can download the latest stable version for free from code.visualstudio.com. Visual Studio Code comes with a variety of useful plugins that will make our life easier when working with Python.

9
00:01:56,300 --> 00:02:14,850
After downloading VSCode, launch it and go to the Extensions panel. You can do that by clicking the View menu and choosing Extensions, or by clicking the Extensions icon. In the Extensions panel type "python" in the search box and install the one provided by Microsoft.

10
00:02:14,870 --> 00:02:25,410
This plugin comes with Python syntax highlighting, but it also lets us run and debug Python code from within the editor. Install the plugin and restart VSCode.


@@@
1
00:00:02,560 --> 00:00:17,710
In this lecture, you're going to write your first program in Python. We'll be using Visual Studio Code from now on, so if you haven't installed it yet, follow the instructions from the "Install and Configure Visual Studio Code" lecture.

2
00:00:17,710 --> 00:00:30,040
Also, make sure that you have Python version 3 set up on your computer as described in the video "Setting up Python on Your Computer."" Let's start by opening VSCode.

3
00:00:30,040 --> 00:00:43,320
We're going to create a new file by clicking File, and select New File. A new file gets created with the name "Untitled 1." Have a look at the status bar at the bottom.

4
00:00:43,560 --> 00:01:51,660
The status bar is enabled by default, but if you can't see it go to View > Appearance and select Show Status Bar. The status bar tells us that the newly created file can hold plain text. We'll change that in a moment, but first type the following in the editor window: print("Hello, world") Now click File again and choose Save As. Name your file "first-program.py" and save it. The .py extension here denotes a Python source file. You should name all your Python source files according to this pattern: xyz.py, where xyz should provide a concise description of what the code does. After saving the file, right click in the editor area and select Run Python File in Terminal.

5
00:01:56,240 --> 00:02:09,660
Visual Studio code adds a new panel below the editor, and you should see the text "Hello, world" displayed in the terminal. The "print()" here is a built-in function that lets us output text to the console.

6
00:02:09,940 --> 00:02:23,910
We must write it all lowercase; otherwise, it wouldn't be recognized as a valid function name. Let's change "print()" to "Print()" with a capital "P" and see what happens if I try to run the file again.

7
00:02:25,340 --> 00:02:50,960
As expected, we've got a NameError. I undo the change to get rid of the error. Now, let's talk a bit about the print() function. An opening parentheses follows the function name "print(," then between double quotes we provide the text to be output - "Hello, world" and we end the statement with the closing parentheses.

8
00:02:51,200 --> 00:03:01,980
We must surround the text to be printed with quotes. You can also use single quotes - Python won't complain. Thus, both of the following statements will work.

9
00:03:05,540 --> 00:03:23,560
You need to be consistent. Either use single quotes or double quotes for your strings. Don't start with a double quote and end with a single quote or vice versa. Otherwise, you will trigger a syntax error, as in the following example.

10
00:03:23,580 --> 00:03:44,930
Now I remove this faulty line and let's print something else. print("Hey Steve!") Feel free to use other names. Actually, you can print anything you'd like, just make sure it's surrounded with quotes.

11
00:03:44,930 --> 00:03:59,880
Also, start each of your print statements on a new line. Use triple quotation marks to the limit your text if it must span on multiple lines. The following statement will appear as it is in the terminal.

12
00:04:02,230 --> 00:04:31,060
Finally, don't forget to save your changes by clicking File > Save, or use the shortcut Command-S on the Mac or Control-S on Windows. You can run your program whenever you wish by right clicking in the editor area and selecting Run Python File in Terminal. Congrats, you just implemented and successfully ran your very first Python program! You made the computer print various texts.


@@@
1
00:00:03,590 --> 00:00:27,220
Computers can perform all sorts of calculations blazingly fast, and output the results in some form, typically by displaying them on the screen. That wouldn't be very useful if we couldn't feed the computer with user data. In this section, we're going to create a program that waits for user input and produces the output based on what the user entered.

2
00:00:27,440 --> 00:01:04,739
Open up VSCode and create a new file by clicking File and select New File. A new file gets created with the name "Untitled-1." Save the file using File > Save As and name it "user-input.py." After saving the file, type in the following statement. It's important to type it as you see it: "name" in lowercase = "input" open parentheses, for text, "Type your name" between double quotes and close parenthesis.

3
00:01:04,910 --> 00:01:28,850
Now, what are we doing here? input("prompt") is a Python function. It prints the prompt string to the terminal and then waits until the user types something and hits Enter. The function returns what the user typed and stores it into a variable called "name." A variable is a container that can store a value we want to use later in our program.

4
00:01:28,850 --> 00:01:42,510
So, the "name" variable stores the value returned by the input() function. We assign the value using the assignment operator. Next, type the following statement in a new line.

5
00:01:42,580 --> 00:02:04,470
Here we create a formatted string literal using f-Strings and assign it to the variable called "message." the code f"Hello, {name}!" creates a formatted string by replacing the expressions between curly braces with their values. If name has the value "Michael." the result will be "Hello, Michael!".

6
00:02:04,540 --> 00:02:17,480
We're going to talk about strings and string manipulation in more depth later in this course. Now type the last statement. The print() function should be already familiar to you.

7
00:02:17,630 --> 00:02:34,670
It outputs the value of the "text" variable to the terminal. Let's summarize what we've implemented. First, we prompt the user to enter a name. Once the user hits the Enter key, we store whatever she entered in a variable.

8
00:02:34,840 --> 00:02:47,950
Next, we create a new formatted string literal that greets the user. And finally, we print the text created at the previous step to the console. Now, it's time to test our program.

9
00:02:47,950 --> 00:03:02,470
Right click anywhere in your editor and select Run Python File in Terminal. Type a name - I enter "Oscar." Press enter when you're done. And here's the result.


@@@
1
00:00:04,720 --> 00:00:14,590
High-level programming languages have a human-friendly syntax. The code written in a high-level language is a way easier to read compared to the binary code.

2
00:00:14,590 --> 00:00:28,560
However, as your programs grow in complexity, it becomes harder to understand its logic without additional information. So far, we've implemented two short programs and I explained every statement.

3
00:00:28,660 --> 00:00:40,630
This approach works for programming courses and books: you type in the code while following along with the instructor. That's usually not a feasible alternative when coding in real life.

4
00:00:40,720 --> 00:01:06,140
Wouldn't it be great to include some guidance in the source code itself? To explain what your code does? That would help other programmers who may read your code. It might be useful even for yourself, especially if you have to look back at your code a couple of months from now. Luckily, each high-level programming language provides the means to include short inline explanations in the code.

5
00:01:06,140 --> 00:01:18,940
These are lines of text called comments. In Python, a line of text that starts with a hash mark sign is a comment. The computer doesn't try to interpret or execute such lines.

6
00:01:18,940 --> 00:01:38,050
They are exclusively meant for humans. So, here's our code from the previous section. You may remember what each statement does. However, added comments can clarify everything in an instant. Python also supports multiline comments called documentation strings.

7
00:01:38,050 --> 00:01:51,820
A docstring starts and ends with a triple quotation mark, and it's used to provide longer explanation when necessary. The triple quotation mark that ends a multiline docstring should be on a line by itself.

8
00:01:51,910 --> 00:02:04,240
Having that said, you don't have to comment every line of code. So, when do you write comments? It's a good idea to explain parts of your code that provide specific functionality.

9
00:02:04,240 --> 00:02:19,140
You should also comment code that's not straightforward or to clear up confusion. Finally, here are some rules for writing good comments: - Comments should be complete sentences, but keep them brief and concise.

10
00:02:19,360 --> 00:02:34,610
- If your code changes, make sure to also update the comments if required. Helpful comments can help understand your code faster, and as a consequence, reduce the time required to maintain or enhance the program.


@@@
1
00:00:03,969 --> 00:00:17,940
We have used variables in the previous lessons. They are containers used to store data that can be accessed or changed while the program is running. A variable is a dedicated location from the computer's memory.

2
00:00:18,000 --> 00:00:42,470
We tag it with a name that allows us to identify it later. Then, we can put a value in it. All right, let's open up VSCode. I create a new file as usual, and save it as variables.py. In Python, you create a variable by typing a name.

3
00:00:42,610 --> 00:00:54,040
The name represents the data that you want to hold in that variable, so better provide a meaningful one. Say that you need a variable that stores the player's name.

4
00:00:54,040 --> 00:01:19,400
Now, you could name your variable "x," or "n," or anything that comes to your mind. But how about this version? It's definitely a better choice, as it describes clearly the purpose of this variable. We've just created a variable called "name" and we used the equal sign to store the value "John" in it.

5
00:01:19,400 --> 00:01:42,890
It's like saying: "Hey computer, here's the variable called "name." Store the value "John" in it. Technically speaking, the value John is a string literal. We call literals predefined values that cannot change. The equals sign is called assignment operator - which makes sense, as it actually assigns a value.

6
00:01:42,890 --> 00:01:55,620
Now, after this line of code, the "name" variable exists, and it can be used to retrieve the value it holds. Bear in mind that you cannot use a variable before declaring it.

7
00:01:55,660 --> 00:02:23,590
Let's try to swap the two statements, and see what happens. So, I select it and press Command-X and place it here using Command-V. If I try to run it, we get a NameError: "'name' is not defined." So, always make sure to define your variables before using them.

8
00:02:23,660 --> 00:02:41,420
All right, let's restore our code to the working version. Variables can be assigned to new values after defining them - that's why they are called variables after all. We can update the value stored in the "name" variable by assigning it a new value.

9
00:02:45,080 --> 00:03:41,020
Running this code produces the following output in the terminal: John and Steve. Now, add another statement, and let us print it, too. Now, we've got John, Steve and Sam. Besides providing meaningful, descriptive names for our variables, we need to follow certain rules called naming conventions. Variable names should be lower case. For example, "temperature" starts with a lowercase "t." Or "text" equals "Done" also starts with a lowercase "t." We could change the name of the variable "temperature" to start with the uppercase "T," but that's not recommended.

10
00:03:41,380 --> 00:04:27,100
If the variable name consists of multiple words, separate them using underscores like in the following examples. Other programming languages use the lowerCamelCase style for variables, where you start with the lowercase word, and all successive words are capitalized, like "firstName," "lastName," and so on. Python prefers the underscore separated style as described in the Style Guide for Python Code. In Python, variable names must start with a letter or an underscore - other characters are not allowed.

11
00:04:27,440 --> 00:04:51,840
Type the following statement in a new line. Try to run it. The program triggers a syntax error. So, don't start your variable names with a number. Let's fix this! All right.

12
00:04:51,920 --> 00:05:09,410
Here's a summary of the rules you need to follow when creating your variables: - Provide short, descriptive names - Start your variable names with a letter You can also use underscores, but that's a special case, and we'll talk about its meaning later.

13
00:05:09,410 --> 00:05:22,750
- Use the underscore separated style if your variable name consists of multiple words. Following the standard naming conventions and coding style will make your code look more professional and easier to understand.


@@@
1
00:00:03,190 --> 00:00:14,170
We've seen what a variable is: a container that can hold different values, with a name that allows us to identify it later and change its value if required.

2
00:00:14,170 --> 00:00:29,260
So far we defined variables that can store text data. Python variables can hold many other data types, including numbers. Besides strings, numbers are the most common kinds of values in computer programs.

3
00:00:29,350 --> 00:00:50,120
Now, open Visual Studio Code. Create a new file and save it as numbers.py. Let's define a variable. This line of code tells Python to create a variable called "score" and store the value 0 in it.

4
00:00:50,120 --> 00:01:08,940
Note that I haven't used quotes around the value zero - that would make it a string literal. Although we use the "score" variable to store numbers, now it holds a string. Bear in mind that most programming languages wouldn't let us change the data type stored in a variable.

5
00:01:08,940 --> 00:01:33,600
Once you declare a variable as a number, you can't assign it a string and vice-versa. Python is less restrictive but that doesn't mean that we should exploit this flexibility. If you want to change the value of the "score" variable, to say 42 million you should write... As you can see, I haven't used the thousands separator.

6
00:01:33,600 --> 00:01:51,410
That's because comma separated values have a different meaning in Python. The following line does not actually change the score to 42 million. Python interprets the comma separated value as a tuple, a list consisting of three elements.

7
00:01:51,410 --> 00:02:12,920
The comma separates the elements in a tuple. Thus, we assign the values 42, 0 and 0 to our variable. So, let's print the values stored in our "score" variable. I'll run the file in the terminal. And here we go. The output is indeed a tuple: 42, 0 and 0.

8
00:02:13,670 --> 00:02:29,630
So, make sure you don't use commas as thousands separators when defining number literals in Python. We can also use negative numbers. Try this and now let's print our card balance.

9
00:02:33,880 --> 00:03:19,580
The output is minus 200. Now, what if we want to use a value that's not a whole number, like say 28.88. We can create decimals by defining number literals that have a point as decimal separators. Python treats the value as a float if the decimal point appears anywhere in it. All the following statements are valid. Don't use the whitespaces between the decimal point and the integer or the fractional part or else you'll trigger syntax errors. To create a negative decimal number, you just put the minus sign in front of it. As you can tell, defining numeric values in Python is effortless.


@@@
1
00:00:05,190 --> 00:00:18,990
In this lecture, we introduce the basic arithmetic operations, that is, addition subtraction multiplication and division. Start VSCode and create a new file called basic-maths.py.

2
00:00:22,790 --> 00:00:48,750
Let us create two variables "a" and "b." I make "a" equal to two, and "b" is 4. We can add them together using the plus sign and store the result in a new variable "c." Python evaluates whatever is on the right hand side of the assignment operator and puts the result in the variable from the left hand side of the equals sign.

3
00:00:48,850 --> 00:01:22,540
Thus, the following code is not valid. Let's try to run it. And we've got the syntax error. All right, so let's remove this line and make sure to keep the operation on the right-hand side of the assignment operator. Otherwise, you will get a syntax error. As we've seen, the operator for multiplication is the asterisk. For division, we use the forward slash. So, these are the basic arithmetic operators.

4
00:01:22,770 --> 00:01:34,310
You can't use any other signs or characters to perform these operations. For example, none of the following statements will work. So again, these are bad examples.

5
00:01:34,320 --> 00:01:45,960
Let's get rid of them. Python doesn't restrict us to perform a single operation. The following statement is completely valid, too. Now, can you guess the result?

6
00:01:46,720 --> 00:01:57,980
What will be the value stored in "c" after evaluating this statement? Let me simplify this for you by replacing the variables with their actual values.

7
00:01:58,020 --> 00:02:11,740
Some may be tempted to execute the operations from left to right like this: Two plus two equals four. Then multiply it by four. So, we've got four times four which gives us sixteen.

8
00:02:11,880 --> 00:02:31,060
Finally, subtract four from sixteen, and we have twelve. Let's print out "c" and run the program. So, why did we get six and not twelve? That's because we ignored the order of operations.

9
00:02:31,370 --> 00:02:44,980
Most programming languages use the operator precedence levels that conform to the order commonly used in mathematics. Multiplication and division have higher precedence than addition and subtraction.

10
00:02:45,020 --> 00:03:00,070
In other words, if an expression has multiple operators, multiplication and division get evaluated before addition and subtraction. Thus, 2 times 4 gets evaluated first, which is 8.

11
00:03:00,470 --> 00:03:20,090
Then, we add two and we get 10. And finally, subtract 4. So, the result is indeed 6. We can override these precedence rules using parentheses. For example, we could do the following to add together the first two numbers before performing the multiplication.

12
00:03:21,200 --> 00:03:37,130
Let's rerun it. In this case, the result is indeed twelve. Because of the surrounding parentheses, the addition two plus two gets evaluated first. So, we have four times four minus four.

13
00:03:37,580 --> 00:03:58,350
The multiplication four times four is performed next as it has a higher priority than the subtraction. Then, we evaluate sixteen minus four, So, we've got 12. If an expression contains operations that have the same precedence, Python evaluates it from left to right.

14
00:03:58,360 --> 00:04:22,530
Consider the following example: x = 8 / 4 / 2 Python evaluates the first division starting from left: 8 / 4 which is two, then performs the second division 2 / 2, and the result is 1.

15
00:04:22,650 --> 00:04:44,030
If we started with the second division, the result would be four because 4 / 2 is two, and 8 / 2 would be 4. As you can see, the evaluation order matters. So, these were the basic arithmetic operators, and we're going to introduce a few more in the upcoming sections.


@@@
1
00:00:05,170 --> 00:00:22,330
We've seen how to define string literals. Now, let's see some more advanced examples of using and managing text in our programs. Open up Visual Studio Code and create a new Python source file called strings.py.

2
00:00:22,330 --> 00:00:39,420
Next, create two variables and assign string literals to them. We can concatenate the two variables using the + operator. The + sign here is not an arithmetic operation.

3
00:00:39,480 --> 00:00:52,300
Instead, we're telling the computer to concatenate the string literal stored in "part2" and "part1" and put the result in the "quote" variable. Let's check the output by printing the "quote" variable.

4
00:00:56,880 --> 00:01:11,710
There should be a space between the two sentences. Let's fix the formatting issue. We can combine multiple string variables and string literals using the + operator. So, I can insert a whitespace by adding it here.

5
00:01:13,530 --> 00:01:32,630
And finally, add "part2" also. Now, we've got the whitespace between the sentences. We could also create the formatted string literal known as f-string. The formatted string literal was introduced in Python 3.6.

6
00:01:32,630 --> 00:01:53,880
It's a convenient way to create new strings by evaluating the expressions delimited by curly braces. Here's an example. The code f"{part1} {part2}" creates a new string literal by replacing the expressions {part1} and {part2} with the values stored in the corresponding variables.

7
00:01:54,120 --> 00:02:04,100
As you've probably noticed, the f-string contains the whitespace separator between the two parts. Thus, the resulting string will be formatted correctly.

8
00:02:04,140 --> 00:02:21,520
Let me show you by commenting on this statement out. And I'm gonna clear the terminal. Now, let's rerun our file. As you can see, the sentence is correctly formatted because we included a space in the f-string itself.

9
00:02:23,610 --> 00:02:47,370
Formatted string literals let us create strings that contain other strings, integers or decimals. Let us type the following. This prints "Your name is Michael and you're 32 years old." Now, let's try something else.

10
00:02:47,370 --> 00:03:08,700
car = "Tesla Roadster" acceleration = 1.9 message = f" The {car} goes 0-60 mph in {acceleration} seconds" Finally, we print the message and here's the output.

11
00:03:09,700 --> 00:03:31,150
We can include format code syntax within the curly braces of our expressions. Write the following code. pi = 3.14159265359 Next, I construct the message using an f-string.

12
00:03:37,860 --> 00:03:55,630
Print the message and it outputs: "The number pi is approximately equal to... and this long number. Now, usually you don't need that high-level of accuracy. So, let's display only two digits.

13
00:03:55,680 --> 00:04:15,310
I'm going to add a format specifier and tell that I only need two digits, and this is a floating point number. The output contains only two decimals. Using ".2f" we specified that the value should be displayed with two digits.

14
00:04:15,310 --> 00:04:38,640
You can even get rid of the decimals completely by instructing Python to display zero decimals. Python provides many other useful string features. So, let's see some of the most commonly used ones. Given a string literal or a string variable, we can query its length, that is, how many characters it has.

15
00:04:38,640 --> 00:04:53,730
I used the len() function here. When we run the snippet it prints out 41, because the number of characters in the message variable is 41. The length will include punctuation and spaces as well.

16
00:04:53,730 --> 00:05:19,680
We can also count the length of unicode strings. We can convert the string to uppercase. upper() is a string method that returns a copy of the string converted to the uppercase.

17
00:05:19,890 --> 00:05:44,420
Note that the original message remains unchanged. Printing the message variable will print the original string. The upper() method has its counterpart that returns the lowercase version of a string. So, I'm gonna call the lower() string method here.

18
00:05:44,430 --> 00:06:04,840
There's also a swapcase() string method that converts the uppercase characters in a string to lowercase and vice-versa. I'm not quite sure about the practical application of the swapcase() method, but it's there if you need it.

19
00:06:04,840 --> 00:06:20,790
We can use count() method to get the occurrence of a substring in a string. Let's check how many times we've got the word "stay" in the original message.

20
00:06:28,470 --> 00:06:40,370
So, the word "stay" appears twice in this message. I'll introduce more string-related functionality later on in this course, but these will suffice to get you started.


@@@
1
00:00:04,590 --> 00:00:23,590
In this lesson, we talk about a new data type called Boolean, that can only represent the values "true" and "false." Start VSCode and create a file called boolean.py. In Python, we define a Boolean variable by assigning the value "True" or "False" to it.

2
00:00:27,090 --> 00:00:37,260
The values "True" and "False" are not surrounded by quotes, as they are not string literals, but instead reserved keywords used to create Boolean data types.

3
00:00:37,260 --> 00:00:58,060
As you noticed, the keywords "True" and "False" must start with a capital. The following statements are invalid, as the names "true" and "FALSE" - written as they are - are not defined in Python. The keywords "True" and "False" are special cases of integers.

4
00:00:58,220 --> 00:01:18,690
The value of "True" is 1, and "False" evaluates to 0. And here's the proof. We see 0 in the console because "False" evaluates to 0, and 42 times 0 is, well 0. And if I replace "False" with "True," guess what we get?

5
00:01:22,410 --> 00:01:36,510
Now we have 42 in the console because 42 times "True," which is 42 times one, is 42. Although the practical use of Boolean may not be evident at first.

6
00:01:36,510 --> 00:01:50,340
They play a crucial role in programming. We can control how our program behaves based on Boolean conditions. For example, we might use a Boolean variable is_valid_email to control the execution of the program.

7
00:01:50,340 --> 00:02:12,450
Initially, the variable is set to "False." The is_valid_email variable becomes "True" once the user has entered a valid email address. After that, we let our program perform the next action like loading a web page or showing "Registration Successful" dialog. We'll get deeper into Booleans and conditional logic in the next section.


@@@
1
00:00:03,670 --> 00:00:16,780
The programs we've written so far were quite simple. We started executing the first line and continued to the next one, then the next one, and so on until we reached the last statement.

2
00:00:16,780 --> 00:00:35,620
Writing Programs this way wouldn't make too much sense. We need to ask questions and make decisions. Even the most straightforward program will probably need some conditional code. In real life, we have to answer questions and make decisions based on the answers to these questions.

3
00:00:35,900 --> 00:00:50,480
Is the traffic light green? If yes, go! Seeing red? You better stop. Is there enough money in your bank account to cover that overseas trip. If yes, go ahead and book your travel.

4
00:00:50,480 --> 00:01:03,800
Similarly, in our programs, we need to have code that only runs if specific conditions are true. That's what we call conditional code. In Python, you write conditional code using the following syntax.

5
00:01:03,920 --> 00:01:19,870
The keyword "if" followed by a conditional statement and a colon, then the code you want to execute when that condition evaluates to true. If the condition is false, we run the code that comes after the "else" word.

6
00:01:19,970 --> 00:01:36,680
The condition isn't a word or a phrase, but rather something in the form "if a equals b" or "if money is less than the balance." The expression that follows the "if" keyword must break down as being either true or false.

7
00:01:36,740 --> 00:01:50,210
Let's continue with an actual example. Open up Visual Studio Code and create a new Python source file called conditional-code.py. Type the following code in the editor.

8
00:01:50,210 --> 00:02:02,070
First, I declare two variables. "balance" represents the bank balance and "money" is the cash we want to withdraw. Then, we have a conditional statement.

9
00:02:02,180 --> 00:02:21,320
If "balance" is greater than "money." The colon character marks the end of the "if" statement. The statements following the conditional statement are four spaces in from the if. And I need to also indent the code that follows the "else" statement.


@@@
1
00:00:05,820 --> 00:00:23,250
A code block is a section of code that gets executed together. Python uses indentation to break down code into blocks. Other programming languages use curly brackets for blocks, but the creator of the Python language decided to use indentation instead.

2
00:00:23,250 --> 00:00:38,080
Fewer special characters mean less typing and less cognitive load for humans. However, it may take some time to get used to it if you already used a C-based language like Java, C# or Swift, to name a few.

3
00:00:38,140 --> 00:00:52,450
Now, if I unintend the statements from the if block, I'll get a syntax error. That's because the code that follows a conditional statement needs to belong to a new block.

4
00:00:52,700 --> 00:01:22,020
The conditional "if" statement is at the level of zero indents. The block following the conditional statement must have a higher indentation level. That's how Python knows those statements belong to a block, and that block of code is associated with the "if" statement. So, let's fix our indentation error by restoring the original indentation. All the statements that belong to a block need to be at the same level of indentation.

5
00:01:22,320 --> 00:01:43,680
If I indent any of the statements differently, you'll notice that I'll get syntax errors. Now, if I try to run the file, we get an indentation error "Unexpected Indent" for this line - line number 5. So, be careful to use proper indentation to delimit your blocks.

6
00:01:43,680 --> 00:01:58,260
Python relies on the indentation level to figure out which statements belong together. We'll use blocks a lot as we proceed throughout this course. Now that we clarified what code blocks are for, we can dig deeper into conditional code.


@@@
1
00:00:05,450 --> 00:00:18,540
As we've seen, a conditional statement must evaluate to a Boolean. In the previous example, we checked if the number is bigger than the other one, and I used the greater than sign to do that.

2
00:00:18,770 --> 00:00:42,240
There are also other operators that can be used in conditional statements. Besides greater than, we can check if the value on the left side is greater than or equal, less than, less than or equal to the value on the right. It is also ubiquitous to check for equality and inequality using the equals (==) and not equals (!=) operators.

3
00:00:42,260 --> 00:00:54,770
Here's the list of the comparison operators you can use in conditional statements. These comparison operators work with numbers, strings, and also other data types that can be compared with each other.

4
00:00:55,770 --> 00:01:15,020
Now, let's take a closer look at our previous example. What happens if the amount we want to withdraw matches the balance? It says "Insufficient funds." So, we couldn't retrieve the money because the condition "balance is greater than money" evaluates to false.

5
00:01:15,530 --> 00:01:27,940
Thus, the else-statement's code block will execute that prints "Insufficient funds." We can fix the issue easily by replacing the ">" operator with the ">=" operator.

6
00:01:32,140 --> 00:01:47,280
The rest of the code remains unchanged. Now, this small change will let us withdraw all the money from our bank account. After this transaction, the balance turns zero.

7
00:01:47,310 --> 00:02:14,250
Make sure you don't add a space between the ">" and the "=" sign. That extra whitespace will cause a syntax error. So, let's undo our change. The ">=," "<=," "==" and "!=" comparison operators must be written together, without spaces between them.

8
00:02:15,500 --> 00:02:44,730
Another common mistake is using a single equal sign in conditional statements. Let me show you what I mean. First, I create the "is_true" variable and set it to "False." If "is_true" is "True," then print "True" else print "False." Can you spot the issue? The "is_true = True" in the code snippet doesn't compare values.

9
00:02:47,460 --> 00:03:08,340
It is an assignment, so you shouldn't use it as a condition. In many other programming languages, assigning a value to a variable evaluates to true, and the "if" block gets executed. Python prevents us from making this mistake. Trying to execute this code will trigger a syntax error.

10
00:03:08,350 --> 00:03:27,260
All right, so let's recap. Follow these rules when writing conditional code: - Keep the "=," "==" and "!=" comparison operators together. - Use the "==" operator to check if two values are equal.

11
00:03:27,430 --> 00:03:38,610
All right. Our examples so far involved both the "if" and the "else" statements. However, that's not mandatory. You can use the "if" statement by itself.

12
00:03:38,740 --> 00:04:11,860
I created the "is_raining" variable and initialize it to "True." If "is_raining" is true, we print "Take your umbrella."" Bear in mind that you cannot use "else" without a preceding "if" statement. However, nothing stops us from using multiple "if" statements in a row. The code prints "The number is even," "The number is greater than ten" and "A dozen." As you may have noticed, I used a new operator.

13
00:04:12,160 --> 00:04:36,150
The percentage sign (%) is the modulo operator, which calculates the remainder of the division. If modulo returns 0, there is no remainder, so the number is even. A non-zero remainder means that the number is odd. Since twelve divided by two is six, and the remainder is zero, twelve is an even number.

14
00:04:36,210 --> 00:04:57,040
Now, let's change the value of the "number" variable to eleven. It prints "The number is greater than ten." Only one of the "if" statements evaluates to true. Indeed, eleven is greater than ten, but it's neither even nor equal to twelve.


@@@
1
00:00:04,350 --> 00:00:14,870
As you start using conditions in your programs, you will notice that a pair of if-else statements is rarely enough. Many times, you will need three or more conditions.

2
00:00:14,880 --> 00:00:28,020
One possibility is to use multiple if statements, as we did in this example. Now, there are cases when we need to check multiple conditions and execute the first one that evaluates to true.

3
00:00:28,020 --> 00:00:45,480
Take a look at the simplified flowchart of a traffic light. We could use multiple if statements to make it work in Python. If we use the if statements like that, Python evaluates each conditional statement. Is the light green?

4
00:00:45,630 --> 00:01:06,190
Yes, so print "Go!." Is the light yellow? No, evaluate next "if." Is the light red? No, next one. Is it flashing? No. The else statement's code won't run, as one of the if statements was true. But we know that the traffic light can only be in one of the states at a time.

5
00:01:06,240 --> 00:01:21,340
So, why evaluate the other conditions if we know that the light can only be either green, or red, or yellow? Performing the additional checks is unnecessary - we're just wasting resources and computing time.

6
00:01:21,400 --> 00:01:35,460
The solution comes in the form of the "elif" keyword, which stands for "else if." Let's rewrite our code using "elif" statements. An "elif" statement can only appear after an "if" statement.

7
00:01:38,890 --> 00:01:53,100
The "if" statement gets evaluated first. If it's true, the "elif" and "else" statements are not evaluated. The first conditional statement - traffic_light == "green" is true.

8
00:01:53,100 --> 00:02:06,600
Therefore, the three consecutive "elif" and the "else" statements are skipped. Now, what happens if we assign the value "red" to the traffic light variable? The condition in the "if" statement is false.

9
00:02:06,710 --> 00:02:20,730
So the first "elif" gets evaluated next. The expression traffic_light == "yellow" also evaluates to false. So, we process the next "elif." traffic_light == "red" is true.


@@@
1
00:00:04,500 --> 00:00:16,660
There may be situations when you want to check for another condition after a condition evaluates to true. In such cases, you can nest an "if" statement inside another "if" statement.

2
00:00:16,680 --> 00:00:32,880
You can also add "else" or "elif" statements to a nested "if" structure. Here's an example. A word of advice: avoid deeply nested code. Normally, you shouldn't go beyond two levels of nesting.

3
00:00:33,080 --> 00:00:55,920
Otherwise, your code becomes overly complex and hard to understand. In programming, deep nesting is a problem known as the Arrow Anti Pattern. The name comes from the shape of nested "if" statements. Boolean operators allow us to combine multiple conditional expressions without relying on nested "if" statements.


@@@
1
00:00:05,320 --> 00:00:20,190
Let's examine the code snippet with the nested "if" statements. I'm going to delete our Arrow Anti Pattern example. Let's scroll up. All right. The first "if" statement checks if the traffic light is red.

2
00:00:20,350 --> 00:00:37,320
The nested "if" checks if "is_blinking" is true. So, basically, we're asking if the traffic light is red, and it is blinking at the same time. What if we could express both conditions at once?

3
00:00:37,390 --> 00:01:06,670
Actually, we can do that! The statement above is completely valid Python code. The "and" word is one of the three Boolean operators, also known as logical operators. The "and" operator takes two expressions and it returns "True" only if both expressions are "True." Otherwise, it evaluates to "False." Now, I'm gonna remove this line, and let's try out something else.

4
00:01:06,670 --> 00:01:22,640
I create a Boolean variable called "success" and let's initialize it to "True." And here's the second variable called "result_code." Next, I'm gonna check if "success" is "True" and the "result_code" equals 200.

5
00:01:26,620 --> 00:02:37,150
If both "success" equals "True" and result_code is 200, I print "Success." Else, print "Failure." If you run this code, it print "Success." Both expressions in the "if" statement resolve to "True." So, we have "True and True," which evaluates to "True." Now, assign the value "False" to the "success" variable and let's execute the code again. This time, the condition in the "if" statement becomes "False == True and True" Now, "False == True" is "False." So, the condition boils down to "False and True." The result is "False" because the "and" logical operator returns "False" if any of the expressions are "False." The "or" logical operator takes two expressions, too. It returns true only if any of the expressions are true.

6
00:02:37,230 --> 00:02:54,660
Now, let's type the following code in your Visual Studio Code editor. I'm gonna close this one. And let's scroll up. I create a variable called "first_name" and let's assign the string literal "Ellen" to it.

7
00:02:54,660 --> 00:03:15,340
And "last_name" make it "Ripley." And next, we check for the length of the "first_name" and the "last_name" in the "if" statement. I use the logical "or" operator to check if both "first_name" and "last_name" have a valid length.

8
00:03:16,550 --> 00:03:40,560
If either is empty, we prompt the user to enter her name. Otherwise, the program greets the user. I'll be using an f-String here, which says "Hi," and the value of "first_name" and "last_name." The program will print "Hi Ellen Ripley." Let's try it out.

9
00:03:43,060 --> 00:04:09,410
Awesome! Now, let's follow through what's happening in the "if" statement. "len(first_name) == 0" resolves to false, since the text stored in first_name - "Ellen" - is five characters long. "len(last_name) == 0" also evaluates to false. "Ripley" has six characters so we have "False or False" which evaluates to false.

10
00:04:09,500 --> 00:04:22,860
So, the else statement's code block gets executed. The third logical operator is "not." The "not" operator takes a single expression, and you can use it to negate a Boolean expression.

11
00:04:23,020 --> 00:04:38,630
In other words, placing "not" in front of a Boolean expression reverses its meaning. Let's go back to the code and type the following. Here, we check if a user is not an administrator.

12
00:04:41,200 --> 00:04:58,070
"not admin_user" resolves to "not False" which is "True."" Thus, the program runs the code block associated with the "if" statement. Let's run it. Indeed, we've got "Permission denied" in the terminal.

13
00:04:58,090 --> 00:05:07,810
Now you know how to write conditional code in Python. To solidify the concepts, play around with the exercise code and see what happens if you make some changes.


@@@
1
00:00:05,080 --> 00:00:22,800
In this section, we'll dive into functions. Functions allow us to write code and reuse it anywhere in our programs. So, why is reusability important? Let me start by showing you an example. Let's start Visual Studio Code.

2
00:00:22,970 --> 00:00:37,050
Next, I create a new Python source file called functions.py. We'll write a program that computes the area of a rectangle. I start by printing a message to the terminal.

3
00:00:40,010 --> 00:01:01,050
I declare two variables, "length" and "width." Let's make it five, and "width," say, four. To calculate the area of the rectangle, we multiply "length" by "width." And let's print the result using an f-String.

4
00:01:04,790 --> 00:01:23,320
This code creates two variables: "length" and "width," and assigns them the values 5 and 4. Then, we calculate the area of the rectangle by multiplying the "length" by "width." Finally, I print a formatted string that displays the area. And let's check the output.

5
00:01:24,790 --> 00:01:38,760
It says "The area of a rectangle with length 5 and width 4 is 20" - correct! Now, what if we want to calculate the area of another rectangle, which has a length of, say, 21 and width of twelve?

6
00:01:38,830 --> 00:01:51,740
We can do that by changing the values of "length" and "width."" I rerun the app. The area has changed as expected. Now, what's the issue with this code?

7
00:01:51,830 --> 00:02:02,800
Whenever we want to calculate the area of a new rectangle, we need to update the values assigned to "length" and "width." What if I need this functionality later in my program?

8
00:02:02,960 --> 00:02:13,480
Let's say that we added a dozen new statements, and we need to calculate the area of a new rectangle after executing all that code. So, what do you do?

9
00:02:13,790 --> 00:02:35,480
You copy and paste the snippet whenever you need it. However, that's not a good idea. You end up having the same redundant code spread throughout your code base, and only "length" and the "width" would change. Our program becomes messy as we keep adding more and more redundant code.

10
00:02:35,770 --> 00:03:03,540
The code base keeps growing up to the point where it's almost impossible to understand what it is doing. You should avoid redundancy in your code. DRY is the acronym for Don't Repeat Yourself, a programming principle that aims to reduce repetition of all kind in order to create a cleaner code base. All programming languages provide a way of grouping parts of code and making them reusable.


@@@
1
00:00:05,280 --> 00:00:27,350
We can create functions to wrap the code that we want to reuse. Use the following syntax to define the function in Python. The "def" keyword shows that we are defining a function. Put a space after "def" and specify the function's name. Function names should be lowercase, and use an underscore to separate the words.

2
00:00:27,510 --> 00:01:09,100
Theoretically, you could name your functions anything you want. However, it is recommended to provide meaningful names, which describe what your function does. Since the function defines a specific functionality, it is recommended to start its name with a verb, such as "authenticate," "calculate," or "fetch." You can add a noun to increase the clarity further, like, for example, "authenticate_user," "calculate_area," or "fetch_sales_data." The function name is followed by a pair of opening and closing parentheses. Inside the parentheses, we can specify the data you want to use in your function.

3
00:01:09,410 --> 00:01:23,160
If the function doesn't expect any data, you can leave the parentheses empty. Otherwise, list the data you want your function to accept. The input data a function takes is called a parameter.

4
00:01:23,180 --> 00:01:34,780
Here's a function that takes a single parameter. If your function takes multiple parameters, you need to separate them by commas. A colon follows the closing parentheses.

5
00:01:34,820 --> 00:01:47,570
This colon tells Python that we're done with the function's declaration, and the function's code comes next. The function's code block must start in a new line after the colon, and the code needs to be indented.

6
00:01:48,410 --> 00:02:02,390
The code block is called the function body, and it contains the statements that execute when the function gets called. A function can contain one statement or many more lines of code.

7
00:02:02,390 --> 00:02:11,270
Usually, functions shouldn't be too long, and there are best practices to prevent the proliferation of code within functions. We'll get to these techniques later.

8
00:02:11,630 --> 00:02:23,670
If the function needs to return a value, use the "return" keyword followed by the value or the expression that provides the return value. Now, let's start Visual Studio Code.

9
00:02:24,050 --> 00:02:40,450
Open the functions.py file we created in the previous lesson. We're going to clean up this mess. So, I'm gonna select all and hit delete. And now, you're going to implement your very first Python function.

10
00:02:40,450 --> 00:02:56,840
First, define the function. The name is descriptive - you can tell what this function is supposed to do just by looking at it. "calculate_square_area" takes a single parameter called "side." All right.

11
00:02:56,860 --> 00:03:09,370
Now, let's implement it. To find the area of a square, we need to multiply the length of each side with itself. The function takes the "side" parameter that's needed to perform the calculation.

12
00:03:09,370 --> 00:03:31,680
Thus, we can write the following code. "area = side * side" Let's return the result. Actually we can get rid of the "area" variable and return the "side * side" expression. All right, we just defined a function in Python. So, let's start using it.


@@@
1
00:00:04,820 --> 00:00:17,950
After defining our function, we can use it from anywhere in our program. However, a function's code isn't executed automatically. Python has no way to know when do you want to run the function's code.

2
00:00:17,990 --> 00:00:33,720
We need to write the code that causes the function and pass in the input data if there's any. We've already used some of Python's built-in functions. You probably recall the print() or the input() functions used in the previous lessons.

3
00:00:33,770 --> 00:01:05,250
We can call any function - including the ones we create - in a similar fashion: we type its name and pass in the arguments, that is, the values for its parameters, if it has any. So, I can call our function by typing its name - calculate_square_area() and I pass in the value 5 for its parameter. Bear in mind that there is a clear distinction between function parameters and arguments.

4
00:01:05,340 --> 00:01:23,680
We use the term parameter when we define a function. Upon invoking a function, the values that we pass in are called arguments. In this function declaration, "side" is a parameter. Whereas when we use the function, 5 is an argument.

5
00:01:23,680 --> 00:01:34,020
Now, that you know the difference between a function parameter and an argument, let's analyze the code further. Although the function's code will run, we can't see the result.

6
00:01:34,570 --> 00:01:48,990
Let's run our code. There is no output, although the function's code was executed. We can't see the result. That's because we haven't used the value returned by this call.

7
00:01:49,830 --> 00:02:17,080
We can easily change that. I'm going to assign the result of the function call to a variable. And let's also print the result. Now, we can see the result of our function call. I can add further code and invoke the function when I need it, and so on, and so on.

8
00:02:22,310 --> 00:02:33,710
Functions help us structure our code in units that can be called whenever we need that particular functionality. I know it's been a long haul but we're not done yet.


@@@
1
00:00:05,480 --> 00:00:15,290
Awesome! You know how to define and use functions. There is a problem we need to solve, though. Currently, nothing prevents us from writing the following.

2
00:00:18,560 --> 00:00:29,250
Trying to execute this statement triggers an error. We can pass in any type of argument to our function because there are no restrictions regarding the parameter's type.

3
00:00:29,420 --> 00:00:50,400
However, the multiplication only makes sense for numbers. Python 3 and above allow us to annotate function parameters and provide type information. Annotations for parameters take the following form. So, we can annotate the type of the parameter our function accepts as follows.

4
00:00:51,580 --> 00:01:14,120
Parameter type annotations inform the caller about the expected argument type. Note, however, that the caller may still provide an invalid argument. Unlike many other programming languages, Python doesn't impose any restrictions based on the parameters type. We can also annotate the type of a function's return type.

5
00:01:14,120 --> 00:01:27,640
Here's how we would specify that the calculate_square_area() function returns an integer. Besides type information, we can also provide default parameter values using the following syntax.

6
00:01:28,420 --> 00:01:41,870
Let's provide the default value of one to the "side" parameter. The "side" parameter became optional, because it has a default value. We can call the function without passing in an argument.

7
00:01:42,010 --> 00:02:04,540
Okay, let's get rid of this line, and I'm gonna call the function without passing in an argument. Here's what happens. Because the "side" parameter's default value is 1, the function returned 1. The default value for parameters is useful if a function gets called with a specific value most of the time.

8
00:02:04,570 --> 00:02:38,240
Consider the following example. I define a function that creates Ferraris. The function takes a parameter called "color" and I provide the default value of "red." The most popular Ferrari color is red, so it's an obvious choice to make red the default value. For the color parameter, calling the function without providing a value will print "Built a red Ferrari." But if we pass in a color, that value will override the default one.

9
00:02:38,310 --> 00:02:53,960
Let's build a blue one. And here's our blue Ferrari. The parameter and return value annotations are optional in Python. Use annotations whenever they improve the clarity of your code.


@@@
1
00:00:04,850 --> 00:00:16,379
To illustrate the problem we discuss in this lesson, I'm going to make some changes to our function. First, I'm going to delete this part as we don't need it anymore.

2
00:00:16,830 --> 00:00:28,530
And now, instead of using the "area" variable outside our function, I'm going to declare it inside the function's code block. So let's delete it from here.

3
00:00:28,950 --> 00:00:52,810
And I'm going to redeclare it inside the function. "area = side * side" and let's return it now. And now, I try to run this code. We got an error. It says "NameError: name 'area' is not defined." That's strange, right?

4
00:00:52,810 --> 00:01:17,660
Since we declared the "area" variable here. So, why is it invisible at this point? To understand why Python insists that "area" is undefined, we need to talk about the scope of variables. Any variable that's defined within a function has a local scope; that is, it can only be used inside the function where we declared it.

5
00:01:17,680 --> 00:01:31,630
Let's take a look at the definition of our calculate_square_area() function. We can access the variable within the function's code without problems. For example, I could insert a new print() statement that reads the "area" variable.

6
00:01:34,430 --> 00:01:48,650
I need to comment this line out. And if I run the file it compiles just fine. However, the "area" variable is not available in the code that's outside the calculate_square_area() function.

7
00:01:48,650 --> 00:02:13,600
So, again, if I uncomment this line, we'll get the usual error. It says "name 'area' is not defined." Python treats it in a similar way as if it wasn't defined at all - hence we got the NameError. If you need a variable that's visible both outside and inside the function, you need to declare it at the global scope.

8
00:02:13,840 --> 00:02:33,940
And here's how to do it. This is a global variable. Now, let's pass in a valid value, say, 4 for the "side" and rerun the demo. Although this code compiled without errors, it produced unexpected results.

9
00:02:33,940 --> 00:02:50,920
The area should be 16 but we got zero. Instead, we still see that the area that's printed inside the function is correct: it's 16. But the second time we print it, it gives us zero.

10
00:02:51,170 --> 00:03:02,270
That's the initial value of the global "area" variable. In fact, the calculate_square_area() function did not actually change the value of the global "area" variable.

11
00:03:02,280 --> 00:03:19,590
Instead, it created a local one inside the function. Now, we have a global and a local "area" variable. The function assigns the result of the multiplication to the local "area" variable and leaves the global "area" variable unchanged.

12
00:03:19,590 --> 00:03:35,690
Python requires us to specify that we want to access a global variable inside a local scope explicitly. By re declaring it using the "global" keyword, we tell Python that we know what we're doing, and we indeed want to change the global "area" variable.

13
00:03:37,070 --> 00:03:48,120
The safety measure is needed to prevent accidental changes to global variables defined outside of a function. After these changes, we should see the right result.

14
00:03:48,260 --> 00:04:02,610
All right, now both print() statements are in sync. The "global" keyword allows us to access global variables at the local scope. However, as a rule of thumb, you should avoid relying on global variables in your functions.

15
00:04:02,790 --> 00:04:20,700
Global variables represent unprotected data, that might be accessed or changed by any function in the system without notice. Instead, you should pass in the data required by your function as arguments, and use the returned value after calling your functions.


@@@
1
00:00:05,200 --> 00:00:18,840
You know a lot about programming in Python already. So, let's implement a slightly more advanced program. We're going to write an application that calculates the area of circles, squares, and rectangles.

2
00:00:18,910 --> 00:00:33,840
You'll be using conditional code, ask for user input and you're also going to implement functions. All right, let's start Visual Studio Code. I create a new file called area-calculator.py.

3
00:00:39,690 --> 00:00:58,990
we define the function that calculates the area of a square first. It takes a parameter called "side" of type float. The function multiplies the length of a side by itself to find the area of the square and returns the result.

4
00:00:59,170 --> 00:01:10,600
The second function is called calculate_rectangle_area(), and it computes the area of a rectangle. The function takes two parameters: the length and the width of a rectangle.

5
00:01:14,350 --> 00:01:50,280
We multiply the values of the input arguments to find the rectangle's area. The last function calculates the area of a circle using the following formula: area equals π times r squared, which is equivalent to area equals π times r times r. Here, r represents the circle's radius, and π - the Greek pi letter - is a constant, which is approximately equal to 3.14. That's the ratio of the circumference of any circle to its diameter.


@@@
1
00:00:04,550 --> 00:00:19,600
We now have all the three functions to calculate the area of squares, rectangles, and circles. Let's print some information to the terminal. I'm using a multiline string literal to display the string wrapped as you see it in the code editor.

2
00:00:20,600 --> 00:00:36,260
If you want to create multiline strings, surround them with triple quotation marks. Any line breaks, tabs or quotes will be included in the resulting string. So, this code prints exactly what I typed in the editor.

3
00:00:36,260 --> 00:00:58,570
All right, let's continue. Next, we ask the user to select the shape. We're using the built-in input() function that prints the prompt string to the terminal and then waits until the user types something and hits Enter. The "\t" sequence here inserts a tab to indent the text after it.

4
00:01:02,310 --> 00:01:17,400
The user should type 'S,' 'R,' or 'C' to select a shape. We then use conditional logic to calculate the area of the chosen shape. First, I define an "area" variable and initialize it to zero.

5
00:01:18,220 --> 00:01:50,680
And now, I'm going to implement the conditional logic. The "if" statement checks if the user pressed 'S' for square. The "if" block prompts the user to enter a value for the square's side and assigns it to the variable "side." The second statement calls the calculate_square_area() function and passes in the value of the "side" variable. The value returned by the calculate_square_area() is assigned to the "area" variable.

6
00:01:50,680 --> 00:02:03,400
Note that I had to convert the values provided by the user to float using the built-in float() function. We need to perform this conversion because input() returns a string, and we cannot multiply two strings.

7
00:02:04,330 --> 00:02:34,780
As a side note: the conversion to float might fail since the user can enter any value. We leave the code as it is for now. Later, I'm gonna show you how to handle conversion errors and other problems. If the user didn't select a square, he might have picked a rectangle. "elif selection == 'R':" Now, I ask for user input for the "width" and the "length" of the rectangle sides.

8
00:02:34,840 --> 00:02:50,550
I create the "length" variable and assign it to the value returned by the input() function. And same for "width." And finally, lets calculate the area.

9
00:02:50,550 --> 00:03:02,800
I'm gonna call calculate_rectangle_area() and pass in the values for length and width. I need to make the conversion to float as in the previous case.

10
00:03:02,830 --> 00:03:21,070
Now, if the user has selected neither a square nor a rectangle, check if he entered 'C' for circle. "elif selection == 'C':" Here, we need to ask the user to input the radius.

11
00:03:21,290 --> 00:03:44,660
So, I create a variable called "radius" equals, and again I'll be using the input() function. And "area" should be equal to calculate_circle_area() in this case, and I convert "radius" to float.

12
00:03:44,980 --> 00:04:11,690
Finally, the "else" statement gets executed if the user pressed any other key. "else" and we just print a warning, which says "Invalid selection. Choose 'S,' 'R' or 'C'." Last but not least, we print a formatted string that displays the area of the shape - or 0 for an invalid selection.

13
00:04:11,690 --> 00:04:32,130
I use an f-String and print the area. And now, I run the app. Let's start with a square. The side is twelve, and indeed, the "area" is 144. Another run.

14
00:04:32,150 --> 00:04:57,570
Now I select a circle, radius, say, 42. OK. And now a rectangle. The length should be, say, 10, and width, 23. And now, I input an invalid selection, say, 'X'. We've got our warning message.


@@@
1
00:00:05,480 --> 00:00:18,070
We can enhance this application further by encapsulating all the condition the logic into a separate function. So we're gonna move all this part into a dedicated function.

2
00:00:18,250 --> 00:00:49,370
Let's create a function called calculate_area() first. And now, I copy and paste this chunk of code, which starts with the declaration of the "area" variable and ends with the "else" statement's block. Press Command-X and paste it here using Command-V. We'll need to increase the indentation level of every line of code that's now part of the calculate_area() function's body.

3
00:00:49,580 --> 00:01:14,080
Python will complain if you don't indent the code properly. If I try to run this code now, I will get indentation errors. All right, so let's make the changes. Just go to the beginning of each line and hit tab.

4
00:01:14,160 --> 00:01:29,650
So, here's what you should end up with. And the function needs to return the calculated area. Next, let's implement a function that returns a textual description of the shape type that's been selected by the user.

5
00:01:29,680 --> 00:01:50,360
Programmers create such helper functions whenever it makes sense. Let's scroll down, and I create the function get_shape_name(). It takes a "tag" parameter, which is the character entered by the user.

6
00:01:50,360 --> 00:02:08,070
I define the "shape" variable, which will be returned by this function. I initialize it with the string literal "Unknown." And now, let's check the tag's value. If "tag" equals 'S', the shape is a square.

7
00:02:11,130 --> 00:02:42,390
Else if the "tag" is 'R', the shape is a rectangle. Another valid value is 'C' for circle. And we accept no other values for now. So, I just return the shape. The function takes a single parameter called "tag" that represents the user's shape selection.

8
00:02:42,390 --> 00:02:53,420
The function's block defines the variable "shape" and initialize it with the text "Unknown." Then it checks for the valid entries and assigns the corresponding shape description.

9
00:02:53,580 --> 00:03:41,590
If none of the conditions are true, the "shape" variable won't change, and it keeps its initial value, which is "Unknown." Finally, the function returns the value of the variable "shape." After all these changes, we can reduce our testing code to the following: "area = calculate_area(selection)" and I enhance the string we output to the terminal by printing the shape's name, the area of the... and her,e I'll be using our helper function get_shape_name(selection) Let's run the application. I start with a rectangle: 'R'. Okay, we've got an error.

10
00:03:41,730 --> 00:04:05,450
It says "calculate_area() takes 0 positional arguments but 1 was given." Indeed, I forgot to add the "selection" parameter. So, let's do it now. Okay, let's run it again. I pick a rectangle. The length should be 22, the width, say. 12.

11
00:04:05,450 --> 00:04:19,200
And now, the string printed to the terminal also includes the shape's type. It says "The area of the rectangle is 264." Let's see for square. The side: 55.


@@@
1
00:00:04,920 --> 00:00:19,410
As an exercise, enhance the app with the option to calculate the area of a rhombus using the following formula: A = (p * q) / 2. p and q are the diagonals of the rhombus.

2
00:00:19,410 --> 00:00:35,540
I give you some hints. First, you should create a new function, let's say, calculate_rhombus_area() that takes two parameters "p" and "q." Then, implement the code based on the formula above.

3
00:00:35,710 --> 00:00:52,820
You should also allow the user to select the rhombus by including the dedicated character in the prompt text. And don't forget to add an "elif" block for the new shape in both the calculate_area() and the get_shape_name() functions.


@@@
1
00:00:05,200 --> 00:00:19,920
Here's the solution for our section challenge. Let's start by creating the function that calculates the area of a rhombus. I insert it here and call it calculate_rhombus_area().

2
00:00:24,090 --> 00:00:57,670
We should pass in "p" and "q" - the diagonals - both of type float, and the function relies on the formula a = (p * q) / 2. Next, I allow the user to select the new shape by enhancing the selection prompt string. Indent, and for rhombus I'm gonna use 'H' since 'R' is already taken. What comes next?

3
00:00:59,320 --> 00:01:24,610
We need to enhance the calculate_area() function as well. If selection is 'H', we ask the user to input "p" and "q." Now, we have the diagonals. Let's calculate the area by calling calculate_rhombus_area().

4
00:01:33,120 --> 00:01:54,140
Let's add 'H'. And finally, I need to enhance the helper function get_shape_name(). If the tag was 'H', the shape is a rhombus. Let's execute our program.

5
00:01:58,770 --> 00:02:12,360
Looks good to me. The function works as before, except that now we can also calculate the area of a rhombus. All right, that's it. Now, you should be able to define functions in Python.


@@@
1
00:00:05,970 --> 00:00:18,520
In programming, you'll encounter situations when you've got to repeat certain tasks. Consider the following: we need to write a function that logs in the user based on a user name and a password.

2
00:00:18,540 --> 00:00:30,930
Quite a common scenario, isn't it? If the login credentials are wrong, we prompt the user to re-enter the username and the password. We could start by implementing the login function.

3
00:00:31,070 --> 00:01:13,110
So, fire up VSCode and create a new file called login.py. And I'm gonna save it as login.py. I define a function called login(). The function takes two parameters: username and password, both of type string, and we return a Boolean indicating if the login was successful or not. In the function's body, we define the "is_authenticated" variable and initialize it to False. And now comes the authentication logic.

4
00:01:16,040 --> 00:01:26,160
The if statement performs a basic user name and password check. To keep it simple, we just compare the user name and the password against predefined string literals.

5
00:01:26,240 --> 00:01:39,910
This approach is fine for this demo, but you should never use it in production code. The function returns the value of the "is_authenticated" variable.

6
00:01:39,910 --> 00:01:54,180
Next, we use the function to authenticate the user. But first, let's prompt the user to enter the login credentials. I use the input() function again to retrieve the username and the password.

7
00:02:00,840 --> 00:02:21,960
Now, call the login() function with the provided username and password. The result of the call gets stored in the "logged_in" variable. I pass in the value of the "user" and the "password," then define the "message" variable and assign it the string literal with the message for the failed case.

8
00:02:21,960 --> 00:02:45,370
How about "Login failed, check your credentials." If the login was successful, we updated the message accordingly. And finally, let's sprint the message.

9
00:02:45,470 --> 00:03:05,920
Now, we could make this part shorter. I show you a technique that relies on conditional expressions. So, let's comment this out, and instead write the following here.

10
00:03:05,940 --> 00:03:26,310
I use a conditional expression to print the right message based on the "logged_in" variable. Conditional expressions, also known as ternary operators, take the form "Expression_A if condition else Expression_B." If condition is True, Expression_A gets evaluated and its value returned.

11
00:03:26,970 --> 00:03:40,020
Otherwise, the result of evaluating Expression_B gets returned. Here's the complete source code we've written so far. We can remove this part and it becomes shorter.

12
00:03:41,060 --> 00:04:07,820
Okay, let's try it out. Right-click in the editor and select "Run Python File in Terminal." I enter the expected credentials: for username, admin and the password One two three four. "Login successful." Great! Now, rerun the program, but this time, I'm gonna use some random user names or passwords.

13
00:04:07,820 --> 00:04:34,230
Let's see what happens. User name, say, Michael. And password: "office" -> "Login failed, Check your credentials." That's the result we expected. However, instead of asking the user to re-enter the credentials, the application exits. Normally, we'd prompt the user until the login is successful.

14
00:04:34,320 --> 00:04:45,650
So, how do you do this? We'd need to write code that: 1.) prompts the user for login credentials, 2.) calls the login() function with the username and the password.

15
00:04:46,230 --> 00:05:09,830
If login() returns false, go back to step #1. Otherwise, continue with whatever follows the login part. We could express this logic by saying "Repeat asking for user input until login succeeds." or "While login not successful, ask for user credentials." That's almost exactly how we're going to implement our logic in Python.


@@@
1
00:00:05,810 --> 00:00:19,040
In Python, like in many, C-based programming languages, we can use the "while" statement to repeat execution until an expression becomes false. Here's the general form of the "while" statement.

2
00:00:19,040 --> 00:00:42,550
Note that the "else" clause is optional. So, you can skip it, and write "while expression: and then the code block. The code that belongs to the "while" clause gets repeatedly executed as long as the expression is true. In other words, the "while" loop tests a conditional expression and runs the body of the loop while the condition remains true.

3
00:00:42,680 --> 00:01:54,240
Let's use the while statement in our login program to make it ask the user for credentials until the login succeeds. We'll implement the logic in the form: "while login not successful, Keep asking for username and password." All right, start VSCode and open the login.py file If you don't have it open already. We're going to remove all the code up to line eleven. Next, implement the while loop. It tests the conditional statement that follows the "while" keyword. In our case, we want to check if the login failed. If the login() function returns false - meaning that the login failed - the condition "login(user, passw)" evaluates to False. False equals False, which is true. The expression "login(user, passw) == False" may look counterintuitive at first, but it's actually like saying: "Did the login fail?" and if the response is "Yes, the login failed.", then we proceed with the loop's code. The loops body consists of three statements.

4
00:01:54,340 --> 00:02:11,530
First, I print a warning message, telling the user that the login failed, and he should re-enter his credentials. Then, we ask for the user name and password using the input() function. Basically, we repeat this sequence.

5
00:02:15,670 --> 00:02:29,830
After executing these statements, we jump back to the start of the while loop and check the "login(user, passw) == False" condition again. This happens over and over again until "login(user, passw) == False" evaluates to false.

6
00:02:29,830 --> 00:02:48,220
When does this occur? When the login() function returns true, that is, when the condition becomes "True == False," which is false. Thus, the "while" loop will exit if the user enters the right credentials - "admin" and "1234" for password.

7
00:02:48,310 --> 00:03:14,410
The code that follows the "while" statement gets executed next. Let's add a success message after the while loop. All right, let's try it out. I enter wrong credentials: "Michael" and "office." Login failed, re-enter your credentials," and we're prompted again.

8
00:03:14,460 --> 00:03:34,140
Now, how about "Dwight," password "1x2y." And now, I enter the right credentials. "Login successful." The program keeps asking for the right credentials until login() returns true.


@@@
1
00:00:02,830 --> 00:00:14,400
In the previous lesson, we created a program that asks for user credentials. We relied on the "while" statement to keep asking for the username and the password until the login succeeds.

2
00:00:14,410 --> 00:00:30,900
Now, what happens if the user has forgotten his password? The "while" statement will loop forever - or until you shut down the computer. That's known as an infinite loop, and it's one of the nastiest bugs that can pop up in your programs.

3
00:00:30,970 --> 00:00:40,770
As a rule of thumb, we should avoid the infinite loops by providing an exit condition. The exit condition needs to make sure that the loop will terminate.

4
00:00:40,810 --> 00:00:51,260
Now, let's revisit our program. As you probably know, authentication doesn't work that way. You get punished after too many unsuccessful logging attempts.

5
00:00:51,340 --> 00:01:02,680
In the worst case, you may be even locked out of your own account. We're going to implement this behavior shortly. We need to be able to track the number of unsuccessful login attempts.

6
00:01:02,750 --> 00:01:21,190
First, create a variable called "attempt" and insert it between the statements that ask for user input and the while loop. So, here, at line 10, I'm going to add a new line and create our new variable. Initialize it to 1.

7
00:01:21,240 --> 00:01:37,200
Next, I create a variable called "max_attempts." The "max_attempts" variable stores the maximum number of allowed unsuccessful login attempts. And finally, we need a Boolean variable that shows if the login was successful.

8
00:01:37,200 --> 00:01:51,340
I call it "is_authenticated" and initialize it to "False." We'll only set it to "True" if the login succeeds. Whenever the user enters wrong credentials, we increment the value of the "attempt" variable.

9
00:01:52,870 --> 00:02:16,940
I must scroll up a bit. I insert a new line, and I increment the value of the "attempt" variable right at the beginning of the "while" code block. "attempt = attempt + 1" We could also use the plus equals (+=) operator to increase attempt by 1. So, we could make it shorter like this.

10
00:02:17,720 --> 00:02:33,790
I prefer this version, but both will work. Next, check if the attempt count is within the acceptable range by comparing it to "max_attempt." If it's greater, we should exit the loop and lock of the account.

11
00:02:33,860 --> 00:02:53,510
I just introduced a new statement: break. The "break" statement can only appear in a loop, and it terminates the loop instantly. The rest of the loop's code gets skipped, including the "else" clause if there was any. In our case, that means that the print() and the next two statements won't be executed.

12
00:02:54,850 --> 00:03:09,980
If the login is successful, we update "is_authenticated" from "False" to "True" in the "else" clause. As you may recall, "else" gets called when the expression the in the "while" statement is no longer true, that is, when the login succeeds.

13
00:03:10,480 --> 00:03:30,870
I set "is_authenticated" to "True" and print "Login successful." I'm going to move this line into the "else" code block. After the loop, we'll check the "is_authenticated" variable and inform the user that his account was locked.

14
00:03:35,700 --> 00:03:48,450
We're using the "not" logical operator that negates the value of the expression that follows it. Thus, "not is_authenticated" becomes true if "is_authenticated" is false.

15
00:03:48,450 --> 00:04:08,780
So, here's the full listing. We have our method, and now we check for the number of attempts. If "attempt" is bigger than "max_attempts," that is, bigger than 5, we lock the account and print "Your account has been temporarily locked." Let's try it out.


@@@
1
00:00:03,600 --> 00:00:31,580
The "while" statement allows us to repeat the execution of a block of code as long as the condition evaluates to true. There are many cases when we need to keep track of an index of some kind to ensure that we don't loop forever. In our previous example, the "attempt" variable was such an index, and "attempt > max_attempts" was the exit condition of our loop. Thus, the loop won't repeat more than five times, no matter what.

2
00:00:31,580 --> 00:00:47,790
Sometimes, that's precisely what we want in our programs: execute the block of code a number of times then exit. The Python "for" statement provides this type of functionality. Let us create a new Python file and call it for-loops.py.

3
00:00:50,620 --> 00:01:09,340
Here's your first for loop. The range() built-in function generates integers from 0 up to, but not including the provided stop value. Thus, range(5) creates the sequence of integers 0, 1, 2, 3, 4.

4
00:01:09,830 --> 00:01:26,440
The for loop iterate over the elements of this sequence. That's why the range() function is generally used in for loops. This code snippet prints "Called from within a for loop" 5 times. Let's try it out.

5
00:01:26,480 --> 00:01:41,240
Next, I'm gonna print the index and the iteration count. since index start at 0. I had to increment it to display the iteration count. I comment out this line, and let's rerun it.

6
00:01:45,320 --> 00:01:57,770
The range() function takes three parameters, out of which the "start" and the "step" are optional. We can specify the lower limit by providing the "start" argument when calling the range() function.

7
00:01:58,100 --> 00:02:10,669
range(1, 5) generates the sequence 1, 2, 3, 4. Just like in our previous example, the value of the "stop" argument, which is 5, is not included in the result.

8
00:02:11,980 --> 00:02:26,970
The "step" parameter specifies the difference between each consecutive number in the sequence. range(1, 5, 2) creates the sequence 1, 3. The sequence starts at 1.

9
00:02:27,090 --> 00:02:47,080
The step is 2. So, we keep incrementing the numbers by 2. The second number becomes 3, and the third number would be 5. However, we reached the top value - 5. So, 5 is not included in the sequence. Both "start" and "step" are optional.

10
00:02:47,120 --> 00:03:06,970
If we don't specify these arguments, the default values apply, which are 0 for "start" and 1 for "step." It's worth highlighting the difference between the "while" and the "for" loop. The while loop executes until the condition is no longer true whereas the for loop runs a block of code a finite amount of times.


@@@
1
00:00:04,190 --> 00:00:18,380
We've seen that the "break" statement can be used to exit the while prematurely. You can use it also with a for loop, and the effect is the same. It instantly breaks out the loop and execution continues after the loop.

2
00:00:18,380 --> 00:00:33,750
Now, let's modify the for loop as follows. This condition checks if the index is 2, and then it breaks out of the for loop. So, our for loop will execute the first time because the index is 0.

3
00:00:33,770 --> 00:00:47,780
That's the starting value. It will print index 0, and index plus 1 iteration count, that is, 1. The next iteration will print index 1, and iteration count 2.

4
00:00:47,890 --> 00:01:02,650
Since index is 1, 1 equals 2 is false. So, we don't break yet. However, the third iteration is when the index becomes 2. index is 2, meaning that 2 equals 2, is true.

5
00:01:02,650 --> 00:01:19,880
So, we break out of the loop. Let's check it out. Clean our console. And now, let's run our Python file. Indeed, we see the two iterations here. There is another statement that's available for controlling loops.

6
00:01:20,080 --> 00:01:30,400
The "continue" statement can be used to skip the rest of the code block and start executing the next iteration right away. Let's replace line number three with the following.

7
00:01:33,380 --> 00:01:45,850
The condition at line number three checks if the index is perfectly divisible by 2, with no remainder. Here, I use the percentage sign (%), which represents the modulo arithmetic operator.

8
00:01:46,010 --> 00:02:00,260
This calculates the remainder. The expression "n % 2 == zero" evaluates to true for even, and to false for odd numbers. Let's see some examples: 1 module 2 is 1.

9
00:02:00,270 --> 00:02:20,600
That's because 2 goes into 1 zero times, so the remainder is 1. We could also express it this way: 1 is 2 times 0 plus 1. 2 modulo 2 is 0 because 2 goes into 2 exactly one time, and the remainder is 0.

10
00:02:20,690 --> 00:02:39,900
Again, we could write this as 2 equals 2 times 1 plus 0. For any odd number, the remainder of division by 2 is 1, whereas even numbers are perfectly divisible by 2. All right.

11
00:02:39,920 --> 00:02:54,150
Let's delete these lines and go back to our for loop. If the number is even, the "continue" statement skips the rest of the code block. As a consequence, only the odd numbers get printed.

12
00:02:54,270 --> 00:03:09,930
Let's see the result. I'm gonna run the Python file again, and we can see we print the index 1 and 3. Only the odd indices get printed. As an exercise, modify this code to print the even numbers.

13
00:03:10,050 --> 00:03:22,660
It's pretty easy. You should only modify the condition here, at line 3. To summarize: You can use the "continue" and the "break" statement with both the for and the while loops.

14
00:03:22,660 --> 00:03:33,820
It is important to remember the difference between the two loop control statements: "break" exits the current loop, whereas "continue" shortcuts the loop and starts the next iteration.


@@@
1
00:00:03,780 --> 00:00:26,510
In this video, we refactor the Login program we implemented at the beginning of this chapter. So start VSCode and open the login.py file. Now, select File, Save As, and save the file as login-using-for-loop.py.

2
00:00:26,520 --> 00:00:38,070
Next, delete all the code except the login() function and the two statements asking for user input. We'll also need the "is_authenticated" Boolean variable, so keep that line, too.

3
00:00:38,220 --> 00:00:53,060
You should end up with the following code: the login() function, the user input queries, and the "is_authenticated" Boolean variable. We can also delete the "attempt" and the "max_attempts" variables as well.

4
00:00:53,080 --> 00:01:10,400
We won't use them anymore. Now, we're going to implement a version that relies on the "for" statement. The overall logic should stay the same: we let the user enter the credentials four more times after the first attempt, that is, five times in total.

5
00:01:10,910 --> 00:01:29,760
This can be expressed with the following "for" loop. Next, call the login() function. If it returns true, set the "is_authenticated" variable to true, and terminate the loop using the break statement.

6
00:01:32,380 --> 00:01:51,250
Otherwise, print a warning. So, I'm using "else" and print "Login failed, re-enter your credentials." And we ask the user to enter their user name and the password using the input() function.

7
00:01:51,330 --> 00:02:19,760
Actually, we can copy the code from here. Command-C or Control-C on Windows, and Command-V or Control-V. Let's indent it. And that's the for loop's complete code. After the loop, I use a conditional expression to print the right message based on the value of the "is_authenticated" variable.

8
00:02:19,990 --> 00:02:43,610
I print "Login successful" if "is_authenticated" is true, else, we lock the account temporarily. If "is_authenticated" has not been set to true, that means that the user made five failed attempts to enter the credentials, and we lock his account.

9
00:02:44,510 --> 00:03:03,430
And here's the full listing. As you can see, this version is shorter and cleaner compared to the version with the while loop because we don't have to increment and check the "attempt" variable manually. And finally, here are a couple of simple rules that will help you identify which loop statement to choose.

10
00:03:03,490 --> 00:03:15,290
Use the while loop to execute a block of code as long as a condition is true. And choose the for loop to repeat your code a fixed number of times. All right.


@@@
1
00:00:03,160 --> 00:00:17,080
You already know how to work with variables that hold individual pieces of data, such as a single number, one string or one Boolean. They did an excellent job in all the demos we've built so far.

2
00:00:17,080 --> 00:00:34,640
However, there are situations when we need to represent collections of items. Imagine that you want to build an application that lists your favorite restaurants or the names of your followers on Twitter. You could use a variable of type string and include all that data.

3
00:00:34,940 --> 00:00:48,080
But how would you retrieve or modify a particular item from that string effectively? We need a better way to organize our data. Python provides data types that can hold multiple values.

4
00:00:48,080 --> 00:01:01,330
The sequence is the most basic data structure, and it stores the items in a specific order. Each element has an index associated with it, which represents its position within the sequence.

5
00:01:01,370 --> 00:01:14,270
We've got sixth names in this list, and each has an index. Note that the indices start at zero. Trading them as if they started with one is a common programming mistake.

6
00:01:14,270 --> 00:01:27,840
So, if you have a sequence of six items, the indices go from 0 to 5, and not from 1 to 6. We can access and modify the contents of a sequence using their indices.

7
00:01:27,920 --> 00:01:41,390
We'll talk later about more advanced data structures that let us access the elements through unique keys. But first, let's delve into sequences. Python has six different built-in sequence types.


@@@
1
00:00:02,600 --> 00:00:17,820
Let's start with the most frequently used container type, the list. A list lets us store multiple elements in a specific order. I suggest you follow along with me by typing and trying out the code that's discussed in this section.

2
00:00:18,080 --> 00:00:47,640
Start VSCode and create a new file called lists.py -> "File," "New," save it as lists.py. We can use the following syntax to create a list. The list() function creates an empty list. If we want to use it, we need to assign the returned empty list to a variable. Printing the list shows that it's indeed empty.

3
00:00:50,880 --> 00:01:54,410
The brackets in the terminal log denote a list, and we can actually initialize the list using this syntax. So, we could write "primes = []." We can add elements using the list's append() method. We'll talk about the difference between methods and functions in the "Introduction to Object-Oriented Programming" chapter. primes.append(), and let's append some prime numbers. We start with 2. Now, I copy this line, and the next prime is 3, 5, 7, and the last one - 11. Let's print it out. And here we go. The argument passed to the append() method gets added to the end of the list. You can see how the list changes by adding a new element. And now, run the file again.

4
00:01:55,520 --> 00:02:10,520
As you can see, 13 has been added to the end of the list. Using the brackets syntax, we can provide the list's elements upon its creation. So, instead of appending the elements, we could write the following.

5
00:02:13,180 --> 00:02:30,380
And the result is the same. The resulting list is mutable also in this case. So, we can add new elements to the end of the list using append(). Let's append 13, and also 17.

6
00:02:33,510 --> 00:03:09,980
We're not restricted to storing integers in a list. Here's a list that contains strings. "names = ["Michael", "Dwight", "Pam"]." And we can have lists of Boolean values as well: "values = [True, False, False, True]" Python, unlike most C-based languages, allows the mixing of types within the same list. The following listing is completely valid.

7
00:03:10,270 --> 00:03:34,470
"bag =" let's initialize it with integers "[1, 2, 3]." Then, append a string, let's say, "Pam." Then, I append a Boolean, and again a number. Finally, let's print our bag's contents.


@@@
1
00:00:02,380 --> 00:00:40,900
Each element in a list has an index associated with it. The index is zero-based, and it gets incremented for each consecutive item. Given the following list, the indices of the items are 0 for Michael, 1 for Dwight, and 2 for Pam. To access an element in the list, we use the name of the list variable followed by the index operator []. Inside the brackets we specify the element's index. The following expression "list[]" - and here, you have to provide an index - returns the element with the given index.

2
00:00:41,060 --> 00:01:04,879
Now, can you tell me the value of the "name" variable after executing these statements? Pause the lesson and take some time to think. Ready? So, let's double-check your answer. The item at index 0 is Michael, Dwight has the index 1, and Pam is at index 2.

3
00:01:05,010 --> 00:01:21,800
Thus, the correct answer is Pam. What happens if we tried this? There is no element at index 3. Accessing an index that doesn't exist will trigger an IndexError.

4
00:01:21,800 --> 00:01:31,610
To avoid such errors, we could check the index before using it. A list index should not be negative, and it must be smaller than the number of items in that list.

5
00:01:31,610 --> 00:02:18,370
We can express these conditions as follows. Let's build a helper function that validates the index before using it. I call the function is_valid_index(), and it takes two parameters: the index of type Integer and the list we want to access using the specified index. It returns a Boolean. Next, create a variable that represents the result and initialize it to "False." If the index is within the acceptable range, we update the result to "True." Otherwise, it keeps its original value, which is false.

6
00:02:19,090 --> 00:03:09,210
And finally, let's return the result. Now, we can use this function to validate the index prior to using it. I'm going to delete this line. And let's check an index, say, index is 3, and I will use an f-String. I output a message here: "Index," and the value of index "is valid" if - I call our new helper function - "if is_valid_index(index, )", and I provide our list, else, index is out of range.

7
00:03:09,290 --> 00:03:22,130
Now, I run our program. As you might have observed, I'm using this "Run Python File in Terminal" shortcut button here. If you have the latest VSCode version you should also see this button.

8
00:03:22,140 --> 00:03:34,820
It's equivalent to using the right-click context menu and "Run Python File in Terminal." So, let's just press the green triangle. And here's our message.

9
00:03:34,820 --> 00:03:51,900
"Index 3 is out of range." If I change it to two, it should be valid: "Index two is valid." And you can play around with it say, 13, is obviously invalid. 0 should be valid.

10
00:03:52,050 --> 00:04:06,770
And how about -1? Out of range as well. So, it works. All right, we've seen how to access the items of a list, and we even implemented a function to validate the indices.


@@@
1
00:00:02,190 --> 00:00:18,430
We've seen how to retrieve the items from a list. Accessing an element through its index returns the element at that position, but it doesn't modify or remove it. To update an element in a list, we can assign it a new value using the brackets syntax.

2
00:00:18,510 --> 00:00:37,600
Now, start VSCode and create a new file called modifying-lists.py. First, I declare a list called "primes." In this example, we're going to modify the element at index 1 in the "primes" list.

3
00:00:37,600 --> 00:00:53,590
Let's make it equal to 17. The item at index 1 gets replaced with the new value. I insert two print() statements to visualize what's happening here. And now, let's print the list also after the change.

4
00:00:56,720 --> 00:01:08,960
As you can see, 3 has been replaced with 17. If we use an index that doesn't exist, we'll get an IndexError. Add the following line and run the program.

5
00:01:09,390 --> 00:01:25,960
So, let's make the element at index 5 equal to 19. We don't have anything at index 5. If you check the primes list, it only has 5 elements, which means its last index is 4.

6
00:01:25,970 --> 00:01:48,350
Remember: we start indexing with 0, so the first index is 0 - 1, 2, 3, 4. There's nothing at index 5. That's why we get this IndexError. So, I'm gonna remove this line. We can use the append() list method to add a new element to a list instead of replacing existing ones.

7
00:01:48,350 --> 00:02:04,830
Let's append 13. The new element gets appended, that is, added to the end of the list. Let's print our list. And here, 13 has been added to the end of the list.

8
00:02:04,930 --> 00:02:14,800
The list's size gets incremented after each append() call. If the list was empty, append() adds the element to the list and the list's size becomes 1.

9
00:02:14,830 --> 00:02:31,640
Let's write some code. I create a new variable called "characters," and initialize it with an empty list. Now, let's append a character, say, 'a' and I print its length.

10
00:02:31,820 --> 00:02:44,480
Here, I am using the len() built-in function, and the output shows the length of the characters list. We can make it more user-friendly by using an f-String.

11
00:02:47,160 --> 00:03:01,170
And let's rerun the program. There are cases when we want to insert a new element at a given position. The insert() list method inserts the new value just before the element at the specified index.

12
00:03:01,170 --> 00:03:18,860
The existing items with an index greater than or equal to the specified index get moved one position to the right. Let's inspect the following statement and provide an index of 1 and the value 3.

13
00:03:18,860 --> 00:03:37,420
This line inserts the value 3 at index 1 into the primes list all the existing list items starting at index 1 are shifted 1 position to the right. Finally, the new value gets inserted at index 1, and here's the resulting list.

14
00:03:37,530 --> 00:03:55,710
You can see, the number 3 appeared after 2 at index 1, and 17 - which used to be at index 1 - is now at index 2. All the other elements have been shifted 1 position to the right. 2 stays in place, because it was at a lower index.

15
00:03:55,710 --> 00:04:20,120
We can also remove elements from a list. The pop() method returns the item at the given index and deletes it from the list. Let's pop the element at index two. The resulting gap is filled by moving all of the elements with higher indices one position to the left. The element at index 2 is removed from the list and returned after the call to pop().

16
00:04:20,120 --> 00:04:45,360
So, we could print both values, and I'm gonna use an f-String here as well. "Element {n} removed... " The list became [2, 3, 5, 7, 11, 13]. Note that the index parameter is optional.

17
00:04:45,590 --> 00:05:00,700
Calling the pop() method without an index argument deletes and returns the last item in the list. So, if I call primes.pop() we get the last element removed, which is 13.

18
00:05:00,710 --> 00:05:16,410
The rest of the list remains unchanged. We still have the old elements - all the elements preceding the last value, which was 13. Now, you shouldn't call pop() on an empty list or with an invalid index, because it will trigger an IndexError.

19
00:05:16,430 --> 00:05:27,100
We can also remove an item without returning it using the remove() list method. Unlike the pop() method which takes an index argument, remove() expects a value.

20
00:05:27,110 --> 00:05:50,230
Bear in mind that the value must be in the list, or you will get a ValueError. I scroll up a bit, and I call primes.remove(5). Again, this takes a value, and not an index. Now, since the value 5 is in the "primes" list, the call should succeed. Indeed, 5 is gone.

21
00:05:50,520 --> 00:06:01,710
The list's elements get reindexed as in the case of calling pop(). Now, these were the most common methods used to modify a list in Python, but you will get to know more in the upcoming sections.


@@@
1
00:00:02,450 --> 00:00:16,920
Tuples are basically lists that you can't change or update after initializing them. In programming, we call such types immutable. To construct a tuple, we simply list the elements separated with commas.

2
00:00:17,050 --> 00:00:36,770
Now, start VSCode and create a new file called tuples.py. Define your first tuple by typing the following code. The enclosing parentheses are optional, but I prefer this style for better visual separation.

3
00:00:36,770 --> 00:00:47,120
Note that I used enclosing parentheses () and not square brackets [] to declare the tuple. Square brackets are used to declare lists, as described in the previous lessons.

4
00:00:47,150 --> 00:01:10,850
Now, the enclosing parentheses are only required when declaring empty or single element tuples. So this is how you will declare an empty topple or a single element topple A lot of what we covered for lists applies to tuples as well - except for the methods used to modify their contents.

5
00:01:11,030 --> 00:01:37,560
We can't call pop(), insert(), or append() on a tuple. If you tried that, you'd get a syntax error. As you can see, the error says the "'tuple' object has no attribute 'append'." Neither pop, or insert.

6
00:01:41,780 --> 00:02:02,480
However, we can access the elements of a tuple using the tuple[] syntax. Let's print the number at index 2 from the "even_number" tuple. It's 4. Indeed, 0 has the index 0, 2 has the index 1, and 4 is at index 2.

7
00:02:02,510 --> 00:02:17,110
Now, can you tell me what gets printed after executing this line? You're right! It prints 8, because that's the item at index 4. Now, what about this line?

8
00:02:20,280 --> 00:02:38,660
If you said it will produce an error, you were right. The highest index in the "even_number" tuple is 4. Hence, we'll get an IndexError. As a rule of thumb, use a tuple if you need a sequence of constant values that don't need to change.

9
00:02:38,750 --> 00:02:50,320
Declare a list if you must modify or update its contents. All right, you've learned about the list and the tuple. But wait, there is another kind of sequence as we'll see in the moment.


@@@
1
00:00:02,910 --> 00:00:23,220
Lists and tuples are great ways to structure ordered data. Python offers another built-in container type, the dictionary. A dictionary lets us store key-value pairs, and it's the perfect data structure if you need to look up values based on their identifiers. Each value must be associated with a unique key.

2
00:00:23,340 --> 00:00:34,260
We can then use the key to access a particular value in the dictionary, but not the other way around. While the key needs to be unique, the values can be redundant.

3
00:00:34,290 --> 00:00:59,640
For example, the key could be the social security number, and the value is the person's name. The social security number 123-456-789 identifies a particular "John Appleseed." However, there might be other persons with the same name but with different SSNs. And one more thing: the order of keys and values is undefined in a dictionary.

4
00:00:59,640 --> 00:01:23,500
All right, let's write some code. Start VSCode and create a new file called dictionaries.py. You can create an empty dictionary using the dict() function. Try it out by typing the following statement in the code editor: "ssn_name_pairs = dict()" The shorthand syntax for creating an empty dictionary uses two curly braces {}.

5
00:01:23,820 --> 00:01:38,910
So, we get the same results if we write the following. We can add key-value pairs to a dictionary by writing the name of the dictionary followed by the key between square brackets, and assign the value using the equals sign.

6
00:01:41,050 --> 00:02:02,130
It's also possible to initialize a dictionary upon its declaration, by putting the key-value pairs between curly braces. Each key is separated from the value by a colon, and the key-value pairs are separated by commas. And let's print out the contents of our dictionary.

7
00:02:02,250 --> 00:02:28,460
Now, the output might differ in your case, because dictionaries don't store their keys and values in order. To retrieve the value associated with a key from a dictionary, use the syntax dictionary_name followed by the key between square brackets. The following statement prints "Pam Beasley" to the terminal, since her name is the value mapped to the given key.

8
00:02:28,540 --> 00:02:47,470
Now, what happens if you try to use a key that's not in the dictionary? And I provide a key, let's say "999-999-999." Trying to access a value using an invalid key triggers an error of type KeyError.


@@@
1
00:00:02,500 --> 00:00:13,700
Dictionaries can be modified - regardless of the way we initialized them. In other words, we can add key-value pairs or replace the value linked to a particular key.

2
00:00:13,780 --> 00:01:05,069
Use the following syntax to add a new key-value pair. If the key already exists in the dictionary, the associated value gets updated with the new value. The statement updates the name "Pam Beasley" with "Angela Martin" for the key "000-000-003." However, if we use a new key, the key-value pair gets added to the dictionary. We can also delete items from a dictionary using the del() function. To identify the item to be deleted, we need to pass in the dictionary name followed by the specific key between square brackets. Let's delete "Dwight." And Dwight's key is this. Let us borrow it from the dictionary.

3
00:01:05,069 --> 00:01:22,710
All right. We're going to track the changes using print() statements. Let's comment these out. So, I put a print here, and let's print the contents of the dictionary after calling the delete function.

4
00:01:24,230 --> 00:01:43,040
Originally, we had a dictionary with four key-value pairs. Then, we deleted "Dwight Schrute," and now we've got three key-value pairs left. "Dwight Schrute" and his key are gone from the dictionary. Before calling del(), make sure the key exists.

5
00:01:43,630 --> 00:02:56,200
Otherwise, you will get a KeyError. Let's change the key to something that's not in the dictionary. And now, I run the program - and here's our KeyError. You can use the "in" keyword to check if a particular key exists in the dictionary. The following code snippet checks for the key before trying to delete the corresponding key-value pair: "if key in ssn_name_pairs:" then we can call delete safely. The key and the associated value gets deleted from the dictionary. Otherwise, we print a warning to the terminal. I use an f-String to include the key, and we print "Invalid key" and the value of the key. Now, this key doesn't exist in our dictionary, so we'll get a warning message. Let's change it to a valid key, let's say, "000-000-003." And now, the key and the associated value was deleted successfully.

6
00:02:59,620 --> 00:03:13,150
All right, let's wrap it up. The dictionary offers fast access to its elements through unique keys associated with each item. It is important to remember that the order of the stored key-value pairs is undefined.


@@@
1
00:00:02,490 --> 00:00:23,820
Containers let us store and organize our data. You've learned so far that the list and the tuple store the values in a specific order, and we can access those values using their indices. The dictionary stores key-value pairs, and it should be used to quickly access the data through the unique keys associated with each value.

2
00:00:23,820 --> 00:00:42,560
One of the most common tasks you will do with a list is to iterate through its elements. We can do that easily using the "for-in" statement. Start VSCode and create a new file called looping-through-containers.py. We start by creating a list of prime numbers.

3
00:00:45,540 --> 00:01:02,760
And here comes the for-in loop. "for number in primes:" and now we print each number, and we can see the result in the terminal. Another possibility is to iterate through the list using a "while" loop.

4
00:01:02,880 --> 00:01:22,760
We need an index. We iterate while the index is smaller than the length of the list. And let us print each item by index. Finally, we increment the index in each iteration. Same result.

5
00:01:22,810 --> 00:01:34,760
Notice that I had to introduce an additional variable for keeping track of the index. We have to increment the index upon each iteration, and check if it's still valid in the while statement.

6
00:01:34,760 --> 00:01:50,230
The len() function gives us how many elements there are in the "primes" list. We have five items in total, and the valid indices are in the range [0, len(primes) - 1] Bear in mind that indices start at zero.

7
00:01:50,270 --> 00:02:02,450
Thus, the fifth element has the index 4, and not 5, which is the length of the list. That's why we check if the index is less than the number of items in the list.

8
00:02:02,570 --> 00:02:18,910
If we go back to our for-in loop, you can see that it's much cleaner. We need no boundary checks or index housekeeping of any kind. Now, we can do more useful things than just printing out the values as we loop through the items of a list.

9
00:02:18,930 --> 00:02:37,790
For example, we could check if a number is odd or even. I use the modulo operator. We've used it in a previous lecture, so it should be familiar. If the number is perfectly divisible by 2, then it's an even number.

10
00:02:39,860 --> 00:03:02,790
Otherwise, we have an odd number. How about collecting the odd and even numbers in dedicated lists? I create two variables - two lists: "even_numbers" and initialize it to an empty list, and "odd_numbers" - another empty list.

11
00:03:02,860 --> 00:03:30,570
Now, if the number is even, instead of printing a message we add it to the "even_numbers" list. I use the append() list method, and if it's an odd number, I add it to the "odd_numbers" list. Then, we can use the "for-in" loop to iterate through the "even_numbers" and "odd_numbers" lists, too. We start with the even numbers.

12
00:03:34,300 --> 00:04:12,760
"for i in even_numbers:" print(i)." And then, we print the odd numbers. "for j in odd_numbers: print(j)" Indeed, our list contains only one even number, the two. All the others are odd numbers: 3, 5, 7, and 11. As you can see, the "for-in" loop has a clear, intuitive syntax.


@@@
1
00:00:03,690 --> 00:00:17,430
Now, how about iterating through the elements of a dictionary? As you may recall, the dictionary doesn't store its elements in a predefined order. Therefore, iterating through the values of a dictionary doesn't make sense.

2
00:00:17,430 --> 00:00:36,490
However, we can retrieve all the keys or values of a dictionary using its keys() or values() methods. Type in the following code in your editor. I create a variable called "keys" and assign it to ssn_name_pairs.keys().

3
00:00:36,530 --> 00:00:57,130
This dictionary method returns all the keys as a set. And same for values. And now, we can write the for-in loops to iterate through the keys and the values. Dictionary keys first.

4
00:00:57,850 --> 00:01:36,370
"for key in keys: print(key)" And the values: "for value in values: print(value)" And here, you can see the output. Again, the order is undefined, and it might be different when you run it, because the dictionary stores its elements in an arbitrary order.

5
00:01:36,380 --> 00:01:52,140
There is also an items() dictionary method that returns tuples of key-value pairs. I create another variable called "key_value_pairs" and assign it the value ssn_name_pairs.items().

6
00:02:00,130 --> 00:02:32,830
And now, we can print the key-value pairs. "print(key_value)." Let's run it. And here are the key-value pairs. Alternatively, you can write the for-in loop to retrieve a key-value tuple directly upon each iteration. So, here we have a tuple, and I can print the key and the value separately.


@@@
1
00:00:02,660 --> 00:00:15,010
To solidify what you've learned, we'll implement an application that relies on Python containers. We start with a dictionary that contains the social security numbers as keys associated with names.

2
00:00:15,020 --> 00:00:31,040
Our task is to extract all the names that appear more than once and print them along with the social security numbers. Let us begin by creating a new file in VSCode called find-duplicates.py.

3
00:00:31,130 --> 00:00:51,550
Next, define the following dictionary. Solving a challenge requires us to understand the task and the expected output. Note that the name "Dwight Schrute" appears only once, while "John Appleseed" is listed twice, and we've got three "Pam Beasley" names in the dictionary.

4
00:00:51,550 --> 00:01:04,860
We need to find the duplicate names and print them together with their SSNs. The result should be in the following form. So, we have the name, and then the social security numbers.

5
00:01:04,860 --> 00:01:24,390
Since John Appleseed appears twice, we have two SSNs. Pam appears three times in the dictionary, so we have three SSNs. Now, to produce the expected output, we need to construct a dictionary that has the name as the key, and the value should be a list of SSNs.

6
00:01:24,620 --> 00:01:49,390
So, we need the dictionary in the form name, which is the key, and the social security numbers within the list. Again, a key, and a list of social security numbers. This format requires a dictionary that holds lists as values.

7
00:01:49,390 --> 00:02:05,100
Luckily, Python and all the other programming languages I know let us construct containers that store other containers in them. Since you already know what a function is and how to define it we incorporate the extraction of logic in the following function.

8
00:02:05,170 --> 00:02:31,730
I call the function find_duplicate_names(), and it takes a single parameter of type dictionary. The return type is also a dictionary. So, this function takes the dictionary that holds the SSN-name pairs as an input argument, and returns the dictionary of name-SSN list pairs.

9
00:02:31,740 --> 00:02:43,560
Now, let's start implementing the function's body by creating an empty dictionary. Next, extract the values of the input dictionary using the values() dictionary method.

10
00:02:43,600 --> 00:03:17,760
This call returns all the names in the dictionary. We need these names to find the duplicates. The values() method returns a view, that needs to be converted to a list using the list() function. We convert the result of calling the values() method on the dictionary to a list. Now, we'll iterate over the key-value pairs of the input dictionary using a for-in loop. I use the items() dictionary method to access the key-value tuples as discussed in the previous lesson.

11
00:03:17,930 --> 00:03:30,590
And now, we check if the name appears multiple times in the dictionary. Here's where we need the "names" list variable. Since we're interested in the duplicates, we check if the given name appears more than once in the list.

12
00:03:31,010 --> 00:03:42,620
And if we found a duplicate we have to add the name as a new key to the result dictionary. The belonging SSN needs to be inserted in the list of SSNs for the redundant name.

13
00:03:42,620 --> 00:04:08,910
I use the get() method instead of using the key-based access, because the latter would cause an error if the key doesn't exist. The key is the name, and the the default value it should return, which is an empty list. And then, we append the SSN to the list of SSNs mapped to the given name. And finally, we return the result.

14
00:04:08,920 --> 00:05:08,030
Now, let's test the function. I create a variable "duplicate_name_ssns" equals, and I call find_duplicate_names() by passing in the "ssn_name_pairs" dictionary. I'm gonna print the results using a for-in loop. "for (name, ssns) in duplicate_name_ssns.items()" We'll print a message using an f-String: "Found duplicate name..." and the name, "with SSNs:" and the list of SSNs. Now, let's see how it works. Excellent! It found "John Appleseed" twice, and Pam three times. All right.


@@@
1
00:00:02,940 --> 00:00:17,310
Even experienced programmers make mistakes. So, it's normal that your code doesn't compile at first when you're a beginner. You may miss a colon, skip an argument in the function call, or use the wrong indentation.

2
00:00:17,310 --> 00:00:28,930
These are common mistakes, and Visual Studio Code - and all the other modern IDEs - will help you fix most of them. This section is not about syntax problems.

3
00:00:28,950 --> 00:00:42,740
Instead, we're going to talk about runtime errors - the issues that come up when running our code. We've seen such errors in our code examples so far. like TypeError, IndexError, and so on.

4
00:00:42,960 --> 00:01:08,520
We prevented these errors by implementing the required conversions and validating the indices before using them. As our programs become more sophisticated, it gets harder to detect subtle problems. The code may break in unexpected places, and it's natural to get frustrated when that happens. You just invested time and effort into learning something new, but it doesn't work as expected.

5
00:01:09,030 --> 00:01:29,570
Hang in there, and I show you how to handle these nasty programming errors. Start by opening VSCode and create a new file called errors.py. Now, type the following code: "z = 10 / 0." And let's run it.

6
00:01:29,810 --> 00:01:42,230
It's a trivial mistake: we tried to divide a number by zero. Nobody makes such basic mistakes, right? But wait, The issues are not always that obvious in programming.

7
00:01:42,230 --> 00:02:14,280
Now, delete the line you just typed, and check out the following code: "x = 10." And now, I write a for-in loop: "for i in range(100):" "x -= 2," and let's print "i / x." Can you spot the problem? If I run this snippet, I get the same ZeroDivisionError as before.

8
00:02:14,320 --> 00:02:41,690
However, the problem isn't that evident as in the case of "z = 10 / 0." We need to analyze the code and depending on our ability to detect logic problems, it may take some time to find that the issue. In the loop body, We keep dividing the value of "i" with "x." As we iterate through the range, x gets smaller, and after 5 iterations, it becomes zero.

9
00:02:41,740 --> 00:02:55,540
Thus, we end up dividing by zero again. In worst cases, ihe issue remains uncovered and it causes your program to crash. Now, add a print statement after the for loop and run the program again.

10
00:02:57,920 --> 00:03:09,810
The greeting doesn't get printed to the terminal. The line that triggered the arithmetic error causes your program to crash. Now, errors like this often arise in programming.


@@@
1
00:00:02,810 --> 00:00:13,710
Exception handling allows us to handle unforeseen errors, that can occur in spite of our best efforts to implement bug-free code. Now, imagine the following situation.

2
00:00:13,790 --> 00:00:42,940
You need to create a program to solve for 'x' in "a * x + b = c." The user enters a, b and c, and the program calculates the variable x. The math part is straightforward. To calculate x, we use the following formula. Here's the explanation just in case you were wondering how we arrived at this solution. First, subtract 'b' from both sides of the equation.

3
00:00:43,060 --> 00:01:02,920
Since "b - b" is zero, the equation becomes "a * x = c - b." After dividing both sides by a, we get the formula that solves for 'x' in "a * x + b = c." All right, now let's implement the program.

4
00:01:02,930 --> 00:01:39,010
Open up VSCode and create the file equation-solver.py. Start with the solve_equation() function that calculates x using the formula above. It takes three parameters: a of type float, b - also a float, and c, the same type. And it returns a result of type float. And the implementation. We're converting the parameters to float using the built-in float() function.

5
00:01:39,010 --> 00:01:51,780
We need to perform this conversion to ensure that we're using the right numeric type. Next, write these statements to let the user input the values for a, b and c respectively.

6
00:01:51,790 --> 00:02:20,620
Let's start with a message to show what we're doing. So, we're trying to solve this equation: "a * x + b = c," which is a linear equation. And now, ask the user for all the three variables. And the code is similar, so I'm just going to grab line 5, and copy-paste it.

7
00:02:20,720 --> 00:02:44,990
b, and c. And finally, let's call the solve_equation() function to calculate x, and then print the result. "x = solve_equation()," and I pass in the parameters a, b and c. And let's print the result.

8
00:02:44,990 --> 00:03:02,820
I'm using an f-String. The message is "x is..." and the value of x. Now, run the program. For 'a' I enter 10; 'b' - let's make it three, and 'c' - how about 5?

9
00:03:02,880 --> 00:03:24,090
So, this is one possible outcome. Now, rerun the program and make sure you enter 0 for a, b is 3, and C, 42. We got an error. Although our code has no issues, we can't control what the user enters.

10
00:03:24,140 --> 00:03:34,040
There are different ways to solve this problem. One approach is to catch errors if they happen. The technique is commonly called exception or error handling in programming.


@@@
1
00:00:02,660 --> 00:00:30,180
In this lecture, we're going to incorporate exception handling into the equation solver program. Python uses the "try" and "except" keywords to handle exceptions in the form: "try:" "except ErrorType:" The "except" statement can catch multiple exceptions by listing the exceptions within parentheses separated by commas. You will also encounter try statements with more than one except clause.

2
00:00:30,370 --> 00:00:40,270
This form is useful if your code may throw different exceptions and you want to handle them separately. This strategy is called Structured Exception Handling.

3
00:00:40,270 --> 00:01:00,750
Now, let's go back to our equation solver. So, here's our function. Instead of returning the result of "c - b / a" directly, we're going to include exception handling using "try" and "except." I added the code that my throw ZeroDivision error in the try clause.

4
00:01:00,910 --> 00:01:26,970
If the error occurs, we catch it and print a warning. "except ZeroDivisionError:," and if it occurs, we print an error message - "Error! 'a' can't be 0. Enter a valid value." Now, if we execute this code, everything works as before.

5
00:01:28,200 --> 00:01:45,920
But there is a huge difference! You'll notice the benefits of exception handling when you enter the value 0 for 'a.' Instead of crashing, the program outputs an error message. And the last print() statement is also executed. Although, the value of x is undefined.

6
00:01:45,930 --> 00:02:05,510
That's why we see "x is none." Now, let's rerun the program and enter some non-numeric characters: "q" for a, "w" for b, and "y" for c. In spite of our exception handling efforts, we got an error.

7
00:02:05,510 --> 00:02:16,430
This is something new. "ValueError" is an error that we didn't handle. We can catch this new error type by adding it through the errors caught by the "except" statement.

8
00:02:16,430 --> 00:02:50,630
Now, I need to use parentheses, since we have multiple values. And I'm going to add ValueError to the list. Let's run the program again: "q" for a, "w" for b, and "y" for c. Now that we're handling multiple errors, we need to change the warning message to something more generic, like "Error! Enter a valid value." Sometimes, it's a better idea to handle errors separately.

9
00:02:50,630 --> 00:03:14,230
Doing so allows us to implement specific logic. In our case, we'll emit a dedicated warning for each error type. So, here we should tell that a can't be 0, and if we got a ValueError, that's a different thing.

10
00:03:15,830 --> 00:03:42,270
So, let the user know what's the real issue: "Make sure you enter numeric values." And now, we should get different error messages. Let's test the first scenario when we have 0 for a: "Error! a can't be 0." And now repeat for non-numeric values.

11
00:03:42,270 --> 00:03:57,870
So, for a I enter "a," for b "b," for c whatever. And now, we've got the second message. So, that's how we intercept and handle errors in Python. We talk about raising exceptions next.


@@@
1
00:00:02,620 --> 00:00:13,740
There are cases when we want to handle the error, but throw it further and let the caller decide what to do next. The "raise" keyword allows us to re-raise an error.

2
00:00:13,990 --> 00:01:08,480
We'll continue working with the equations-solver.py. So, reopen it if you haven't opened it already. Add the "raise" statement to the second "except" clause. Now, run the app and enter invalid, non-numeric values. We see the error message printed to the terminal, but the ValueError exception occurs, too. To make it disappear, we need to handle the error also on the caller side, by embedding the "x = solve_equation()" statement in a "try" clause. And we need the "except" part, too. Print "Something bad happened." Note that "except" has no errors listed, which means that it catches all exceptions.

3
00:01:08,690 --> 00:01:25,160
That's a bad idea, since we'll also catch exceptions that aren't actually errors that should be handled by user code. Instead of using a bare except, a better approach is to catch all normal errors - that is, the errors meant to be intercepted by client code.

4
00:01:25,250 --> 00:01:42,290
These errors are represented by the "Exception" type. So, I'll put "Exception" here. The "try" - "except" statement has an optional "else" clause. The else block gets executed if the try clause doesn't raise an exception.

5
00:01:42,290 --> 00:02:00,830
So, let's add "else" to our code. If everything went well, there was no exception. We print the value of x, instead of having it here. The use of the "else" clause is recommended over adding additional code to the "try" clause.

6
00:02:00,840 --> 00:02:13,130
This approach avoids catching exceptions that aren't raised by the code protected by the "try" - "except" statement. We can use the "raise" statement to force a specific exception.

7
00:02:13,130 --> 00:02:30,110
For example, we could check the user input to prevent division by zero issues early on. Insert this code right after retrieving the user input for the variable a. "if float(a) == 0" we raise a ValueError.

8
00:02:30,110 --> 00:02:46,950
And you can provide a text explaining what the issue is. If the user enters 0 for 'a', the ValueError exception with the custom message gets raised, which in turn causes the program to crash instantly.


@@@
1
00:00:03,190 --> 00:00:20,030
There might be cases when we need to do some processing before leaving a function, regardless of whether an error occurs or not. Typically, this includes executing clean up tasks such as closing open files and releasing external resources.

2
00:00:20,370 --> 00:00:42,320
You can use the "finally" keyword to run cleanup actions. The "finally" keyword's block gets always executed before returning from the function, even if an exception gets raised. In the following example, I'm going to use "finally" to print a trace message. Let's remove the "raise" statement and add a "finally" block.

3
00:00:45,900 --> 00:01:02,090
"print("Leaving solve_equation().") Now, this message "Leaving solve_equation()" will always appear in the terminal, even if an exception occurs within the function. I need to remove these lines.

4
00:01:02,710 --> 00:01:27,010
And now, let's rerun the program. I enter zero for 'a', 12 for 'b', and 42 for 'c'. So, we've got the error message "'a' can't be zero. Enter a valid value.," but also the "Leaving solve_equation()" trace message. We'll see a practical example of implementing clean up actions in the "File Input and Output" section.


@@@
1
00:00:03,710 --> 00:00:16,340
Reading data from a file or saving files to the hard drive are everyday tasks in programming. A file is a collection of data that's persisted on a storage medium, such as the computer's hard drive.

2
00:00:16,340 --> 00:00:50,750
The type of data contained in a file can vary. We have text files, but there are also files containing binary data like programs and images. A file is identified by a folder pathm which is the file's folder location in the file system; a name - the actual name of the file, and an extension that indicates the type of data stored in the given file, such as ".py" for Python files, "".txt" for text files, ".png" for image files, and so on.

3
00:00:50,750 --> 00:01:07,520
Python makes it easy to work with files. However, there are a couple of things to watch out for when it comes to file input and output. Let's start with the requirement of reading data from a file. To access the file's data, we need to know its path.

4
00:01:07,520 --> 00:01:20,090
Then, we try to open the file for reading. I said we "try" because our attempt my fail for various reasons. The file may not exist, or it could be open already.

5
00:01:20,090 --> 00:01:34,790
The data it contains might be in a different format than we expected, for example, binary versus text. Now, if none of these errors happen, we read and process the file's contents. And finally, we need to close it.

6
00:01:34,880 --> 00:01:49,870
It's imperative to close the file when we're done with it, or you will get strange problems in your programs. Here's a simplified activity diagram showing the decisions involved in the process of opening a file and reading its contents.

7
00:01:51,710 --> 00:02:05,140
There may be even more conditional logic required when working with files since so many things can go wrong. The bottom line: file input and output requires us to be prepared for various errors.


@@@
1
00:00:03,570 --> 00:00:26,260
In this lesson, we're going to implement a program that writes text to a file. Create a new file in VSCode and name it file-write.py. To write to a file, we must first open it. Once the file is open, we can write data into it. When we're done with the writing, we need to close the file.

2
00:00:26,360 --> 00:00:45,720
Let's embed all these steps into a function with the following signature. I call it write_file() and it has a "file_path" parameter of type string, and the text that should go into the file.

3
00:00:47,640 --> 00:01:01,890
The return type is an integer. The write_file() function takes two parameters: "file_path" identifies the file in the file system, and "text," which is the text we want to write into this file.

4
00:01:01,890 --> 00:01:22,280
The function returns an integer that represents the number of characters written into the file. To open the file at the provided path, we use the built-in open() function, which takes several parameters, but we'll only use two: the path to the file to open, and the mode in which the file is opened.

5
00:01:22,380 --> 00:01:32,480
The default mode is to open the file for reading in text mode. We can provide the modes using letters. Here's the list of mode values and their meaning.

6
00:01:35,770 --> 00:01:52,700
If we don't provide the mode argument, the file opens for reading in text mode by default. But we're going to provide this parameter, and we'll be using 'w' for writing, since we want to write to this file. The open() function returns a file handle upon success.

7
00:01:52,930 --> 00:02:06,760
So, let's declare this handler first, and initialize it to 'None', which denotes an empty initial state. As we saw in the previous lesson, opening a file may fail for various reasons.

8
00:02:06,760 --> 00:02:22,830
The open() function raises OSError upon failure. Thus, we call it from a "try" clause and use the returned handle to write the text to the file. Next, we pass the text to the write method.

9
00:02:22,890 --> 00:02:35,510
Now, I use the returned handle to write the text to the file. The write() method returns the number of written bytes. we're going to return this value to the caller.

10
00:02:35,550 --> 00:03:00,050
Next, we need to catch the OSError exception, and print an error message if it occurs. "except OSError:." Let's print - I use an f-String, which allows us to also include the file path in the error message: "Couldn't open file at path..." and the value of the file path "{file_path}".

11
00:03:00,060 --> 00:03:33,730
We're almost done. Let's not forget to close the file. We could add the missing statement in the "try" clause. However, if an exception occurs in the middle of our code, the file remains open. To make sure this code always executes, we need to put it in the "finally" clause. If the file handle is not 'None', we call file.close(). As an extra precaution, we check if the file handle is valid.

12
00:03:33,730 --> 00:03:48,590
If opening the file failed, the file handle kept its initial value, which is 'None'. Calling close() on an invalid handle would raise an exception. So, it's a good idea to validate the file handle. The function is ready.

13
00:03:49,250 --> 00:04:16,820
All right. Now, let's use our freshly implemented function. First, create a variable that holds the file's name. Then, call the write_file() function and store the returned value, which is the number of characters written to the file in the "count" variable. "count = write_file()" and I provide the file name and the text.

14
00:04:16,829 --> 00:04:51,400
How about "Hello Python!"? If the call succeeds, we print the number of characters to the terminal. Otherwise, we print a warning message. "if count != None:" print the value of the "count" variable "characters written to {filename}" else print "Couldn't write to file" and the file name.

15
00:04:54,510 --> 00:05:09,240
Now, run the program. A file called myfile.txt should be created. Since we passed the name of a file without a file path, the file gets created in the same folder in which you are running the program.

16
00:05:09,240 --> 00:05:47,730
If you don't see the file where you expected it to be created, your program may be running in a different folder. To check where your script is running, add the following statements and check the path printed in the terminal after executing your program: import os, print os.path dot absolute path, and retrieve the current working directory, which in my case is the root folder. Excellent, now you know how to write text to a file! Next, we're going to implement a program that reads the contents of this file.


@@@
1
00:00:03,330 --> 00:00:37,400
We've seen how to write text to a file. Now, let's write a program to read the contents of a file. Open VSCode. Create a new file and save it as file-read.py. We start by creating a function called read_file(). The function takes a "file_path" parameter that identifies the file in the file system, of type string, and it returns an array of strings that represent the text lines in the file.

2
00:00:38,550 --> 00:00:50,070
We declare the handler and initialize it to 'None'. We'll use the open() function to open the file as we did in the previous lesson. However, we don't provide the mode argument.

3
00:00:50,070 --> 00:01:19,890
Thus, the default mode applies, which opens the file for reading in text mode. As we've discussed, the open() function may raise an exception. Therefore, it is necessary to embed it in a "try" clause. If an OSError occurs, we print an error message: print("Error! Couldn't open the file at path ..." and the value of the "file_path" argument.

4
00:01:22,780 --> 00:01:35,720
The actual reading of the text lines happens in the "try" - "except" statement's "else" clause. As discussed in the "Error Handling" lesson, the "else" block gets executed if the "try" clause doesn't raise an exception.

5
00:01:36,040 --> 00:01:45,910
That means that the statements in the "else" block will only run if the file could be opened successfully. Python makes it very easy to read a text file.

6
00:01:46,160 --> 00:02:20,230
We can use a for-in loop to read the lines of text. Each line is then added to the list, and when the loop finishes, we return the list to the caller. I initialize the "lines" variable with an empty list. And now the for loop: "for line in file:" I use the list's append() method. I append the line of text that was read from the file. And finally, we return the list.

7
00:02:20,230 --> 00:02:31,760
Let's not forget to close the file in the "finally" block as usual. First, validate the handle. If it's not 'None', meaning that it was opened, then let's close it.

8
00:02:33,550 --> 00:02:47,630
We can try it out right away. Call the read_file() function and assign the return value to the "text" variable. And let's print the returned list with the text lines to the terminal.

9
00:02:47,760 --> 00:03:12,330
"if text != None:," let's print it. If everything went well, you should see this output. You might get an error message instead saying "Error! Couldn't open the file at path myfile.txt." This message appears if myfile.txt has not been created.

10
00:03:12,330 --> 00:03:35,030
If you ran the previous section's demo successfully, the file should exist in the folder from where you were running the program. If that's not the case, load the file write-file.py and run it once. Congrats, you have just learned the basics of file input and output using Python. In the next section, we'll be digging into more abstract topics.


@@@
1
00:00:04,000 --> 00:00:21,380
We did pretty well so far without object-orientation. So what's all the fuss about it? To understand the importance of object-oriented programming, we need to go back a few decades and see how things evolved in the Stone Age of programming.

2
00:00:21,390 --> 00:00:35,440
There were no fancy IDEs or text editors. Actually, programs were written way before the days of displays. Programmers coded their programs on special sheets of paper called coding sheets.

3
00:00:35,460 --> 00:00:53,660
The following example shows a COBOL coding sheet. I'm not kidding, that's how programmers wrote their code until the mid 1970s. The sheets were taken by operators whose job was to punch in the instructions into a punched card using a keypunch machine.

4
00:00:53,850 --> 00:01:15,580
If the operator made a single mistake, the entire card had to be repunched. Later, the punch cards were converted to magnetic type files that could be stored more effectively. Initially, computer programs were big, contiguous chunks of code. Unstructured programming was the earliest programming paradigm.

5
00:01:15,580 --> 00:01:38,950
The code consisted of sequentially ordered instructions. Each statement would go in a new line. Source code lines were numbered or identified by a label. Here's a snippet in Sinclair Basic that converts from Fahrenheit to Celsius degrees. As the programs grew in complexity, the drawbacks of this approach had become apparent.

6
00:01:39,260 --> 00:01:54,890
Maintaining or even understanding such a code base was challenging. To make any changes or improvements, you had to check the statements line by line. This task becomes overwhelming as the number of code lines increases.

7
00:01:55,120 --> 00:02:13,820
Non-structured programming has received much criticism for producing hardly readable, so-called spaghetti code. The term spaghetti code is a pejorative description for complicated, difficult to understand, and impossible to maintain software. Structured programming emerged in the late 50s.

8
00:02:13,980 --> 00:02:24,550
Structured programming languages break down code into logical steps. They rely on subroutines or functions, which contain a set of instructions to be carried out.

9
00:02:24,900 --> 00:02:38,660
By now, you should be familiar with these concepts, since we have implemented and used functions in the previous lectures. Structured programming was a significant improvement compared to the monolithic coding practices.

10
00:02:38,660 --> 00:03:03,080
The introduction of named functions improved the readability of the computer programs and reduced development time substantially. Even with the improved quality, developers started to face new challenges as the programs became more sophisticated. Structured programming could not address the increased complexity. Object-orientation appeared in the 1980s.

11
00:03:03,320 --> 00:03:13,580
It was the next big step in the evolution of the programming paradigms. Object-orientation aims to bring the world of programming closer to the real world.

12
00:03:13,580 --> 00:03:28,250
The main idea was to split apart the program into self-contained objects. Each object represents a part of the system that gets mapped to a distinct entity. An object functions as a separate program by itself.


@@@
1
00:00:03,750 --> 00:00:15,720
Object-oriented programming is organized around self-contained objects. Now, that might sound vague at first, but it's really about the way we think about designing our programs.

2
00:00:15,720 --> 00:00:28,890
It requires a mental shift compared to focusing solely on functions. However, once you get used to this new way of thinking, you will notice that it becomes easier to build sophisticated applications.

3
00:00:28,890 --> 00:00:41,550
All right, let's introduce the main ideas around object-orientation. We start with the object. An object represents a thing. Each object encapsulates its own data and logic.

4
00:00:42,330 --> 00:00:54,630
Objects interact with each other to make our programs work. An object can be simple or complex, depending on the level of granularity we need to accomplish a specific functionality.

5
00:00:54,630 --> 00:01:08,370
We could model a rectangle as an object, but we might consider a space station and object, too. The way we define our objects depends on the level of detail needed to solve a particular problem.

6
00:01:08,370 --> 00:01:24,920
Sometimes, a higher-level abstraction will suffice. We could say, "This object represents a person, who has a name and a social security number" - without considering details like the person's height, weight or hair color.

7
00:01:24,960 --> 00:01:37,500
In other cases, we need to be more specific. We can describe an object using its properties, such as its name, color, size, or shape. Let's consider a car.

8
00:01:37,660 --> 00:02:02,620
We can choose between petrol, diesel, electric or hybrid engines. Most cars come with a basic, solid color, such as white, black, grey or silver, but we can have metallic or matte finishes, too. The car's color and the engine type are fixed properties, while other attributes - such as the car's position or speed - can change.

9
00:02:02,620 --> 00:02:21,510
We can describe an object in the real world using its properties, like "The car's name is Tesla Model S, its top speed is 155 mph, color 'Midnight Silver Metallic." This approach also works in an object-oriented language.

10
00:02:21,670 --> 00:02:34,420
Objects have their identity, their own state. Changing the state of an object doesn't change the state of other objects. If we start a car, it won't affect all the other vehicles.

11
00:02:34,420 --> 00:02:46,920
Their state is independent, and each has its private identity. Besides properties and identity, an object has its own behaviour. The behavior of an object is what it can do.

12
00:02:46,960 --> 00:03:07,980
"The black car starts." In this sentence, we identify one object: the car. "Start" is the behavior or the action performed by the car object, and "black" is its color, one of its attributes. We can identify the object quickly since it is the noun in the sentence.

13
00:03:08,200 --> 00:03:27,890
The verb is the behaviour, and the adjective is the property. So, 'black' is a property, the 'car' is the object, and 'starts' is the behaviour. The idea of describing an object using its properties, identity, and behaviour is pretty straightforward.


@@@
1
00:00:04,040 --> 00:00:22,170
The creation of object-oriented systems start by identifying the required objects. The objects in our programs represent things like cars, persons, files, databases. In the object-oriented world, we need to have a class before we can create an object.

2
00:00:22,430 --> 00:00:32,880
The class is the blueprint of an object. You can think of a class as a plan, a description of an object. A concrete object is a realization of this blueprint.

3
00:00:33,470 --> 00:00:43,430
Let's say you want to use a Pok�mon in your program. A class called Pok�mon would provide a blueprint for what the Pok�mon looks like and what it can do.

4
00:00:44,470 --> 00:01:24,050
All right, we've had enough theory. It's time to switch to coding. Open VSCode and create a new file called class.py. In Python, we create the class using the "class" keyword followed by the name of the class in the upper camel case style. Next, we define three instance variables, that represent the Pok�mon's name, armor level, and hit points. In Python, instance variables are defined within methods. Bear in mind that most object-oriented programming languages use a different approach to declaring instance variables.

5
00:01:24,050 --> 00:01:43,600
But that's how Python works. All right, we're going to define the name, armor and hit points instance variables within the __init__() method. __init__(), also referred to as a constructor, is a special method that gets executed whenever we initialize a Pok�mon object.

6
00:01:43,800 --> 00:01:55,530
You should never call a class's __init__() method directly. In Python, leading and trailing double under scores '__' indicate a variable or a method that's not meant to be used directly.

7
00:01:55,530 --> 00:02:39,010
We'll talk about private access later in this section. Now, Python requires us to specify 'self' as the first parameter of each instance method. 'self' is the new object created when we instantiate a class, and it gets passed to the initializer. Most modern programming languages pass 'self' as a hidden parameter to instance methods, but Python decided to make it explicit. The "self.variable_name" syntax means that we're accessing instance variables of the Pok�mon object. Setting them using "self.name," "self.armor," and "self.hit_points" makes them accessible for the lifetime of the object.

8
00:02:39,040 --> 00:03:04,690
This class tells us that each object that gets created has a name, armor level, and hit points. It doesn't say what the name or the armor level is. We initialize these properties during instantiation. To create a new instance, type the class name followed by the argument lists surrounded by parentheses. Let's create one instance. I call it pikachu.

9
00:03:08,120 --> 00:03:37,130
I provide "Pikachu" for name, 100 max armor level, and max hit 1000. Now, let's define some behavior. Pokemons can attack and defend themselves. So, add the attack() and the defend() method. Instance methods are defined the same way as functions, except that we need to pass in 'self' as the first parameter. And let's print the object's name.

10
00:03:40,430 --> 00:03:53,560
And now, let's define the defend() method, too. And again, we print a message to the terminal. To use an instance method, we need an object of that class first.

11
00:03:53,750 --> 00:04:13,340
Then, we can call the method using the dot syntax. Since we have an object, we can call the methods right away. Let's call attack(), and, say, attack() again. And now it defends itself.

12
00:04:13,450 --> 00:05:12,070
All right, now let's give it a try. And here, in the terminal, we can see the result of executing the program. We defined a class by giving it a name (Pok�mon), declaring its instance variables (name, armor and hit points), and the methods (attack() and defend(). The Pok�mon class lets us create as many objects as needed. We could create another object, say, "snorlax." I provide its name, max armor and max hit, and it attacks. And the third object: "charmander." The name, again, max armour and hit points, and I can call any of its methods, say, defend().

13
00:05:14,670 --> 00:05:37,380
Another big benefit of classes is that we can reuse them. We've already used many built-in types, including the string, the list, the dictionary, and the various numeric types. Instead of reimplementing the functionality provided by these types, we could focus on creating our programs. We covered the object and the class.


@@@
1
00:00:03,500 --> 00:00:14,870
Abstraction is a way of describing complex problems in simple terms by ignoring some details. Eliminating the nitty-gritty details let us focus on the bigger picture.

2
00:00:15,020 --> 00:00:35,870
We can dig deeper once we have a broader understanding. If I say "cat," you know what I'm talking about instantly. I don't need to specify that it's a small, furry, male Persian kitten unless these additional details have relevance to the story. We are naturally good at generalizing things.

3
00:00:35,870 --> 00:00:52,220
We skip the irrelevant details but people can still understand us. That's because our brains are wired to understand abstract ideas like cat, house, or car. Abstraction works the same way in the object-oriented world.

4
00:00:52,310 --> 00:01:10,740
When we start defining a class, we focus on the essential qualities of that class and discard the unimportant ones. In our Pok�mon example, we started with the essential attributes and methods. We don't need details like age, weight or height.

5
00:01:11,060 --> 00:01:22,440
These attributes are only essential in our current application. That's how abstraction works. We focus on what's important and ignore all the details we don't need.


@@@
1
00:00:04,540 --> 00:00:28,960
The next fundamental idea to keep in mind when dealing with object-orientation is called encapsulation. We encapsulate something to protect it and keep its parts together. In object-orientation, encapsulation translates to packing together variables and functions in a class. Encapsulation also means hiding the internal details that shouldn't be used by callers.

2
00:00:29,150 --> 00:00:44,810
We can use a phone without understanding how the touchscreen, the camera, or the logic board works. Similarly, we don't want to expose the inner workings of our class. An object should only reveal the essential features.

3
00:00:44,810 --> 00:00:58,860
This concept is called data hiding. By hiding its internal details, we protect the object from external interference. Other programming languages let us hide the properties and the methods by making them private.

4
00:00:59,000 --> 00:01:13,450
Private variables and methods can only be used within the class that defines them, but can't be accessed from the outside. Python doesn't have a 'private' keyword. All class instance variables and methods are public.

5
00:01:13,500 --> 00:01:24,900
Instead of using a special keyword, Python relies on naming conventions. If a variable or method shouldn't be accessed from the outside, we precede its name with an underscore.

6
00:01:26,790 --> 00:01:41,080
Allright, now let's switch over to VSCode. We're going to add a property and a method to the Pok�mon class. We add the "_is_charging" private property first.

7
00:01:41,090 --> 00:01:56,980
Next, I define the private method. Now, since "_is_charging" and _change_attack() start with an underscore, they are considered private. And let's copy over the print() statement and make some changes.

8
00:02:00,300 --> 00:02:27,360
"_is_charging" is a private property, and _change_attack() is a private method. In other words, they are not meant to be used by clients. Note that you can still access the "_is_charging" variable or call the change_attack() method on the pokemon object. Although you won't get any warnings or errors, Python developers know that using variables or methods that start with an underscore is a bad idea.

9
00:02:27,590 --> 00:02:45,150
Since these are private, their behavior may change or they might even be deleted over time. Hiding certain properties or methods prevents clients from modifying the object in ways we did not originally plan, whether it's intentional or accidental.

10
00:02:45,780 --> 00:02:57,230
Additionally, we prevent other parts of the system from relying on properties or behavior that may change. Data hiding is not about selfishly keeping stuff for ourselves.

11
00:02:57,450 --> 00:03:10,370
It's rather about protecting our classes from unwanted external dependencies. If we expose unnecessary details, any changes to those attributes or methods may affect other parts of the system.

12
00:03:10,620 --> 00:03:23,970
Whereas if we restrict access to that data or behavior, we don't have to worry about the ripple effect of our changes. As a rule of thumb - expose only as much of your class properties and methods as needed for normal usage.

13
00:03:24,870 --> 00:03:42,540
Data hiding plays an essential role in reducing the dependencies between objects. A tightly coupled system, with most of the objects depending on each other, is the unmistakable sign of a bad design. Updating or maintaining such a system is a pain.

14
00:03:42,540 --> 00:03:56,970
Any tiny modification cascades down and requires you to change other parts of the system, too. It's like a never ending nightmare. Object-oriented programming principles are here to make our lives easier.


@@@
1
00:00:04,180 --> 00:00:23,500
Inheritance is a key concept in object-oriented programming. Without inheritance, we'd end up writing similar code over and over again. Inheritance means code reuse, that is, reusing an existing class's implementation in new classes. Let us start with an example.

2
00:00:23,600 --> 00:00:39,950
We modeled the Pok�mon class with the main properties and behaviour in mind. Given this class, we were able to create our Pok�mon instances. Now, what if we need new types like electric, water or flying Pok�mon?

3
00:00:39,950 --> 00:00:52,300
We need new classes since these new types have special abilities. The Pok�mon class has the properties name, armor, and hit_points, and it can attack and defend itself.

4
00:00:52,400 --> 00:01:27,780
The electric, water and flying Pok�mons have all these properties, and they are able to attack and defend themselves, too. Additionally, they also have specialized functionality. An Electric Pok�mon has the ability to "wild charge." This attack is only available to electric type Pok�mons. "aqua tail" is a damaging Water Pok�mon move, and Flying Pok�mons can perform the "dragon ascent" attack. As you've probably realized, the three new classes are almost identical to the Pok�mon class.

5
00:01:27,780 --> 00:01:40,390
The only difference is the special attack type. We could add the new methods to the Pok�mon class. If we did that, we'd end up in a class that has too many responsibilities.

6
00:01:40,540 --> 00:01:52,450
Suddenly, all Pok�mon objects could swim and fly and discharge electricity. Now, that doesn't sound like a particularly good idea. Our classes should be simple.

7
00:01:52,450 --> 00:02:12,890
They need to have a well-defined purpose. Object orientation is about granularity and separation of concerns. Each class should focus on one set of specific functionality, and do that well. Creating one-size-fits-all, monolithic classes is a major mistake in object-oriented software development.

8
00:02:12,940 --> 00:02:32,750
So, how about keeping these classes separate? Now, only Electric Pok�mon objects can discharge electricity. Water Pok�mons can employ the "aqua tail" attack, and Flying Pok�mons are capable of performing a "dragon ascent." Great! However, we're now facing another issue.

9
00:02:32,900 --> 00:02:53,460
We keep repeating the same code for the shared functionality. Object-oriented programming languages have a solution for this kind of problem. The solution is called "Inheritance." In Python, a class can inherit all the variables and methods from another class using the following syntax.

10
00:02:53,460 --> 00:03:06,560
Now, ChildClass has the same properties and methods as ParentClass. All right, let's make ElectricPokemon, WaterPokemon and FlyingPokemon inherit from the Pokemon class.

11
00:03:07,460 --> 00:03:22,160
In object-oriented terms, Pokemon is called the base, parent or super class, whereas the ElectricPokemon, WaterPokemon and FlyingPokemon are subclasses or child classes.

12
00:03:22,160 --> 00:03:45,380
The data and the behaviour from the Pokemon class become available to all its subclasses, and we only had to add the specialized methods to the Pokemon subclasses. If we enhance or modify the Pokemon class, the subclasses will automatically receive those changes, too. Inheritance is a powerful idea which can save us from a lot of typing.


@@@
1
00:00:03,770 --> 00:00:18,240
The ElectricPok�mon, WaterPok�mon and FlyingPok�mon all inherit the properties and the behavior of their Pok�mon superclass. So, they have a name, armor, hit points, and they can attack and defend themselves.

2
00:00:18,350 --> 00:00:30,360
The WaterPok�mon inherits the attack() method from the Pok�mon superclass. Now, what if we need WaterPok�mon types to cause more damage than basic Pok�mon instances?

3
00:00:30,380 --> 00:00:55,440
For that, we need to provide a specialized implementation of the attack() method in the WaterPok�mon class. Changing the behaviour of a method inherited from a parent class in one of its child classes is called method overriding. By overriding a method of the superclass, we tell that we want a different behavior in our child class than the one we inherited.

4
00:00:55,450 --> 00:01:25,530
Method overriding is straightforward. We reimplement the method with the same name and parameters as the one defined in the parent class and provide our own behavior. By doing so, our WaterPok�mon objects have a different attack behavior than their Pok�mon superclass. Calling the attack() method on the ElectricPok�mon and FlyingPok�mon objects use the logic implemented in their superclass since we didn't override the attack() method in their case.

5
00:01:25,540 --> 00:01:41,590
Now, let's assume that we need a new "speed" instance variable in the WaterPok�mon class. We could override the __init__() method and add a new parameter to initialize the variable. When we override a method, the superclass's method will no longer be called.

6
00:01:41,800 --> 00:01:53,640
We need to explicitly call the parent's method if we want it to execute. So, let's call the parent's __init__() method to initialize all the instance variables defined in the base class.

7
00:01:57,730 --> 00:02:08,990
And then, initialize the new WaterPok�mon "speed" instance variable, too. After this change, we need to add an additional argument when creating WaterPok�mon objects.


@@@
1
00:00:04,290 --> 00:00:41,230
Polymorphism is another term you will often hear when it comes to object-orientation. The word has Greek origins, and it consists of two words: "polis," which means many, much and “morphē,” meaning form or shape. If you look up the word "polymorphism," you will find the following definition: "The condition of occurring in several different forms." Now, how does this apply to programming? Polymorphism lets us work with objects created from the Pokémon superclass or any of its subclasses.

2
00:00:41,230 --> 00:00:51,970
We don't need to know whether it's an ElectricPokémon, WaterPokémon or FlyingPokémon instance to call any of the common methods defined in the superclass.

3
00:00:52,000 --> 00:01:15,150
We could create an army of mixed Pokémons and tell them to attack at once. The following snippet creates instances of different Pokémon classes. Then, we create the tupple that contains the Pokémon instances. And finally, we can iterate through the items in the tuple, and call their attack() method without knowing their concrete type.

4
00:01:15,400 --> 00:01:31,250
The objects in the "pokemons" list are all instances of the Pokémon type or one of its subclasses, and that's all we know. Polymorphism is about working freely with instances of many different classes that share a common superclass.


@@@
1
00:00:03,600 --> 00:00:17,120
If you continue coding, sooner or later, you're going to encounter the term "algorithm." In essence, an algorithm is a sequence of steps describing what the computer should do to solve a particular problem.

2
00:00:17,960 --> 00:00:28,230
Algorithms are essential in computer science and are basically everywhere - even if you haven't noticed them yet. Your GPS uses route-finding algorithms.

3
00:00:28,430 --> 00:00:46,580
YouTube relies on audio and video compression algorithms to play high-definition videos flawlessly. The amazing 3D-graphics in games are possible thanks to sophisticated rendering algorithms. Computer algorithms have been developed and refined over the last couple of decades.

4
00:00:46,820 --> 00:01:04,590
The study of algorithms is essential to any programmer who wants to get past the basic "Hello World" beginner applications. We can't avoid algorithms when building complex systems that need to manage large amounts of data or solve complex problems efficiently.

5
00:01:04,700 --> 00:01:25,700
Besides, algorithm related questions will pop up during job interviews. So, it's not a bad idea to know what algorithms are and how they can be applied to write more efficient code. By definition, Algorithmic Thinking is the ability to approach a problem and find the most efficient technique to solve it.


@@@
1
00:00:05,450 --> 00:00:39,510
To demonstrate the importance of algorithms, we're going to solve the same problem using two different approaches. The problem we're about to solve is the following: "Implement a function that calculates the sum of the first N natural numbers." All right, let's open up VSCode and create a new file called sum-n.py. Now, declare a function called sum() which takes a single parameter. This parameter represents the number of natural numbers whose sum we want to calculate.

2
00:00:39,840 --> 00:00:53,470
The function returns an integer which gives the sum. The logic of our function is straightforward - it sums up all the numbers starting with zero up to the value of the input parameter 'n'.

3
00:00:53,510 --> 00:01:10,790
First, I initialize a variable called "result." Then, I use a for-in loop to calculate the result. So, we iterate through the range of numbers starting with 0 up to 'n'. The += operator keeps adding the number 'i' to the result.

4
00:01:10,790 --> 00:01:25,410
And finally, we return it. Now, we can try out our function. I create a variable - let's call it "sum_3" - equals... And I call the function and pass in the number three.

5
00:01:25,460 --> 00:01:42,750
Let's print the returned value. All right, now run the demo. The result is 6, which is correct, since one plus two plus three is six. The sum function relies on a for-in loop to calculate the result.

6
00:01:42,890 --> 00:01:55,680
The value of 'n' determines the number of iterations. That means that the time to execute the sum() function increases with the input argument 'n'. We can prove this by measuring the execution time.

7
00:01:55,750 --> 00:02:14,440
We're going to rely on the "time" Python module that provides functions to measure elapsed time. Now, what's a module? A module is a file consisting of Python code and can include functions, classes, and variable definitions. To use a Python module, we need to import it.

8
00:02:14,770 --> 00:02:33,890
So, let's insert a new empty line at line number one in the editor and add the following statement to import the "time" module. Next, insert a new line right after the sum() function's definition. We need to call sum() with steadily increasing values for 'n'.

9
00:02:33,900 --> 00:03:08,580
So, let's define the tuple called "ranges" with the values 10, 1,000, 10,000 and 100,000. Then, we call sum() in a loop using the values from the ranges tuple. I'm going to remove this part, and instead, let's implement our for-in loop. "for n in ranges:" and call sum() with the value 'n'. Again, 'n' comes from the "ranges" tuple. We'll rely on the process_time_ns() function to keep track of the elapsed time.

10
00:03:08,880 --> 00:03:21,480
We need to sample the time before and after calling sum() to measure the time required to execute the function. I create a variable called "start" and let's fetch the time.

11
00:03:21,480 --> 00:03:33,680
This function is very accurate. It returns the time in nanoseconds. Next, I create another variable called "end" and call process_time_ns() again to initialize it.

12
00:03:33,780 --> 00:03:50,090
Finally, all we need is to calculate the elapsed time and print the values. The execution time is represented by the variable "exec_time," and it's simply the difference between "end" and "start." And let's print the value.

13
00:03:50,250 --> 00:04:20,310
I'm using an f-String - the value of 'n', and the execution time is the value of "exec_time" in nanoseconds. Now, run the program. And here's the output. Your values may be slightly different but the trend is clear: the execution time increases linearly with the input.


@@@
1
00:00:03,719 --> 00:00:16,910
The previous lectures code successfully computed the sum of the first N natural numbers. However, a working solution doesn't always mean that we found the optimal way to solve a particular problem.

2
00:00:16,950 --> 00:00:33,710
Our tests revealed that our function's performance deteriorates as the input gets bigger. Carl Friedrich Gauss is said to have found a better way to calculate sum(N) in his early youth. In the late 17 hundreds, Gauss was only an elementary student.

3
00:00:33,710 --> 00:00:52,970
He amazed his teacher with how quickly he found the sum of the integers from one to one hundred to be 5050. Gauss recognized he had fifty pairs of numbers when he added the first and the last number in the series, the second and the second last number in the series, and so on.

4
00:00:52,970 --> 00:01:35,950
That can be expressed using the following formula, known as the triangle numbers formula: sum(N) = n * (n+1) / 2. Gauss was probably not the first to discover this formula. Likely, its origin goes back to the Pythagoreans, and it was known as early as the sixth century BC. All right, given this formula we can implement an improved version of the sum() function. I create a new function and call it sum_optimized(). It takes the argument 'n' of type int, and returns an integer just like its sibling.

5
00:01:38,510 --> 00:02:13,680
Now, instead of applying a for-in loop, I'm going to apply the triangle numbers formula. So, we return n times n plus 1 divided by 2. The sum_optimized() function is not only shorter, but it's execution time doesn't depend on the input's size. Let's run the same tests as we did for the sum() function. I'm going to copy the for-in loop and paste it here. And we call the sum_optimized() function in this case.

6
00:02:19,060 --> 00:02:40,510
Let's print what we're doing. I print a message for the sum_optimized() part in a new line, and also for our original measurement here. And let's also change the f-String in the second case.

7
00:02:40,570 --> 00:02:53,200
Now, let's run our program. And here are the numbers. The results show that the execution times for the sum_optimized() function do not vary regardless of the input size.

8
00:02:53,200 --> 00:03:16,780
There are only some minor, negligible differences in the range of microseconds. Besides, sum_optimized() is more efficient even for smaller values. sum_optimized(), unlike the sum() function, doesn't depend on the input size. By applying a smart, 2000-year-old formula, we managed to implement a solution with optimal performance.

9
00:03:16,780 --> 00:03:28,440
Hope you've got a taste of what algorithms can do for your code's elegance and speed. Finding the optimal approach requires more analysis for sure, but the results are definitely paying off.


@@@
1
00:00:02,000 --> 00:00:16,766
Understanding a software system just by looking at its source code can be very time-consuming. And communicating ideas about software design or business processes is even harder if there�s no commonly accepted way to do it.

2
00:00:16,766 --> 00:00:29,633
The Unified Modeling Language - in short UML was introduced to solve this problem. UML is not a textual programming language, but rather a graphical notation.

3
00:00:29,633 --> 00:00:41,833
A set of diagrams that help in designing and communicating software systems. We can use these diagrams to describe the objects that form a system and their interactions.

4
00:00:41,833 --> 00:00:56,400
UML has many diagram types. We�ll be discussing the most common ones. The use-case diagram describes the functional model of a system - that is, the functionality of a system from the user�s point of view.

5
00:00:56,400 --> 00:01:11,066
To describe the structure of a system, UML provides structural diagrams. We�ll talk about the class diagram, which can be used to describe the structure of a system in terms of objects, attributes, operations, and relations.

6
00:01:11,066 --> 00:01:25,633
Last but not least, UML lets us model dynamic behavior, too. The behavioral diagrams describe the functionality of the system, focusing on what happens and the interactions between objects.

7
00:01:25,633 --> 00:01:40,066
We�ll talk about the actual diagrams shortly. The best part about UML is that it�s independent of any particular programming language. But, we can start coding an Object-Oriented software based on UML diagrams.

8
00:01:40,066 --> 00:01:56,733
And if those diagrams are detailed enough, they can be converted to source code. Now, let�s see some ways of using UML in real-life. We can quickly draw a diagram to sketch a specific part of a software or a new functionality.

9
00:01:56,733 --> 00:02:13,533
I've done that myself on numerous occasions. Whenever something was unclear, I started to sketch UML diagrams before writing a single line of code. The benefit was that I not only understood what I should implement, but I also had a design.

10
00:02:13,533 --> 00:02:25,066
A documentation that could be used to communicate my ideas with other team members. Another frequent use of UML is drawing diagrams from existing code.

11
00:02:25,066 --> 00:02:36,233
This technique is called reverse engineering, and it helps to understand and document a system. We can also use UML to create the detailed blueprint of a system.

12
00:02:36,233 --> 00:02:53,500
While sketches focus only on the essential aspects of a system, the blueprint is about completeness. Detailed UML blueprints are usually required for software developed using a Waterfall-approach - and less frequently for Agile projects.

13
00:02:53,500 --> 00:03:06,766
You can use UML diagrams to describe any system that�s developed using an object-oriented programming language. UML has become so popular that it's also used for non-Object Oriented projects.


@@@
1
00:00:02,000 --> 00:00:15,666
The Class diagram is one of the most frequently used diagram types. It�s a structural diagram. It provides an overview of the classes that form a software system and describes the static relationships between them.

2
00:00:15,666 --> 00:00:28,400
In UML, we represent a class by drawing a rectangle divided into three compartments. The top compartment includes the class�s name. Attributes go beneath the name compartment.

3
00:00:28,400 --> 00:00:41,100
And the bottom compartment lists the operations. It�s quite common to leave out the attributes or the operations in early stages of development. First, we figure out the required classes.

4
00:00:41,100 --> 00:00:53,633
We can add the details as we realize what�s needed to fulfill the required functionality. The UML tools allow us to hide or unhide the attributes or the operations.

5
00:00:53,633 --> 00:01:09,700
Now, let�s talk about visibility. Visibility lets us control who can access the attributes and the methods of our classes. UML uses the following symbols to describe the visibility levels: �+� denotes public visibility.

6
00:01:09,700 --> 00:01:20,200
public attributes and operations are accessible by everybody who uses an instance of that given class. �-� minus marks private operations and attributes.

7
00:01:20,200 --> 00:01:31,666
Only the current class will have access to private members. �#� means protected access. Only the current class and child classes can access protected members.

8
00:01:31,666 --> 00:01:43,166
There�s one important rule to remember. You should hide everything that�s not required for your system�s proper functionality. Exposing too much leads to unexpected problems.

9
00:01:43,166 --> 00:01:53,633
Class attributes will usually have private or protected access. We should provide public setters and getters instead of allowing everybody to access our class�s data.

10
00:01:53,633 --> 00:02:03,466
This lets us control what the callers do with our class�s attributes. Class diagrams provide an overview of the essential classes that play a role in our system.

11
00:02:03,466 --> 00:02:14,100
They are also great at documenting the static relationships between these classes. The class diagram can�t describe what happens when these relations come to life at runtime.


@@@
1
00:00:02,000 --> 00:00:18,833
Hi there, in this clip, I am going to talk about UML relations. Generalization is a way of describing parent-child relations between classes. This relationship is best described by the phrase �B is an A�.

2
00:00:18,833 --> 00:00:39,500
For example, a dog is a pet. A cat is also a pet. In UML terms, Pet is a base class, whereas Dog and Cat are child classes. The UML graphical representation is a hollow triangle on the base class end of the line that connects it to one or more child classes.

3
00:00:39,500 --> 00:00:52,866
An association between two classes represents a connection between instances of those classes. We need association if the instances of two classes need to reference each other in order to function properly.

4
00:00:52,866 --> 00:01:12,500
The UML representation is a solid line which connects the classes. For example, there is an association between an online course and a review. Multiplicity The end of an association may also include multiplicity, which shows the number of instances participating in the association.

5
00:01:12,500 --> 00:01:27,266
An online course either has reviews or not. A review can be written for a specific course, but it may as well be skipped. Possible values for multiplicity.

6
00:01:27,266 --> 00:01:41,700
Navigability Association can be bi-directional, where both objects know about each other. However, in some cases it is unnecessary for both objects to be aware of each other.

7
00:01:41,700 --> 00:01:52,133
It makes no sense for the Car to know about the Driver. In this case we need a unidirectional association, where only one of the objects is aware of the other one.

8
00:01:52,133 --> 00:02:06,066
This is a one-way relationship and is represented by adding an arrow to the appropriate end of the association. Aggregation Aggregation is a specific case of association.

9
00:02:06,066 --> 00:02:18,000
Aggregation denotes that an object is part of another object. It is also mentioned as a �has-a� relationship. For example, an "Instructor" has a "Course" to present.

10
00:02:18,000 --> 00:02:35,466
Aggregation is graphically represented as a hollow diamond shape on the containing class connected with a line with the contained class. Composition Composition is a stronger variant of the �has-a� relationship, which implies that parts live and die with the whole.

11
00:02:35,466 --> 00:02:50,100
For example, the chassis is part of the car. if the car is destroyed, the chassis is destroyed as well. The composition is graphically represented as a filled diamond on the owner end connected with a line with the contained class.

12
00:02:50,100 --> 00:03:05,800
A course will outlive the instructor who created it, whereas the chassis is destroyed together with the car it belongs to. This is why the Car - Chassis is a composition relation, while the Instructor - Course is an aggregation.

13
00:03:05,800 --> 00:03:21,500
Realization. Realization shows that a class implements the behaviour specified by another model element. Graphically it is represented as a hollow triangle on the interface end connected with dashed lines with the implementers.

14
00:03:21,500 --> 00:03:36,566
Dependency In some cases a class may depend on another, yet the relation is not an association. This relationship is weak. For instance, if one object sends a notification to another object via a third party.

15
00:03:36,566 --> 00:03:48,300
Another example would be when a class received a reference to another class via a member function argument. A dependency is represented by a dashed line, with an arrow at one end.


@@@
1
00:00:02,170 --> 00:00:14,110
What if you need to show how the objects interact with each other? When are objects created and for how long are they around? Static diagrams can't answer all these questions.

2
00:00:14,190 --> 00:00:33,740
UML provides dynamic diagrams to represent how objects communicate with each other. The most common dynamic diagram is the sequence diagram. We use the sequence diagram to describe the flow of logic in one particular scenario. A sequence diagram starts by drawing boxes at the top of the page.

3
00:00:33,770 --> 00:00:50,820
Each box represents an object. Since these are objects we named them differently. "aTrip" instead of "Trip" and "anExpense" rather than "Expense". We can also display the type after the instance name separated by a colon.

4
00:00:50,960 --> 00:01:09,020
This may be helpful in some cases. The lifeline of an object is represented by the dotted lines beneath each box. The science shows the time the instance exists during the scenario. The sequence diagram also lets us show the message sent from one object to the other.

5
00:01:09,060 --> 00:01:23,940
The message is basically a method call. Now let me illustrate the various messages in a practical example. I'll be using StarUML. StarUML is a diagramming software that can be downloaded for free from staruml.io.

6
00:01:24,170 --> 00:01:37,150
Let's assume that we have a PersistenceManager object. This object is responsible for storing entities in the local database. The persistence manager needs to create and store a TripEntity instance.

7
00:01:37,380 --> 00:01:51,500
First I add the TripEntity object. The PersistenceManager instance sends a "create" message to instantiate the TripEntity object. The "create" message is represented as a dashed line with a stick arrowhead.

8
00:01:51,500 --> 00:02:07,380
Next the persistence manager sends a regular message to the art of the created trip entity. This message corresponds to calling the addNote() method on the TripEntity instance. A regular message is shown as a solid line with field arrowhead.

9
00:02:07,430 --> 00:02:32,480
We can also add parameters to our messages if we wish. Although we could display the return message, only do it if it's important. Return messages are implicit for synchronous messages, so we don't have to display them. Asynchronous messages are drawn as solid lines with a stick arrowhead. The controller object sends on the async "save" message to the persistence manager.

10
00:02:32,480 --> 00:02:45,390
These operations are slow, so inserting a new record into the database is a perfect candidate for an async call. When an object sends an async message, it doesn't need to wait for a response.

11
00:02:45,470 --> 00:02:59,900
The asynchronous call gets executed in the background and it returns once it completes. Unlike synchronous calls, it doesn't block the caller. Asynchronous behavior stands at the core of modern software systems.

12
00:02:59,990 --> 00:03:12,290
They improve responsiveness on multi-core processors and provide better user experience because lengthy operations won't block the user interface. So you would probably draw async messages a lot.

13
00:03:12,290 --> 00:03:27,780
The issue is that the difference between regular and async messages is very subtle. Stick arrow head instead of filled arrowhead. To avoid misunderstandings, you can add an extra note to make it visible it's an async message.

14
00:03:27,840 --> 00:03:39,180
We also have self-messages. These represent the method calling another method of the same object. An object can also send the "delete" message to another object.

15
00:03:39,360 --> 00:03:55,020
The persistence manager sends a delete message to the TripEntity instance. The trip entity gets destroyed and its lifeline gets terminated by a cross symbol. Sequence diagrams should provide an overview of what's going on in a given scenario.

16
00:03:55,050 --> 00:04:12,340
We don't try to represent all the method calls precisely. Instead, we focus on the most relevant parts. Sequence diagrams help us in clarifying the interactions between objects in a specific scenario by getting more profound insights into the inner workings of our objects.

17
00:04:12,390 --> 00:04:29,310
We may need to refine their behavior or even add new classes or establish new relationships between our classes. And that's perfectly fine. The process of designing a software system is all about finding out what's missing, what needs to be enhanced or changed.


@@@
1
00:00:02,330 --> 00:00:14,330
Activity diagrams can be used to describe workflows. The actions are represented by nodes. We start an activity diagram with an initial node drawn as a small filled circle.

2
00:00:14,330 --> 00:00:27,480
We can then transition to the next node. The transition is called flow and is shown as a line that ends with an open arrowhead. The arrow points to the direction of the logic flow from one action to the other.

3
00:00:27,680 --> 00:00:39,370
Activity diagrams can also express conditional logic. We model a decision node as a diamond. It has a single incoming flow and two or more outbound flows.

4
00:00:39,830 --> 00:01:16,080
Each outbound flow has a guard, a boolean condition placed inside square brackets. The guards need to be mutually exclusive. Whenever we reach a decision, we can choose only one of the outbound flows. After a decision, the flows can be merged using a merge activity. A merge has multiple input flows and a single output flow. Activity diagrams support parallel behavior. To express concurrent and flows, we use a fork drawn as a thick horizontal line. A fork has one incoming flow and several outgoing concurrent flows.

5
00:01:16,280 --> 00:01:28,070
We need to synchronize the tasks that execute concurrently. For example, we can't display the image while it's being read from the local persistence or downloaded from the server.

6
00:01:28,070 --> 00:01:40,500
A JOIN represents a synchronization point. The final node marks the end of the workflow. The following activity diagram describes a simplified version of the trip creation process.

7
00:01:40,550 --> 00:01:53,800
We begin with the initial node. The user decides to create a new trip. Next, he's asked to type the trip's name. Now the app needs to check whether a trip with the same name already exists.

8
00:01:54,020 --> 00:02:06,950
If it does, we prompt the user to enter a new name or cancel the trip creation process. If he decides to cancel the flow, we end the activity. Otherwise, we validate the name again.

9
00:02:07,040 --> 00:02:18,700
If the trip name isn't taken, we let the user fill out the remaining trip data. Finally, the user has the "Save" button. We may also want to let him cancel the process here.

10
00:02:18,810 --> 00:02:29,900
Now I use a fork to show that we perform some actions in parallel. Storing the new trip into the local persistence and uploading it to the cloud server happen concurrently.

11
00:02:30,270 --> 00:02:41,620
If both actions succeed, we inform the user about the successful trip creation and we're done. The activity diagram is a useful technique to represent behavioral logic.


@@@
1
00:00:02,440 --> 00:00:15,690
The state machine or statechart diagram models how an object transitions from one state to another over its lifetime. It describes the state changes of an object in response to certain events.

2
00:00:15,690 --> 00:00:44,100
A state is a condition in which an object exists. Think of objects states like "New", "Pending Changes" or "Completed". These states can change when some event gets triggered. The "Pending Changes" state transitions to "Saved" after a successful "save" event. And the "Saved" state will change to the final "Terminated" state if the object is deleted. The state machine diagram starts with an initial state.

3
00:00:44,120 --> 00:01:03,500
This is not a real state but rather the entry point. States are drawn as rectangles with rounded corners with the state's name. The transitions from one state to another are shown as lines that end in an open arrow. Each transition can be labeled with an event name and a guard.

4
00:01:03,590 --> 00:01:14,820
The guard is a boolean condition that needs to be true for the state change to occur. Let's assume that pending changes can only be saved if the device is connected to the Internet.

5
00:01:15,020 --> 00:01:25,700
We can represent conditional logic in state diagrams as follows: The final state shows that the state machine is completed and it also implies the deletion of the object.


@@@
1
00:00:02,719 --> 00:00:17,670
The very first website appeared in 1991. It didn't take too long till we realized the importance of the web. Nowadays, every business and company has some sort of web presence or even runs on the internet.

2
00:00:17,690 --> 00:00:34,150
Just think of Amazon, YouTube or Facebook. So, even if you don't plan to become a web developer, it's not a terrible idea to understand at least the basics of web development. And that's exactly what we'll discuss in this section.

3
00:00:34,170 --> 00:00:56,240
First, I'm going to give you a brief explanation of how websites work, followed by an introduction to the fundamental Web technologies. You're going to write HTML code, use CSS instructions to style a web page, and finally, you will also learn how to add a dynamic behavior to the HTML document using JavaScript.

4
00:00:56,250 --> 00:01:07,790
This is the web page you're going to put together from scratch using HTML, CSS, and Javascript. Next, we'll talk about the challenges you will face as a web developer.

5
00:01:08,430 --> 00:01:21,580
Finally, I'm going to provide you guidance and further resources if you wish to find out more about web development. So, just hang in there, I promise you're going to learn something new and exciting in this section.


@@@
1
00:00:02,260 --> 00:00:24,780
Simply put, web development is about building applications that run in web browsers. In other words, you need a browser to run web applications. At the time of writing this course, the major web browsers are Google Chrome, Apple Safari, Microsoft Internet Explorer, Microsoft Edge, Firefox and Opera.

2
00:00:24,930 --> 00:00:38,040
You're probably using one of these right now. Web applications can be developed in various programming languages. The end result is basically plain text that can be interpreted by the browser.

3
00:00:38,050 --> 00:01:17,300
This text consists of HTML code, and it might also include CSS instructions and JavaScript snippets. Before delving into web development, it is important that you understand what's happening when you visit a Web site in the web browser. Your computer connects to the Web through a wireless connection or via a cable. When you type in the name of a web site into your web browser, the browser sends a request to a web server. The server is basically a computer - or actually more - that store websites, images, and other resources that can be accessed via the Internet.

4
00:01:17,300 --> 00:01:39,850
So, we've got a client that asks for a web page and the server that's supposed to find and return the resource. The browser sends a request in the form of a Uniform Resource Identifier, in short URI. By definition, a Uniform Resource Identifier is a string of characters that unambiguously identifies a particular resource.

5
00:01:39,860 --> 00:01:58,310
Basically, it's a unique ID. The server looks up the requested content, and if it finds it, it sends the response back to the client browser. The response consists of one or more text files that contain HTML, CSS, and JavaScript code.

6
00:01:58,640 --> 00:02:15,300
The web browser parses the HTML and the CSS content to display the web page in its final form to the user. It can also execute JavaScript code that allows web developers to add dynamic behavior and interactivity to web pages.

7
00:02:15,650 --> 00:02:30,610
Now, this is an overly simplified picture of how the web works. There's a lot more going on behind the scenes, but this primer will suffice to get you started with the fundamental web development concepts and technologies.


@@@
1
00:00:02,530 --> 00:00:35,830
HTML, CSS and JavaScript are the basic technologies behind web development. Regardless of the tool or programming language used to create web applications, you will end up having one or more text files that contain HTML, CSS and JavaScript. Let's start with a quick introduction to HTML. HTML stands for "Hypertext Markup Language" and it was introduced in 1989 by Tim Berners Lee, who invented the web.

2
00:00:36,020 --> 00:00:50,060
He created HTML to describe the structure and the contents of web pages. HTML uses tags to add paragraphs, headers, lists, images and other types of content to a web page.

3
00:00:50,060 --> 00:01:14,810
Let me give you an example. The following line describes a paragraph element that is a standalone line of text. The line begins with an opening tag. HTML opening tags wrap the name of the element in angle brackets. The element's name is "p" in this case and denotes a paragraph. The content of the paragraph element comes next.

4
00:01:15,930 --> 00:01:32,910
The closing tag marks where the element ends. It wraps the name of the element in angle brackets, and it includes a forward slash before the element's name. Elements that wrap content need to have a closing tag or else you'll encounter weird issues.

5
00:01:33,930 --> 00:01:54,810
Here's another basic HTML element, the heading. You can use up to six heading levels. The first level heading (h1) is like a chapter in a book, h2 denote sections contained within chapters, h3 would be a subsection included in the section and so on.

6
00:01:55,720 --> 00:02:19,310
This HTML snippet describes the following structure. And finally, here's an HTML example that describes a basic Web page with some minimal content. The first line is the DOCTYPE, and it's there for historical reasons only. The "html" element wraps the content of the entire web page.

7
00:02:19,330 --> 00:02:36,230
You might also see it referenced as the root element. The "title" element sets the title of your page that's displayed in the browser's header when the page is loaded. The "body" element contains the content that you want to show on your web page.

8
00:02:36,240 --> 00:02:47,920
In this example, we're displaying a level one heading - it's like the title of a chapter in the book. Then we have a level two heading and a paragraph element.

9
00:02:48,020 --> 00:03:01,510
You can simply copy this content into a text file and save it with an *.html extension, for example, page.html. Any browser can load this file and display a basic web page.


@@@
1
00:00:02,300 --> 00:00:26,890
So we use HTML to define the structure and the content that we want to display on our web pages. Let's go back to our previous example. This HTML code does the job, yet wouldn't it be great if we could make it look more appealing by using, say, a different font and maybe some colors? Here's where a CSS can help us out.

2
00:00:26,920 --> 00:00:45,140
CSS stands for "Cascading Style Sheets" and it allows you to style your web pages. You can tell how an HTML element should be rendered by setting properties like text and background color, text alignment, font family and size, borders and so on.

3
00:00:45,140 --> 00:00:58,730
All right, now let's take our HTML document and style it a bit using CSS. First, I introduce the "head" element. The "head" element includes information that's not shown to the user.

4
00:00:59,820 --> 00:01:12,370
Next, we need to add a "style" element and we're going to place the CSS definition inside this element. We start by specifying a different color for the paragraph text.

5
00:01:12,650 --> 00:01:38,510
Let's make it blue. The CSS defines the rules that apply for specific HTML elements. A rule starts with the element selector, which in our case is the paragraph, followed by the declaration block. The declaration block is surrounded by curly braces, and it contains one or more property/value pairs, also known as declarations.

6
00:01:38,700 --> 00:01:54,410
Each declaration consists of a property name like "color" or "font-family" and the associated value, for example "green" or "verdana". The values of the properties declared in a rule will be applied to the given HTML element.

7
00:01:54,610 --> 00:02:12,030
In our example, the color of the paragraph text will change to blue. Now, let's use a different font by adding the following declaration. We can also change the text color and the font for the first level and the second level heading elements.

8
00:02:12,030 --> 00:02:30,110
So, let's declare two new rules. As an exercise, center the text of the first level heading and change the background color of the paragraph to light gray. As a hint, use the "text-align" and the "background-color" properties.

9
00:02:30,210 --> 00:02:41,400
You can visit the following link for a complete list of CSS properties. All right, stay tuned. Next, we're going to add interactive features to our webpage using JavaScript.


@@@
1
00:00:02,390 --> 00:00:33,420
We know how to present web content and how to style it. In this lecture, I introduced the basics of JavaScript. JavaScript is a programming language that can be applied to HTML documents. You can use it to integrate dynamic features into websites, like for example changing the text color when the user presses a button. displaying and animating 3D-graphics, providing text editing capabilities, e-commerce modules, games and so on.

2
00:00:33,420 --> 00:00:45,400
So, let's get started with a basic example that helps you understand the fundamental concepts and syntax of JavaScript. We're going to enhance the web page created in the previous lectures.

3
00:00:45,570 --> 00:01:07,530
I'm going to use Atom, a versatile text editor. Atom is free and it works on OS X, Windows and Linux. You can download it for free from atom.io. So, here's the source of the web page with the HTML code and the CSS declarations. Let's switch to auto-detect.

4
00:01:07,530 --> 00:01:23,540
And Atom is capable of detecting the HTML source code. Now, we also have syntax highlighting. To add JavaScript code, we need to use a new element. The "script" element wraps the JavaScript code we're going to implement.

5
00:01:23,670 --> 00:01:44,410
So, let's insert the "script" element just before the closing "body" tag. ... and also the closing tag. The reason I put it here is that the browser loads the web page in the order it appears in the file.

6
00:01:44,620 --> 00:01:59,490
The JavaScript code operates on the HTML content. Therefore it is important to load the HTML before the JavaScript. Putting the JavaScript code near the bottom of the page is a recommended strategy.

7
00:01:59,490 --> 00:02:14,870
Next, we declare a variable. A variable is basically a container that can store a value. For example, you could declare a variable called "title" and assign the value "Software Development from A to Z" to it.

8
00:02:14,900 --> 00:02:28,930
I use the keyword "var" which denotes a variable, followed by the name of the variable. Let's call it "title" ... equals ... and I'm gonna provide the string between quotes.

9
00:02:32,740 --> 00:02:46,350
And let's finish the declaration. Later, you can change the value stored in that variable by simply assigning a different string to it. Title equals, say, "Web development".

10
00:02:49,960 --> 00:03:13,210
So, to sum it up, a variable starts with the "var" keyword followed by the name - "title" in this example. This name identifies the variable. You can pick almost any name, but note that there are some restrictions. You should provide meaningful names for your variables so that you can instantly tell what's their purpose, without digging in the code.

11
00:03:14,320 --> 00:03:49,560
JavaScript lets us declare a variable without assigning a default value like this. "var text" You can give it a value later by using the variable name and assigning it the value using the equals sign: "text =" The following snippet assigns the value stored in "title" to the variable "workingTitle". Besides the string values, JavaScript variables may store additional data types.

12
00:03:50,190 --> 00:04:25,190
Here's a list of all the available data types: String represents textual data like the ones we used in the previous examples. You use quote marks to define the string value. Boolean: a true or false value. Number - note that JavaScript works with floating point numbers. Although you can declare a variable and assign it a value that appears to be an integer, in reality JavaScript doesn't define an integer type. Array lets you store multiple values.


@@@
1
00:00:02,680 --> 00:00:15,310
All right. Now that you've seen some basic JavaScript code, how about implementing something more practical. In this lecture, I'm going to show you how to create a color theme picker for our web page.

2
00:00:15,430 --> 00:00:28,790
And this is what the result will look like. So, let's get started. We start from scratch so I remove the old code. I simply select it all and hit delete.

3
00:00:28,910 --> 00:00:52,120
First, I declare a variable called "firstHeading" and set its value. "var firstHeading = document. querySelector("h1");" Now, let's talk about this document.querySelector() part.

4
00:00:52,130 --> 00:01:10,800
The document represents the HTML content that was loaded by the browser. querySelector() is a function that returns the reference for a given element - in this case, the first level heading. Functions are building blocks that package functionality that you can reuse.

5
00:01:11,120 --> 00:01:22,230
Javascript uses the dot syntax to access properties and methods. Later in this example, I'm going to show you how to implement a function. Now, back to our code.

6
00:01:22,400 --> 00:01:31,990
So, we've got a reference to the first level heading element we can use it to change the element's text color. I'm gonna change the text color to red.

7
00:01:32,210 --> 00:01:46,680
We can access the text color property through the heading's style object's color property, and I make it red using a string literal. I assign the color using the predefined color name.

8
00:01:46,700 --> 00:01:59,350
Now, let's change the text color for the second level heading and the paragraph, too. Again, I'll create a variable for each. Let me scroll up a bit so we can see what we're doing.

9
00:02:01,180 --> 00:02:24,650
"var" - I'm going to call it "secondHeading". Again, it's a good idea to give meaningful variable names like this one, so we know it's about the second level heading... equals,,, and we use the same syntax "document.querySelector()" and we need the second level heading.

10
00:02:24,680 --> 00:02:59,320
So, I use "h2" and I set it's color also to red. "secondHeading.style.color = "red";" And let's create a variable for the paragraph: "var paragraph = document.querySelector()" and we use the paragraph element that is "p". And I set its color to red.

11
00:02:59,490 --> 00:03:12,150
I'm gonna save the file. Let's open it in a browser to see how it works. As you can see, all the text appears in red: the first level heading, the second level heading, and the paragraph.


@@@
1
00:00:02,240 --> 00:00:14,270
Next, we implement a color theme selector. You're going to add two buttons that let the user switch between the light and the dark theme. So, let's continue with the code we implemented.

2
00:00:14,270 --> 00:00:28,140
We only keep the variables and remove the color setting code. So, let's delete this one. And this one. We end up having only the variable declarations.

3
00:00:28,140 --> 00:00:39,800
Now, let's start implementing our first function. We declare a function using the function keyword followed by the name of the function. I call it applieDarkTheme.

4
00:00:39,870 --> 00:01:03,030
"function applyDarkTheme()". Functions may take input arguments that are input data needed by the function to do their job. You can list the function arguments separated by commas inside the parentheses. The applieDarkTheme() function doesn't take any arguments, so we leave the parentheses empty.

5
00:01:03,070 --> 00:01:33,280
Next, I mark the scope of the function using curly braces. The statements that appear within the scope will be executed by the given function. Now, the function should set the text color for the first and second level heading, and the paragraph elements to white. "firstHeading.style.color = " and I will use a new constant which represent the color white.

6
00:01:33,290 --> 00:02:12,310
Same for the second heading... and the paragraph. Finally, the function changes the document's background color by setting the body style's background color property to dark gray. "document.body.style.backgroundColor = "darkgrey". If you leave this code as it is, it won't do anything. That's because the function isn't called. You call a function by typing its name followed by the parentheses, and providing values for its arguments.

7
00:02:12,310 --> 00:02:25,120
Our function doesn't have any arguments, so we can call it just like this. Now let's add another function that changes the font color to blue and the background color of the web page to white.

8
00:02:25,210 --> 00:02:40,200
I'm gonna call it applyLightTheme(). We can simply copy the code we used in the other function, and just change the values. So. instead of white we use blue.

9
00:02:44,560 --> 00:02:59,280
Also for the paragraph and we set the background color to white. All right, we won't call this function directly, so let's remove it. Next, we add two button elements.

10
00:02:59,280 --> 00:03:12,490
The buttons are HTML content, so we need to define them outside the script element, but within the body element. Let me scroll up a bit. And I define the first button.

11
00:03:12,690 --> 00:03:33,810
Its onClick event handler... and the first button will set the dark theme, so it needs to call the applyDarkTheme() method. Next, I provide the button's title. Say, "Dark Theme" and now close the button tag. Similarly, I create the second button.

12
00:03:33,940 --> 00:03:58,510
I simply copy the definition of the first button and make some changes. So, we'll call applyLightTheme(). And the title should be "Light Theme". Let's open the web page in the browser. I can apply the dark theme by simply pressing that button and revert it back to a light theme by pressing the second button.

13
00:04:00,680 --> 00:04:13,730
By now, you've probably got an idea of what web development is. We talked about the core web technologies and you even wrote some basic HTML, CSS and JavaScript code.


@@@
1
00:00:02,000 --> 00:00:18,800
Hello, K�roly here. This is the q&a section of the "Software Development from A to Z" course. I had a student who asked: �What are the methods developers use for bug fixing?� There's no precise science behind fixing software bugs.

2
00:00:18,800 --> 00:00:32,033
But one thing is sure: solving software issues requires various skills and a lot of patience. Let's first talk about bugs. Some are easy to fix, like e.g.

3
00:00:32,033 --> 00:00:44,766
correcting a misspelled text on a label. But more often than not, bugs are complex and subtle. These kinds of issues require a deeper knowledge of the software system.

4
00:00:44,766 --> 00:01:00,333
Other bugs may surface deeper issues or critical design flaws. Such problems require a lot of time and analytical skills to get rid of them. And then, there are the scary ones: the sporadic bugs.

5
00:01:00,333 --> 00:01:16,400
These are issues that pop up randomly and can't be reproduced easily. Now, how do we usually detect bugs? Bugs can be detected by developers during implementation, code reviews or unit testing.

6
00:01:16,400 --> 00:01:31,266
They may be caught during the testing phase by testers. And some problems may slip through and are spotted by the end users. Once found, bugs are categorized and assigned to developers.

7
00:01:31,266 --> 00:01:47,866
Developers then try to reproduce and analyze the bugs. After detecting the root cause, the bug is fixed. The solution is tested and if everything goes well, the fix is submitted either as a patch or as part of an update.

8
00:01:47,866 --> 00:02:03,600
Some corrections may require more extensive testing. Especially if the fix involved profound changes. Not all bugs can be fixed, though. Some may be caused by faulty third-party or system libraries and frameworks.

9
00:02:03,600 --> 00:02:17,566
In such cases, we need to contact the given developer or the company. Companies like Apple, Microsoft and Google provide public access to their bug-reporting systems.


@@@
1
00:00:02,166 --> 00:00:20,233
K�roly here with another q&a from the "Software development from A to Z" course. This student asked: �Would you suggest us a free and full-featured software for agile project management?� During my career, I tried many different project management systems.

2
00:00:20,233 --> 00:00:32,766
Here are the ones I�ve used in the last couple of years. JIRA from Atlassian. Although it�s not free, the self-hosted version is quite inexpensive for smaller teams.

3
00:00:32,766 --> 00:00:44,133
JIRA provides scrum boards - or, you can switch to Kanban mode if that�s what you need. JIRA offers powerful reporting tools, including burndown and velocity charts.

4
00:00:44,133 --> 00:00:56,100
You can also use JIRA for roadmap planning. This feature is useful if you�re working with multiple teams. Last but not least, you also get an integrated bug tracker.

5
00:00:56,100 --> 00:01:12,533
You can have your JIRA infrastructure in the cloud or self-hosted. JIRA is a paid solution. You can try it for free. The self-hosted version�s trial expires after 30 days, and you can evaluate the cloud version for seven days.

6
00:01:12,533 --> 00:01:25,633
After that, you can pick a premium plan of your choice. The self-hosted server version is the cheapest. For a one-time payment of only $10, it�s a good choice for teams up to 10 members.

7
00:01:25,633 --> 00:01:37,433
For larger teams, the price goes up sharply. Also, note that the cheapest option only includes the core functionality and 12 months of software maintenance.

8
00:01:37,433 --> 00:01:49,066
You�ll need to pay separately for the roadmap planner, the issue tracker, the collaboration tool and the version control system. These will cost you an additional $40.

9
00:01:49,066 --> 00:02:03,733
So, for $50 you can have a full-blown, self-hosted agile project management system. Now, while JIRA is inexpensive, there�s another project management app I�d like to make you aware of: Asana.

10
00:02:03,733 --> 00:02:16,433
It�s my favorite. And it�s entirely free for teams up to 15 members. I�ve been using it for a couple of years now. Asana provides a straightforward, easy to use interface.

11
00:02:16,433 --> 00:02:29,800
You can create projects and tasks, assign them to people, add comments, links, and images. It even replaces the conventional email, as all conversations happen within Asana.

12
00:02:29,800 --> 00:02:44,233
Let me show you quickly how it works. I already logged in. You can quickly sign-up using your email address if you want to follow along. You can start adding tasks, but I prefer to create a project first.

13
00:02:44,233 --> 00:02:59,633
I click on this red plus button and choose "Project." Next, I give it a name. How about �Software Development from A to Z�? For the layout, we�ve got two options: list or board.

14
00:02:59,633 --> 00:03:15,033
I prefer the list for most projects, but let�s pick the board to show you how to create a Kanban board using Asana quickly. We can assign new members by adding existing users or by typing in an email address.

15
00:03:15,033 --> 00:03:33,933
New users receive an email with a link that lets them join Asana and our project. Now, I can add columns. I�m going to create a slightly modified Kanban board with the following columns: NEW, IN PROGRESS, VALIDATING, DONE and BLOCKED.

16
00:03:33,933 --> 00:03:56,000
Now, we can add cards, which represent tasks. Every new task will originally appear in the NEW column. I can assign each card to a member of the team, set a due date, assign sub-tasks, add a description, create custom tags, write a comment or add followers.

17
00:03:56,000 --> 00:04:10,633
Asana also integrates a bunch of useful third-party tools like Slack, Dropbox, Harvest and so on. As we work on a particular task, we move it to the corresponding column.

18
00:04:10,633 --> 00:04:22,700
Tasks marked as completed contribute to the overall progress. We can track the progress in the Progress view, which also lets us update the project�s status manually.

19
00:04:22,700 --> 00:04:41,233
. The Conversations tool lets us communicate with team members. I won�t cover all Asana features, but you�ve probably got an idea about it already. I suggest you sign up - again, it�s free - and start playing around with a sandbox project.

20
00:04:41,233 --> 00:05:00,800
Now, if you want to switch to a more powerful premium account, it costs you around $6 per user per month. You won�t be limited to 15 team members. Plus, you�ll get a lot of advanced features, like unlimited dashboards, task dependencies and priority support.

21
00:05:00,800 --> 00:05:17,633
Another popular tool for agile project management is Trello. You can create boards, lists and cards just like in Asana. It also provides collaboration features, you can add comments, attachments and assign cards to team members.

22
00:05:17,633 --> 00:05:43,233
Trello offers a free package which provides all the basic features you�ll need to manage your projects. The premium packages include app integrations called "power-ups." For $9.99 per user per month you get enhanced security and privacy options, better user management tools, priority email support and other advanced features.

23
00:05:43,233 --> 00:05:56,666
While this is not an extensive list of project management tools, it definitely lists some of the most popular ones. Feel free to message me if you have questions related to the course�s topics.


@@@
1
00:00:02,000 --> 00:00:14,000
Congratulations,
Now you know more about software development than most people on this planet! So, you want to make a career switch to software development? You might be wondering, what’s next?

2
00:00:14,000 --> 00:00:38,166
Well, in this section I am going to provide some additional guidance and hints that will help you in accomplishing your goal. The next logical step is to start gathering the experience you’ll need to become a software developer. As I highlighted in the video on The Biggest Misconceptions About Becoming a Developer, the process of learning how to code must not ruin you financially.

3
00:00:38,166 --> 00:00:48,300
You can learn to code on your own. There are plenty of free or inexpensive online resources that will teach you how to program using a specific programming language.

4
00:00:48,300 --> 00:01:12,600
Let’s say you want to learn how to develop apps for iOS using Swift. All you need to do is to visit a website like Udemy, and look up “iOS app development in Swift.” Udemy allows you to refine your search further by applying filters for level, language, features and even price. Let’s say we want to list all English speaking beginner level courses which include coding exercises and are free.

5
00:01:12,600 --> 00:01:43,266
Well, no results, so let’s uncheck coding exercises.  We can even sort the results by various criteria, for example by relevance or by ratings. Now, free courses usually only cover the basics or they provide less value compared to their paid counterparts - - for obvious reasons. For more advanced topics you’ll usually need to spend some money.

6
00:01:43,266 --> 00:01:54,633
As a word of advice: if you discover a course which matches your needs, but it’s too pricey, just add it to your wishlist. Then wait until it gets discounted.

7
00:01:54,633 --> 00:02:11,766
Udemy offers promotions quite frequently, and in most cases, you can get a $200 course for 10 bucks if you wait a bit. Pro tip: Contact the author directly and ask for a reasonable coupon. Most authors will happily help you out.

8
00:02:11,766 --> 00:02:21,800
Alternatively, you can search for coupon codes on the internet, but this is usually just a waste of time. You should also join “learn to code” meetups.

9
00:02:21,800 --> 00:02:35,133
On meetup.com you may be able to find one that is in your city or very close to you. See for example www.meetup.com/topics/learn-to-code/ See for example www.meetup.com/topics/learn-to-code/.

10
00:02:35,133 --> 00:02:47,766
Meetups are great to share your thoughts with other, like-minded people, and learn from more experienced programmers. Once you master a programming language, start working on a project.

11
00:02:47,766 --> 00:03:18,066
It is also a good idea to create a GitHub or a Bitbucket account, and place your project into a public repository so that others can provide feedback on your code. Besides, prospective employers may also find you. Hint: you should only share your code publicly if it meets certain quality criteria - that is, it builds without issues, produces very few or no build-time warnings, it’s thoroughly commented, and it works as expected.

12
00:03:18,066 --> 00:03:27,933
Let the world know about your new skills. Write blog posts, update your LinkedIn profile, add the newly learned programming language to your skill set.

13
00:03:27,933 --> 00:03:37,566
Finally, if you are confident enough, you can start looking for a software development job.  You can also work as a freelancer if this fits you better.

14
00:03:37,566 --> 00:04:01,900
Luckily, there is an increasing demand for computer software, and the need for software developers if bigger than ever. According to the United States Department of Labor, Bureau of Labor Statistics: Employment of software developers is projected to grow 17 percent from 2014 to 2024, much faster than the average for all occupations.


