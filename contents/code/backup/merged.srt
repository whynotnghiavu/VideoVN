@@@
1
00:00:00,005 --> 00:00:10,005
- [Scott] Data drives our world, and SQL is the language we often use to work with that data. Querying databases with SQL gives us the ability to explore, analyze, and most importantly, use all kinds of data.

2
00:00:10,005 --> 00:00:21,008
In this code challenge course, you can test your knowledge of intermediate-level queries in SQL to build your confidence working with the various data analysis and reporting tools that many SQL-compatible relational database management systems provide.

3
00:00:21,008 --> 00:00:31,007
I'm Scott Simpson, Senior Staff Instructor at LinkedIn Learning, and I've put together five code challenges that cover a variety of intermediate level SQL concepts that allow us to use and transform data.

4
00:00:31,007 --> 00:00:42,006
Build and test your solutions to these challenges in the built-in interactive coding environment. No special software required. And when you finish your solution to each challenge, take a look at my solution videos to see how I solve them.


@@@
1
00:00:00,005 --> 00:00:09,006
- [Tutor] In this Code Challenge Course, I expect you to be familiar with writing queries in SQL. We'll spend time grouping and filtering data, joining tables, and transforming values.

2
00:00:09,006 --> 00:00:22,004
These challenges each combine a couple of intermediate difficulty concepts, that are often used in data reporting and data preparation. If you need to refresh your SQL knowledge, take a look at these courses in the LinkedIn Learning Library.

3
00:00:22,004 --> 00:00:31,001
In the challenges, we provide a database that describes a small neighborhood restaurant. We'll see tables like employees, reservations, orders, dishes, and so on.

4
00:00:31,001 --> 00:00:39,006
Each challenge will give you an entity relationship diagram to describe the table or tables being used. And feel free to SELECT * on the tables to look at the actual data.

5
00:00:39,006 --> 00:00:48,005
If you do, the interface will show that output is a wrong answer. But don't worry, there's no points or time, or anything like that, that you'll lose or risk having taken away.

6
00:00:48,005 --> 00:00:55,000
To work on these challenges, you don't need to install any separate software. The Coding Challenge environment is part of the LinkedIn Learning COurse Page.


@@@
1
00:00:00,005 --> 00:00:12,000
- [Instructor] This course consists of automated code challenges that appear when you click on the challenge links in the course's table of contents. Each challenge includes instructions and a code editor you can use to create and test your own solution to the challenge.

2
00:00:12,000 --> 00:00:24,008
These challenges are hosted by CoderPad, and they appear in the same area of the course page where you watch the course's videos. We recommend using a desktop browser for the best experience with code challenges, but you can use the LinkedIn Learning mobile app if you prefer.

3
00:00:24,008 --> 00:00:33,005
The code challenge has three areas, instructions in the top left, a console for output in the bottom left and a code editor for your answer on the right.

4
00:00:33,005 --> 00:00:43,006
You can use these drag handles to allocate space as you like. To get even more horizontal space for the code editor, you can collapse the course's table of contents on the left.

5
00:00:43,006 --> 00:00:52,000
Each challenge has instructions that include a description of the challenge and the challenge's desired result. Create your answer in the code editor.

6
00:00:52,000 --> 00:01:08,008
(keyboard clicks) When you click Test my code, you'll see a message indicating whether your code returned a correct result and a text-based version of the returned data.

7
00:01:08,008 --> 00:01:20,001
If your answer doesn't create a correct result, you'll see a message telling you the code is incorrect and showing the data that was returned. If any of the messages are too long to fit in the console, you can scroll sideways to see all of the text.


@@@
1
00:00:00,005 --> 00:00:09,007
- [Instructor] Here is how I solved this challenge. I start out returning the customer ID, their first and last name, and the sum of the dishes that the customer has ordered.

2
00:00:09,007 --> 00:00:19,009
That's made possible by joining the orders table, which I'm calling O in the CTE notation, with orders dishes, which I'm naming OD. And I'm matching up the order ID on each table.

3
00:00:19,009 --> 00:00:28,009
This lets me get each item that was part of each order. The orders dishes table stores dish IDs, and to get a dishes price, we need to join the dishes table, which I'm calling D.

4
00:00:28,009 --> 00:00:40,006
Based on matching the dish ID on orders dishes and dishes, that completes the set of things we need to get prices of dishes and orders. We also need to join the customer's table because we want to know the names of the customers.

5
00:00:40,006 --> 00:00:52,009
The orders table contains a customer ID, and so does the customer's table, so we match those up to give us access to the customer's name fields. We group these results by customer ID since we're adding up the total price of items spent by each customer.

6
00:00:52,009 --> 00:01:02,002
So we need to have just one row per customer. Without a condition, this would represent all our customers, but the challenge asked for only those customers who spent more than $450.

7
00:01:02,002 --> 00:01:14,000
So we need to evaluate each customer's total spend. Total spend is an aggregate value based on more than one row's values, not a single row value. So we need to use HAVING to check its value instead of where.

8
00:01:14,000 --> 00:01:23,001
We could still have a where clause in here to check some other individual row value, like the customer's home state or something like that, but we don't need a where for this particular solution.

9
00:01:23,001 --> 00:01:36,000
Finally, I order the table by total spend descending to put our top spender at the top of the list. I'll run this and see if it works. It does. Here's a list of our top spenders of all time.


@@@
1
00:00:00,005 --> 00:00:14,005
- [Instructor] To solve this challenge, I used GROUP_CONCAT, a function in MySQL and similar DBMSs that concatenates items based on their grouping. Microsoft SQL has a similar function called STRING_AGG, short for string aggregation, that works in the same way.

2
00:00:14,005 --> 00:00:22,005
If you use that, you'll need to have provided a separator, which to make the output match with the challenge request, should be a comma with no space following it.

3
00:00:22,005 --> 00:00:33,009
This function works together with a grouping term, which in this case is GROUP BY OrderID. Here we can see the different versions of MySQL and MS SQL syntax that have the same result that we're looking for.

4
00:00:33,009 --> 00:00:43,001
The challenge also asked for the list of items to be sorted alphabetically, and here with this MySQL syntax, I'm doing that with the ORDER BY D.Name in the GROUP BY function.

5
00:00:43,001 --> 00:00:55,001
Ascending is the default order here, so I can leave that off. But if I wanted to be explicit, I could add ASC as well. With MS SQL, that would be a bit different, including A within GROUP clause where the order by D.Name would be.

6
00:00:55,001 --> 00:01:05,002
Back here in my solution, we can see that I've joined the three provided tables, Dishes, OrdersDishes, and Orders, so that I can resolve an order ID to the names of the dishes included in it.

7
00:01:05,002 --> 00:01:22,001
And as the challenge asked for, I'm only interested in the orders from May 1st, 2022, or 2022-05-01 and later. Then, when these names are returned, they're listed altogether, in alphabetical order, separated by commas, by each order ID.


@@@
1
00:00:00,005 --> 00:00:13,000
- [Instructor] To solve this challenge, I'm using the Orders, OrdersDishes, and Dishes tables to find all the orders that include the dish called "Handcrafted Pizza." The challenge asked for the quantity of pizzas sold and the date, let's start out with the date.

2
00:00:13,000 --> 00:00:27,000
Each order in our database has a Datetime value associated with it, but we only want the date portion of that, the year, month, and day. Having this date value will allow us to group the count of our pizza orders by day, but right now those values still have a time value attached.

3
00:00:27,000 --> 00:00:45,006
So if we tried to group by the current value, we'd only really ever have one pizza ordered at a specific time on a specific day. So, we'll use the CAST keyword and tell the database to reinterpret the OrderDate value as a date type that gets us only the date portion without the time portion, and we'll call that Day.

4
00:00:45,006 --> 00:00:56,004
We'll group our results by Day and order them by Day as well. And we'll use the COUNT aggregate function to tell us how many pizzas were sold by day, and we'll call that NumSold.

5
00:00:56,004 --> 00:01:06,000
I'll run this to see if it works. And there we go, for each day there was one or more pizza ordered, we have that date and the count of pizzas just like the challenge asked.


@@@
1
00:00:00,005 --> 00:00:12,001
- To solve this challenge, we need to use some logic that handles different situations, or cases. We'll start out with some pretty straightforward things, like the name of the dish as dish name, and the price as original price.

2
00:00:12,001 --> 00:00:22,005
These fields come from dishes and we'll order our results by dish name. What the challenge asks for though is two more columns; the discount percent and the discounted price.

3
00:00:22,005 --> 00:00:34,004
To get the discount percent, which has three conditions to match, I use a case statement and provide those three conditions. When the price of a dish is less than seven the statement returns the text string 5%.

4
00:00:34,004 --> 00:00:46,002
When the price is between seven and 10 the statement returns the string 10%. And in any other case, which for us here means any price larger than exactly 10, the statement returns the string 15%.

5
00:00:46,002 --> 00:01:00,007
That gets us our discount percent values. So next we need to actually calculate the prices for our items with those discount amounts applied. Here I'll use another case statement with the same conditions, but this time I'll return numbers instead of strings.

6
00:01:00,007 --> 00:01:21,003
0.05, 0.1, and 0.15, to represent 5%, 10%, and 15%. That number will be subtracted from one, giving us the portion of the remaining price to charge. So that would be 0.95% or 95%, 0.9 or 90%, and 0.85 or 85%.

7
00:01:21,003 --> 00:01:35,001
Then we multiply that value by the price of an item and round it so we don't get long decimal values that we won't be able to make change for. We're rounding this value to two decimal places as the challenge requested, and we'll call this value discounted price.


@@@
1
00:00:00,005 --> 00:00:07,006
- [Instructor] To solve this challenge, we'll focus on string manipulation. My solution returns some values from the employee's table, ordered by name.

2
00:00:07,006 --> 00:00:19,001
Without a where condition we'll get all the records and that's what we want. The first item in the challenge asked for a strictly five digit employee ID, with leading zeros to fill empty spaces at the beginning of the string.

3
00:00:19,001 --> 00:00:30,008
To create this, I used the LPAD or left pad function, which takes three arguments, the field to include, the number of digits to pad to, and the digit or character to use for that padding.

4
00:00:30,008 --> 00:00:49,006
I'll call this ID. The next item in the challenge is to provide the employee names in the format last comma first with a space in the middle. So I use the concat or concatenation function to return one string made out of the last name value, a string value comma space, and the first name value, and I'll call this name.

5
00:00:49,006 --> 00:00:59,005
Third, I need to generate usernames that are no longer than eight characters, and which include the employee's first initial and whatever part of their last name fits in the remaining seven characters.

6
00:00:59,005 --> 00:01:10,000
That all needs to be lowercase. So I start out using substring to slice a specific piece of the string's first name and last name. For first name, I start at character one and return one character.

7
00:01:10,000 --> 00:01:19,008
That's the first character in the string. For last name, I start at character one again and I return seven characters from that point. If a string is longer than seven characters, I just get the first seven characters.

8
00:01:19,008 --> 00:01:28,002
And if it's shorter than seven characters, I'll get the full string. Then I use the concat function to stick these two strings together with the first initial first.

9
00:01:28,002 --> 00:01:38,004
And then I use the lower function to convert that all to lowercase, and we'll call that value login. And finally, we'll generate email addresses at which our employees can be reached.

10
00:01:38,004 --> 00:01:45,003
Our employees have a username in our system, but unfortunately that's different than the logins that we needed to generate for them on this other system.

11
00:01:45,003 --> 00:02:00,009
For example, our founder and head chef have their first name as a username in our system, instead of a regular username like the other employees. So we'll use concat again to stick each user's real username to this string here that represents our email domain, and we'll call that value email.

12
00:02:00,009 --> 00:02:11,000
I'll run this and let's see what we get. Great, this passes the challenge. We'll often need to transform data from our databases in some way instead of just returning it verbatim.


@@@
1
00:00:00,005 --> 00:00:09,004
- [Scott] If you we're able to solve these challenges, congratulations, and if not, take some time to refresh your knowledge of intermediate level SQL queries and come back and try again.

2
00:00:09,004 --> 00:00:18,000
If you're ready to move on and solve more challenges, take a look at our other interactive SQL code challenge courses here on LinkedIn Learning. See you next time.


