@@@
1
00:00:00,780 --> 00:00:16,300
Welcome to data structures and algorithms for coding interview course, I designed this course with ton of content, if you want to build your strong understanding in data structures and algorithms.

2
00:00:16,920 --> 00:00:33,560
This is the perfect course for you. Now, let's see what we will be learning throughout this course. We'll start off with run time analysis. First, we'll see how to find out complexity of your algorithms.

3
00:00:34,510 --> 00:00:51,490
We'll talk about omega notation, big O notation & theta notation. For rest of the course we'll be talking about, big O notation just for learning purposes, we will be talking about omega notation notation and theta rotation.

4
00:00:51,970 --> 00:01:14,160
In this section, you will learn how to find it. Time, complexity of an algorithm using some examples then we will start learning array data structures in the array data structure section, we will be talking about 1D array &2D array. How to create array, how to use array.

5
00:01:14,740 --> 00:01:49,020
And we'll be talking about how 1D & 2D array is represented in computer memory. Then we will talk about linked list data structure. In this section of this course, we will be talking about four types of linked list, singly linked list, circular singly linked list, doubly linked list and circular doubly linked list. We will implement the four types of linked lists and we will implement all functionality of linked list for four types of linked list from complete scratch.

6
00:01:49,780 --> 00:02:15,850
Then we will talk about stack, we will implement stack from scratch and we will see how LIFO principle works for stack. Then we will talk about Queue data structure, we will implement Queue using linked list and array and we will implement Queue from complete scratch and you will see how FIFO principle works for Queue.

7
00:02:16,060 --> 00:02:32,630
Then we'll start our new data structure. Tree. For tree data structure, we have many types of tree, but in this course will be talking about most commonly used tree data structure.

8
00:02:33,570 --> 00:02:49,620
First we will see binary tree We'll see how to implement binary tree, how to traverse binary tree, we will traverse a binary tree using breadth first traversal (BFS) and using depth first traversal (DFS).

9
00:02:49,830 --> 00:03:09,890
That means BFS or DFS Then we'll talk about binary search and we'll talk about AVL tree, we will implement binary search tree from scratch and we'll implement all the method of humanity's history and also will implement avl tree from scratch.

10
00:03:09,900 --> 00:03:25,980
And we will implement all the functionality for AVL Tree data structure from complete scratch. Then we'll talk about trie data structure for auto search suggestions or for word correction's we use tried data structure.

11
00:03:26,370 --> 00:03:37,260
When you type something on Google, then Google gives you some suggestions and the suggestions comes from Trie data structure. Then we'll talk about binary heap.

12
00:03:37,380 --> 00:03:49,940
We have two types of binary heap, min heap & max heap, we will implement binary heap from complete scratch. There is a famous algorithm that is called sorting algorithms.

13
00:03:49,950 --> 00:04:03,660
"Heap Sort". Heap sort uses Binary heap data structure and we'll see that also in a sorting algorithm section. Then we'll learn sorting algorithms. You're given an unsorted array.

14
00:04:03,660 --> 00:04:19,080
You have sort the array into ascending order. In this course, we'll lean seven sorting algorithms, Bubble Sort Selection Sort, Insertion Sort, Quick Sort, Merge Sort, Bucket Sort & Heap Sort algorithms after that.

15
00:04:19,080 --> 00:04:30,330
We will see recursion For tree problem recursion is almost mandatory. There are a lot of applications for recursion and that you'll see throughout this course.

16
00:04:30,570 --> 00:04:42,900
Dynamic programming uses recursion, For tree problems Most of the time we use recursion, For graph problem We use recursion and there are a lot of problems problems where we use recursion.

17
00:04:43,200 --> 00:05:08,430
Then we'll talk about dynamic programming. Using dynamic programming, we can transform our exponential time complexity to linear time complexity that we will see in this course, we'll see the properties of dynamic programming, overlapping sub-problems and optimal substructure, Also we'll see what is the bottom of approach, what is top down approach of dynamic programming.

18
00:05:08,610 --> 00:05:27,420
Then we'll talk about hash table (Hashing Data Structure) Finally, we'll talk about graph data structure. In this section of this course, we'll have a lot of content, a lot of algorithms and we'll implement Graph data structure from complete scratch, we'll have a complete section for graph.

19
00:05:27,570 --> 00:05:41,400
In this section of this course, we'll talk about some popular algorithms, dijkstra algorithm, bellman-ford algorithms. Floyd-warshall algorithm, primes algorithm, kruskals algorithm.

20
00:05:41,610 --> 00:05:59,910
And there are a lot of content will have in this section. We'll have a complete section for graph data structure. If you want to work at a big tech industry like Google, Microsoft, Amazon, Netflix, Uber, etc., Then you have to understand data structures and algorithms.

21
00:06:00,100 --> 00:06:11,100
Deeply for you coding interview. After finishing this course, you will have a clear understanding on this concept data structures and algorithms. You will feel confident.

22
00:06:11,730 --> 00:06:29,010
After finishing this course. I use illustrated video examples and we'll go through line by line of code and we will explain every single details and how the algorithms works and how the data structures relate to that algorithm.

23
00:06:29,220 --> 00:06:38,910
If you want to ace your next coding interview, this course will help you a lot. If you were a self-taught programmer, if you don't have any college degree, don't worry.

24
00:06:39,060 --> 00:06:50,750
Enroll this course and start learning data structures and algorithms from scratch. This course comes with 30 day money back guarantee. So what are you waiting for?


@@@
1
00:00:00,570 --> 00:00:15,360
Hey, what's up, guys? Welcome back to this video. In this video, we're going to talk about a random analyze it. In order to be a great programmer, you have to understand the random analysis of an algorithm in this video.

2
00:00:15,390 --> 00:00:30,240
We're going to talk about what is a random analyze it. Now let's talk about what it algorithm random analyze it, random analyze. It is an estimate of increasing the runtime of an algorithm as its input grows.

3
00:00:31,080 --> 00:00:42,810
This is the formal definition of algorithm, random analyze which one should elaborate. We should learn random analyses to measure the efficiency of the algorithm.

4
00:00:43,800 --> 00:00:55,950
In order to measure the efficiency of your algorithm, you should learn a random analyze it for random analysis. You have to factor, time, factor and Espace factor.

5
00:00:56,310 --> 00:01:07,110
The number of operations required for a particular algorithm is called time factor and the amount of memory used by an algorithm is called Espace Factor.

6
00:01:07,350 --> 00:01:26,040
The time factor is called time complexity and the space factor is called Espace. Complexity, time. Complexity measures the number of operation records for the particular algorithm and the space complexity measures the amount of memory used by a particular algorithm.

7
00:01:26,610 --> 00:01:38,300
Now let's talk about the notations for runtime analysis. We have three notations for runtime analyzed which will make a notation begal notation notation.

8
00:01:38,820 --> 00:01:58,590
We'll make a notation majoras that best case of an algorithm bigo or annotations majors, the worst case of an algorithm. Annotations, mesures, the average case of an algorithm for interviewing purposes most of the time will be using big annotations.

9
00:01:59,010 --> 00:02:12,210
In the rest of this course we'll be talking about Bigo notations, not OMCG annotations or annotations or make annotations and annotations are used for academical purposes mostly.

10
00:02:12,540 --> 00:02:35,680
Now let's talk about Omega annotations, big annotations and annotations. Now let's talk about Omega notation. This notation gives the lower bound to up an algorithm that means the base to get this notation is used to measure the best of an algorithm when we need the best gauge of an algorithm.

11
00:02:35,710 --> 00:02:46,180
Then we have to consider omega notation. Now, let's talk about a notation. This notation gives the upper bound up in algorithms that meant the worst kept.

12
00:02:46,840 --> 00:03:03,640
This notation used to measure the set up an algorithm. Now let's talk about the notation. This notation gives the average of the lower bound and upper bound up an algorithm, and this notation used to measure the average case scenario of an algorithm.

13
00:03:04,210 --> 00:03:18,000
So we can say notation is the average of common in addition and be notation. Now let's take an example to understand Omega notation and notation. Let's say we're given an error.

14
00:03:18,070 --> 00:03:33,420
This is an array of integers. We have integer from one to eight for immigration to find out an element in this area. The best cat is omega of one. If you are, say, to find out the element one in this area.

15
00:03:34,060 --> 00:03:47,970
And we have to do here just one operation that we will find out the desired element in one unit of time. And this is the best gauge for bigger annotation.

16
00:03:48,280 --> 00:03:59,110
It will take off in time complexity because this is the worst case. We proceed to find out the Element eight in this area. Then you have to scan this out from left to right.

17
00:03:59,620 --> 00:04:09,790
And here we have the Element eight. If the length of this error is in, then it will take Spiga of in time complexity. So it will take in unit of time.

18
00:04:09,820 --> 00:04:29,410
This is the oldest kid and this is the best gift. OK, the worst case is we go in and the best case is because of one for rotation. Basically rotation is the average of Omega and begin rotation and that is in divided to the average is in divided two.

19
00:04:29,560 --> 00:04:37,390
So you can say that addition is the average American tradition and typical addition of have understood what is Omega tradition, tradition and tradition.

20
00:04:37,540 --> 00:04:48,520
In the rest of this course, we will be talking about tradition and this is used for interval settings and almost in everywhere. So we'll will be talking about being an addition for the rest of this course.

21
00:04:48,910 --> 00:04:59,710
Now let's see example of random analyze it you complexity. We have new and here we have example bigger of one. This is called constraint time complexity.

22
00:04:59,830 --> 00:05:16,690
Adding an element in the front of a linguist takes constant time. Complexity, bigger of log in. It is called logarithmic time complexity. Sassing an element in a solid array takes a logarithmic time complexity.

23
00:05:17,020 --> 00:05:30,520
Bygrave And this is called a linear time complexity. Certainly an element in an unsorted array takes linear time complexity bigger of in log in. This is called linear logarithmic linear logarithmic time complexity.

24
00:05:30,640 --> 00:05:44,620
Meurs sort algorithm takes linear logarithmic time complexity bigger in scope. This is called quadratic time complexity. Shootist part between two cities in a graph takes quadratic time complexity.

25
00:05:44,950 --> 00:05:56,290
This is called Kubic Time complexity. A matrix multiplication takes Kubic time complexity. This is called this is Bego up to the bar in. This is called exponential time complexity.

26
00:05:56,950 --> 00:06:11,770
Knabe solution of intimacy problem takes exponential time complexity because in fact Terryl this is called factorial time complexity nive solution of travelling salesman problem takes a factorial time complexity.

27
00:06:11,890 --> 00:06:26,500
So these are the examples of random. Analyze it now let's see a graph for a random analyze it this it bigo complexity chart. Hurry up the graph representation for our complexity.

28
00:06:26,500 --> 00:06:41,620
Analyze it here. We have a number of operations and here we have the site of elements here. This black line is called Constant Time Complexity because it's super fast.

29
00:06:41,800 --> 00:06:55,390
Then we have big log in. This is also a first time complexity than linear time complexity. This is the area for logarithmic time complexity. Then we have your linear time, complexity, linear time.

30
00:06:55,390 --> 00:07:07,750
Complexity is better than big in log-in. This is called because of log in area. OK, here we have off into the board to then we have your exponential, then we have your factorial.

31
00:07:08,020 --> 00:07:21,930
Factorial is the worst ever. This is consider bad. This is considered fear. This is good and this is excellent. So our constant. Excellent logarithmic time.

32
00:07:21,950 --> 00:07:38,450
Publicity is good, linnear is fear than in log-in is bad. Then we have your horrible for exponential factorial or we can say for Kedrick, this is bigger or complex, the chart and this is the basics of random.


@@@
1
00:00:00,510 --> 00:00:09,990
A lot of guys will come back to this video in this video we're going to talk about around them, analyze it for them, analyze it. We have time, complexity and complexity.

2
00:00:10,200 --> 00:00:20,520
The number of operations record for a particular algorithm is called time complexity. The amount of memory is used by an algorithm is called space complexity.

3
00:00:21,610 --> 00:00:46,180
The time complexity is not about timing with the clock, how long the algorithm takes, instead, how many operations are executed, that number of instructions executed by a program is affected by the size of the input for a high configuration Apple computer program will work faster than in a low configuration Apple computer.

4
00:00:46,480 --> 00:01:01,240
But with time and space complexity, analyze it will not consider the power of CPU, will just consider the number of operations or the unit of memory is taken by an algorithm.

5
00:01:01,780 --> 00:01:13,000
Big operation is used to classify algorithms by the worst case scenario. That's what we have talked about in the previous video. Now let's talk about common running times.

6
00:01:14,020 --> 00:01:30,320
All you need at times is record for arithmetic and logical operations. One unit of time is required for assignment and region value, and one unit of time is required for a read and the right operation.

7
00:01:30,670 --> 00:01:43,180
These are the common running times. Now let's talk about constant time. What is constant time? Constant time means the running time is constant. It's not affected by the sight of input.

8
00:01:43,180 --> 00:02:04,270
Constant time complexity is not dependent on the side of input hearable function. If in this function takes an input in inside, here we have it equals to in times in here we're declaring a variable that here we're printing a value and here we returning a value.

9
00:02:04,390 --> 00:02:18,520
This all our constant time operations this are this all takes one unit of time to execute that statement. So this program works in constant time complexity.

10
00:02:18,820 --> 00:02:28,510
This variable degradation takes constant time. This printing of taking constant time and returning a value is taking constant time. What is a linear time?

11
00:02:28,510 --> 00:02:40,180
Complexity in an algorithm except in input side, it would perform in operations as well. For example, here we have an array and then we have here LOOF.

12
00:02:40,420 --> 00:03:08,720
We're iterating this array from the first index to the last index in the side of this array is in. Then this loof will run 14 times. The error declaration will index because of one time complexity, but because of in space complexity, because we have here in a number of elements and this fall of all iterate through from zero to in actually doing iterate through from zero to and minus one.

13
00:03:08,860 --> 00:03:24,010
So you can say it takes off in steps step to execute this love. And inside here we're printing a value and this all takes constant time, complexity. So we can say this is taking off in time complexity.

14
00:03:24,280 --> 00:03:40,720
So you can say this problem is taking bigger in time complexity. Now let's talk about logarithmic time complexity algorithm that has a running time or log in is slightly faster than because of, in example, binary search algorithm decision by energizers.

15
00:03:40,750 --> 00:03:52,890
Algorithm for a time are in four sides of the given array for this binary source algorithm here. This operation takes constant this operation takes constant theoretical into variables.

16
00:03:53,110 --> 00:04:03,910
Here we have loof using this loop. We're dividing the array into two halves. It's time that where sanity of anybody to and this all are taking constant.

17
00:04:04,210 --> 00:04:18,610
If we want to find out the time complexity for the first iteration, the length of our areas in divided to the departure, that means in four second iteration Leontes the to deploy one and we're dividing that into two halves.

18
00:04:18,610 --> 00:04:31,440
Four is time for step. It takes anybody to the park up to division. Length of the array will be one in the order to the equals to one. And here we have solved this problem and we get here log to end.

19
00:04:31,450 --> 00:04:49,150
And this is the time complexity for this binary search algorithm. We've understood how to find it time complexity of a binary source algorithm. The time complexity is because of luck to end and the space complexity is because of one because we are using some variable here, left, right and meet.

20
00:04:49,570 --> 00:05:01,180
Now, let's talk about linear logarithmic time complexity. This algorithm divides the problem into some problem and then merge them in in time. Example Mursau algorithm.

21
00:05:01,570 --> 00:05:10,960
This is my algorithm. This is a little bit critical to understand. We have a section where we have explained every single informations about master algorithms.

22
00:05:11,230 --> 00:05:20,650
We have a section in discourse sorting algorithms. You can check the video in that section. Our algorithm uriarte off in and we are dividing the problem into.

23
00:05:20,930 --> 00:05:34,850
Perhaps it's time he ripped Europe in the too and Europe to have invaded too, and here this one takes a linear time capacity and if we solve this formula, then we get our time complexity bigger in terms of login and space.

24
00:05:34,880 --> 00:05:48,290
Complexity is bigger. And this is the time, complexity, analysis of linear logarithmic, time, complexity. We have explained everything in the video, mastered algorithms in the sorting algorithm sections, and this is called back substituting method.

25
00:05:48,500 --> 00:05:57,470
Now let's talk about quantity time. But algorithm takes quality time, complexity. In other words, a loaf instead of a loaf is considered quality time.

26
00:05:57,680 --> 00:06:12,860
This is an example of quality, time, complexity. We have a tool of value for entire Ejiro. I list an entire flat. The sidedly less than in this loaf, either through from zero to and minus one.

27
00:06:12,860 --> 00:06:26,300
That means in times it takes in New York Times and this loop also takes in uptimes and the statement to execute in Konstantine. If we add all that will get bigger and square time complexity for one in Egypt.

28
00:06:26,300 --> 00:06:39,230
Times of this move, this in a loop takes in unit uptimes four in unit of time of this hour. Aluf that in a loop text in times in unit of times over have understood what is a quality time complexity.

29
00:06:39,620 --> 00:06:50,890
Now let's talk about Kubic time, complexity. It has the same principle as we go off and square. This is a slow algorithm. Now let's talk about exponential time, complexity or up to the bar.

30
00:06:50,900 --> 00:07:02,180
And it is a very slow algorithm as input growth, if any, close to one zero zero zero zero zero time complexity will be two one zero zero zero zero zero zero.

31
00:07:02,540 --> 00:07:14,000
We can consider the brute force algorithm example. Backtracking algorithm, backtracking algorithm takes exponential time, complexity factor real time, bigger in factorial.

32
00:07:14,570 --> 00:07:27,800
It is the slowest algorithm ever. Now we're familiar with common random algorithms. Now we are familiar with common random. Analyze it now you might say, why should we learn complexity?

33
00:07:27,800 --> 00:07:40,280
Analyze it. Now, let's answer to this question. Let's say you were given an input. Upside's ten now for input and goes to ten ipe far from binary source or linear source.

34
00:07:40,310 --> 00:07:54,020
Then there is no significant difference. But if the size of our input in it goes to one billion, then if we perform linear source, it will takes one billion millisecond.

35
00:07:54,290 --> 00:08:12,620
But we far from vandalisms. Banister's will takes thirty two millisecond. Here we see a huge difference for one billion millisecond. If we convert one billion millisecond into this then we get forty six days for the input and it goes to one billion.

36
00:08:12,800 --> 00:08:27,230
If is a unit of operation takes one millisecond then linear source algorithms takes approximately forty six days. And this is called linear algorithm for Bannister's algorithm.

37
00:08:27,240 --> 00:08:45,710
This is called logarithmic algorithm. Linear search algorithm takes linear time. Complexity by analysers algorithm takes logarithmic time. Complexity binary search works in thirty two milliseconds, but linear statistics one billion milliseconds for the input and equals to one billion.

38
00:08:45,920 --> 00:09:04,070
Then we can see here he was different. This is why you should learn a random analyze it. That means complexity, analyze it. If we write an algorithm that you can measure the efficiency of your algorithm using complexity, analyze it, you can see your code is optimized.

39
00:09:04,340 --> 00:09:13,220
If we do not know complexity, analyze it, then it will have no idea what your code about the efficiency of your code. With that complexity. Analyze it.

40
00:09:13,220 --> 00:09:24,290
You cannot be a great programmer. Complexity analysis either. Must having skills for software engineer Hoffe have understood what is complexity, analyze it and the basics of complexity.

41
00:09:24,290 --> 00:09:36,580
Analyze it. Now we have a basic knowledge of complexity. Analyze it in the rest of the video. In the sections will be talking about how to find out the complexity of an algorithm.


@@@
1
00:00:00,300 --> 00:00:08,450
Here you are, guys. Welcome back to this video. In this video, we're going to see how to find a time, complexity of an algorithm. Let's say you're given this code.

2
00:00:08,880 --> 00:00:26,400
Can we have a fall of and insert here or just printing the value of this wall of start from one and end up at in if we consider is iteration of the sluff, text one unit of uptimes, then for any iterations this love will takes in.

3
00:00:26,410 --> 00:00:42,840
You need to uptimes so we can see the time. Complexity is often and the space complexity is bigger up one. That means constant space complexity because we're not using any additional data structure to store our data in computer memory.

4
00:00:43,680 --> 00:00:57,940
So the time complexity of this algorithm is bigger often. Now, let's take another example. For example, if you're giving this algorithm here, we have loof for AI from one to less than equals two in and here.

5
00:00:57,960 --> 00:01:14,580
Incrementing by two is time and the speed operation takes constant time. Now we have to find out the time complexity of this algorithm. If we have any goals to ten, then this loof will iterate in divided two times.

6
00:01:14,850 --> 00:01:27,420
That means five times if it's iteration of this, love takes one unit of time for input in this loop will text in the other two in Europe times for time complexity.

7
00:01:27,420 --> 00:01:41,940
Analyze it. Will it consider our constant part will take the degree from that expression. OK, so here we have in will take just in will discard this constant part in the other two here.

8
00:01:41,940 --> 00:01:50,940
Two is a constant. So the time complexity of this algorithm is big enough. And if you're given this algorithm here, we're increasing by 20 years time.

9
00:01:51,210 --> 00:02:05,250
This form of oil takes into what, a twenty unit of times for the input end. And here all this the constant all the way. Just no matter what, if we have 100, 200, 300 will not consider that.

10
00:02:05,520 --> 00:02:17,170
We'll just discard that part and will take the degree of the equation. And that is in. So the time complexity is bigger and the space complexity is become one because we're not using any original speech.

11
00:02:17,640 --> 00:02:32,490
Now, let's take another example. For example, if you given this algorithm and we're going to break it down, the iteration for the Aluf and for the loop, and this print statement is taking constant time, complexity.

12
00:02:32,790 --> 00:02:54,360
Here we break down the iteration. Four outer and inner love for first iteration of our Aluf in the Loop will not execute for the second iteration of the Our Love in Aluf execute one times for any iteration of our love in Aluf Executes in times if we add all the execution zero.

13
00:02:54,360 --> 00:03:05,220
One, two, three, four and then we get this equation OK. So we get from the situation in terms in plus one divided two and here we get in squared plus in the other two.

14
00:03:05,610 --> 00:03:25,920
Now in order to find out the time, complexity from this equation will consider the degree of this equation. The degree of this equation is in square. So the time complexity of this algorithm is because in square and the space complexity is bigger, one, because you are not using any additional speech.

15
00:03:26,100 --> 00:03:50,970
Now, let's take another example. For example, if you're giving this algorithm, we have close to zero and I believe we are running this loop from zero to less than equals to in here we have pocket Peeler's and equal to in and we're increasing I, I got two I plus P and here we have a statement now how we can find out the time, complexity of this algorithm.

16
00:03:51,330 --> 00:04:06,560
We break down the iteration for the slope. OK, before I got to one because to zero plus one for I got to two because to one plus two four I got to kill because two one plus two plus three plus four plus K.

17
00:04:06,780 --> 00:04:19,670
If we assume B is greater than in then this loop will stop. When E.S.P is greater than in this loop will stop. OK, now here we go to one plus two plus three plus four plus so on.

18
00:04:19,950 --> 00:04:39,150
So here we get from this equation K Damski plus one divided to get squared plus K divided two. Now here get squared plus the military goes to P so well two is greater than N when we find out this condition that love all stop executing.

19
00:04:39,660 --> 00:04:53,820
Now here will take the degree from this equation that is square. So we will will discard this part K and two. So you get Gascoine greater than in four random analyses.

20
00:04:53,820 --> 00:05:13,250
We will consider only the degree of equation and here we get Cagle's to. Roadable in so we find out our time, complexity of this algorithm is Rouda in, so the time complexity of this algorithm is of rober in and the space complexity is constant because you're not using any additional Spetz.


@@@
1
00:00:00,750 --> 00:00:15,830
Hey, what's up, guys? Welcome back to this video in this video. You're going to see how to find out the complexity of an algorithms, for example, ever given this algorithm to find out the complexity of this algorithm.

2
00:00:16,140 --> 00:00:27,770
Tom, complexity and complexity. First, we break down the iteration of this love for first iteration. I go to one, then for a second iteration. I got to do the deeper one.

3
00:00:28,350 --> 00:00:45,270
Then for third duration, I got to report three, the Prickett iteration, I got to two to the power key because we are multiplying the value of AI by two in its iteration inside.

4
00:00:45,300 --> 00:00:57,750
Here we have a statement, this statement which takes constant time, complexity and how we can find it. The time, complexity of this problem here we see for cat iteration, I go straight through to the power K.

5
00:00:58,560 --> 00:01:10,650
If we find is greater than or equal to N, then this love will stop executing. So here we appointed EcoStar two to the Power K Workingmen's Kate iteration.

6
00:01:10,650 --> 00:01:28,590
That means the last iteration of this love for the loop or the lowest of its execution. So we can say to the debark greater than equal to N and here if we take log two on the both side, then we get Cagle's to log two in.

7
00:01:28,800 --> 00:01:44,100
And this is the time complexity of this algorithm. So the time, complexity of the algorithm is of lock to end and the space complexity is constant because we're not using any additional speech or we have understood how to find out the time, complexity of this algorithm.

8
00:01:44,430 --> 00:01:57,990
Now, let's take another example. For example, if you are given this algorithm, we're starting AI from in until I is greater than it goes to one and inconsideration or dividing AI by two.

9
00:01:58,350 --> 00:02:16,500
Here we break down the iteration of this for love for first iteration. I got to endeavour to do the Bajirao we can assume. OK, so for first iteration I got to in the first, second iteration I got to endeavour to the one for third iteration.

10
00:02:16,980 --> 00:02:36,490
I got to endeavour to the departure here, not showing in divided to the Bajirao for catheterisation. It takes endeavour to do the work. Now if we see one is greater than I whenever this form of find out one is greater than I, then it was stuff its execution.

11
00:02:36,930 --> 00:02:52,950
Here we have find it equals two in divided to do the power care for iteration. So here again riblets. I would endeavour to board came and if we saw this expression then we get Greg Sheridan Locke to end.

12
00:02:53,130 --> 00:03:03,950
So this is our time complexity of this algorithm. So the timing of this algorithm is awful. OK, to end and the space complexity is constant because we're not using an additional spit.

13
00:03:04,560 --> 00:03:23,190
Now, let's take another example. We have I got to Gerardine, items I less than in the eye. Plus Blatche here. We have the condition I times I listen in here, if we adiam items, I got to n then this Lupul stuff.

14
00:03:23,790 --> 00:03:46,170
OK, for the last iteration items I got in here, items I got to Wickwire, so I was going to go to N so I got to root for N so I got to root in. So the time complexity of this algorithm is of rober in and the space complexity is bigger up one because you're not using any original speech.

15
00:03:46,740 --> 00:04:04,010
We're just using some variables. Now let's take another example. For example, let's say we're giving this algorithm first year for AI. You go to less than anyplace, Blatche, we have here for the cost of less than in the blood splatter.

16
00:04:04,460 --> 00:04:14,830
We know that this algorithm takes big in time complexity and this algorithm takes big of interm complexity from the previous explanation. What is the time complexity of this algorithm?

17
00:04:15,180 --> 00:04:30,370
Again, this algorithm uses this to follow. If we add the time when we step to fall off, we get big to for a time complexity, analyze it will reject or discard the constant partitas constant.

18
00:04:30,620 --> 00:04:42,590
So the time complexity of this algorithm is big enough and we're not considering the constant part. So the time complexity is big enough in the space, complexity is bigger point.

19
00:04:42,740 --> 00:04:55,630
Now let's take another example. We have aanestad for all of. For this, Wolf, we have your eye to enable us plans for this wall of the to one day less than the cost of the times, too.

20
00:04:56,050 --> 00:05:12,070
So here we see where incrementing by one end here or incrementing by multiplying the value of the by two. From previous example, we saw that this algorithm will decs logarithmic time complexity and for these algorithms.

21
00:05:13,230 --> 00:05:26,990
Takes linear time, complexity, because here we're iterating from zero to minus one for each iteration of this love, this loop will takes longer than any time complexity for any iteration of this love.

22
00:05:27,330 --> 00:05:46,560
This will takes in log in time complexity. You're already seeing four in the iteration of this out of love. We're seeing four in iteration. OK, if this love iterate in times, then it will take as big of a log in time complexity.

23
00:05:46,800 --> 00:06:07,210
Some of the time complexity is in log in. So for one iteration of our Aluf in the Loop takes log in time complexity. This is simple math. OK. For any iteration of the role of the initiative, Will takes a log of.

24
00:06:08,950 --> 00:06:24,110
In logoff, in time complexity, so the time complexity of this algorithm is big enough in Logan and the space complexity is bigger up one because you're not using any additional speech, we've understood how to find it.


@@@
1
00:00:00,690 --> 00:00:26,490
Hey, what's up, guys? Welcome back to this video. In this video, we're going to talk about what is an arrest and why we need an area is a data structure that contains a group of elements, is identified by our index and areas toward such that the position of is HUMINT can be computed from it indexable by a mathematical formula.

2
00:00:27,030 --> 00:00:45,470
This is the formal definition of a gray area will store a group of inmates and we can exit any of the element in constant time using the index. Number three has some properties in regards to data of some type of area.

3
00:00:45,660 --> 00:01:00,060
Cannot store the data of different types of it all against the data of same type of area has contiguous memory, location. And we will talk about in details in this section of this course.

4
00:01:00,720 --> 00:01:16,530
Then the next property is the Arrow Index. Start with zero, then the next property is the site of every need to be specified mandatorily and cannot be modified so that our message is constant.

5
00:01:16,530 --> 00:01:32,880
We can't change the site of error after a declaration. This is an example of error. We have here eight elements and here we have index number. Using the index number, we can exit any of the array element in constant time.

6
00:01:33,480 --> 00:01:46,780
The length of this error is eight and we see the index start from zero. The index of first element is zero. The index of second element is one, then two, then so on and so forth.

7
00:01:47,820 --> 00:01:59,910
Now you might ask why we need an error. Before answering your question, let me ask you a question. We want to store one million similar data types in computer memory.

8
00:02:00,150 --> 00:02:13,640
Then what do you do? How you store one million similar types in computer memory? You might say we will declare primitive data structures like integer, flawed, Boulin, etc..

9
00:02:14,340 --> 00:02:37,230
Now the problem erate how will you maintain such a huge list of variables? You have to do a lot of works. The solution to this problem is that we will declare an area of site 1000000, will store one million elements in an array and we can exit and of the element by index number in constant time.

10
00:02:37,530 --> 00:02:48,420
We don't have to maintain a huge list of variables. This is an example of an array and the length of this area is eight and we have index number from zero to seven.

11
00:02:48,630 --> 00:03:03,900
We can access any of the element in constant time using the index number. If we have an area of length, one million, we can exit any of the arrangement from that area using the index number in constant time.

12
00:03:05,010 --> 00:03:26,700
Now, let's take an example. Let's say we want to store one hundred integer from one to one hundred in computer memory. Then what do you do? You might tend to create one hundred variables to store the integer from one to one hundred, and that will takes a lot of work and that's not efficient.

13
00:03:27,360 --> 00:03:50,340
If we have to declare one hundred a variable, they need to maintain the list of variables and that will need a lot of works. In doing that, he can declare an area of land one hundred and you can assign the integer to the array and that will take less work and you can access any of the array limited by the index number.

14
00:03:50,580 --> 00:04:10,530
And that's super efficient. This is what we should use array instead of variables. This is an example of the array and the length of this array is one hundred one, two, three, four, five, six and door-To-Door then one hundred.

15
00:04:10,890 --> 00:04:21,510
We have index number from zero to ninety nine. We can access any of that element from this area using the index number. Here we are using the other dot.

16
00:04:22,230 --> 00:04:37,020
We can't show you that one hundred umid in this area for the display site anyway. We've understood what is an area and why we should use array. Thanks for watching this video.


@@@
1
00:00:00,720 --> 00:00:16,790
Hey, what's up, guys? Welcome back to this video. In this video, we're going to talk about different types of area. There are two types of array, one dimensional array and multidimensional array in this video.

2
00:00:17,400 --> 00:00:33,500
And in this course, we'll talk about two dimensional array will not talk about three, four or five dimensional array for most of the kids that we use, one dimensional array and two dimensional array as multidimensional array in this video.

3
00:00:33,510 --> 00:00:53,880
And in this course, we will talk about tutelary decision, an example of one dimensional array, and this is an example of to the array. Now let's talk about one dimensional array in details in one dimensional array is element is represented by a single subscript.

4
00:00:54,210 --> 00:01:09,870
The elements are stored in consecutive memory. Location will see how are elements stored in computer memory in the next video. An example of an array we have declared an area of land eight.

5
00:01:10,290 --> 00:01:25,800
The size of this area is eight. And here we have eight elements. These are all represented, something like this. We have index number from zero to seven and we have that element from one to eight if we see area one.

6
00:01:26,400 --> 00:01:49,560
And here in between this bracket, we have one. This is index number. So at index one, we have the element two. So it will return to if we say here array for then what we do in return instead on ABC and before then it will return five because it index four, we have the value five.

7
00:01:49,920 --> 00:02:04,050
If we see here every seven, then what it will return, it will return this value eight because at index seven we have the Value eight. We have understood the concept of one dimensional array.

8
00:02:04,200 --> 00:02:21,960
Now let's talk about two dimensional array in two dimensional array is element is represented by two subscript, a two dimensional array in buy in has imroth and in columns and contents in times in elements.

9
00:02:22,320 --> 00:02:38,490
And this is an example up to the array array. It has three rules and four columns and these are all represented. Something like this. This is row. We have three two and we have four column.

10
00:02:39,180 --> 00:02:58,740
We have index number of is row and column here. If we say area one two, one means here, one means the row index and two means the column index here at one, this is one and column two.

11
00:02:59,310 --> 00:03:13,740
So at one end, column two we have the value forty. So it will return forty if we say array two one at row two and add column one, we have the value three hundred.

12
00:03:14,010 --> 00:03:33,240
So it will return three hundred and it will say every two three. At row three. At column three we have the value 500. So it's written the value of five and this is two dimensional array and this is how we can accept any, every element in two dimensional array.

13
00:03:33,450 --> 00:03:44,610
Let's see it. We want to get that element to the new order. We have to do we have to say array to zero at Ruggiero at columns, you know, have the value to it.

14
00:03:44,620 --> 00:04:00,960
We want to get the value three from this two area. Then we will say original one. First, the index of Rolan, the index of columns. We have understood the concept of two dimensional array and one dimensional array.


@@@
1
00:00:00,750 --> 00:00:16,000
Hey, what's up, guys? Welcome back to this video in this video. We're going to talk about how area is stored in random access memory. First, we're going to talk about how one degree is taught in computer memory.

2
00:00:16,260 --> 00:00:29,280
Then we'll talk about how to Reira is stored in computer memory. Now, let's talk about one dimensional array. This is an example of a room the size of this area is eight.

3
00:00:29,280 --> 00:00:40,230
And we have here eight elements. This is the representation of this array. We have index number with the index number. We can access any of their element in constant time.

4
00:00:40,950 --> 00:00:55,290
Now, let's say this is our computer memory. I mean, this is our random access memory and we assume that this memory is empty. Now, how this area will be stored in computer memory.

5
00:00:55,890 --> 00:01:13,560
Computer memory is the collection of a block, OK? In its block, our element will be stored. The Arab element will be stored. The element first will be converted to binary, then the binary equivalent will be stored to a computer memory.

6
00:01:13,920 --> 00:01:35,700
For sake of understanding, we're going to store the decimal value. So you might say the agreement will be stored. Something like this one will be here to will be here, then four will be here, five here, then six here, seven, eight.

7
00:01:36,610 --> 00:01:50,130
We might assume the arrangement will be stored, something like this in the definition of array. We see that every element will be stored in consecutive memory location one after another.

8
00:01:51,300 --> 00:02:09,800
So the array element will not be stored something like this. It will be stored in country use manner one after another. The other element will be stored, something like this one, then two, then three, then four, five, six, seven, eight.

9
00:02:10,740 --> 00:02:27,560
We see that the arrangement is stored in consecutive memory locations, one after another, first block at the first block we have this well one. Then in the second block we have these two, then three, then four, five, six, seven, eight.

10
00:02:27,840 --> 00:02:39,660
We see that are stored in consecutive memory location one after another. This is how error is represented in computer memory. For the sake of understanding or just storing the integer value.

11
00:02:40,140 --> 00:02:50,610
Actually the element will be converted to binary equivalent and the binary equivalent will be stored in the computer memory in continuity, memory, location, something like this.

12
00:02:51,310 --> 00:03:00,750
We have understood how one dimensional array is stored in computer memory. Now let's talk about how two dimensional array is stored in computer memory.

13
00:03:01,590 --> 00:03:13,980
This is an example up to really three rows, three rows, two columns, and these are all represented. Something like this. You might assume the array will be stored, something like this.

14
00:03:13,980 --> 00:03:28,980
One, two, three, four, five, six. You might think the inner area will be stored in a security location, but not the whole area. That's not to say that the area will not be represented, something like this.

15
00:03:29,650 --> 00:03:45,400
This area will be stored in consecrated memory, location, first one, then two, then three, then four, then five and six will be represented. Something like this one will be stored here, then two, then three and four, then five and six will be stored.

16
00:03:45,400 --> 00:04:00,840
Something like this. This is how to Reira is stored in computer memory. This is the fundamental. We have understood the concept of how a restored in random access a memory.


@@@
1
00:00:00,660 --> 00:00:15,210
Hey, what's up, guys? Welcome back to this video. In this video, we're going to talk about how we can create one. Deery in the declaration statement will create a reference to an area then will instantiate in that institution.

2
00:00:15,210 --> 00:00:29,520
Freij will create an array then initialization in the initialization Freij. We will initialize values to that area. Now let's see if we can declare, how can instantiate and how can initialize each and every.

3
00:00:30,390 --> 00:00:41,230
First, let's talk about the declaration of an array for declaration Freij. First that at a time, then the bracket, the square bracket, then the name of the array.

4
00:00:41,730 --> 00:00:53,670
Something like this into this square bracket. Then the name of the array. In this case, the name of the there is no different. Instantiate the array in the instantiation.

5
00:00:53,790 --> 00:01:10,100
It will create a reference to ordinary new data types in the site. Something like this numskulls to new interfer here. We have created an array and we assigned that array to this variable nums and we will reference of this array here.

6
00:01:10,380 --> 00:01:22,440
Then we're going to initialize the array at Index zero room to insert Ormat index or insert to add index to. We're going to insert three and at and at index three we're going to insert four.

7
00:01:22,620 --> 00:01:35,640
We can declare, instantiate and initialize the array in one statement, something like this int square brackets in the name of the array equals through the colorists and the elements.

8
00:01:36,090 --> 00:01:44,490
These are will be represented something like this. One, two, three, four. And we have our index number one, two, three. This is how we can create one.

9
00:01:44,490 --> 00:01:56,070
Deery That iteration of an array will take constant time. The institution also will takes constant time and this all operations. The insertion operation all takes constant time.

10
00:01:56,490 --> 00:02:11,630
And if the length of the error is in, then all the insertion will take Spiga of in time complexity. And if we declare initialized and instantiate the array in one statement, it will takes bigger of one time complexity.


@@@
1
00:00:00,840 --> 00:00:11,180
He lots of guys will come back to this video. In this video, we're going to talk about how counter-revolutionary that you were given this array of Cidade.

2
00:00:11,550 --> 00:00:21,300
Here we have eight elements. This array will be represented, something like this. We have your index number with the index number, we can access any of the irrelevant in constant time.

3
00:00:22,200 --> 00:00:31,770
Now, let's see how we can traverse this element. Traversing means simply visiting this year given array. These are all represented, something like this.

4
00:00:31,770 --> 00:00:43,150
And then we have our follow for Ibram due to the land of the area minus one. And this is where index for this array, this love will iterate from zero to seven.

5
00:00:44,040 --> 00:00:54,290
That's why we have your length of the array, Meynet one. Then we're just printing the value of current element for first iteration, the one of it zero.

6
00:00:54,300 --> 00:01:17,640
So it will print one, the second iteration, the value of is one. It will print to the third iteration. The value of is two, it will print three. Then for the next iteration it will print four, five, six, seven and eight whenever we.

7
00:01:18,680 --> 00:01:34,150
Resort to this index, this loof will strive for the next generation, the value of I will be evaluated eight and that's out of this area boundary. So we're done with this array and this is our kerosine result.

8
00:01:34,160 --> 00:01:44,810
One, two, three, four, five, six, seven, eight. This is what we can traverse an array. Is it on the array? It's very simple by using it for all of what we can towards the array.

9
00:01:45,110 --> 00:02:04,240
Now let's talk about the time complexity for the error declaration. It will takes constant time. Complexity for this fall off schedule takes because in time complexity where it is the length of the given error and then we are just printing the element and the print operation all takes big of one time complexity.

10
00:02:04,250 --> 00:02:16,810
So the average time complexity is big, often for added everything. So for every traversing the cost we go off in. And this is time complexity. Thanks for watching this video.


@@@
1
00:00:00,570 --> 00:00:12,450
A lot of guys in this video, we're going to see how we can get insert and update operations in an area that were given this area one, two, three, four, five, six, seven, eight.

2
00:00:12,480 --> 00:00:23,170
These are all represented, something like this. Now, first, let's talk about operations. This is a pseudocode. Forget operations that are given this area.

3
00:00:24,270 --> 00:00:36,330
We have your element from one to eight. We have an index number. If we call this function gate with area and the index number, then it will return one because it index number.

4
00:00:36,330 --> 00:00:54,750
We have the element one at index five, we have the element six and index seven, the element eight. And using this region, we're just returning the element to the given index set index seven of the Element eight, and it is called target operations.

5
00:00:55,020 --> 00:01:09,270
It's very simple. We have this function, then have this written statement. We're passing this area to this function and the index number and then this function will return the value at the given index.

6
00:01:09,930 --> 00:01:22,800
This function takes constant time, complexity, and this written statement takes constant time, complexity as well. And the realtime complexity for this function gate is bego of one that means constant time complexity.

7
00:01:24,480 --> 00:01:35,280
Now let's talk about insert operation. Let's here we are given this material. We have to fill this area and this is our pseudocode to fill this array first.

8
00:01:35,280 --> 00:01:46,290
If we call this function, insert a zero one. And your first argument is the array. The second argument is the index number. And the third element is the value we have to insert.

9
00:01:46,890 --> 00:02:04,160
So we will insert onto the first index. Then if we say insert every one to an index, one to insert two. Then we see a three to three that indicates to we have to insert three, then at index three to insert four.

10
00:02:05,360 --> 00:02:17,540
So we have filled this array with this function call and this operation will take because of one that means constant time, complexity. And this operation will decrease because of one.

11
00:02:17,930 --> 00:02:28,140
That means constant time, complexity. This is all about insert operation. Now, let's talk about OPNET operation. This is a surrogate for ABC operations.

12
00:02:28,160 --> 00:02:41,000
It's super simple that you were given this area. We want to update the value in this array. It was the update Original five at Indexed. You know, we're going to at index zero, we're going to replace that element with five.

13
00:02:41,180 --> 00:02:57,020
So let's replace one with five. Then we say update air one six at index one, we're going to replace two with six. Then we say, update our two, seven, eight, two, we're going to replace three with seven.

14
00:02:58,630 --> 00:03:15,250
Again, if we say a bit, our trade and industry, we're going to replace four with eight and this is called ablate operations in an area this average operational takes constant time, complexity, and this operation will also take constant time, complexity.

15
00:03:15,310 --> 00:03:26,050
This is all about Abdelal operations. We can update any and limited by the index number, something like this array index equals to value. Now we're going to talk about the lead.

16
00:03:26,090 --> 00:03:41,360
Operation Lead operation is super simple. Initially, when we construct an array in Java, by default we have the element is zero. If we replace the element with a zero.

17
00:03:41,890 --> 00:03:53,010
That means we deleted the element. Let's see if we can make the operation that that's similar to ablate operations. We're just replacing the element with zero.

18
00:03:53,010 --> 00:04:06,750
If we say delete Arimidex zero, so it will just replace one with zero initially when we declare an error. We have all the element is zero. If we say again, array one delete.

19
00:04:06,970 --> 00:04:21,790
So we'll delete, add two. So replaced with zero. If we said it are two then we will replace three with zero. Replacing in Eretria will replace four with zero.

20
00:04:22,360 --> 00:04:34,570
And this is called delete operations in an area. And this operation will decrease constant time complexity. And this is all about get insert update and delete operation in an array.


@@@
1
00:00:00,450 --> 00:00:12,210
A lot of guys will come back to this video in this video, we're going to talk about searching algorithms, binary search and linear searches. First, we'll see how long your search works.

2
00:00:12,510 --> 00:00:34,010
Then we'll see how one resource works. Then we'll explain that a random complexity of binary search look to end and that we will see in the last part of this video for linear search will scan the array from left to right, one by one, and that will take off in time complexity.

3
00:00:34,230 --> 00:00:46,940
And that super simple will not show you the code for linear search. We'll just show you how linear search works. We can do that by using a simple fall of four from zero to the length of the array.

4
00:00:47,970 --> 00:01:05,650
And then we can check if we found any of the element at the index is masked, then will return that index. And for binary service you'll see every bit of information you need to understand binary search and within the boundaries, resource only for sorted array.

5
00:01:06,000 --> 00:01:16,790
We can do a linear search for any type of array and in this video, all focused on binary search and how binary search works and everything. You need to understand binary search algorithms.

6
00:01:17,220 --> 00:01:33,480
Also, we'll talk about linear search algorithms. Now let's talk about linear search. Then we'll talk about a binary search. For example, if you live in this area and a target, all we have to find out the index of the target element.

7
00:01:34,140 --> 00:01:46,920
If the target element does not exist in the area, we should return minus one. If this target exists in the array, we should return the index of that element.

8
00:01:47,370 --> 00:01:57,780
You might assume that the given array always is sorted. We can solve this problem using linear search pretty easily by checking the error element one by one.

9
00:01:58,080 --> 00:02:09,450
Let's see how this actually works. First, we'll check the first element. One does one equals two, three, four, no. So let's go to the next element. That's three Kolstad Takfir.

10
00:02:09,450 --> 00:02:20,550
No, let's go to the next element. That's five is equal to 34. No, let's go to the next element. Does ages equals photographer. No, let's go to the next element.

11
00:02:21,270 --> 00:02:37,710
12 is not a constant. However, let's go to the next element. Now we see that the current element is equal to target. So in this case, only return the index five and this is called linear source algorithm.

12
00:02:38,220 --> 00:02:54,300
Linear source all takes up in time complexity because first guess we have to is element one. So the time complexity is Bekoff in linear source is not an efficient algorithm to source an element in an array.

13
00:02:54,750 --> 00:03:11,130
Now let's talk about a binary search and how this works. OK, now we're going to talk about binary deserves. Our target is thirty four. Now we have to service this target in this error in logarithmic time complexity.

14
00:03:11,130 --> 00:03:21,270
Don't worry about logarithmic time complexity. We'll talk about in details. First, what we're going to do. We're going to find the middle element in this area.

15
00:03:21,270 --> 00:03:33,390
The middle element is eight. Now, our goal is to take those eight equals to target. No, now we're going to take those eight less than Target. Yes, it is.

16
00:03:33,660 --> 00:03:46,580
If the middle is less then target, then we'll discard all the element on the left, including the middle element. All right, so we discarded the left portion.

17
00:03:46,810 --> 00:04:00,960
Now let's find out middle in this area, the Middle East, 34, and we see that we found that target in this area. In this case, you have to return that in the search of this elementary school.

18
00:04:01,330 --> 00:04:11,860
All right. And this is how actually works. Don't worry. We'll see how we can find the middle element. We are given this area and target. It goes to 34.

19
00:04:12,010 --> 00:04:33,540
If we divide this area by element, then this will be like this. Then if we divide this array using this middle elementary, then we get like this. OK, then if we divide this sabari by this middle element, then you get like this.

20
00:04:33,870 --> 00:04:47,400
OK, now we see that this is a binary search street. Now how this actually works. Now, let me ask you a question. How do you search the target value in a binary circuitry?

21
00:04:48,000 --> 00:05:01,100
First, you check the value of node and the target value. If the target value is greater than the value of note, that will go to the that will go to the right subtree.

22
00:05:01,200 --> 00:05:12,660
If we see the target is less than the value of node, then will move to the left subtree and we keep doing that process until we found our target value.

23
00:05:12,720 --> 00:05:24,130
OK, now let's first trilled to this binary circuitry. First, we're going to take eight and 12 does 12 is greater than eight. Yes, it is. So let's go to the right subtree.

24
00:05:24,360 --> 00:05:38,760
Now let's check its target. And it's a lot harder for you to target is less than 34. So it will go to the left subtree. And we found this element you see here we found 12 by Three-step.

25
00:05:39,000 --> 00:05:54,020
OK, one step. Two step, two step. We don't have to visit all elements who are just visiting three elements. OK, now let's see how we can find a target of five in the mining industry.

26
00:05:54,910 --> 00:06:06,090
We have your target. You got to fight first. We're going to check it and find the target is greater than eight. No. So let's go to the left subtree. That's five is greater than three.

27
00:06:06,130 --> 00:06:18,610
Yes, it is. So let's go to the right subtree. And we found this yellow five and this is how we can service it. Target in a binary Sastry binary search algorithm works exactly like this.

28
00:06:18,640 --> 00:06:32,980
Now let's see how we can find the index of our target element in an array. We're going to find out the index for Target 34. OK, first we're going to declare two point a left and right left one to the first element and right point to the last element.

29
00:06:33,190 --> 00:06:44,880
Then we're going to find the middle and this is our middle. How we can find middle, we can find the middle by doing a simple formula plus. Right. Divide it to zero six divided to three.

30
00:06:44,890 --> 00:06:53,950
So this is our middle. Now we're going to check that the target is greater than this middle. Yes, it is. So it will move the left pointer to middle class one.

31
00:06:54,250 --> 00:07:06,730
So little pointer will point to this element 12. Now, our goal is to find the middle for this area. OK, so four plus six divided to five. So three, four is our middle.

32
00:07:07,270 --> 00:07:27,570
Now we're going to take this target equal to 34. Yes, it is. So it will return the index of this target. So we'll return the index of this element that is five, and this is how we can as an element in an array using binary search and how many staff we have done.

33
00:07:27,670 --> 00:07:40,590
So we found 34 by Tuesday, just by Tuesday. We don't have to traverse the entire array to find a value. We found, however, by doing to save this model and this model.

34
00:07:40,890 --> 00:07:54,270
And this is how we can serve as an element in an array using binary search. Now, let me show you how this actually works using pseudocode. First, we're going to declare a function that takes an array and a target as input.

35
00:07:54,480 --> 00:08:05,760
The sorted array manager source doesn't work for unsorted array. The array must be sorted. Then we're going to get to point a left and right left point to the first element.

36
00:08:05,770 --> 00:08:17,250
Right point to the last element. We're going to value until late is less than or equal to. Right then we're going to calculate mid lipless plus redivided two.

37
00:08:17,580 --> 00:08:39,380
Then we're going to take in the middle element is our target then will return index of the middle element. If not, we'll check if the target is greater than the middle and then we'll move a little pointer to the next up middle, if not, then we'll move the right pointer to the left upper middle at the end.

38
00:08:39,380 --> 00:08:54,150
If we haven't found this target in the area will return minus one. Now, let's see how this works or given this array and target fellow 34, we have to find the index of this value target for in this area.

39
00:08:54,740 --> 00:09:05,840
First, we're going to have to point to left and right. Then we're going to find the middle and eight in the middle. Then we're going to check. Does the middle element equal to our target element?

40
00:09:06,020 --> 00:09:16,550
No, it is not equal to Tarifa. Then we're going to check if target is greater than the middle element that will move left to the next upper middle. And we see that 34 is greater than eight.

41
00:09:16,550 --> 00:09:33,030
So it will move left to the next of middle. Then we're going to calculate middle for this. Summary, OK, and the middle, in this case, 34, for now, we see that 34 is equal to the target, so it will return middle.

42
00:09:33,210 --> 00:09:48,810
So it will return the index five if we see a target value does not adjust in this area, will just return minus one. If the target is does not exist in the given area, then this condition will never be, if alleged, true.

43
00:09:49,050 --> 00:10:02,660
For this input, it will return five. Five is the index of the 134, that is our target as well. Now let's see the time complexity for this problem for first iteration, the length of the areas in.

44
00:10:03,880 --> 00:10:27,700
It is the human error and we can do this like this in the way to the first consideration, the land of the free will be in to because it is time for dividing the area by two hops for third iteration and divided for the four fourth iteration and divided eight who are dividing that area by two hops is time for Kett iteration.

45
00:10:28,090 --> 00:10:44,490
The land will be invited to the Park Aftercare Division. The length of the area will be one. In that kit, the left pointer, right and middle point will point to the same element, then length of array for consideration will be one.

46
00:10:44,670 --> 00:10:57,480
Then if you do this math that will get this time complexity off, look to end. Right, guys? So this all takes a lot to End-Time complexity and constant expense.


@@@
1
00:00:00,780 --> 00:00:20,120
A lot of guys will come back to this video in this video, we're going to talk about how we can create to the area in order to create a reference group to declare in the Declaration of Rage, we're going to create a reference to an array then in the instantiation, which will create an array, then will initialised.

2
00:00:20,700 --> 00:00:35,620
Then in the initialization, Frade will assign values to that area. In the declaration, Freij will declare an array, something like this, the type in the square bracket to square bracket here, then the acronym, since this is two dimensional array.

3
00:00:36,630 --> 00:00:50,500
This is an example of our declaration in square brackets, square bracket. Then the name of the array in the instantiation fridge will create an array and will assign that array to the reference of our declaration.

4
00:00:51,390 --> 00:01:08,210
And this is the example numskulls to new entry to trace number of row and to its number up column. And this is the example of three rows and two columns to the array to the arrays also called Matrix.

5
00:01:08,580 --> 00:01:28,650
Then the initialization Freij will assign the value to the to the array. Something like this we have at index zero at index zero and zero, we have one at rounding zero column index one, we have two at row index one column we have three.

6
00:01:29,190 --> 00:01:45,210
The Net Index on column index only available for A2 index two following the we have five at four, index two and column index one. We have six or we can declare, instantiate and initialize using one statement, something like this.

7
00:01:45,720 --> 00:02:05,040
And this is similar to this esteve this is shortened. This is how we can create a theory. Lets the time complexity. This operation takes constant time for the duration of array then for creating the original text also constraint time.

8
00:02:05,850 --> 00:02:20,220
Then we're going to instantiate of the array, then we're initializing the array here. Its operation will take Spiga of one time complexity. That means it will take constant time, complexity.

9
00:02:20,670 --> 00:02:43,990
And here we see we have six steps. We take their six operations, we have six operations. So that overall time complexity is because of a times call. Here we see three times three calls to six and here we have six operations or we declare, instantiate and initialize the area in one statement.

10
00:02:43,990 --> 00:02:55,650
Then it takes constant time, complexity. What we have understood the concept, how we can create to the array. Thanks for watching this video. Also in the next video.


@@@
1
00:00:00,650 --> 00:00:12,580
A lot of guys will come back to this video in this video or go into made get insert and update operations into the area that will go in this area. This will be represented, something like this.

2
00:00:12,590 --> 00:00:35,600
We have three rows and two columns. Now, let's talk about the operation. This is the code for operation. This function takes away and ruined X and column index, and it will return whatever value we have at the ruined X and column index that you were given this array EBC array zero one.

3
00:00:35,600 --> 00:00:50,510
This array means this array and it ruined X zero and it indicated that we have the value to so it's returned to thin at one end column index one we have the value four.

4
00:00:50,510 --> 00:01:04,750
So it will return value for the Adirondacks two and column index zero. It will return. The value of this function will take speak of one time complexity and this operation also takes constant time complexity.

5
00:01:04,850 --> 00:01:16,880
So the overall time complexity is bigger of one. Now let's talk about insert operation. This is our function insert it takes a reading the index, then column index.

6
00:01:16,880 --> 00:01:29,120
And evalu that we have to insert, then we have disarrayed and ruin this column indexical. Well, let's say we're given this empty. To reiterate, we have to fill this array with some value.

7
00:01:29,570 --> 00:01:44,880
If we say insert original at rounding zero zero, insert one zero, insert one being at index zero column, index UNSNAPPED, insert two, then add or index one column index zero.

8
00:01:44,880 --> 00:02:01,550
We have to insert a three, then ADIRU index on that column. Index one we have to insert for then at index to at index zero to insert five, then at index two and column index one, we have to insert six.

9
00:02:01,820 --> 00:02:12,560
And this is how we can insert element two to rearrange this into the operational text of one time complexity. And this operation also takes picture of one time complexity.

10
00:02:12,920 --> 00:02:30,140
And if we add all the operations, then it will take Spiga of Rule Times column time complexity since we have here functions. So the term complexity for these functions is bigger of order because it takes because it's doing one operation at a time, no matter what.

11
00:02:30,140 --> 00:02:42,230
If we use the loop to insert the value, then it will takes big of M times in time complexity where it means the number of rows and it is the number of columns.

12
00:02:42,440 --> 00:03:08,570
And let's talk about Abduh operation this year. Around this year were called Visual CustomMade Ablate Operation ABC Ablate 00 at Rentech. We're going to update the value with seven then if we say Aberdare one eight at indexed one column index one, we're going to replace these two with eight to eight.

13
00:03:08,990 --> 00:03:26,050
If we say to the row at Riddick's two and we're going to update it nine to that RBD five with nine if we say one one ten at Riddick's on and column index or learn to update within two years, we will have to develop with ten.

14
00:03:26,840 --> 00:03:35,600
And this is how we can meet ablate operations and the operations will take up on time complexity. And this operation also takes Bego of all time complexity.

15
00:03:35,900 --> 00:03:47,270
These are constant. This takes constant time, complexity we can update and element to to the area. All right, guys, thanks for watching this video. I'll see you in the next video.


@@@
1
00:00:00,720 --> 00:00:10,230
A lot of guys will come back to this video in this video. Going to see how we can get to the area that you are given this array of three rows and two columns.

2
00:00:10,560 --> 00:00:20,340
And these are all represented, something like this. One, two, three, four, five, six. We have the column index and we have their index. And let's see if we can traverse this area.

3
00:00:22,220 --> 00:00:34,700
The to the code to traverse the array dysfunction takes the array, then we have the rules road calls to arms length and it will return the number of roads we have been columns.

4
00:00:35,570 --> 00:00:48,070
It returned the length of the column. Then we're running a loop for I from jail to room minus one. Minus one. Here we have three rows, so length of rows is three.

5
00:00:48,470 --> 00:01:03,350
So three minus one is two. So we'll iterate from zero to two. Then we have this in Aluf in this in a loop. We have four year from zero to Haltzman. Let's also iterate from zero to one and then are just printing the current element.

6
00:01:04,580 --> 00:01:15,500
Here we have the iteration, we break it down the iteration. I go to zero zero two zero four. I goes to record. It will print one, then four. I go to geological two to one.

7
00:01:15,500 --> 00:01:31,890
It will print two. Then I go to one zip code to generate will print three. Then Eggleston's equals to one, it will print for your eyes the index of Arrow, and it is the index of column.

8
00:01:33,580 --> 00:01:48,130
So I want to meet the index operator, so is one that is there is one end. The calls to one means the index of color and there is one. So one one here we see four, then four.

9
00:01:48,130 --> 00:02:00,460
I go to do and they to do that we have five, then four equal to the close to one. We have this element six and the silver against towers to area. This is super simple.

10
00:02:01,790 --> 00:02:10,210
We understood how we can terrorists to rewrite this code. I that has the source code to this video. We can check it out now. Let's see the time complexity.

11
00:02:11,650 --> 00:02:24,190
Now we have to calculate the time complexity for this function. This operation all takes constant time. This operation will take constant time and this loof will take a bit of time.

12
00:02:24,640 --> 00:02:36,820
And this will takes because of all time complexity. And this operation will takes Bego off one that means constant time complexity. Four one iterations of this love.

13
00:02:37,270 --> 00:02:52,830
This loop will iterate. Called times, the number of times, if we have caller records, two, three, four is iteration of this love, this loop will iterate three times.

14
00:02:54,030 --> 00:03:14,250
So simply we can do a math here for complexity analysis. Let's assume that we go to three and quality calls, two to four iterations of this. Aluf, the Innaloo will execute two times since the columns is two, then four.

15
00:03:15,180 --> 00:03:40,200
Three iterations of this out of love that in a love execute six times simple, you can see if this love will execute once the initial love will execute column times so we can see or see or if the our love is executed at times when our is unknown, then the initiative will be executed.

16
00:03:40,560 --> 00:03:57,320
Three times are right. So we can see the time. Complexity is bigger of columns, times to rule or rule times columns. So the time complexity for this algorithm is because of Rule Times column.

17
00:03:57,920 --> 00:04:11,410
We have understood the time, complexity, analyze it and you just print the element. It will not cost any extra speed. So it all takes constant space complexity.


@@@
1
00:00:00,660 --> 00:00:15,320
In this video, we're going to solve a one degree problem, move zeros, given an numbers, right, a function to move all the jurors to the end of it while maintaining the order of that non-zero element to solve this problem in pledge.

2
00:00:15,330 --> 00:00:26,570
We can't use any extra space even given this area. We appreciate all the zero to the right hand by maintaining the relative orders of non non zero elements.

3
00:00:27,120 --> 00:00:39,480
So I really believe in something like this. Here we have the element and we have shifted and shifted to the right. And if you're given this input, then what?

4
00:00:39,540 --> 00:00:56,030
We should return, right? So first we have one, then we have three, then we have 12, then dangerous. OK, we should return this error how we can solve this problem.

5
00:00:56,400 --> 00:01:13,470
Also, we have to solve this problem in bigger of in time complexity. OK, let's see how I think about this problem. If you given this particular error then we'll start searching.

6
00:01:13,800 --> 00:01:29,120
The non-zero element here is non-zero element one. So it will replace this element at zero index. So we have a dual index value zero. So we're going to replace it with the value one.

7
00:01:29,490 --> 00:01:41,910
OK, then we see we have Dira, then I see non-zero element. So then we're going to reflect the element at index one. OK, so we're going to replace this one with three.

8
00:01:42,920 --> 00:02:12,330
Right then we see twelve is also non-zero element. So we're going to reflect this with twelve. Then we see reflected that to the element, then we're going to just replace the treatment with Jairus, OK, and this is our modified error rate and this is how we're going to solve this problem.

9
00:02:12,720 --> 00:02:26,990
Now, let's see pseudocode. First, I'm going to declare a function move gyrus that takes an array nums for sake of understanding. Let's assume this is our given array.

10
00:02:28,050 --> 00:02:44,160
Then we have a variable currently called to zero. It points to the first unit in our area right through to point right over here. Then we're going to run it live for eye from zero to Len No.

11
00:02:44,180 --> 00:02:58,410
Spinetta one. Then we're going to check if the current element is equal to zero for first duration of this loop, we see the element is zero. So this condition is not much.

12
00:02:59,190 --> 00:03:14,520
Then for next iteration we have one. Right? So this condition match, then what we're going to do, we're going to just change this dero to one. OK, so let's play this with one.

13
00:03:15,740 --> 00:03:33,630
Alright then we're going to change current to this element right over here for next iteration. We have do so this condition is false. Then for next iteration we have three right to this condition is match.

14
00:03:34,080 --> 00:03:44,310
Then we're going to replace this one with these three, then we're going to change the current to this element or at current two point right over here.

15
00:03:45,420 --> 00:04:03,240
Then we have the next 12. So it makes this statement, then it reflects this with twelve. OK, so we're done with this love. Now let's fill this element with injuries.

16
00:04:04,080 --> 00:04:23,280
For that, we have another move here for EI from current to lend manage on. OK then nums Eichhorst to gyro. So we do replace this element with zero and also it will replace this element with zero.

17
00:04:24,390 --> 00:04:48,270
Right at the end we have this modified array and that is our answer. Right. This is our solution to this problem. The solution will take off in time. Complexity or end is the length of the given array and it also takes constant space complexity of this concept.


@@@
1
00:00:00,600 --> 00:00:11,100
Hey, what's up, guys? Welcome back to this video in this video are going to solve a very interesting problem, remove duplicates from sorted. This is one dimensional array problem.

2
00:00:12,480 --> 00:00:26,610
Even a sorted array nums remove the duplicates in place says that is ilmenite appears only once and return the new. The problem statement a bit of confusing.

3
00:00:27,030 --> 00:00:48,630
For example, if you are given this array, what are you to return? You have to return five because in this area we have to five distinct element and shift all the distinct element and we should have all the string element from left to right.

4
00:00:49,260 --> 00:01:08,610
No matter how much a distinct element we have in the array in this area, we have five distinct elements one, two, three, four, five. And the five distinct element we should have in the light of this array and outside of this area is eight.

5
00:01:08,610 --> 00:01:20,400
But but the sight of the distinct element in this area is five. From index zero to four, we have your five element. There is no repeating element. We have to solve this problem in split.

6
00:01:20,580 --> 00:01:36,270
We can't use any extra switch. And we know that the array side is fixed. We can't change the area side. So we have to change the value in this area in flat on the left with the distinct element.

7
00:01:36,600 --> 00:01:53,170
We don't have to worry about whatever element we have on the right side. We have to clear the distinct element on the left from left. OK, if you're given this array, we have to modify this array, something like this, and iterating the length of the array for the distinct element.

8
00:01:53,220 --> 00:02:01,720
Now, what we have understood the problem. Now let's see how we can solve this problem. Right. Let's say you were given this array to solve this problem organdy.

9
00:02:01,740 --> 00:02:11,490
It was two pointer. I pointer will point to the first element and the the pointer will point to the second element initially. Now, what are we going to do?

10
00:02:11,500 --> 00:02:21,660
We're going to check the value of this two pointer. I pointed pointing to this element one and you pointed, pointing to this element one and the value are the same, the value, the same will move.

11
00:02:21,840 --> 00:02:31,530
They pointed to the next element. So let's move to the next element. In this case, we see that the value where I point the it is pointing out not the same.

12
00:02:31,530 --> 00:02:45,990
If we found the value are not the same, then we'll move it to the next element and will replace the value of a pointer with the value of the pointer. So it will replace one with two.

13
00:02:45,990 --> 00:02:54,000
So let's replace one with two. Then in the next iterations we're going to move the they pointed to the next element, so let's move to the next treatment.

14
00:02:54,000 --> 00:03:03,300
And we see that the value of the pointer and the same. So let's move on to the next filament and let's replace develop a pointer with the pointer. We develop the pointer.

15
00:03:03,300 --> 00:03:15,780
So let's replace to it three. And let's move to the next element now, we see that the value and appointed are the same. So let's move to the next element that is Porfiry and you are not the same.

16
00:03:15,790 --> 00:03:26,830
So let's move to the next element and let's replace the value of appointer. We develop the pointer, so let's replace this value with four and let's move to the next element.

17
00:03:26,830 --> 00:03:37,540
And that is five. Five and four are not the same. So let's move on to the next element and let's replace the value of this element three with five and let's move it to the next element.

18
00:03:37,810 --> 00:03:45,960
And we see the value of five and five at the same. So nothing need to be done here. Let's move to the next and this out of our boundary. So we're done now.

19
00:03:45,970 --> 00:04:00,160
We see that our load part is sorted and on the left, but we have no duplicates, no reputations. And the length of this is for simplicity plus one, and that will be the length of the array on the left.

20
00:04:00,520 --> 00:04:15,910
OK, so the length of this array is five from index zero to four, and we have to motivate a given area, something like this, and we have to return the new length of this SOUTHBURY and we have no distinct element.

21
00:04:16,210 --> 00:04:24,910
This is how we can solve this problem. Now let's see how we can implement this solution using pseudocode. Right. This is our pseudocode to solve this problem.

22
00:04:24,910 --> 00:04:35,020
First of this function, remove, duplicate. It takes the uras input. Do a checking. If the lender is zero, then will return zero then or initializing I pointer.

23
00:04:35,020 --> 00:04:50,290
I will point to the first element, then another pointer inside this falloff. So they will point to this element one and then we'll iterate from this element to the very end using this follow through, taking the value and they are not the same we see are.

24
00:04:50,560 --> 00:05:00,580
So let's move to the next element. So they will point to this element and we see that one and three are not the same. So let's move on to the next and let's replace the value of.

25
00:05:00,760 --> 00:05:10,870
So let's replace the value of this element with three for the next iteration. Let's move to the next element that will point to the element three right over here.

26
00:05:11,410 --> 00:05:20,410
So Jasen are pointing to this element three and we see three and three are the same. So let's move to the next element again. And we see three and five on the same.

27
00:05:20,410 --> 00:05:31,690
So let's move it to the next element. I will point here and we're going to replace the value of it with five. So let's replace this three with five. In the next iteration.

28
00:05:31,810 --> 00:05:48,070
We're going to move to the next element. Let's move to the next on the next. We have new element. We're out of every boundary. And this wall of stuff here, since you're out of the area boundary here, we see we have no reputations of ilmenite and the length is three.

29
00:05:48,280 --> 00:06:02,230
So the index of is two. So two plus one is three. So this function will return three for this given area. And this is how we can solve this problem, even at understanding all highly encourage you to go through your own examples, then it will make sense.

30
00:06:02,650 --> 00:06:14,770
This is my solution to this problem. The solution will take off in time. Complexity or end is the length of the given area because whatever the array from left to right once and the solution will takes constant space complexity.

31
00:06:14,770 --> 00:06:30,400
Since we're modifying the original flat, we're not allocating any extra space to solve this problem. So that time complexity is bigger in our order of in and the space complexity is and the space complexity is order of one.

32
00:06:30,670 --> 00:06:40,750
That means the solution takes constant space complexity. We have understood this very explanation. If any question is additional, let us know. Thanks for watching this video.


@@@
1
00:00:00,720 --> 00:00:18,970
Welcome back to this video now we're going to solve a very popular coding interview question, rotate image. Here's the problem statement. You given an invite in to The Matrix representing an image, rotate the image by 90 degrees clockwise.

2
00:00:19,680 --> 00:00:37,360
But the constraint to this problem is that we have to rotate the images in pledge, which means we have to modify the input to the Matrix directly. We cannot allocate another to the Matrix to do the rotation.

3
00:00:38,130 --> 00:01:00,490
All right. And this is the problem statement and this is the constraint to this problem. If you are given this particular metrics as input, then we have to rotate this metrics by 90 degree clock, which so this first column will be our first row in a row, rotated metrics.

4
00:01:01,480 --> 00:01:16,700
The second column will be our second row. This third column will be our third row and this will be like this. OK, so this column is our first row. This column is our second row.

5
00:01:16,980 --> 00:01:35,040
And this column is our Stargirl. OK, if you are given four by four or Matrix like this, you rotate this Matrix coocoo eight by 90 degree. Then this first column will be our first throw in the rotated matrix.

6
00:01:36,000 --> 00:01:53,000
The second column will be our second row. This third column will be our third row and this fourth column will be our fourth row. So if we rotate this matrix by 90 degree clockwise, then we will see this matrix.

7
00:01:53,720 --> 00:02:08,080
So you see the seizure first through the siege, our second row, the siege, our third row and the siege. Our fourth row. OK, now how we can solve this problem.

8
00:02:08,560 --> 00:02:21,190
All right, let's suppose that you were given this array as input. First, what we're going to do is that we're going to flip this matrix at the second diagonal.

9
00:02:21,220 --> 00:02:38,400
This is our second diagonal. If we flip this matrix at the second diagonal, then this to be changed. So four will go here and it to go here. Then these two values will be changed.

10
00:02:38,920 --> 00:02:54,820
Nine will go here and two will go here. Then finally, two and six. OK, so six will go here, two will go here. All right. After flipping this matrix at second, diagonal will get this matrix.

11
00:02:55,090 --> 00:03:08,440
Does this matrix ninety degree rotated clockwise. No. So this matrix still not rotated. How you can rotate it actually. OK, in order to rotate it we have to do one more operations in this matrix.

12
00:03:08,650 --> 00:03:29,770
We have to flip this matrix horizontally. And this is the middle right. So we have to flip this matrix at this middle horizontally. So this to value will be exercised in between then this to render will be extended in between and the struggle at three and one will be it just in between.

13
00:03:30,100 --> 00:03:50,620
So here we go. Here we go here. Four will go here, six to go here, one will go here and three will go here. OK, then we'll get this matrix and this is clockwise ninety degree rotated matrix that we have to return, OK, and we have to do this all Operation Inflate.

14
00:03:50,620 --> 00:04:02,770
We can't allocate another to the Matrix to solve this problem. All right. Basically, we're going to flip the matrix at second diagonal, then we're going to flip the matrix horizontally.

15
00:04:02,920 --> 00:04:13,750
So first we have to flip a second diagonally, then we have to flip horizontally. OK, if you're given by poor order matrix how you can rotate this matrix.

16
00:04:13,960 --> 00:04:22,870
So this is our second diagonal for this matrix, right? So we have to flip this matrix at this diagonal, then this to value will be actually in between.

17
00:04:23,380 --> 00:04:41,170
Then there's two value, two and two will be exchanged, then five and 16 will be exchanged. Then there's two, one and seven will be at just the nine and ten will be a chance in between then four and six will be exchanged in between.

18
00:04:41,380 --> 00:04:57,160
When we flip this matrix at diagonally, then we'll get this matrix. We see that this is not ninety degree clockwise rotating the matrix. In order to get the ninety degree clockwise rotating matrix, we have to flip this matrix horizontally.

19
00:04:57,160 --> 00:05:11,560
So this is the middle. If we flip this matrix, then this tool and this fourteen will be actualized, then six and three. All right, then eight and four, then nine and one.

20
00:05:11,830 --> 00:05:29,170
So it will all go here. Fourteen will go here, six will go here, three will go here, then eight and for the nine and the nine and one then you have to extend sixteen and fifteen, then seven and then ten and two.

21
00:05:29,290 --> 00:05:44,290
At the end you win and five. And this is our matrix. In order to get this matrix we flipped the matrix first, the second diagonal. Then we flipped that second diagonal split matrix horizontally.

22
00:05:44,290 --> 00:05:54,880
Then we get this matrix and this is your answer, OK? And that's how we can solve this problem. Now, let me show you how we can solve this problem using pseudocode, OK?

23
00:05:55,150 --> 00:06:06,760
Let's assume that this is our given matrix and this matrix diagonally flipped and this matrix horizontally flipped. OK, first we're going to declare a function rotate that takes the given matrix as input.

24
00:06:07,030 --> 00:06:18,910
Then we're going to flip the matrix diagonally. This is the function. OK, flip diagonal. This takes this matrix as input. Then here we have this function definition, flip diagonal matrix.

25
00:06:19,210 --> 00:06:29,710
Then we have a tool of this loop. Oil started running from zero until the last minute, one of the given matrix and holds from the Lindop Matrix minus eight minus one.

26
00:06:29,980 --> 00:06:41,050
OK, don't worry, we don't get it. So for first iterations of this love the value of I and J zeros, it points to one. All right. Now our goal is to find the index of this value nine.

27
00:06:41,080 --> 00:06:52,690
So how we can do that. For that we have your matrix length of this matrix, minus G minus one, so that if you wanted to Leontes three minus the Ejiro minus one.

28
00:06:52,690 --> 00:07:03,850
So two. So it points to this last nested array here. Right. And then we're going to get the lost value here. So let matrix minus eight, minus one. So we're going to flip this to.

29
00:07:04,280 --> 00:07:15,740
And this one will be replaced by nine. Then we have your current to this one. So we're going to just replace this nine by one. So it will be one. So a diagonal value remaining as it is then, what next iteration of this move?

30
00:07:15,950 --> 00:07:25,890
So it will point to this area and points to the last here by this rule here. So we're going to flip two and six. So two will be at here and six will be at here.

31
00:07:25,940 --> 00:07:35,090
OK, then for next iteration, that becomes too. So in this case, it will point to this tree. And here also you have three. So we're going to replace this three by three.

32
00:07:35,120 --> 00:07:45,890
So it remains as it is for the next iteration of this loop, it points to this nested array. OK, the first iteration here, we have a zero, right. And ECLSS to one.

33
00:07:45,980 --> 00:07:58,610
OK, so in this case, what we're going to do here is that we're going to extend this to four and eight. So eight will be at your four will be at your. OK, so we're done with this flip diagonal matrix.

34
00:07:58,940 --> 00:08:12,720
Then we're going to flip this matrix horizontally. And this is the horizontal model. Right. So we're going to flip this, too. So we have a function here until the text are rotated, matrix A. function definition flip horizontally, the text matrix as input.

35
00:08:12,740 --> 00:08:22,700
Then we have to live here. OK. The value for this will remaining as it is. So eight, five and two, we have this to follow. So I is always just zero for this matrix.

36
00:08:22,710 --> 00:08:38,870
So it's pointing to the first rule. Then we're going to just extend the two value here by this formula here. So seven will go here, nine will go here, then four will be better than six here and then one will be at your end will be at here.

37
00:08:39,020 --> 00:08:50,310
If you are wondering how it actually works, just go through the pseudocode and the solution code is attached to this avideo. Check the attached code. OK, and this is my solution to this problem.

38
00:08:50,330 --> 00:09:05,860
And finally, we have this matrix rotated and the solution all takes because it's quite time complexity. What is the length of the given matrix? And it all takes constant space complexity because we are modifying the matrix in place.

39
00:09:06,080 --> 00:09:13,610
And this is my solution to this problem. Solution code is available for download. Check that out. Thanks for watching this video. I'll see you in the next video.


@@@
1
00:00:00,480 --> 00:00:16,330
Hey, what's up, guys? Welcome back to this video into the video. We're going to solve a very popular calling into question spiral matrix. Is it truly a problem, given an MBA in Matrix written all elements of the Matrix in spiral order?

2
00:00:17,730 --> 00:00:34,480
For example, if you were given this matrix, you have to traverse this matrix in spiral order and you have to return the elements in a spiral order. So first oldtimers one and two, then three six nine, eight, seven, four, five.

3
00:00:35,130 --> 00:00:56,770
So if you were given this matrix, you have to return this list and this is the spiral or the traversal of this matrix. For example, if you were given this matrix as input, you have to traverse this matrix in spiral order and you have to return elements in spiral order traversal.

4
00:00:57,060 --> 00:01:18,090
So first Ultravox one, then two, then three, then four. Then eight, 12, 16, 15, 14, 13, nine, five, six, seven, 11, 10. So if you were given this matrix as input, you have to return this list and this list we gained by traversing the matrix in spiral order.

5
00:01:18,270 --> 00:01:50,170
Now, let's take another example. For example, if you're given this matrix as input, we have to traverse this matrix in spiral order and we have to return the list of elements in spiral order traversal first of the towers one, then two, then three, then four, then five, ten, sixteen, twenty one, twenty six, 25, 24, 23, 22, 17, 11, six, seven, eight, nine, 15, 2019, 18, 12, 14.

6
00:01:51,150 --> 00:02:03,570
So if you given this matrix, you have to return this list. We can gain this list by traversing the matrix in spiral order. Now, let's see if we can solve this problem.

7
00:02:03,780 --> 00:02:14,450
To solve this problem. We're going to use four pointer Roman Rotu column one and column two. Let's see if we can solve this problem first by understanding.

8
00:02:14,640 --> 00:02:31,640
Let's take an example. Let's given this matrix, we have to traverse this matrix in spiral order. And if the written list of elements in spiral order, so let's declare for pointed out on two and soon and see to our own pointer all point to the first row at all.

9
00:02:31,650 --> 00:02:48,350
Point to the last row, seven point to the first column and Sidel point to the last column. First we're going to traverse the first row, then the last column, then the last row and then the first column.

10
00:02:48,870 --> 00:03:00,850
Let's see how we can do that. First, we're going to traverse the first row from seven to zero from zero to say that we have four elements. So let's add these four elements to a list using a falloff.

11
00:03:01,350 --> 00:03:13,800
And this is our list. This list now contains four elements. We have terrorised the first row from seven to two. No, let's traverse the last column from R1 plus one to R2.

12
00:03:13,980 --> 00:03:32,810
We have here three elements, eight, 12 and 16. So let's add that element to our list. Then the list will be represented, something like this. Now we have to traverse the last row for last row traversal will traverse from C to minus one to seven plus one.

13
00:03:33,720 --> 00:03:50,790
So we have just two elements, 15 and 14. So let's add 15 and 14 to our list in the list will be represented, something like this. Then to traverse the first column in the first column, we have to turn our to to our one plus one from our to do our own plus one.

14
00:03:50,820 --> 00:04:06,200
We have three elements, 13, nine and five. So let's add the three elements to our list. The list will be represented, something like this. So terrorist first, faster than the last column than the last straw in the first column.

15
00:04:06,560 --> 00:04:18,900
Now let's move on to the next and the let see you move. Your city will move here. I will move here and I will move here. All right. Now let's apply the same formula.

16
00:04:19,010 --> 00:04:28,490
First, let's start first row in the first row. We're going to terrorists from to say to you, we have to eliminate six and seven. Let's add that element to the list.

17
00:04:28,670 --> 00:04:37,100
Then the list will be represented, something like this. Then let's cherish the last column from our on plus onto our two. We have are only one element.

18
00:04:37,100 --> 00:04:50,780
So let's add that element to our list. Now, let's covers the last row in the last, whichever's from Setto minus one to seven, plus one in that case, seven will be greater than zero and that's invalid.

19
00:04:50,780 --> 00:05:03,650
And that all handled when you go through our pseudocode. So we can't traverse the last row in this case. Now, let's try the first column in the first global terrorist from our two to our on plus one.

20
00:05:03,650 --> 00:05:23,720
In that case, you have only one element ten. So let's add to our list and this is how we can solve this problem. Then if we move, C1 and C2 seven will be greater than C2 and here alone will be greater than R2 and that's invalid and that will be handled when will go through the pseudocode.

21
00:05:23,780 --> 00:05:36,950
This is how we can solve this problem. So we have traversed this matrix in spiral order, something like this. We've understood how we can solve this problem for better understanding.

22
00:05:36,970 --> 00:05:46,560
Let's take another example. Let's say you were given this matrix. Now let's see if we can solve this problem for this matrix. First, let's initialize Route one.

23
00:05:46,600 --> 00:05:57,370
This is our one a.m. point to the first rule, then our to our total point to the last rule. Then see, once you open to the first column, then C2C will point to the last column.

24
00:05:57,370 --> 00:06:10,360
First, we're going to traverse the first row in the first row. We have five elements from C1 to settle. Let's add this five element to a list. We can do that simply using a falloff from seven to C2.

25
00:06:10,840 --> 00:06:26,320
Now let's traverse the last column from our own plus onto our two. We have your four elements, 10, 16, 21, 26. Let's add that element to our list and let's start Lastra from SEDAR minus one to seven plus one.

26
00:06:26,560 --> 00:06:40,450
So in that case, we have three elements 25, 24, 23. So let's add that element to our list in the list. Be represented, something like this. Then let's traverse the first column from R to to add on plus one.

27
00:06:40,570 --> 00:06:52,000
Here we have four elements 24, 22, 17, 11 and six. Let's add that four element to our list. Then the list will be represented, something like this. Now we're done.

28
00:06:52,000 --> 00:07:06,240
We have processed two columns. And Tuross, let's move on to the next set. We will let out onto the bottom and at the top. Then it'll be represented. Something like this in the row one, we have three element unvisited.

29
00:07:06,460 --> 00:07:19,450
Now, let's traverse the first row from you want to see do we have three element seven, eight, nine. Let's add that element to our list. Then let's change the last column here.

30
00:07:19,450 --> 00:07:32,740
We have two elements from our own plus one to R2. Let's add that to our list now. Let's try the last row from minus one to seven plus one. We have only one elements late at night to our list.

31
00:07:32,890 --> 00:07:43,330
Now we have to traverse the first column in the first column. We have to eliminate unvisited from to our plus one. We have to eliminate 18 and 12. So let's add that to the list.

32
00:07:43,510 --> 00:07:57,340
Now, we have only one elements for him. Let's move on right over here. Sit right over here are one right over here and and R2 right over here. Now, seventy two is not pointing to this column and our own art is pointing to this column.

33
00:07:57,340 --> 00:08:11,920
So let's cover the first row from side to side. We have only one element fourteen. So let's add four into our list now over towards the last column from R1 plus one to R2 and that will be invalid.

34
00:08:12,160 --> 00:08:23,710
I will be greater than R2 and that will handled when you go through this record. All right. This is how we can solve this problem. So we have terrorized this matrix in this spiral order.

35
00:08:24,310 --> 00:08:41,310
This is the spiral order. OK, one, two, three, four, five, ten, sixteen. Twenty one. Twenty six. Twenty five. Twenty four. Twenty three, twenty two, seventeen eleven six seven eight nine fifteen twenty nineteen eighteen 12, 14.

36
00:08:41,350 --> 00:08:58,840
This is how we can solve this problem. We have understood the concept. Now let me show you how we can implement this solution using pseudocode. This is the pseudocode to solve this problem first with this function as part of Matrix, it takes a matrix as input.

37
00:08:58,840 --> 00:09:09,190
Then we're creating a list. This list will store the elements in spiral order. Then we're checking if the length of the matrix is zero. They were returning the empty list.

38
00:09:09,190 --> 00:09:23,110
If not, then we're declaring our own R2. I will point to the first row at all, point to the last row, then C once you open to the first column. So it will point to the last column, then we're running.

39
00:09:23,110 --> 00:09:36,880
Aluf, why leave well alone is less than or equal to our to end soon is less than or equal to Sido. Then this loof will traverse the first row. This loof will traverse the last column.

40
00:09:36,880 --> 00:09:56,470
The checking if we have two rows and two columns, then all towards the last row, the will towards the first column. And then we're moving the arrow into the next room to the previous second to the next column and ceded to the previous column.

41
00:09:56,470 --> 00:10:06,490
And at the end we're returning that list. Now let's see how it works. This is an empty list we created right over here. Let's suppose that were given this matrix.

42
00:10:06,640 --> 00:10:20,080
So I will point to this first row and I point to the last point, to the first column. It will point to the last column. Now, this wallaby's true because our own is less than our two and soon is less than Sido.

43
00:10:20,200 --> 00:10:43,180
Now, let's traverse the first row first C from second to C2 and we're adding the first row to our list. Here are one is constant. It points to the. Strozzi is a dynamic will iterate from soon to Sido, so it will add one, two, three, four tallest, the list will be represented, something like this.

44
00:10:43,360 --> 00:11:04,690
And let's traverse the last column for our from our own plus one to our two. So we're terrorists in this column from our unpassed on to our two, we have your three element eight, 12, 16 here, Sidwell's Constant since you were the last column and are is dynamic originating from around plus one to R-2.

45
00:11:05,350 --> 00:11:23,950
So it will add eight, 12 and 16 to a list. Then the list will be represented, something like this. Then we're checking if we have two rows and two columns and here we see that our own and art is not pointing to the same rules and so on, and so it is not pointing to the same column.

46
00:11:23,950 --> 00:11:42,280
So let's traverse the last row from C to minus one to see one plus one. So it will traverse 15 and 14. Here we see that artery's constant because we are tracing the last row and Sounness dynamic iterating from zero minus one see seven plus one.

47
00:11:42,760 --> 00:11:58,960
So it will add this to limit to a list 15 and 14. Then the list will be represented, something like this. Now let's traverse the first column using this falloff for our from our two to our own plus one.

48
00:11:59,080 --> 00:12:08,770
And here we see that Sounness constant because you are traversing the first column and are as dynamic as iterating because you are iterating from R2 to around us one.

49
00:12:08,770 --> 00:12:19,230
So we have a three elements, thirty nine and five. So let's add that element to our list. Then the list will be represented, something like this, and we're done with the first iteration of this as well.

50
00:12:19,480 --> 00:12:32,140
Now we have traversed the first rule, Lastra last column in first column. Now let's move on to the next column suited to the previous column and add on to the next row added to the previous row.

51
00:12:32,140 --> 00:12:46,150
Here we have this formula, our own blood splatter to minus minus seven plus plus minus minus. So it will be represented something like this. And let's try this first row from second to C2 using this falloff.

52
00:12:46,480 --> 00:12:57,760
So let's add six and seven to our list. Now, let's traverse the last column from our numbers onto R2, and that will point to this element only one element.

53
00:12:57,760 --> 00:13:12,070
So let's add to our list now. Watching this condition, we see that our role is less than R2 and so on is less than zero. It means we have at least two rows and two columns.

54
00:13:12,160 --> 00:13:27,940
Now, using this falloff, we're going to converge the last lateral in this formula, we see that C two minus one city, minus one is one to see one plus one, seven plus one is to or iterating from one to two.

55
00:13:28,090 --> 00:13:38,530
And that is the default I have to the source code to this video, to the source code. Then it will see how it evaluated falls to the source code I have attached to this video.

56
00:13:38,560 --> 00:13:48,970
Then you'll see how this invalided falls. Then let's traverse the first column in the first column recovers our from our two to our on plus one and we have only one element.

57
00:13:48,970 --> 00:14:03,760
So let's turn ten and let's add that to our list and we're done. And again, let's move on to the next original point here. And at one point here, central point here and central point here.

58
00:14:03,790 --> 00:14:15,640
And that break this a while of in that case alone is greater than our two and two and is greater than zero. And that's why this will stop, because this condition is false.

59
00:14:15,640 --> 00:14:28,570
And at the end, we're returning the list. This is the list we gain to this list, whichever's in this matrix, in spiral order, something like this. This is a spiral order traversal of this matrix.

60
00:14:29,230 --> 00:15:01,150
We've understood this with explanation. The solution will takes a bigger of the solution, only takes bigger of M times in time complexity where it is the height of the matrix and it is the weight of the matrix because you see all the element in the matrix once, no matter what, no matter how much value we have here and how much nested falu and how much nested we have here, it will only just take big off M times in time.

61
00:15:01,150 --> 00:15:26,560
Complexity or M is the height of the matrix and it is the width of the matrix. And the solution will take up one space complexity if we exclude from our complexity analysis, if we include our output list to the complexity, the system and then the space complexity will be big of M times in whatever is the height and it is the width of the given matrix we have understood is really expression.

62
00:15:27,010 --> 00:15:37,050
If you are not understanding this very explanation or if you have any question or if it's a. Let us know, thanks for watching this video. I'll see you in the next video.


@@@
1
00:00:00,480 --> 00:00:09,570
Hey, what's up, guys? Welcome back to this video in this video. We're going to talk about linguistic data structure. Link list is a dynamic data structure.

2
00:00:09,630 --> 00:00:27,300
Where is ilmenite called in? Node is made of of two items. The data and the reference or pointer response to the next node illing list is a collection of nodes or is node is connected to the next node three pointer or a reference.

3
00:00:28,790 --> 00:00:43,850
This is the formal definition of a linguist data structure for every element. We have only one items for linguist element. We have two items. One, a value or a data and a pointer or a difference.

4
00:00:44,420 --> 00:01:03,610
OK, so a note contains two parts. One part, it's stored the data or a value and the other part is stored the referent or pointer. OK. This is not a representation of him using this point, it will connect one, not with another.

5
00:01:04,370 --> 00:01:19,670
This is an example of a list. The first note is called head, and the last node is called a tale. In this link list, we have four nodes. The site of this link list is for this node is connected by the pointer to this node.

6
00:01:20,120 --> 00:01:30,500
This node is going to get to this note by this pointer. This note is connected to this node and this note is connected to now node. That means to nothing because now means nothing.

7
00:01:30,530 --> 00:01:40,850
There is no existence in computer memory for now node. This is a high level representation of a link list. The first note is called the last node is called a tail.

8
00:01:41,060 --> 00:01:56,180
This node is stored two items. One is Dhara and one is the address of another node and the address of this node is directed. The original one or hit pointer is points to when is say hit.

9
00:01:56,570 --> 00:02:13,560
Then it means we're calling the node of this address. And here this note is connected to this node by this address. And it was during the address of this node restoring the address of this note here, restoring the address of this node and restoring nothing that meant.

10
00:02:13,750 --> 00:02:26,900
Now, this is an example of linked list of we have understood what is a link, this data structure. Now let's talk about legalist versus array side up. The list is not fixed.

11
00:02:27,150 --> 00:02:38,690
We can change or modify the site up a linguist during the time, but the site of an error is fixed. We can't change the site of an error during runtime.

12
00:02:38,870 --> 00:02:51,440
We can't access it, not randomly, but we can exit an element randomly for error. We cannot exit a node randomly for lengthiest, but for error. We can access an element randomly by the index.

13
00:02:51,440 --> 00:03:05,960
No link list is stored in nonconsecutive memory location, but the error is stored in continuity of memory location one after another. For example, this each and every year we have five elements and we have your index number.

14
00:03:06,200 --> 00:03:15,440
With the index number, we can access any of the arrangement in constant time. This is an example of linguist. The first note is called the last node is called to here.

15
00:03:15,440 --> 00:03:26,720
We cannot accept any node randomly. In order to access any node, we have to traverse the link list from left to right. Let's say we want to find it the value of this node.

16
00:03:26,900 --> 00:03:40,560
Then we have to say, hey, dot next dot eval, then it will get this value. So to find out a value of a particular note, we have to use a loop. But for error, we can access that in constant time.

17
00:03:40,850 --> 00:03:54,500
Now let's see how an array and linguist is represented in computer memory. This is our array and this is an example of random or random access memory and will be stored something like this.

18
00:03:54,770 --> 00:04:05,660
The element will be first converted into binary. The binary equivalent will be stored in the RAM. But for sake of understanding, we're showing the integer representation.

19
00:04:05,840 --> 00:04:15,440
First it will store one, then two and three, then for the five. This is stored in consecutive memory location, so array is stored in consecutive memory location.

20
00:04:15,440 --> 00:04:27,020
First one, then two and three and four and five. There is no gap in between. Now let's see the linked list representation in computer memory. This Erguven link list and this link lists will be represented.

21
00:04:27,020 --> 00:04:40,670
Something like this, the link list represented in scarily it's not represented in consecutive memory location this year. First node one, then two, then three, then four and five is your head node.

22
00:04:40,970 --> 00:04:49,160
Then this note is connected to this node. This node is connected to this note. This note is connected to this node and this note is going to get to this node and this is called tail.

23
00:04:49,370 --> 00:04:59,840
And we see that there are many gaps in between is node. But for continuity, memory, location, there is no gap one after another, but linked list is represented something like this.

24
00:05:00,080 --> 00:05:11,120
It can be anywhere in the computer memory and we have link so it can go from one note to another node. This is how linkage is represented in computer memory.


@@@
1
00:00:00,870 --> 00:00:16,860
Hey, what's up, guys? Welcome back to this video. In this video, we're going to talk about types of linked list. There are four types of link list, single list, circler, single list, doubling list, search, doubling list.

2
00:00:17,530 --> 00:00:34,950
Now, let's see all of them in details for a single list. We have these types of nodes. The nodes contains two items. The first item is called value or data, and the second item is called pointer or a different to another node.

3
00:00:35,790 --> 00:00:48,060
This is the formal definition of a single list in a single link list is not in the list stores, the data of the node and reference or point to the next node in the list.

4
00:00:48,600 --> 00:01:02,250
It does not store the reference or pointed to the previous node. This is an example of a single list is not in single list, contains two items, data and pointer.

5
00:01:02,970 --> 00:01:19,340
This is data and this is pointer. And this point, it is pointing to this, not by this address. Now, let's talk about circler single analyst. The Circler single linked list are the same at single list, but with only one difference.

6
00:01:19,710 --> 00:01:30,980
The end node or the last node in the list is connected to the first node of the link list. Something like this. The last node is connected to the first node.

7
00:01:31,140 --> 00:01:46,550
That means the tail is connected to the node and this is called circular single interest in single link list. The tail node is connected to include that it's connected to nothing but circles, including this.

8
00:01:46,890 --> 00:02:21,890
The last node is connected to the first node. Now let's talk about double interest in the list. We have different note in the list. The node contains three items, one data and two pointer, three pointer and next pointer, three pointer point to the previous node and the next pointer points to the next node in DoubleLine list is not contains one data and two referent or pointers that references or points to the previous and next node.

9
00:02:22,170 --> 00:02:37,410
This is an example of doubling list. This is our head node. And the address of this node is this address is not contains three items, two pointer, three pointer and next pointer or a reference.

10
00:02:37,710 --> 00:02:58,800
And the data and the data for this node, the pointer is pointing to nothing. And the next point, responding to this node and for is not, it contains three items, three pointer, pointing to this node and a data and the next one, the next pointer pointing to this node for doubling list.

11
00:02:58,980 --> 00:03:10,940
We can go forward and backward, but for a single increased, we can only move forward from left to right. But for a list we can move from left to right and also we can move from right to it.

12
00:03:11,730 --> 00:03:29,430
And let's talk about circular list. Circular list, exactly same as doubling the list, but with only one different. The last node in the list is connected to the first node and the first node is connected to the last minute of the link list, something like this.

13
00:03:29,430 --> 00:03:45,880
The first note is connected to the last node and the last note is connected to the first node. And this is called Circular Downlink List. We have understood four types uplinked list, single linked list, circular single link list, doubling list and circular list.


@@@
1
00:00:00,420 --> 00:00:10,570
A lot of guys will come back to this video in this video. We're going to create a single interest and let's see how we can create a single linguistic algorithm to create a single list.

2
00:00:10,590 --> 00:00:23,130
First will create a class node with two attributes, data. And next next is a pointer to the next node. Then we'll create another class which has two attributes, head and tail.

3
00:00:24,180 --> 00:00:36,720
Then you'll create a method, add node, add method will add new knowledge to the list. And will create a method, print method, will print the not present in the list.

4
00:00:37,260 --> 00:00:51,210
This is the class node and this is my single linked list, but this is our first class note and this is our missing link list, Clutz. Now, let's combine them together.

5
00:00:51,420 --> 00:01:03,370
If we combined them together, then we get this code here. We have inside of this class, we have a class not this, not represent a node. It contains two properties into value.

6
00:01:03,780 --> 00:01:16,290
We can see all the data and a next pointer. Then we have your head node and tail. Not that points to now node. And then we have here to method add node and we have print.

7
00:01:16,890 --> 00:01:33,150
And this is the node, OK? It contains a data here we have well as data and the next pointer and we have here now node OK. This note contains null data and now pointer and to hit and tell is not pointing to this node.

8
00:01:33,540 --> 00:01:47,360
Now let's say the code for addNode, we have initially this node head and tail pointing to a download. Now here we have this method add node. It takes a parameter data.

9
00:01:47,700 --> 00:01:57,330
Then we're going to create a new node with the data and the note, checking if Heracles channel will create a new note and will address the head until pointed to that node.

10
00:01:57,720 --> 00:02:17,190
If not, there will add the new note to the next and will move the tail to the newly created node. Let's see how we can do that. If we call this function addnode one, then we'll create a node one and all at once here, two pointer head and tail synch.

11
00:02:17,190 --> 00:02:28,470
Our head is empty initially. Then if we call this function again at node two, then we will create another node two and then we're going to say tailcoat next.

12
00:02:28,650 --> 00:02:48,580
So at this point to this node and we're going to move tail to this node, then it will be represented, something like this. We call this function addNode three, then will create a new node and will add this point to this node and it will move tail to this node, then it it'll be represented something like this.

13
00:02:49,000 --> 00:03:00,040
Then again, it will call this function add node for the newly created node for and all at this link to this node here, we're going to say next to go through the unit.

14
00:03:00,040 --> 00:03:10,340
So we're disconnecting this link and we're connecting to this note and we're going to move tail to this node. Telecaster, Leonhard and Linguist's will be represented, something like this.

15
00:03:10,870 --> 00:03:22,000
So by calling this function four times, we get this list, something like this. Now let's see our print method, how we can traverse this link list and how we can print the nodes values.

16
00:03:22,900 --> 00:03:33,880
This is the code for printing the nodes values. Print function takes no parameter at all. Checking if Sternhell will print empty list and it will edgett by this written statement.

17
00:03:34,960 --> 00:03:45,060
If not, then we're creating a current pointer to head node and then we're checking. Well, current is not external. We're going to print the current data and then we're going to move into the next.

18
00:03:45,070 --> 00:04:00,290
And until current, is it now node initially current point responding to this head node and now we see this note is not another. So let's print one and let's move to the next node is not is not analogous to let's print developed is not my current data.

19
00:04:01,150 --> 00:04:17,890
Now let's move to the next node and let's develop this, not three. Let's move on to the next node and let's bring the value of this node for and we get this output and this is what we can print value up a linguist node values.

20
00:04:19,000 --> 00:04:29,530
This function will take Spiga off in time complexity since we are divorcing the linked list from left to right and it will takes constant space complexity.

21
00:04:29,680 --> 00:04:50,530
Since you are not using any original speech, we are just using a pointer current and here this function will takes bigger of one time complexity because we're adding the node to the tail in constant time and it takes also constant space complexity because you are inserting one node at a time.

22
00:04:50,800 --> 00:05:01,060
We add all of them functions. If we consider, then it will take zwigoff in time complexity. What is the number of nodes? And here we say this counterpointed is pointing to the last node.

23
00:05:01,330 --> 00:05:11,460
In the next iteration it will point to the now node when it will point to the this envelope will stuff. And this is how we can print the values of nodes already.


@@@
1
00:00:00,610 --> 00:00:14,080
A lot of guys will come back to this video in this video. We're going to see insertion operation in. A single analyst in this video are going to made three operations and a state added to and added index.

2
00:00:15,190 --> 00:00:28,420
Now, let's implement all of the operations right in this video. First, we're going to see added hate, then added to the newly added index. First, let's talk about added hate.

3
00:00:29,480 --> 00:00:41,800
This is our linked list representation. OK, first we have this now not a hit until Point is pointing to the download and we have initially calls to zero.

4
00:00:42,460 --> 00:00:58,590
Now let's see the code for and hate. Read the serial code for agitate, and initially we have cycles to zero. This is our method added hate. It takes a parameter data.

5
00:00:59,200 --> 00:01:08,310
You're creating a node with the data and we're checking the site close zero. Then we're going to say Hiriko strategy calls to node and something like this.

6
00:01:09,240 --> 00:01:24,300
If not, then we're going to say no, that next we got to hit and we're going to say Heracles to Node. And here we're just connecting the current node to hate and we're going to move hate to our current node.

7
00:01:24,930 --> 00:01:41,790
And at the end we're going to increase the site. We need to keep track the site. When we implement adead index, we need the site of appalling list. If we call this function, agitate with the node value for the newly created node, something like this.

8
00:01:42,330 --> 00:02:00,450
And then we're going to initialize. Hayden pointed to this note since the site calls to zero initially. So head and tell pointillist pointing to this node and at the end or just increasing the site to size became one, then let's call this function again with added three.

9
00:02:01,020 --> 00:02:17,550
Then we will create a node. And in this case it is not going to say no dot. Next, this is our current node. So we're going to connect this link to this node and we're going to move the hit pointer to this node so it will be represented something like this.

10
00:02:17,790 --> 00:02:38,230
Three, four, three is the head. OK, and the site is to maybe call this function again and at head to then we're going to create a node, something like this, and then we're going to disconnect this link and we're going to connect to hate and we're going to move ahead to this node.

11
00:02:38,740 --> 00:02:48,970
Then it will be represented, something like this, and the site will be increased. So the linguists will be represented, something like this, if we call this function again with agitate one.

12
00:02:50,120 --> 00:03:05,120
So we'll create a new note of Value one, and we're going to disconnect this link from now and we're going to connect to head and we're going to move our hit pointed to this note and our linguist will be represented something like this, and it will be increased from three to four.

13
00:03:05,870 --> 00:03:20,030
And this will be the representation of a link list if we made this full function call. We have understood the ad at Haid method. Now, let's talk about added tail method before that.

14
00:03:20,270 --> 00:03:31,640
Let's say the time, complexity, the time, complexity for this problem is bigger of one, because you are inserting a note to the head and the space complexity is bigger one as well.

15
00:03:32,300 --> 00:03:46,510
Now let's see. Added tail method. All right, this is our ED method. Initially, we have this note, OK, hit and tell point is pointing to unload inside the studio.

16
00:03:47,410 --> 00:03:58,840
This is our method added to this program takes a parameter and recruiting a new not. If decided, then we're going to initialize your head and pointed to our current node.

17
00:03:59,410 --> 00:04:12,760
If not, we're going to add the note to that, too, and we're going to move tail to the current node and we're increasing the site. If we call this function with added tail one, then will create a node, something like this.

18
00:04:12,940 --> 00:04:27,290
And initially we have cycled through zero since we have initially Santigold to all ETAs head and tail pointed to this note by this statement, hate equals routinely go through node and the site became one.

19
00:04:27,430 --> 00:04:42,040
Now let's call this function again added to the node of value to then we're going to say the next call to node. So till the next equals to node, we're going to connect to the node and we're going to move tail to this node.

20
00:04:42,320 --> 00:04:53,440
So the link is something like this and the site is now to be called this function added to it will create a node of value three. And we're going to disconnect this link.

21
00:04:53,440 --> 00:05:01,690
We're going to connect to this node and we would move tail to this node in the link. This will be represented something like this, and the answer is increased by one.

22
00:05:01,870 --> 00:05:11,830
And if you call the function added tail for the moment to create a new node, and we're going to disconnect this and are going to connect to this node and we're going to move tail to this node.

23
00:05:12,160 --> 00:05:25,770
So the linguist will be represented something like this, or we have understood added to the method. This method will take bigger of one time complexity and bigger of one space complexity.

24
00:05:26,050 --> 00:05:36,820
It takes bigger of one time complexity because we are adding the node to the tail in constant time. We understood added to method. Now let's talk about added index method.

25
00:05:37,030 --> 00:05:49,030
Now we're going to talk about added index method. In order to implement Adut index method, we need added hate, added detail and get node. So this is our function.

26
00:05:49,300 --> 00:06:08,770
This function takes two parameter index and data, the index number where we want to insert the current node. And then what if index is less than zero or indexes greater than size didn't exist in order to keep Indexical 2.0, then we have to call added Haid if indexical to change the number to call this function additive.

27
00:06:09,010 --> 00:06:19,870
So let's talk about Arijit hate and added to for this method we have already discussed about edited and added detail in a lot of details in the previous slide.

28
00:06:20,230 --> 00:06:28,600
If not, we're going to get the previous node of our current index. Then we're going to create a new node and we're going to say not next. We got to what next?

29
00:06:28,930 --> 00:06:39,730
And they're not the next node and size plus. Plus, we'll see how it works. And this is we're getting what method it will return the current node by this fall.

30
00:06:39,970 --> 00:06:50,580
For sake of understanding, let's assume we're given this link list and the site is two. This is our head node and the celebrityhood the index number we have here from zero to one.

31
00:06:50,590 --> 00:07:02,860
This is this is the node of indigenous to the node of index one. Now we call this function added index on to at index one and at Index Wallerawang to add to so the node will goes in between these two nodes.

32
00:07:03,550 --> 00:07:12,950
So let's create a new node here. This is our new node we created using this statement and here the third previous node. And this is your previous note.

33
00:07:12,980 --> 00:07:25,300
OK, now we're going to see in the next exults to Peanut Dot next. We're going to disconnect this. We're going to connect this link to this node and then we're going to separate note that next to node.

34
00:07:25,450 --> 00:07:34,570
So we're going to disconnect this and we're going to connect this to this node and we're going to just increase the site. Society will be changed to three and the link lists will be represented.

35
00:07:34,570 --> 00:07:48,810
Something like this. One, two, four. One is the head and four is the tail. So Linkous represented something like this. If we call this function two, three at index two, at index two, we have to add a node three.

36
00:07:49,090 --> 00:07:58,600
So the node three will goes in between these two, node two and three. So this not all goes in between these two node first. Let's find out the previous node.

37
00:07:58,600 --> 00:08:13,990
This is the previous node and let's create a node by this statement decision node. And now the next goal is to preview the next. So we're going to connect this to this node and we're going to disconnect this and we're going to connect this to this node.

38
00:08:14,170 --> 00:08:23,140
And we would increase the site site will be evaluated for and the link will be represented, something like this. This is how this other index method works.

39
00:08:23,510 --> 00:08:35,290
We have understood this added index operations, insertion operations, added index so we can add a node at any index. This method will take Spiga off in time.

40
00:08:35,290 --> 00:08:52,150
Complexity for the. We're scared because we have to find out the price of not using this falloff, using this method, Guignard and this solution will take up one space complexity since we're adding or not at a time where we have understood this very explanation in this video.

41
00:08:52,170 --> 00:09:02,610
We have covered three method added hate added to and added index. Thanks for watching this video. If any question this additional, let us know. Thanks for watching.


@@@
1
00:00:00,570 --> 00:00:12,980
A lot of guys will come back to this video in this video, we're going to talk about terrorism and searching in a linguist in this video. We're going to implement this to metaverse and search this method.

2
00:00:12,990 --> 00:00:25,230
Will terrorists doing this from left to right? And it will print the notes from left to right. And this method will reach an index of a given note. If the note does not exist, then it will return minus one.

3
00:00:25,560 --> 00:00:37,340
Now, let's see how we can implement this to method the serial linguist representation. OK, we have this class. Then we have this two pointer head and tail and we have disturbers method inside this method.

4
00:00:37,350 --> 00:00:46,660
We're going to check if Heracles will return using this written statement. It will just Edgett. Then we're creating a pointer current that will point to a head note, then we're running a while.

5
00:00:46,660 --> 00:00:57,960
Livewell currently is not. Sternhell will print the current note, then we're moving current to the next. Let's see how it works later. We're given this link list first current point-to-point to the first node.

6
00:00:58,230 --> 00:01:07,440
So we see that this node is not a normal toilet. So let's print one. Now let's move on to the next. This note is not a node, so let's print the value of this note, too.

7
00:01:07,740 --> 00:01:20,550
Now, let's move on to the next note. Develop this notice through this note is not now, not so. Let's print three. Now, let's move on to the next node and let's print develop this node for again, let's move to the next.

8
00:01:20,580 --> 00:01:36,300
Now we see that our current pointer is pointing to a now not so old stuff. This is how we get towards a linguist. This method will take off in time complexity and it will takes constant space complexity since we're not using any original speech.

9
00:01:36,780 --> 00:01:55,620
Now, let's talk about Sarsae method. This is our method of this method takes one parameter. Well, we'll search the well in the lengthiest if we found the well in the lengthiest will return the index of that node inside your checking, if you go to null, will return minus one.

10
00:01:56,050 --> 00:02:06,660
Then we have indexical. Initially, the index zero means the first node initially indexed to the index of first note, then were initialized in current pointed to the head node.

11
00:02:07,080 --> 00:02:24,750
Then we are running a while of well, current is not null. We're going to check if the yellow card not equal to the whole region, the index then will increase index and then we will move to that next node if we do not found the value in our node already in Minnesota.

12
00:02:24,930 --> 00:02:35,930
Let's see how it works that searching the value tree the head is not also current point-to-point point to this node and the value is not equal to three.

13
00:02:35,940 --> 00:02:52,480
So let's move to the next node and we see the value is not equal to three. So let's move to the next node and we see the value close to three. So we'll return the index to and we're tracking the index of our current not using this index variable lookup.

14
00:02:52,860 --> 00:03:05,370
If we're sourcing the value of five and that value is not exist in this link list, then this current pointer will point to this node in that get this valuable stuff and it will just return my network.

15
00:03:06,080 --> 00:03:18,840
We have understood the source method and this is how it works. This method will, because of in time complexity for the worst case scenario, and it all takes constant space, complexity or not using any additional split.


@@@
1
00:00:01,350 --> 00:00:18,600
Hey, what's up, guys? Welcome back to this video. In this video, we're going to see how to meet the lead operation in a single killing list. In this video we're going to implement to build Operation Delete at index and delete internalised.

2
00:00:19,140 --> 00:00:30,940
This method will delete a node at a given index and this method will delete the entire list. First, let's see how we can implement this method. Then you'll see this method.

3
00:00:32,640 --> 00:00:48,810
This is our code. This is going to delete at index method. This method takes a parameter index and here we're checking if index is liaison's or index is equal to or greater than size, then we'll just return.

4
00:00:49,380 --> 00:01:01,300
If index is zero, then we will move our hit points to the next. OK, if not, we're going to get the previous node. Then we're going to see Peter next to it next year.

5
00:01:01,350 --> 00:01:17,190
Next year we're just keeping our current node and then we're checking if the index is the last node, then we have to move tail to the pregnant and here we're just decreasing the site.

6
00:01:17,820 --> 00:01:30,480
Now let's see how it works. Let's say we're giving this lengthiest and we call this method delete at index with three. So our job is to remove this node four from a link list.

7
00:01:30,780 --> 00:01:40,770
So for what we're going to do, we're going to get the previous node decision, our previous node. OK, then we're going to say P'-- next go to Peter next DOT next.

8
00:01:40,780 --> 00:01:51,160
So we're going to disconnect this point and we're going to cunningness pointed to this note next. This is the next note. So next door, what next? That means now node.

9
00:01:51,630 --> 00:02:05,520
So this node is now pointing to nothing. There is nothing is pointing to this node. So Garrick's collector will remove this node from computer memory in computer memory.

10
00:02:05,520 --> 00:02:23,060
That means in random access memory or in IRAM, there is a garbage collector, garbage collector, all just looking for unused data. In RAM, whenever it found unused data, the data will be removed by the garbage collector.

11
00:02:23,730 --> 00:02:37,170
Then we see that indexical to size minus one. So we're going to move our tail pointed to this node. So this link list will be represented. Something like this we call this function delete at index one.

12
00:02:37,170 --> 00:02:48,050
In this case, we're going to delete this node for that. What we're going to do, we're going to get the previous node. This is the previous node, then previous the next to the next.

13
00:02:48,450 --> 00:02:58,110
So we're going to disconnect this link and we're going to connect to this node. And in this case, this condition is false and will just recreate the site.

14
00:02:58,290 --> 00:03:08,850
And now we see that there is nothing is pointing to this node. So this node will be removed by garbage collector. So the link list will be represented, something like this.

15
00:03:09,250 --> 00:03:20,280
This is how delete at index works. Let's call delete at index zero. In this case, what are you going to do in this case? You're going to move your head pointed to the next node.

16
00:03:20,280 --> 00:03:31,900
So it will point to this node and this. So it will point to this note and there is nothing is pointing to this node one. So this note will be removed by Garrick's collector.

17
00:03:32,100 --> 00:03:53,960
So it will be represented something like this. We have only one node in all this. This is how we looked at index method works. This method takes because of in time complexity, since we have to find out the previous node for the circuit and it will take constant space complexity.

18
00:03:54,210 --> 00:04:05,850
We are not using any additional spit. Now let's see how we can delete interlink list. Now let's see how we can delete interlink list. This is our method delete enter list.

19
00:04:06,000 --> 00:04:18,000
And here we're just saying to to Haiti cluster null. Let's you were given this linguist then we call this function delete enter list and here we're just moving here until the null node.

20
00:04:18,230 --> 00:04:27,750
OK, now we see that there is nothing is pointing to this node. So this is unused data in RAM. So garbage collector will collect and delete this node from them.

21
00:04:28,350 --> 00:04:40,410
Then we have this node. There is nothing is pointing to this node since this node is already removed by garbage collector. So this note will be also get removed by garbage collector.

22
00:04:41,010 --> 00:04:54,000
Then this node three, we see that there is nothing else pointing to this node. So colleague does not and will delay this note from RAM. Then this node we see there is nothing is pointing to this not so.

23
00:04:54,000 --> 00:05:10,770
This note will be removed by garbage collector and then we have no no means nothing. This is how entire journalist works, if we still equals to to know, then this linguist will be deleted from our computer memory.

24
00:05:10,950 --> 00:05:25,330
This is how this method works and it takes constant time, complexity and constant space complexity since we're moving till and Hayden known to the download, nothing we're doing except these operations.

25
00:05:25,380 --> 00:05:37,930
So it takes constant time and constant space complexity of we've understood this video explanation, if any question, if we have any issue understanding this explanation, let us not.


@@@
1
00:00:00,420 --> 00:00:14,270
Hey, what's up, guys? Welcome back to this video. In this video, we're going to see how to create a circular single list decision node. Again, this node contains two attributes, data and the next pointer.

2
00:00:14,790 --> 00:00:29,430
And we have this circular single head and tentacles to null and cycles to zero. Initially, this is our node representation and our linkage. Initially, Hayden is pointing to now node.

3
00:00:29,430 --> 00:00:41,790
That means it points to nothing. This is our code mailing list. This is my sampler single list. We have this class node. Then we have hidden data control inside called Cejudo.

4
00:00:42,210 --> 00:00:54,180
Initially we have this node in this video. We're going to implement add node and this method will add node to the tail and will print the node values.

5
00:00:54,720 --> 00:01:08,760
And I'm going to convert this code to pseudocode so it will take less speech on our computer screen. Now let's add node method. They say they want to add node method.

6
00:01:08,770 --> 00:01:19,950
It takes one parameter, then we're creating a new node and you're recruiting new node. And then we're checking in with regards to node. And then we're going to assign Headend pointed to the new note.

7
00:01:20,160 --> 00:01:31,650
Then we're saying Taylor needs to go it. If not, then we're going to say Taylor needs to go to new node 900 960 to to head and tail Coldstone unit. And then we're going to increase the size of our linguist.

8
00:01:32,610 --> 00:01:45,720
Let's call this method addnode with one. Now, what are we going to do? We're going to create a new node with a value one and then we're going to assign Hayden pointed to this note since he didn't initially know.

9
00:01:46,710 --> 00:01:59,410
And the address of this node is zero zero zero one, for example. Now here we're seeing Taylored next to it. So we're going to add this pointer to this node.

10
00:01:59,700 --> 00:02:12,300
OK, so here we're storing the address of this node. So this note will be represented, something like this. So we have a connection of this tale to hate.

11
00:02:12,600 --> 00:02:24,660
OK. Now, the site of all this is one let's call this function add value to. In this case, we're going to create a new node. So let's create a new discover new node.

12
00:02:24,870 --> 00:02:36,870
And then we see here is not equal to now and we see here is not equal to now. So now we're on this ILD statement here. We're going to see sit next class for neonate.

13
00:02:37,080 --> 00:02:53,730
So we're going to disconnect this pointer and we're going to connect to this node. OK, then you the next Coldstream. So we're going to connect this point to this node and then we're going to move tail to this node.

14
00:02:54,240 --> 00:03:08,960
Then this link list will be represented, something like this. And the site of this link list is to end. This node is connected to our Hayden node. Now let's call and node with value three.

15
00:03:09,660 --> 00:03:32,850
Now, we created a new node here, OK? And we see how it is not equal to now. So we're going to say till the next call to new node. So we're going to disconnect this and we're going to connect to this node and then we're going to send the next class to hate and then tell goes to this new node and then the linguist will be represented, something like this.

16
00:03:33,150 --> 00:03:45,090
And we see here we have a cycle. We can go from one to two, from two to three, from theta one. We have a cycle here, OK? This is called circular single linguist.

17
00:03:46,200 --> 00:04:05,780
This is how we can add node to the tail. This method will takes a bigger of one time complexity and bigger on space complexity. Now let's see our print method, how we can print the value of the subclassing list.

18
00:04:06,110 --> 00:04:20,820
OK. Initially it will print the value of a node. So we have printed the value of a node. Then our current then current pointer current pointer will point to this node and we see this node is not our head node.

19
00:04:20,940 --> 00:04:33,940
So let's bring the value of this node. So let's bring it to now let's move current to the next node. Now our current pointer will point to this node three and let's bring the value of this Node three.

20
00:04:34,320 --> 00:04:49,890
Then let's move current to the next or the next node of this node tail is hate since we have a circle here. So current will point to this note. And in this case we see that our current node is here.

21
00:04:50,220 --> 00:05:10,950
So we will stop. We have this result one, two and three. This is what we can print node values of a circular single. Englis, thanks. In this video, I'll see you in the next video, oh, the time complexity for this matter is bigger of in synch or traversing the lengthiest from left to right once.

22
00:05:11,550 --> 00:05:25,360
And it all takes constant space complexity since we're not using any additional spit. All right, guys, we have understood this video explanation. If any question about any issue, understanding this explanation, let us know.


@@@
1
00:00:00,630 --> 00:00:22,260
Hey, what's up, guys? Welcome back to this video. In this video, we're going to traverse and search in Circler single legalist. We're going to implement two method travelers and service disturbers method will traverse the link list from left to right and it will print the nodes values and service method will search for a specific nodes values.

2
00:00:22,530 --> 00:00:36,180
If the values exist, then it will return the index of that particular node. If the value does not exist, then it will return minus one first gletty towards method, then Altisource method.

3
00:00:37,440 --> 00:00:48,450
This is our code and this our terrorist method. For instance, going to check if haricots to know will print empty list and will just by this written statement.

4
00:00:49,080 --> 00:00:58,990
If not, we're going to print the hit value, then we're going to initialize current point to the next node or had not been Organa running wild of all kinds.

5
00:00:58,990 --> 00:01:13,500
Is Noriko's to hate the old print, the current note value and then we're going to move current to the next node. This method is exactly similar to the print method that what we have learned in the previous video.

6
00:01:14,070 --> 00:01:26,910
We're going to have this one more time. This time this method name is Devers. So initially it will print the value of our hidden nodes. So we'll print one, then we're going to initialize it.

7
00:01:26,910 --> 00:01:36,830
Pointed to this note, this is the next node or hate node and this is our current node. And we see this current node is not to Hayden. So let's print the value of this node.

8
00:01:37,350 --> 00:01:47,520
Let's move on to the next. We see this note is not our hadler. So let's bring develop this, not three. Let's move current to the next and the next node up tailers haid.

9
00:01:47,700 --> 00:02:09,390
Since we have here a circle and we see that no current is the to hate node. So all stuff. And this is our Tamasi result and this method will take Spiga of in time, complexity or whatever the link is from left to right once and it will take constant space complexity since we just using one pointer current.

10
00:02:10,260 --> 00:02:24,000
Now let's see sers method. This is our source method. First we're going to check if Haiti goes to null will return minus one. If the value of our hidenori goes to hell, it will return the index of our node.

11
00:02:24,420 --> 00:02:35,220
It is zero based index index of this node on is zero index of this node to his one index of this NE two. Then we're going to initialize a variable int index close to one.

12
00:02:35,520 --> 00:02:47,340
Then we're initializing a pointer current to our next net overhead node. Then we're going to check if current is Noriko's to hit. We're going to check if current to value will return the index.

13
00:02:47,910 --> 00:03:00,250
If not, we're going to increase the index and then we're going to move. Current pointed to the next node after doing this. While if we if we do not found current Derechos too well, then we will return minus one.

14
00:03:00,660 --> 00:03:11,760
Now let's call a function SERS three. Now we're going to search the value tree in this link list and we're going to return the index of the node three.

15
00:03:12,060 --> 00:03:19,560
If it's not found, it's not in the linked list already, minus one. So first we're going to check this. Well, what we not we see one is not close to three.

16
00:03:19,740 --> 00:03:28,740
So let's initialize appointed to this, not two. Then we're going to check two and three. So they are not equal yet. So let's move current to the next.

17
00:03:29,400 --> 00:03:41,310
Now we see three equals two three. So it will return the index of this node three. That is two. So it will return to and counting the index by this variable index.

18
00:03:41,610 --> 00:03:54,900
OK, if you're certain you know, that do not exist in this linked list, then I will return. All right. This is how this harassment works. This method will take off in time complexity for the worst case scenario.

19
00:03:55,380 --> 00:04:08,190
And it will takes constant space complexity since you are just using two variable index and current here. Current is a pointer. We've understood this really explanation.


@@@
1
00:00:00,300 --> 00:00:15,960
Hey, what's up, guys? Welcome back to this video. In this video, we're going to see how to insert in circular single Enquist in this video. We're going to meet three operations added to hate, added detail, added index.

2
00:00:16,740 --> 00:00:27,520
First, we're going to start off with this method, added hate. Then you see added detail, then will see added index. First, let's see added head method.

3
00:00:27,990 --> 00:00:42,750
All right. This is our added hate method. Initially we have this linguist and decided to go. This method takes one parameter. Well, inside here, we're creating a new note with the value.

4
00:00:43,230 --> 00:01:00,390
Then we're checking if heretical Citronelle word will assign head and tail to new node. Then we'll say till the next goal is to hit it. If not ahead equals to null new, not the next to go to head to next to to not really Coldstone unit and size plus klatsch.

5
00:01:00,810 --> 00:01:13,920
If we call this method at a date with one, then we will create a new node with the value one and we're going to say here hadit train equals to new node.

6
00:01:14,580 --> 00:01:30,390
So we're assigning hit undetailed pointed to the new node and then we're going to say here Geldart Mixteco to hate. So we were connecting tail to this note so we're studying the address of this node might be called this function again.

7
00:01:31,770 --> 00:01:43,610
Then we're going to create a new node, ok. And in this case it is not equal to now. So what we're going to do what going to say that next class to hate.

8
00:01:43,620 --> 00:02:00,960
So this is not possible. This is new node. OK, so new node dot next equals to hate and tell the next class to new node and we're going to move ahead to this node.

9
00:02:01,680 --> 00:02:15,530
So this link will be represented, something like this. This is our hate node and this is our tail not and this tail is connected to this hate node. OK, this is how this add at hate method works.

10
00:02:15,660 --> 00:02:32,640
This method will take Spiga of one time complexity and because of one space complexity. Now let's talk about added tail method. Initially we have this linguist, OK, here, this method takes one parameter bell here, creating new node.

11
00:02:32,880 --> 00:02:42,750
And then we're going to check if we're going to assign hidden pointed to the new node, then we're going to say Taylored next to go straight, if not till the next week.

12
00:02:43,110 --> 00:02:53,610
To the next goal is to hate Coldstone Node and or increasing the site. Now let's call this method added to with one. So we're going to create a new node.

13
00:02:53,760 --> 00:03:09,760
And here we're sending Hidell Pointer to this new node. And here we see that here equals to now. So we're assigning hit and killed to this, not the until the next goal to tail that next call straight.

14
00:03:10,050 --> 00:03:18,300
So we're connecting this trail with this hate. So it will still hate the address. Zero zero zero one. So the link list will be represented, something like this.

15
00:03:19,230 --> 00:03:36,300
OK, this is the representation and the size equals to one. Now you call this function again added to two. And here we're creating a new node and we see here is not Egleston also Taylored next to new not so disconnected.

16
00:03:36,330 --> 00:03:51,720
Let's connect to this node and then unitaid next equal to hate. So we're going to connect to this hate and we're going to move tail to this node. And the link list already represented something like this.

17
00:03:52,380 --> 00:04:05,550
OK, the linguist will be represented something like this. This is HAID and this is true. This is how editable method works. This method also takes Bego of one time complexity and big up on space complexity.

18
00:04:06,120 --> 00:04:18,970
Now let's talk about added index method. This is all added to index method for this method. We need a helper method to get node, OK? This method takes two parameter index and eval.

19
00:04:19,720 --> 00:04:32,520
The checking index is less than zero or indexes greater than site and will return here if indexical will apply at a state index equals to site and all apply here at the table.

20
00:04:32,850 --> 00:04:48,630
And this two method we have learned in the previous slide, if index is not equal to zero and index is not equal to the site, then this ELT's statement will be executed here, will create a new node, then we'll get the previous, not the previous node.

21
00:04:48,630 --> 00:04:59,820
The next cluster neonate 900, next cluster previous not dot next. And here to get previous not will call this a helper method. And here we have a current pointer and we're running a little.

22
00:04:59,920 --> 00:05:16,330
To find out the not at index minus one, we have to find it the previous night, for example, after given this link and we have to add antiparticle index to this linguist, let's call this function added index to four.

23
00:05:16,360 --> 00:05:29,620
So we have to add this note for add index, too. So right here in between this to note, let's create a new note here. This is our new node. So we're going to get the previous note to the previous node of the index.

24
00:05:29,620 --> 00:05:44,640
Two is this note. This is our previous not so organized. The previous dot next to numerals is connected to are going to connect to this node. Then we're going to say, you know, that next equals to prevent the next.

25
00:05:44,650 --> 00:05:54,850
So we're going to connect this note to this note. So this note will be inserted right in between these two node two and three. So that linguist will be represented, something like this.

26
00:05:56,260 --> 00:06:07,960
This is how this added index method works. This method takes because in time complexity, since we have to find out the previous node for the worst case scenario and it will take pick up on space complexity.

27
00:06:08,350 --> 00:06:17,950
Well, we have understood this very explanation. If you have any issue understanding this explanation, let us know. Thanks for watching this video. I'll see you in the next video.


@@@
1
00:00:00,360 --> 00:00:24,870
Hey, what's up, guys? Welcome back to this video in this video. We're going to med operation in surplus, including last in this video we're going to implement to delete at index and delete, interlaced delete and index method will delete a note at a particular index and delete enter list all delete the entire list.

2
00:00:24,920 --> 00:00:43,530
Now let's see how we can implement this to method. First, let's talk about this deleted index method and we'll talk about lead into a list method. This is our code for delete at index, the serial helper method that we need to implement this method.

3
00:00:43,530 --> 00:00:54,120
Delete at index. This method takes one parameter. Then here we're checking index is less than zero or index is greater than or equal. Society will just exit by this written statement.

4
00:00:54,600 --> 00:01:08,470
If index equals to zero, then we move it pointed to the next node. If not, then we're going to get the previous not using this here the method, then we will separate the next cluster period.

5
00:01:08,490 --> 00:01:19,180
Next up next. And here, if we find out index cards to size minus one, then we have to move our tail pointed to that note and we're just recruiting the site.

6
00:01:20,340 --> 00:01:34,210
Now, let's see how it works. If we call this method delete at index one. So we have to delete this note. So how we can do this for the first to get the previous note, your previous note and then organize it.

7
00:01:34,290 --> 00:01:46,500
Next goes to the next dot. Next, we'll skip this note and will connect to this. Not now. We see that there is nothing is pointing to this. Not as a garbage collector will collect this note and remove this not from RAM.

8
00:01:47,460 --> 00:02:01,890
You know, in computer room there is a garbage collector, that's all. I just searched for unused data. If it found any unused data, then the garbage collector will remove that unused data from RAM.

9
00:02:02,520 --> 00:02:21,900
So this will be represented. Something like this. We call this method again with this index one, then what's going to happen in this case? We're going to get the previous note and we're going to we're going to say not next week, but next right next to it will disconnect and it will connect to this node.

10
00:02:22,680 --> 00:02:37,950
So it will point to this same node. And now we say there is nothing is pointing to this node. So garbage collected is not and will remove this note. And also we will move our tail pointed to this, in this case, indexical, ostracise Meynet one.

11
00:02:38,090 --> 00:02:58,110
OK, so the link list will be represented, something like this. We have understood this matter to delete at index. This method will take Spiga of in time complexity for the worst case scenario, because we have to find out the previous node of a given index and it will take constant space complexity.

12
00:02:59,100 --> 00:03:12,630
Now let's talk about delete enter list. This method takes no parameter and in turn here we're going to check. If scale is not Citronelle, then we're going to settle the next external and Head and Chillicothe's Tranel and we're going to set aside the Constitution.

13
00:03:13,050 --> 00:03:24,440
So what all this means, first, we're going to check if it is not equal to null if Tali's nautical sternhell ordering and discarding to D-Link by saying Chillicothe's to our children next.

14
00:03:24,450 --> 00:03:40,130
Cottonelle OK, so it will disconnect this link so there is nothing pointing to this. No one except the pointer ahead. Now what are we going to do. We're going to remove this two pointer and we're going to point this two pointer to it now node.

15
00:03:40,530 --> 00:03:58,050
So it is not pointing to this, not until it is not pointing to this node. And we see now there is nothing is pointing to this. Not so this note will be collected by garbage collector and it will be removed then this node there is nothing is pointing to this, not since this node is removed by garbage collector.

16
00:03:58,200 --> 00:04:06,810
So this node also will be collected by garbage collector and garbage collector will remove this node, then this node. And there is nothing is pointing to this node.

17
00:04:06,810 --> 00:04:19,650
So this node also will be removed by garbage collector. And now we see there is nothing in our computer memory and this is how this method works. We have understood this method.

18
00:04:20,010 --> 00:04:29,940
This method works in constant time and constant space complexity. Since we have to meet here these operations, we have understood this with the explanations.

19
00:04:29,940 --> 00:04:37,350
If you have any issue understanding the speed explanation, let us know the source code is addressed to this video. Check it out. Thanks for watching this video.


@@@
1
00:00:01,260 --> 00:00:14,340
Hey, what's up, guys? Welcome back to this video in this video. We're going to see how to create a double-dealing list this hour, not for increased. We have three attributes to prevent next year.

2
00:00:14,340 --> 00:00:26,600
Two pointer priv. And next, this is our downloading list. Initially, head and tail is pointing to now north and south. Kojiro, this is no representation we have to point out.

3
00:00:26,940 --> 00:00:45,750
And next and we have a data, our linguist initially, OK, just in now, no hit and tell will point to this note. This is our code we have here. Note it contains three attributes, Daraprim and next.

4
00:00:45,930 --> 00:00:57,320
And here we have this null note. This is our new representation, OK? And here we have added two matter. It takes on data and we are creating a new node inside.

5
00:00:57,320 --> 00:01:08,880
Then we're going to check. If hidden is equal to null, then we're going to say here is to tell equals new node here we're assigning. Hillendale pointed to the node, if not till the next day goes to new node.

6
00:01:09,530 --> 00:01:20,700
Know that clavicles to tell Anteriorly Goldstone and we're increasing the site later. It works. We call this method. Add a detail with one, then we'll create a new node, OK?

7
00:01:21,120 --> 00:01:33,150
And we will assign here head and tail synch our head initially null, so it will assign head and tail pointer to this node. Now let's call this function again.

8
00:01:33,330 --> 00:01:46,200
Now we'll create another node with the value to now. In this time we see here it is not equal to now so that next year to new not so the next equals two new node is still a tail.

9
00:01:46,800 --> 00:02:03,270
So it will connect this node, something like this, till the next new node. Then you know that goes to tail. So it will connect this node, something like this and then Chillicothe's to nios it will move tail to this node so that link list will be represented.

10
00:02:03,270 --> 00:02:13,950
Something like this. We have your address. We did. I just you can see how it actually works or string the address right here of this note and right here of this note.

11
00:02:14,610 --> 00:02:32,040
If we call this matter again with three then we will create a new node again and will add here till the next we go to new node, something like this, then Ninon that goes to tail and Chillicothe's to unite.

12
00:02:32,400 --> 00:02:44,160
So the links will be represented. Something like this. This is how we can create a list. This method will takes constant space and time complexity since we are doing an operation at a time.

13
00:02:44,550 --> 00:02:56,770
And the size of this linguist is a we have understood this avideo explanation. If an issue understanding this with explanation, let us know. Thanks for watching this video.


@@@
1
00:00:00,450 --> 00:00:17,200
Hey, what's up, guys? Welcome back to this video. In this video, we're going to implement two metatarsus and two towers search method. All searches for a particular value in the first and antiterrorist method will ever still exist from left to right.

2
00:00:17,790 --> 00:00:31,650
Now, let's talk about that first. Let's talk about the terrorist method. This method takes these terrorist methods takes no parameter here. We're taking it very close to now, will print in the list and will get by this written statement.

3
00:00:31,650 --> 00:00:44,670
If not, we're going to initialize the current pointed to Hadnot and will run a while of is is nautical. Citronelle will print the current data. That means the current node values then currently goes to current.

4
00:00:44,850 --> 00:00:52,940
Next here we're moving the current pointed to the next chart. If we call this method trebles and if you're given this link list, then what's going to happen?

5
00:00:53,310 --> 00:01:02,550
First we're going to check had external. No, it is not Goldstar now. So let's create a new pointer that would point to this node. And this note is not a download.

6
00:01:02,550 --> 00:01:18,090
So let's print one and let's move current to the next not so current old point to this node. And we see this node is not enough not to. Let's print here too and let's move on to the next.

7
00:01:18,090 --> 00:01:29,620
Not so current will point to this node and let's print here three. Now let's move to the next node with the current pointed to the next node and this node is not another.

8
00:01:29,640 --> 00:01:40,920
So let's bring the value for let's move on to the next node again. And now we see current point responding to this now node. So this whole loop stuff and we get this output.

9
00:01:40,920 --> 00:02:01,590
One, two, three, four. This is how different method works. This all takes off in time complexity because you have to traverse the link list from left to right once and it will takes constant space complexity since you're just using one pointer current understood terrorist method.

10
00:02:01,770 --> 00:02:15,390
Now let's talk about source method. Now let's talk about source method. This method takes on parameter here. Instead, we're checking if it is equal to null already region minus one or initializing a variable index equals 2.0.

11
00:02:15,810 --> 00:02:26,970
Then you're creating a new point that will point to the head node. Then we're running a wildfowl. Current is not external inside of checking it according to the directions to data then will return the index.

12
00:02:27,450 --> 00:02:52,350
If not, then move to the next node and will increase our index if we do not find this statement is invalided. True. Well, running this live and will return my network if we call this function, if we call this method source with three and if you're given this link list, then first we're going to check this node here is not external.

13
00:02:52,680 --> 00:03:02,740
We see it is not external, so it will not return. Mindich one we have your index is zero will keep tracking the index of our current, not using this index variable.

14
00:03:02,920 --> 00:03:13,620
Then we we're getting a few pointers current that will point to this node. Then we're running a well well count is not Gosta. Now currently the records that we see three is not equal to one.

15
00:03:13,620 --> 00:03:28,480
So let's move on to the next, not the three. Our current not and we see two is not close to three. So let's move again to the next node. Now currently point to this node and in this case we see that the value of this note equals two three.

16
00:03:28,620 --> 00:03:43,620
So in this case, will return the index of this node. The index of this node is two. So it will return to for this function call. If we call this method source with five, then it will return minus one, because five is not just in this link list.

17
00:03:44,250 --> 00:04:04,510
This is how this search method works. This will take Spiga of in time complexity for the worst case, because with the worst case, we have to traverse this link list from left to right and it will take constant space complexity or using one variable index and one pointer current.

18
00:04:04,970 --> 00:04:14,290
What we have understood this Aveda explanation, if should be of any problem. Understanding this with explanation, let us know the source code is attached to this need.


@@@
1
00:00:00,960 --> 00:00:13,020
Hey, yo, what's up, guys? Welcome back to this video in this video. We're going to talk about insertion in DoubleLine list in this video, all going to implement to add at hate and added index.

2
00:00:14,280 --> 00:00:25,410
Now let's talk about added hate. Then we'll talk about added index. This it added hate method. This method takes one parameter here. We're creating a new node with the data.

3
00:00:25,770 --> 00:00:35,160
They're checking if very well, then we're going to initialized Hadil pointer to neonate. That means we're going to assign Hadil points to the new node.

4
00:00:35,760 --> 00:00:50,970
If not, we're going to send the next to go to hate. Hate it. We've we got to new not Heracles to new node and size plus Blatche. If we call this metadata with one that will create a new not pinpointed is now and next pointer is now.

5
00:00:50,970 --> 00:01:06,780
And the current data and the data is one and only as incidental pointed to this node synthetical Sternhell initially. And the site of this linked list is one we call dysfunctioning in added to hatred to the will create a new node in the circuit.

6
00:01:06,780 --> 00:01:22,560
We're going to apply this statement. Nunatak next to calls to hate so nunatak next we got to hate, then headed very close to new node, so headed very close to new node.

7
00:01:23,010 --> 00:01:47,790
And we're going to move ahead to this node. Locating the legalist will be represented, something like this. If we call this function again in recruiting new node, this is not three, then we're going to see a new not the next call to hate pinheaded priv equals to new node and hayday calls to this new node in the link list will be represented, something like this.

8
00:01:48,670 --> 00:02:00,130
OK, this is how this method works. This method will take Spiga of one time complexity and we go of one space complexity. We've understood this method, added Haid.

9
00:02:00,150 --> 00:02:11,130
Now let's talk about added index method. Alright, this is your added index method. To implement this method, we need another method get node. This is a helper method and all that has called.

10
00:02:11,130 --> 00:02:22,320
And in the code you will see this method. This method takes three parameter index and data. It was the index called to the unit will apply added hate method if indexical ostracising will apply here.

11
00:02:22,320 --> 00:02:36,660
Added detail method if index in regards to Duroux and index is not size will apply this code. Let's see how this actually works. Let's see. We call this method added index all three one is index and three is the data.

12
00:02:36,660 --> 00:02:46,800
So we'll insert a node in between these two node. So instead of in between these two. So let's create a node with value three. Then here we're going to do we're going to get the previous node.

13
00:02:46,800 --> 00:03:07,680
This is the previous node then people that next dataprep. So next dot period is not equal to neonate. OK then previous, the next equal to this node, then the pre records to prove node will connect to this node and nunatak next equal to this next node.

14
00:03:07,830 --> 00:03:16,920
Then it will be represented something like this. This is how this method works for better understanding data, everything on a piece of paper. Then it will see how it actually works.

15
00:03:17,460 --> 00:03:28,440
This material takes because in time complexity for the worst case, for this gate node method and it will takes constant space complexity. Well, we have understood this very explanation.


@@@
1
00:00:00,510 --> 00:00:12,430
A lot of guys will come back to this video. In this video, we're going to talk about religion in a e in this video, we're going to implement this to method delete at indexed and delete internalised.

2
00:00:12,450 --> 00:00:25,550
First, let's talk about to delete at Indexed and we'll talk about delete enter list. This is our code for delete at index. First we're going to check that boundary.

3
00:00:25,560 --> 00:00:35,010
If if index is less than zero or indexes greater than or equal to size then all exist by this written statement. It was the index digital. Then it will move.

4
00:00:35,010 --> 00:00:46,000
It pointed to the next node and it will disconnect the previous node for our new height. If index is not related to this ELT's statement will be executed first.

5
00:00:46,000 --> 00:00:54,440
On the previous note, for that we need this method. We're not showing up here. The method we have at the code to this video, check that out in the source code.

6
00:00:54,450 --> 00:01:06,990
We have this method and this is very simple. We can get the previous night by using a follow and the pointer then we're seeing here permanent dot next to codes to prevent the next to the next checking.

7
00:01:06,990 --> 00:01:16,730
If not the next of next is not ReelzChannel. They're going to say permanent the next it pretty to pivot. You've really got to index minus one will move.

8
00:01:16,740 --> 00:01:40,200
It pointed to the president and then it will decrease the site this size will be right here. OK, now let's see how it actually works. If we call this function with index zero, then what's going to happen will move ahead to the not and will disconnect this previous pointer and it will become now then the list will be represented, something like this.

9
00:01:41,790 --> 00:01:53,010
OK, let's take another example from the understanding that you were given this link list and we call this function with the index to indicate what we're going to do or going to find it the previous not of index two.

10
00:01:53,050 --> 00:02:08,820
This is the note of index to the previous node that makes two calls to previous node. Next. Next. Next. So this pointer points to now node. OK, that means it all points to now node something like this.

11
00:02:09,000 --> 00:02:19,500
It's pointing to now node in four and now then we're going to check in previous node the next, the next nautical two. Now then we're going to apply this formula.

12
00:02:19,620 --> 00:02:28,200
But in this case we see that previous the next dot next to No. So this statement will not be executed in our checking evangelical's to indicate minus one.

13
00:02:28,470 --> 00:02:37,440
In this case. It's true. So it will move tail to this note. So the link list represented something like this for better understanding. Let's take another example.

14
00:02:37,950 --> 00:02:52,580
Let's say you're given this long list and we call this function with index one. So this is the node of index one first. What are we going to do? We're going to find that the previous nodes in the previous node then organize the previous node next to go to the previous node, that next to the next.

15
00:02:52,590 --> 00:03:03,600
So we're going to disconnect this note and we're going to connect to this node and then we're going to check your previous knowledge. Next to the next is not to now we're going to say previous next to the next.

16
00:03:03,750 --> 00:03:13,650
That privacy call to prevent this condition is related to this statement will not be executed. And here we see that there is nothing is pointing to this node.

17
00:03:13,800 --> 00:03:21,630
So this node will be collected by garbage collector and garbage collector will remove this note from RAM. Then our linguist will be represented, something like this.

18
00:03:22,260 --> 00:03:34,110
We have understood this everyday explanation. This method takes bigger of in time complexity to find it the previous node, and it will take constant space complexity.

19
00:03:34,590 --> 00:03:44,820
Now let's enter list method. This is our Diligenta list method for us to have this current pointer and we're going to remove the next pointer. This is the next pointer.

20
00:03:44,820 --> 00:03:56,500
This is your next pointer. OK, we have removed the next pointer. Then we're going to remove head and tail pointer from our head until node and we'll move that to now node.

21
00:03:57,420 --> 00:04:05,310
Now we see that there is nothing else pointing to this note. So this note will be collectible garbage collector and it will be removed by garbage collector automatically.

22
00:04:05,460 --> 00:04:12,390
In this note, there is nothing is going to go into this node. So this note will be removed by garbage collector. Then this note there is nothing is pointing to this node.

23
00:04:12,540 --> 00:04:24,060
So garbage collector will remove this note from RAM and this is how it works. The solution will take Spiga of one time and space complexity. We have understood this very explanation.


@@@
1
00:00:00,330 --> 00:00:11,760
Hey, you guys all come back to this video, in this video, we're going to see creation of Sakala, this video, not of a list, OK? They're not all represented, something like this.

2
00:00:11,760 --> 00:00:24,810
And we have here our class, my circler list. And essentially the linked list is now head and tail pointed, is pointed to Knowland and close to zero. This is our nerd a.

3
00:00:25,780 --> 00:00:39,060
OK, and initially we have our no decision were not initially hit until this point to download. And the size is zero. And this is our added tail method.

4
00:00:39,060 --> 00:00:50,790
This method takes one parameter data in recruiting new not here, not checking each side equal to zero to initialize here until pointed to a new note. Then we're going to say till the next goal is to hit hedonistic next.

5
00:00:50,890 --> 00:01:04,370
Still, if not new, not that next to go straight till the next class to know you need to tell daily calls to not hadit new node and size plus. But now let's see how this actually works.

6
00:01:04,380 --> 00:01:15,720
Initially we have this lengthiest we call this a method with one, then will create a new node with data one. And we have your next pointer since the citable link is zero.

7
00:01:15,810 --> 00:01:23,060
So initialize hidden until pointed to this note and we'll will to tailgating close to hit header next week or two. So the long list will be represented.

8
00:01:23,070 --> 00:01:35,760
Something like this we're storing as priv the edges of this note and as next the edges of this note. So we have a circle here. We can go from here to here and we can go from here to here.

9
00:01:35,970 --> 00:01:45,840
And we call this function at a table with two will create a new node. And here will say now here we are at this ILD statement here, Nunatak next equals three eight.

10
00:01:46,080 --> 00:02:02,940
So Newlander next equals to hate. And then the next question. So we're going to disconnect this link, OK, from here to here. So we're going to disconnect this link from here to here and we're going to say here to this next node.

11
00:02:02,940 --> 00:02:11,520
But we have here another link, something like this from here to here. This link is already exist, but we've removed this link. This might be a little bit complex.

12
00:02:11,520 --> 00:02:24,270
Don't worry. Then we're going to set new records. To do so will connect this note to this tale and will move tail to this node and also headed to unit.

13
00:02:24,630 --> 00:02:37,050
And it looks a little bit crazy. Don't worry about that. It will be represented something like this. Try to wrap your head around with this problem, then it'll make sense if we call this method added to it three.

14
00:02:37,290 --> 00:02:50,700
And let's create a new node here. So, you know, dot next class to hate this. Next all points to this hate. OK, then next we go to New Node. So we're going to disconnect this link, something like this.

15
00:02:51,000 --> 00:03:02,100
We have a link, something like this from table to hate. So we're going to disconnect this and we're going to connect to this node. OK, then it's really close to new node.

16
00:03:02,100 --> 00:03:13,800
We're going to move this point to this note. We're going to move to this node and then we're going to see headed pretty close to new node and it will be represented, something like this.

17
00:03:14,880 --> 00:03:27,600
We've understood this very explanation's understanding. Try to look at this code here. We have here to arrow with this same line that might confuse you, but don't worry about it.

18
00:03:28,050 --> 00:03:43,070
Try to write out on this piece of paper so you will see how it works. This method will take constant time and constant space complexity since we're doing the operations in constant time and we're not using any additional spit off.

19
00:03:43,120 --> 00:03:51,600
We have understood this with the explanations. If you have any issue understanding this explanation, let us know the source code is addressed to this video.


@@@
1
00:00:00,870 --> 00:00:11,130
And lots of guys will come back to this video in this video. We're going to talk about SARS and terror smattered in Sakala exist in this video. We're going to implement this tomato sauce and terrorists.

2
00:00:12,390 --> 00:00:22,620
And let's talk about sauce method. This method takes one parameter data as input. Then we're taking Heracles oil region manager and then we're taking the one overhead.

3
00:00:22,620 --> 00:00:32,820
Not if the reservoir hit new records to Data Zero, then we're initializing the index one. Then we're initializing a current pointer to the next overhead note.

4
00:00:33,210 --> 00:00:45,060
Then we're running a Wildfowl guarantees in regards to hate. We're going to check current records to data. If it's related to an index, then we're increasing the index and we're moving current to the next pointer.

5
00:00:45,660 --> 00:01:00,870
After doing this a while of if this condition is never related to, then it will return minus one. Now let's see how it actually works. We call this function for stretching the hadnot and develop is one that is not equal to three.

6
00:01:01,140 --> 00:01:10,380
So we'll move to the next node and one of these, not two, is not equal to three. So let's move to the next node by the current pointer and develop this node.

7
00:01:10,380 --> 00:01:30,690
Threes equals four threes already on the index of this node since the index at your best. So the index of this node is to zero one two. So it will return to if we call this function with five, it will return minus one, minus one because the node value five does not exist in this linked list.

8
00:01:30,690 --> 00:01:40,980
So it will return minus what we have understood the search method. This method will take Spiga of in time complexity for the worst case scenario, and it will take Spiga of one space complexity.

9
00:01:41,430 --> 00:01:49,310
The source code is attached to this video. Check that out. Now let's talk about terror method. This is a terrorist method. This method takes no parameter here.

10
00:01:49,630 --> 00:02:01,470
You've got to now will be able to list and will exist by this written statement. Then print here will print developer hadnot not. So let's print one then were initially pointed to the next report hadnot.

11
00:02:01,740 --> 00:02:15,180
And this is not to hit. So let's print to then let's move to the next node. And this is not pointing to hate node, so let's develop this. Not the three then will point to this node and we see this General Hayden also.

12
00:02:15,840 --> 00:02:34,710
This will stop. This is what we can Devers is subclassing lengthiest? We have understood this with the explanations. This matter will take Spiga in time, complexity, whatever the linguist from left to right wants, and it will takes constant space complexity.

13
00:02:35,430 --> 00:02:45,240
So that time, karpinsky is because in the space complexity is big of one. This is my implementation of terror. Smattered, the source code is attached to this video.

14
00:02:45,240 --> 00:02:53,220
Check that out if any question with an issue understanding this with explanation. Let us thanks for watching this video. I'll see you in the next video.


@@@
1
00:00:00,840 --> 00:00:15,890
Hey, what's up, guys? Welcome back to this video. In this video, we're going to talk about insertion in circle, at least in this video. We're going to implement two method added hate and added index for Sakala and linguist.

2
00:00:16,500 --> 00:00:27,510
First, let's talk about added hate method. Then all talk about added index method. This is the code for added hate method. This method takes on parameter.

3
00:00:27,960 --> 00:00:37,080
Then right inside here we're creating a new node with the data. Then we're checking if site equals digital, then we will initialize until pointed to the new node.

4
00:00:37,470 --> 00:00:51,650
Then Heytesbury goes to tail until the next call to hate if not new, not very close to tell, till the next goal is to new node 960 goals to hate hate it Marigold's to neonate radicals to neonate size, blah blah.

5
00:00:52,110 --> 00:01:06,720
This is the code. Now let's see how it actually works. If we call this method added hate with one initially we have this linguist head and tail pointer is pointing to download again here.

6
00:01:07,050 --> 00:01:21,240
This code will be applied because cycles to GIRoA. Initially here we have created a node with data one and then we're going to initialize your Hadil pointed to this node and then it say he did very close to tell.

7
00:01:21,570 --> 00:01:46,890
He did Pericles retail and taylored mixed equals to hate. So we see a circle here. This is called circular linguist. Now we because this method again with data to then we're going to create a new node here with data to then we have to apply here we to apply this statement here new not the typical STR tail.

8
00:01:47,140 --> 00:02:07,140
So this is a new note that equals to tail. OK, then guilded next equal to the next equals to new node and here 960 got to head. This is next. Next equal to a hate and hated passive equals to new node.

9
00:02:07,860 --> 00:02:17,370
Here we have connected the head and tail node. Then what are we going to do. We're going to move ahead to the neonate. So we're going to move ahead. Pointed to this node.

10
00:02:17,850 --> 00:02:25,800
This might seem a little bit complicated. Don't worry. Try to write it everything on a piece of paper, then it'll make sense. And the link this represented something like this.

11
00:02:26,430 --> 00:02:41,040
Maybe call this function again with data three. Let's create a node with three data. Now let's create a node with data three. And here we have prev and next now we have empty empty means nothing now.

12
00:02:41,280 --> 00:03:01,860
So let's apply this statement here. Perry, Pericles to tail. So we're going to apply to this to the until the next Coldstone node. So this is still till next equals to new node and new node, but next equal to hate.

13
00:03:02,160 --> 00:03:13,700
So we're going to connect to this. So we have connected this next of this new not to hate and hated Pravy calls to this node and we're going to move it pointed to this note.

14
00:03:14,280 --> 00:03:32,100
Then the link list will be represented, something like this. This is how this added hate method works. This method will take off on time and off on space complexity since we're adding one node to the hate at a time.

15
00:03:32,520 --> 00:03:44,270
So it will takes constant time and constant space complexity. Now let's talk about added index method. This is added index method. This method takes two parameter index and data here.

16
00:03:44,370 --> 00:03:56,970
Checking index is less than zero or indexes greater than size then will exist by this written statement. Then we're checking if index equals to the road and will call this function with a data added hate data.

17
00:03:57,570 --> 00:04:07,860
LCP If we found indexical size then we call this method added to. If not, then we will apply this statement and will increase the site. Appalling list.

18
00:04:08,400 --> 00:04:17,850
If we call this method added index with one and three, we have to add this node three at index one. So the neutral because in between these two nodes.

19
00:04:18,330 --> 00:04:27,570
So let's create a node with there are three and here let's apply this formula. So we've created a new node and the Prevnar, this is a positive note. We're not showing up here.

20
00:04:27,570 --> 00:04:40,290
The implementation of K.A. method, the source code is attached to this video, to the source code where we have the implementation of this method. Then what we're going to do, we're going to say that next EcoStar new node.

21
00:04:40,470 --> 00:04:52,470
So priv not the next equal to this note. We want to connect this pointed to this node, then new node don't go to pavement. So we went to connect to this, not to this node.

22
00:04:53,080 --> 00:05:07,880
OK, then you need it next course to have DOT next we're going to connect to this node. And that makes it very close to neonate. We're going to connect this link to this note and this is how it works.

23
00:05:08,460 --> 00:05:16,550
The linguist will be represented, something like this, and this is how it works. This method will take speak of in time complexity for the worst case scenario.

24
00:05:16,560 --> 00:05:26,660
We've defined it the previous not and it will takes constant space complexity. We have understood this very explanation. If you have an issue, understand this with explanation.

25
00:05:26,670 --> 00:05:36,630
Let us know if you have an issues understanding the method, edited and edited index, then try to write it everything on a piece of paper. Then it all makes sense.


@@@
1
00:00:00,390 --> 00:00:15,780
Hey, you guys all come back to this video in this video, we're going to talk about the in circle, at least in this video, we're going to implement two method delete at index and delete entire list for circler list.

2
00:00:16,410 --> 00:00:44,450
First, let's talk about looked at indexed and we'll talk about delete and list this each hour. Delete at index method. This method takes one parameter index inside here or checking if index is less than zero or index is greater than or equal to size, then will affected by this written statement ebc see index equal to zero then will move to the next node.

3
00:00:44,700 --> 00:00:58,590
They are going to say till the next is to hate. Hate it because to tell you that we're going to find out the previous node for that we need this method get node one and showing here the method we have at the source code to this.

4
00:00:58,620 --> 00:01:12,420
We can check that out where we have the implementation of this method. Then here, the next goal is to prevent that next or next. If not dot, next dot next is not null.

5
00:01:12,930 --> 00:01:26,550
Then we will say not the next, but next it Pericles the preeminent ipsi the to index minus one the tail equals to prev not and size minus minus. Here we have this if statement.

6
00:01:27,150 --> 00:01:45,410
We can remove this statement for circular list. No worry. We can use this statement. Now let's see how this actually works. If we call this function with index zero, that means we have to remove the first node at index zero.

7
00:01:45,450 --> 00:01:58,920
This is the first node here. What are we going to do? We're going to move hate to this node, OK, synch indexical to zero. Then we're going to see till the next goal to hate.

8
00:01:59,250 --> 00:02:10,590
So till the next goal is to hit, we're going to disconnect this and we will connect to this node. Since this is our new hate, then it pretty close to kill.

9
00:02:10,920 --> 00:02:29,490
So we will disconnect this and we will connect it to this link, get something like this. Now we see that there is nothing is pointing to this node. So this node will be collected by garbage collectors and garbage collector will remove this node.

10
00:02:29,730 --> 00:02:47,000
So our linguist will be represented. Something like this we have understood for better understanding. Let's take another example. If we say delete at indexed two for this linked list, in this case, we have to remove this node, OK?

11
00:02:47,330 --> 00:03:06,560
You don't want to. The index of this node is two for dysfunctional. We see that this statement is false. Now this statement will be executed. So first of the final, the permanent decision will not be an organism, not the next course to prevent the next to the next.

12
00:03:06,900 --> 00:03:19,780
So not the next equal to the next dot next. So it will point to this node. OK, then we're going to check, if not the next. The next is not equal to now.

13
00:03:19,800 --> 00:03:31,920
We see pregnant dot next dot next is not go to trial. In this case, hate not hate node is not a noun. Not so we're going to say head node dot Pericles to pivot.

14
00:03:32,160 --> 00:03:46,890
So we're going to we're going to connect this link to this node and we're going to remove this link since we have connected the brief to this node. There is this site called Index Minus One.

15
00:03:46,980 --> 00:04:00,600
So it will move daily to this period and will decrease the size of this link list. And now we see that there is nothing is pointing to this node. OK, so this node will be collected regardless.

16
00:04:00,600 --> 00:04:11,130
Collector and garbage collector will remove this note from RAM, not the link list will be represented. Something like this. We have understood how it works.

17
00:04:11,490 --> 00:04:24,030
Now, let's take another example for better understanding. Let's say we're giving this link list and we call this function with index one in this case to remove this node for that first trip to find out the previous note.

18
00:04:24,030 --> 00:04:41,450
This in your previous, not the previous the next then previous node, the next two calls to previous, not the next or the next. So we're going to skip this node and we're going to connect to this node and then we're going to see here PEB, not DOT next to next is not Goldstar.

19
00:04:41,480 --> 00:04:57,060
Now we see this node is not now, not so this node because the pavement. So we're going to connect this node to this node, OK, and this is condition. It already defaults.

20
00:04:57,420 --> 00:05:13,310
So this statement will only be executed and then we. The site. Now we see that there is nothing is pointing to this, not so this not all be collected by garbage collector and garbage collector will do this not automatically from computer memory dinner linguist will be represented something like this.

21
00:05:13,820 --> 00:05:27,260
Then a linguist will be represented, something like this. Or we have understood this method at index. This method will take Spiga of in time complexity and it will takes constant space complexity.

22
00:05:28,160 --> 00:05:42,500
Now let's talk about delete enter list method. This is your delete angel list method. First you're going to check if it is not going to say, hey, we got to know if this is not done until the next goal is to know.

23
00:05:42,740 --> 00:06:01,950
And then we're going to initialize current pointer to hate and we're going to disconnect the link. The next link from is Node again. And here also we have disconnected this prevented by this statement and the next note for our tenant.

24
00:06:02,270 --> 00:06:26,540
OK, so these are disconnected. Now we're going to disconnect head until pointer. So let's remove a hidden tail pointer and let's disconnect them and let's point Hayden tail to include and we see that there is nothing is pointing to this taylored since this is disconnected and this next pointer for this node is disconnected.

25
00:06:26,750 --> 00:06:37,100
So there is nothing is pointing to this node. So this note will be removed by garbage collector automatically from REM. Then we have this node. There is nothing is pointing to this node.

26
00:06:37,220 --> 00:06:46,940
So this note will be removed. Reagonomics collector then this node there is nothing is pointing to this note. So this note will be removed by garbage collector from computer memory.

27
00:06:47,450 --> 00:06:58,340
This matter will decrease because in time complexity, because you have to disconnect. The next pointer for is not and the solution will decrease because of one space complexity.

28
00:06:59,290 --> 00:07:07,500
We have understood this will transition. The source code is attached to this video. Check that out. If we have an issue understanding this very explanation, let us know.


@@@
1
00:00:00,690 --> 00:00:11,850
Hey, guys, welcome to this video. Now we're going to solve a classical linked list calling the problem, you're given a single interest and you have to reverse it.

2
00:00:12,090 --> 00:00:22,430
You have to solve this problem iteratively and recursively. We have already solved this problem. Incredibly, we have a video link in the description. Check that out.

3
00:00:22,650 --> 00:00:40,480
Now we're going to solve this problem recursively. This is going to be a little critical to understand when you are going to solve this problem. Using recursion, for example, if you were given this link list, then you have to reverse it.

4
00:00:41,580 --> 00:00:53,490
So this node becomes the head of our reversed link list. OK, first four, then three, then two, then one. Then now. So we have to return this link list.

5
00:00:54,360 --> 00:01:09,510
So for this given input, will return this link list, if you will. Given this link list, we have to reverse it first. This is not five and this is now our head for the revised linked list.

6
00:01:09,900 --> 00:01:26,010
Then four, then three, then two, then one. Then now. OK, so we have to return this link list if we are given this link list now, let's see how we can solve this problem recursively for the sake of understanding.

7
00:01:26,010 --> 00:01:41,670
Let's assume we're given this list. OK, first we're going to declare two points ahead and NextEd that will point to the head of our given list. Now for the first recursive function call.

8
00:01:42,000 --> 00:01:56,270
First, we will move this pointed to this, not to the will this coming to this. And then we'll connect this node to now node. OK, and this is for first recursive function call.

9
00:01:56,610 --> 00:02:16,520
Now this is our head for the new function call. Now this is the head of our list for the next recursive function call. OK, so this is our head. And then we have the next note pointed to the next of our head and what we're going to do.

10
00:02:16,520 --> 00:02:28,140
What we're going to disconnect is we're going to connect it to now node. OK, then this node will be our head for the next recursive function call. All right.

11
00:02:28,530 --> 00:02:38,460
Now, again, we're going to disconnect this. We're going to connect it to that now node. Then this will be represented like this. Now we have this node.

12
00:02:38,620 --> 00:02:54,060
This is the head for our next recursive function call. OK, so this is the head. So what we have done at this hour, we have done for recursive function call and we found our best case.

13
00:02:54,060 --> 00:03:09,870
It this is our best case. It's OK. And here for is recursive function called we're disconnecting the head node from the link list. So here we disconnected one, then we disconnected two.

14
00:03:10,080 --> 00:03:29,340
When we disconnected this node, it means that we disconnected here as well. OK, when we disconnected this Node three from the link list, then we're disconnecting this node and this note, as will be called in the computer memory.

15
00:03:29,580 --> 00:03:40,890
We have the same node. We don't have the different not four is recursive function call. We're just changing the pointer for is recursive function call.

16
00:03:41,190 --> 00:03:54,750
OK, so here we have this node for that points to know now what we're going to do. We're going to return this node for as our head node because this will be the head for our revised linguist.

17
00:03:55,110 --> 00:04:09,570
And this head pointer is pointing to this node for then we have this next node pointer and this pointing to this node. For now, we're going to disconnect this pointer and we're going to connect it to this node three, how we can do that.

18
00:04:09,570 --> 00:04:22,140
We can do that by using formula next node that makes the call to hate. And we have had this not for this pointer is pointing to, not for in the computer memory.

19
00:04:22,170 --> 00:04:34,920
Right. If we return this node, then what we will have will have all the node we have connected to this node, for we don't have to worry about what we're doing on the top.

20
00:04:36,210 --> 00:04:50,970
We don't have to worry about what we're doing in the recursive function. Call still this pointer here, we created a new pointer, new head, this pointer responding to the node for in the computer memory.

21
00:04:50,970 --> 00:04:59,610
Right. If we have something that is connected to this note, then we will have all the node is connected to this node. So here we are disconnecting this note from this node.

22
00:05:00,000 --> 00:05:12,340
Now, incompetent memory is written now in computer memory. This note is three, this not three is connected to this note four. And here this head pointer points to this note three.

23
00:05:12,660 --> 00:05:23,350
Now here this. McFarland is pointing to this note three as well. If we say mixed note that makes the call to head, then this will connect to this note.

24
00:05:23,580 --> 00:05:37,710
It means that we're adding this note to to this note three as well, because all the notes are same in the computer memory. We don't have to worry about what they're doing on the previous recursive function call.

25
00:05:38,100 --> 00:05:49,810
OK, so basically it means this not get connected to this note to then right here, if we say next and the next to go through, now we're connecting this node to this node one.

26
00:05:50,710 --> 00:06:08,110
OK, what we're doing, we're just adding this, not one to this node to by the link or by the pointer. So what does this means? It means that we're adding the pointer of node to to the node one, OK?

27
00:06:08,280 --> 00:06:20,730
That basically means that we're adding the pointer of this, not two to this, not one, because all the nodes are in computer memory. Now our new head is still pointing to this node for now.

28
00:06:20,730 --> 00:06:33,710
It will return this note for that will get all the node is connected to this note for. And here we see node three node to not one is connected to this node four separate and this network.

29
00:06:33,900 --> 00:06:51,270
Then we'll have our reversed Renquist. This is going to be a little bit critical to understand this problem. Be tricky to understand once you understand the concept, a pointer that you will be able to understood this problem easily.

30
00:06:51,750 --> 00:07:12,060
If you take a look at this picture and what I have said then. It will make sense this is the code to solve this problem first. We're checking if the given link missed it and now then will return the now if we see the next load of our.

31
00:07:12,900 --> 00:07:30,950
Current node is now then will return the head. That means the current node and that not will be our head. And here we're just manipulating pointer and and here we're disconnecting the Hadnot for its recursive call stack.

32
00:07:31,380 --> 00:07:44,870
Then this is our new head. This new unit will be assigned right here and this will stay the same for all the recursive function called Stack. And here we're just reversing the node and will return the new hit.

33
00:07:45,390 --> 00:07:56,820
It will point to the node for all ages. And if we have the node for that will get all the node is connected to this note for and this is how we can solve this problem.

34
00:07:57,150 --> 00:08:11,430
The solution will take Spiga off in time complexity. The solution will text because in time complexity and because of in space complexity or it is the number of nodes in the given linked list.

35
00:08:11,460 --> 00:08:25,980
Alright guys who've you have understood this problem in a very high level. If you aren't clear, if you are not understanding the speedy explanation, try to go through with the pseudocode, with your own examples, then it will make sense.

36
00:08:26,100 --> 00:08:38,790
If you are understanding still, then take a look at this picture, then it will make sense. I have another video on this problem. I will link that video in the description it can all that video.

37
00:08:39,300 --> 00:08:49,980
I hope it was the video link in the description. Then you will be able to understood this problem clearly. Thanks for watching this video and I'll see you in the next video.


@@@
1
00:00:01,620 --> 00:00:28,020
Now we're going to solve a classical lengthiest, calling it a problem reverse link list, you're given a single linguist and you have to reverse it. If they solve this problem iteratively and recursively in this video, we're going to solve this problem iteratively and I'll create another video where we will solve this problem recursively.

2
00:00:29,700 --> 00:00:45,320
For example, if you're given this linguist, we have to reverse it. If we reverse it for not only our head, then three, then two, then one, then this one not pointing to download.

3
00:00:45,540 --> 00:00:59,130
All right. And this is our hate. So we have to return this linguist, if you will, given this link list, then you have to reverse it. If we reverse it, five becomes our hate.

4
00:01:00,260 --> 00:01:16,570
Then four, then three, then two, then one, then now. OK, so if we reverse this long list, we get this linked list. So we have to return this link list now how we can solve this problem iteratively.

5
00:01:17,810 --> 00:01:33,170
No, let me go through the intuition. Now, let me show you how we can solve this problem. For the sake of understanding, let's assume we're given this list, this is our Hadland.

6
00:01:33,380 --> 00:01:45,440
OK, we're going to declare appointer current. That would point to Hayden. Now we're going to declare two pointer that points to download PRIV and 10th.

7
00:01:46,620 --> 00:02:08,360
First, we're going to move this 10 pointer to the next up current, so 10 pointer will point to this note to. OK, now we're going to disconnect this link and we're going to connect this link to this now, not where people point it points to.

8
00:02:09,610 --> 00:02:24,000
OK, then we're going to move three pointer to current and current to 10th. Now we're going to move temp to the next up current, so temporal point here.

9
00:02:24,620 --> 00:02:38,450
Now we're going to disconnect this link and we're going to connect it. Three pointer pointing. OK, so we connect this to this node. Now we're going to move pointer to current.

10
00:02:39,400 --> 00:02:57,690
And current pointer to temp. All right, now let's move this team point to the next note, her current pointer points to then let's disconnect this link and let connected the pointer point.

11
00:02:58,450 --> 00:03:21,150
So. We connect here now, we're going to move three pointer to current and current to temp. Now let's move to the next up current tempo point here. Now, let's disconnect this link and let connected to the halfway point it points to.

12
00:03:22,470 --> 00:03:40,900
Now let me point out to current and current to temp. OK, when you see current pointer is pointing to a now not old stuff and will return, the happy pointer is pointing.

13
00:03:41,980 --> 00:03:56,820
We see that this is the head of Reversed Lindqvist. You will return this head. That means we're returning the reversed legalist, the reverse link listed for three to one now.

14
00:03:57,130 --> 00:04:09,940
So we're returning this legalist and this is how we can solve this problem for better understanding. Let's take another example. Now, let's suppose that we're given this long list.

15
00:04:10,750 --> 00:04:25,440
This is our head node, OK? And we're going to declare a new pointer current that points to this hadnot. Then we're going to declare 2.0, pave the response to Norrland and 10th that it also points to download.

16
00:04:26,870 --> 00:04:53,870
Now our goal is to move the ten pointer to the next node. Her current pointer is pointing. So we'll move temp to this, not to. Now, we're going to disconnect this link and we're going to connect it to the not point it points to in this case, but Pointer is pointing to a not so well connected to the download.

17
00:04:54,080 --> 00:05:11,960
Now we're going to move the pointer to current and current to tenth. OK, let's move the temp to the next up current. So temp lowpoint here. Now, let's disconnect this link and let's connected to the node pointer is pointing.

18
00:05:12,140 --> 00:05:28,190
OK, now let's move on to current and current pointer to temp. Now let's move the temp point to the next node where our current pointer is pointing. Now let's disconnect this link and let's connected to the node pointer is pointing.

19
00:05:28,370 --> 00:05:39,830
OK, now let's move to current and current temp. Now let's move to the next node and let's disconnected. That's connected to the node. Halfway point it is pointing.

20
00:05:39,980 --> 00:05:52,770
Now let's move to current and current to temp. Now let's move to the next up current. So point it will point to this now node and we're going to disconnect this link that's connected to this node.

21
00:05:52,910 --> 00:06:10,180
Now let's move a pointer to this node and current pointed to this note. We see current pointer is pointing to announce it. When we see current pointer is pointing to another, it will return the pointer or the node pointer is pointing in.

22
00:06:10,610 --> 00:06:29,570
We see this is the head of our Rivers link. The reverse link listed five, four, three, two, one. Now. OK. And this is how we can solve this problem. The solution will take off in time complexity when it is the number of not in the given list.

23
00:06:29,570 --> 00:06:42,500
And it all takes constant space complexity. Since we're just using some pointer, we are not using any additional spit to solve this problem and this is how we can solve this problem iteratively.

24
00:06:42,770 --> 00:06:54,320
Now let me go through the pseudocode for a better understanding. OK, here we have our pseudocode first, let's review our pseudocode, then we'll see how it works.

25
00:06:55,200 --> 00:07:07,500
First, all the function, reverse the text ahead of a given list, then will declare a three pointer of current and temp. Then we're going to run a live well current in regards to now and here.

26
00:07:07,500 --> 00:07:21,150
We're manipulating the pointer. We are disconnecting, we connecting and removing moving pointers. OK, at the end of this three pointer will point to the head of reversed lengthiest right for first iteration.

27
00:07:21,150 --> 00:07:34,170
If we're giving a linguist one, two, three, four. Now, then for the first iteration, that link list will be represented like this. Then for second iteration of this Wellinghoff, the linked list will be represented like this.

28
00:07:34,560 --> 00:07:48,480
Then for third generation, the linked list will be represented like this, and for fourth iteration, the linked list will be represented like this. And here this is the head of our revised linguist.

29
00:07:48,660 --> 00:08:02,100
So all this linked list here you can see for three to one and now is our revised linked list. OK, I'm not going to go through this pseudocode line by line.

30
00:08:03,090 --> 00:08:16,830
If I go through the pseudocode line by line that you will get bored. I don't want that for better understanding. Take a look at this picture. Only then you can understand this problem easily.

31
00:08:17,160 --> 00:08:29,850
The solution only takes because in time, complexity is the number of nodes in the given linked list and it all takes constant space complexity. Alright guys, this is my solution to this problem.


@@@
1
00:00:00,480 --> 00:00:11,340
Hey, what's up, guys? Welcome back to this video in this video. We're going to talk about what is stick. Stick is a data structure used to store a collection of objects.

2
00:00:12,090 --> 00:00:30,870
It is just like a pile of letters kept on top of each other, something like this. We have your six plate, one plate, top of the other. They say that top flight, if you want to place in new blood, then you have to put the pledge to the top of this pile.

3
00:00:31,690 --> 00:00:45,870
You'll be want to place a plate to the bottom, then hurry up to do. We have to remove all the plates. Then you have to place the plate to the bottom. We can make two operations.

4
00:00:46,350 --> 00:00:58,830
We can put a new blood on the top or we can remove the top plate. And this principle is called Last In, First Out, the last item. That is the first item to go out.

5
00:00:59,100 --> 00:01:18,750
So in this pile, we see that we have six plate. We have to remove all the plate. We can we can only remove the plate from the top again if we remove all the plate from this pile, only then we can place a new pledge to the bottom.

6
00:01:19,540 --> 00:01:33,840
OK, and this is an example of standard structure and the principle of standard structure is level last in, first out. If we add a new plate right over here, this is called Last In.

7
00:01:33,990 --> 00:01:45,090
And if we want to remove a plate from this pile, then you have to remove the plate from the top. And that's called first out. So it's called last in, first out.

8
00:01:45,600 --> 00:01:56,700
Now let's talk about Leifur principle up stick. Putting an element on the top of the stack is called push operation. Removing an item from the top of the stack is called pop operation.

9
00:01:57,300 --> 00:02:08,600
So this is our stick it we say here, push and let's push it one. Now on the stack, we have only one element. There is one now we have this stack here.

10
00:02:08,610 --> 00:02:19,040
OK, let's push two to this stack. Now we have this stack and we have only one element we call this method pop. Pop will remove the element from the top.

11
00:02:19,230 --> 00:02:30,120
So if we remove the element from the top, then we are left with only one element. If we push another element to this stack, then we have to eliminate to this stack again.

12
00:02:30,120 --> 00:02:41,120
If we push three and we have added three. So we have three element on this stack, ABC puff. It will remove the top element, then elected only Willmot one and two.

13
00:02:41,310 --> 00:02:52,080
So we are putting an item on the top of the stack by this push operation and removing an item from the top of the stack using this pop operation. And this is called push and pop operation.

14
00:02:52,230 --> 00:03:04,170
This is the common operations in a stack that we can meet and this is called principle last in, first out. So by this push operation we see lost in and by these operations last out.

15
00:03:04,230 --> 00:03:16,500
This is called Leifur Principle Up Stick. Now let's talk about operation in Steck. We have five common operation in a stack push operation. By this push operation, we can add an element to the top of it.

16
00:03:16,500 --> 00:03:28,050
Stick by this operation. We can remove an element from the top of Aztek is empty. This operation will check if the stack is empty is pull, it will take.

17
00:03:28,050 --> 00:03:40,390
If the stack is full and peak, it will get the value of the top element without removing it. Also have another operation that is called delete stack and that will implement right in the section.

18
00:03:40,410 --> 00:03:59,160
Don't worry about that. And this fight with the common operations that it can made on a stack we have here stack. So let's push on into the stack. So we have pushed one element to the stack and that is for if we say POF, it will be done for and it will remove the top element and that is four and related three element up doing this operation.

19
00:03:59,640 --> 00:04:11,750
Now in the stack, if we made these operations or we call this method is empty irreligion false because the stack is not empty, APC is full and we see that this track is not full.

20
00:04:11,840 --> 00:04:28,140
We consider the side of the stack is for this check is not full. We can add one more element to this stack. So it will return false since the stack is not full and pig operations, these operations will retain the top element and it will not remove the top element.

21
00:04:28,360 --> 00:04:36,570
OK, and this is the current operations that it can meet if another operation that is called the stack and that it will delete a stack from a computer memory.

22
00:04:36,600 --> 00:04:45,510
OK, and you'll see how we can implement that right in this section. Now, let's talk about application of stick. We use a stack in compilers, compilers.

23
00:04:45,510 --> 00:04:59,610
It was the stack to calculate the value of expressions like two plus four divided five times seven minus nine. And that's insert this parentheses by converting the extrusions to prefix.

24
00:04:59,720 --> 00:05:12,930
Our postscript for so in order to calculate that expression, we have to use a stick and embroider the back burning browser saves all that you realise you have visited previously in a stack.

25
00:05:13,170 --> 00:05:25,760
Each time you visit a new page, it is added on top of the stack. When you press the button, the current URL is removed from the stack and the previous Eurail is accessed.

26
00:05:27,510 --> 00:05:42,470
This is an example of our borders backburn and this is back button. OK, and let's say we visited this five website, first Facebook, then linking, then you, then Google and we see here Google, OK?

27
00:05:42,750 --> 00:05:56,160
And this will be represented in Steck, something like this first year Facebook, then linking that Udemy, then Google. If we press to this beg pardon, then it will remove this site from Steck and it will move to you to decide.

28
00:05:56,430 --> 00:06:12,090
If we click on this back button again, it will remove this item from Steck and it will move to this site linking. If we click on backburn again then it will move to Facebook dot com again and click on back button again.

29
00:06:12,090 --> 00:06:25,550
Then it will, then it will move to the empty tab. OK, this is how Steck works. This is a real example of Steck. This backburn is implemented using is have understood the concept of Steck.


@@@
1
00:00:00,600 --> 00:00:18,810
Hey, what's up, guys? Welcome back to this video. In this video, we're going to talk about implementation option of Steck. We can implement step into this is an array or using a list for every implementation we have pros and cons pros is that it's easy to implement.

2
00:00:18,810 --> 00:00:36,120
And the cons is that the site of an error is fixed. So the sage of Steck will be fixed. And that might be an issue for some Kasit and for linguist implementation process that the site can be changed.

3
00:00:36,480 --> 00:00:48,970
It's a variable site. We can change the size during runtime and Korn's is that it Mordred to implement and it's a little bit difficult to implement, but for our implementation is super easy.

4
00:00:49,770 --> 00:00:58,050
Now let's see the common operations we can meet for an implementation and for legalist implementation. For an implementation. We can make this method here.

5
00:00:58,170 --> 00:01:10,650
Push POF peak is empty, Espoo and Delyth Steck and full implementation. We don't know the site. OK, so we can't implement this method for linguist's implementation.

6
00:01:10,880 --> 00:01:26,940
Sparklingly we have Push-Pull Peak is empty and Delyth Stack method right in this section and we'll see how we can implement STAC using area and will implement all the method and also we'll see how we can implement STAC using linguist and will implement all the method.


@@@
1
00:00:00,480 --> 00:00:14,280
Hey, what's up, guys? Welcome back to this video. In this video, we're going to see STAC implementation using error and we're going to implement Steck from scratch using Ouray for our implementation.

2
00:00:14,470 --> 00:00:27,060
The pros is it's easy to implement. And how is it fixed? Saidi's, we can change the site. Now let's see some operations that will be implementing in this video.

3
00:00:27,840 --> 00:00:45,240
In this video will implement these two operations, create Steck push operation and pop operation. This is the code for Steck implementation using every Urabe class, Streck is an array.

4
00:00:45,830 --> 00:01:01,310
And here we have this error and we have this horrible trouble. Steck And we have here seven methods. Great Steck Push-Pull Peak is empty, is the little stack and will implement this three method in this video.

5
00:01:01,550 --> 00:01:13,400
Now let's talk about create Steck method. Here we have created Tegmental. This method takes one parameter site inside here we're creating a new area with the given site and type of area he to manage one.

6
00:01:13,550 --> 00:01:30,860
Using this variable, we will keep track our tough element in our stack. Since you are implementing STAC using every you because this method with five, they're creating a new integer array of LENTE five and we have index number for each cell for first sale.

7
00:01:30,860 --> 00:01:46,190
Index number is zero for the Kinsale in this number is one and so on. We're using zero programming language throughout discourse. When you create an integer array in Java, the default value for all the sale of an array are zero.

8
00:01:46,310 --> 00:02:00,860
We're not showing you zero. Just for sake of understanding. We're assuming that the array is now empty and top of agriculture minus one. Using this array will keep track our top element in our stack and the stack will be represented.

9
00:02:00,860 --> 00:02:10,850
Something like this. The stack is empty. This is just a visualization of a stack. But internally we're using array to represent a stack. Now let's see push method.

10
00:02:11,060 --> 00:02:23,280
This is our push method. This method takes one prominent dhara inside here. We're checking if the length of the array minus only goes to top up stack, then will print stack overflow later.

11
00:02:23,510 --> 00:02:43,670
That means the stack is already full. We can't insert any more element to the stack if not all. Insert the data at the index. Top of array plus one currently top of error is minus one and it will insert the first sale initially, then removing top of stick to the next element.

12
00:02:43,670 --> 00:02:58,970
And we're printing here. Insert it now. Let's see how it works. Now if we call this method push with one, what's going to happen? We're going to insert this one to this area and insert to this first select top of error.

13
00:02:58,970 --> 00:03:11,960
Plus one is zero percent top of arrays, minus one. So we'll insert the data one to this cell. And in the stack, it will be represented something like this, and it will insert right over here.

14
00:03:12,050 --> 00:03:29,990
And the value of this type of array will be changed to zero. Now, if we call this method again, push with two, then what's going to happen? We're going to insert this data to this sale of index one and we can get the index of this sale by saying DUBOV three plus one.

15
00:03:30,170 --> 00:03:43,910
So zero plus one is one. So let's insert here too and in the stack as well. And we're just showing you the visualization of the stack and stack will be represented, something like this, and develop this a little bit.

16
00:03:43,910 --> 00:04:03,620
Ten to one, maybe call this method again with three then it will be inserted here and it will be represented something like this in Stack and it will be increased to two if we call this matter again, push for, will insert here for and still will be represented.

17
00:04:03,620 --> 00:04:12,020
Something like this. The top element is four and the value of this variable is a three. So what are you doing here or increasing develop? This variable is time.

18
00:04:12,050 --> 00:04:23,180
Why? We want to access the top element in this area. We see the top element in this adding. The top element is this element four. And with this index number, we can get the top element.

19
00:04:23,180 --> 00:04:42,230
And in the stack we see that this is the top element, OK? And that's why we're using this variable to keep track our top element. Since you're using heavy implementation of Stack, if you call this method with five, then five will be inserted right here, also here for the presentation.

20
00:04:42,410 --> 00:04:52,850
And this value of this will only be interesting for now. We see our second full. If we call again, push six, then it will throw this error stack overflow error.

21
00:04:53,150 --> 00:05:07,640
It will not be inserted in our stack since the stack is full. This is how this Bush operation works and this is how we can implement push method. Now let's talk about pop method with pop method all remove and return the top element.

22
00:05:07,910 --> 00:05:18,920
Now let's see how we can do that. This is your method. This method takes no parameter. And here we're taking up top obstacles to management that will print stack underflow error that means or stack it's empty.

23
00:05:19,190 --> 00:05:35,290
Empiricists grubstake is minus one. That means our stake is empty. Then we're storing the top value to this temp variable and we're printing the value of ten variable and then we're setting that.

24
00:05:35,780 --> 00:05:46,570
Two zero percent only created an area, an integer area in Java, the default is zero that were in 13 years and are decreasing the site of top of stack variables.

25
00:05:47,000 --> 00:05:56,510
So it will pop out the top element. Then our next top element would be the previous element. OK, that's what we're decreasing the size of this variable.

26
00:05:56,690 --> 00:06:11,690
Now, if we call here pof, then what's going to happen? It will remove this element five and we can access this element of this index number. So it will remove this element and it will return the element five and the five will be removed from our stack as well.

27
00:06:11,870 --> 00:06:20,340
Since we're just showing you here the stack representation, actually working with this array and the sides of this variable will be decreased to three.

28
00:06:20,450 --> 00:06:32,600
So our stack will be represented something like this and will be represented something like this. If we call this method again, Pop, it will return for if we call this method POF again, what's going to happen?

29
00:06:32,600 --> 00:06:48,280
It will return and remove this element four from our stack and do set to zero and it will return four and four will be removed from our stack and the site of this variable will be changed to our top element is three.

30
00:06:48,290 --> 00:07:03,920
And with this variable we can access the top element. And this is why we're using top of every variable. All right. This is all about this push and pop operation we have understood push operation, pop operation and create stack operation.

31
00:07:04,250 --> 00:07:21,470
This stack operation will takes a bigger of one time complexity and we go of one space complexity since we're creating the array at once. And this variable, this Operation Push operation will also bigger up on time and space complexity.

32
00:07:22,190 --> 00:07:33,650
This pop operation also takes bigger of one time and space complexity. We have understood this every explanation in this video. We have explained great stack push and pop operation.

33
00:07:34,100 --> 00:07:44,750
In the next video we'll talk about in the next video, we'll talk about big operation is empty, operation is full operation and stack operation see in the next video.


@@@
1
00:00:00,480 --> 00:00:09,630
A lot of guys will come back to this video in this video. We're going to talk about in this video, we're going to talk about this for operations peak operation.

2
00:00:10,170 --> 00:00:19,860
Is the operation in full operation and the lipstick operation? In the previous video we have talked about these three operations create Streck push and pop operation.

3
00:00:20,370 --> 00:00:34,050
Now, let's talk about this for operations. First, let's talk about peak operation right in this video. We're going to see this for method. Now let's talk about peak operation for peak operations.

4
00:00:34,050 --> 00:00:47,750
This method takes no parameter inside here or checking. It obviously goes to management. Then we are printing here, stack empty. If not, then we're printing the top of our stack.

5
00:00:47,760 --> 00:01:09,560
If we call this method and if are given this area as a stick and he wrapped up Arrigo's to and this area will be represented something like this, since we're implementing STAC using every we call this method, this method will return five because five is the tough element in this attack and this is peak operations.

6
00:01:09,570 --> 00:01:18,570
It's pretty simple. And this operation will take up on time and big up one space complexity. We have understood peak operation. Now let's talk about the rest of the operation.

7
00:01:18,810 --> 00:01:28,410
This is a major operation. This operation will return to our efforts. If the stack is empty, then it will return. True, if the strike is not empty, it will return false.

8
00:01:28,410 --> 00:01:48,120
If we call this method is empty for this given stack, then it will return false because the stack is not empty. And for this method is full. Checking if every landmine lentivirus, when it goes to top up stack, then we're returning to, if not already false for this given stereotypical this method, it will return.

9
00:01:48,120 --> 00:02:06,270
True, because this because the size of this stack is full, so it will return true. Then we have this method stack and here we are used to now and obviously you've got to monitor it because this method that will be set to now so arrogant, deleted from our computer memory and the stack will be removed as well.

10
00:02:06,270 --> 00:02:15,960
This is just a representation of our error. So our stack is removed from our computer memory and all of the operational text. We go off on time and space complexity.

11
00:02:15,960 --> 00:02:27,810
This operation takes up one time the face complexity. This operation also takes up one time and space complexity. This operation as well takes up one time and space complexity.

12
00:02:27,930 --> 00:02:41,000
We have understood this very explanation. I test the source code in Java for STAC implementation. Using every single source file. You have an equation in it's addition or with an issue understanding this better explanation.


@@@
1
00:00:00,570 --> 00:00:13,810
Hey, what's up, guys? Welcome back to this video. In this video, we're going to see Steck implementation using lengthiest when you will implement this six method for linguists implementation.

2
00:00:13,830 --> 00:00:24,520
In this video, we're going to see how they implement this three method. In the next video, we'll see how they implement this three method. Now, let's talk about grades, tech push and pop operation.

3
00:00:25,230 --> 00:00:36,900
Let's start off with great tech operations. This is our code for STAC implementation using linguist. First, we have this class node. This is our node.

4
00:00:37,140 --> 00:00:49,640
This node contains two attributes, data and the next pointer we have. You know, this is our head node for our linked list. When you were calling this method or initializing Hajja now pointer.

5
00:00:49,740 --> 00:01:02,340
So our initial linguist is now and this is our head node. OK. It will be tough for our stack and the stack will be represented. Something like this. Now stack is empty since the list is empty.

6
00:01:02,370 --> 00:01:25,110
Now let's talk about push operations. This is the push method. OK, this method takes one parameter data inside Iraq, recruiting a new node. And then we're going to check if it's true now then to go to new node, if not NENO the next go to head and ahady to unit, maybe call this method with data one then will create a new node.

7
00:01:25,350 --> 00:01:38,040
Since the head of a list is not initially will move our head to this new thing, the linguist will be represented something like this. And this is our stack of Lenthall one.

8
00:01:38,250 --> 00:01:52,930
And we have here one element on our stack and here will be our top element. Maybe call this method to push it to the node, create a new node with the data to and here it will apply this ELT's statement since it is not now.

9
00:01:53,040 --> 00:02:08,060
So here we're going to say the next to go through it. So the next equals to hate and Hayday Gholston. So it points to this not only be represented, something like this and our stack will be represented, something like this.

10
00:02:08,730 --> 00:02:21,430
This is just a visual representation of Stack and this is our Hadnot, OK, and this is our top of our stack. I call this method push with three, then will create a new node with there are three.

11
00:02:22,050 --> 00:02:31,080
And here we're going to send in the next to go through Hatswell connected to this node and will move it pointed to this node. Then all Englis will be represented, something like this.

12
00:02:31,080 --> 00:02:50,310
And this is the representation of our stack. And they said, OK, this is our push method works and this is tech. This is a linguist. But we are treating this as a check since we're inserting our data to the front and this linguist is represented something like this.

13
00:02:50,460 --> 00:03:02,830
And in the script we have three. The top element now, if we made here peg operations, the operations will retain the value from our top of our stick. If simply, say, redon headed data, then it will return this value.

14
00:03:03,300 --> 00:03:12,660
Don't worry about that. It will explain every single detail. Now let's talk about the pop operation. The studio operations newsmedia takes no parameter inside your checking.

15
00:03:12,660 --> 00:03:30,660
If it goes to know, you're going to say Streck is empty ELT's print developer head node and move over here to the next node. OK, if we call pop method, what's going to happen so it will print the value three one and return the value or just printing the value we can reach and the value.

16
00:03:30,780 --> 00:03:38,280
What we're just printing the value here. Don't worry about that. If you want to return the value you can return the value. But we're just printing here.

17
00:03:38,340 --> 00:03:47,580
Here we're going to print the value of our head, not with your head, not all. Print three. So this method will print three and we're going to move ahead to the next node.

18
00:03:47,730 --> 00:03:57,560
So if we move ahead to the next node, then we see there is nothing is pointing to this node. So this note will be removed by garbage collected from our computer memory, from our stack representation.

19
00:03:57,690 --> 00:04:14,490
This value tree will be removed. OK, our link list will be represented. Something like this, if we call this matter again, in this case, the head we see to the top of our stack is to and we'll print the value of this aid node that is two.

20
00:04:14,940 --> 00:04:28,320
So it will print here too, and it will move ahead to the next node. And there is nothing is pointing to this. Not so garbage character will automatically remove this note from RAM and this will be removed from our stack representation.

21
00:04:28,500 --> 00:04:36,500
This is just a representation of our linguist. OK, so our Stegall represented something like this. So this is our linguist and this is our representation.

22
00:04:36,660 --> 00:04:49,440
This is how we can implement Stack using linguist. It's not that difficult, but if you understood the concept, this punishment, it only takes because of one time and space complexity.

23
00:04:49,740 --> 00:05:02,320
And this operations also takes picture of one time and space complexity. Understood this very explanation in the next video we'll talk about. Is empty and it's checkmated.


@@@
1
00:00:00,360 --> 00:00:09,810
Hey, what's up, guys? Welcome back to this video. In this video, we're going to talk about STAC implementation using linguist and this is the second part in this video.

2
00:00:09,840 --> 00:00:22,860
We're going to implement this three method. It's empty handed. Let's take first let's talk about peak, then we'll talk about it. Then we'll talk about the let's take now let's start off with this pick method.

3
00:00:23,610 --> 00:00:32,700
So in this video, we're going to see this three method. Let's talk about peak method. Let's say we're given this link list and this link list is represented as something like this.

4
00:00:33,210 --> 00:00:44,460
This is the top element, OK? This method takes no parameter inside here or checking if you go through now, will print stack is empty. If not, will print the value from our note.

5
00:00:45,030 --> 00:00:55,590
If we call this method, this method will print for from our hadnot because the header is for we see in our stack the top element is four. So it print four.

6
00:00:56,280 --> 00:01:21,390
If we were given this stack and this link lists and the visualisation of this link list at the stack, something like this, we call this method for this stack, then it will return a three because the overhead node or the variable are tough because the value of our history and that means on the top of our SEC, we have three to it print three.

7
00:01:22,130 --> 00:01:31,470
We have understood the peak method. This method will take Spiga up on time and space complexity. That means this method works in constant time and constant space complexity.

8
00:01:31,770 --> 00:01:55,420
Now let's talk about is empty. The solution is implemented. This method takes no parameter inside your checking if to one region into if not all going to return false for this given stack we call this method is empty it religion false because it is not now this method takes because of one time and space complexity is super easy.

9
00:01:55,760 --> 00:02:07,190
OK, now let's talk about the last method. Let's check this super interesting here. We're just seeing here you got Sternhell. So it was very good to know the entire link is to be deleted.

10
00:02:07,210 --> 00:02:19,560
That means that Steckel will be deleted if we remove this pointer from this. Not any point to this head to now note that means to nothing. And now we see that there is nothing pointing to this node.

11
00:02:19,560 --> 00:02:28,620
So garlic's to remove this not from REM. And then this node we see there is nothing else pointing to this node. So this will be removed by garbage collector.

12
00:02:28,620 --> 00:02:38,820
And then this note there is there is nothing else pointing to this, not this note will be removed by garbage collector. So this stack will be deleted as well, because this track is a visualization of all linguist.

13
00:02:39,090 --> 00:02:51,270
Since we're implementing Steck isn't a linguist, this method will take Spiga of one time and space complexity. We've understood this very expression. I tell the source code to the source code in the source code.

14
00:02:51,270 --> 00:03:00,210
We have the implementation of all of our methods. If we have an issue understanding this, be the explanation, let us know. Thanks for watching. I'll see you in the next video.


@@@
1
00:00:00,360 --> 00:00:20,270
You're given a string containing just the characters, this bracket, did you mind if the input string is valid and input inputting is valid, if open brackets must be closed by the same type of bracket and open bracket must be closed in the correct order?

2
00:00:20,490 --> 00:00:33,900
Not that an empty string is also considered valid. If we have input this combination of bracket, then the program should return. True, because this is a valid point, is it?

3
00:00:34,200 --> 00:00:48,510
If we have this combination of brackets, then we should return. True, because this is valid combination. If we have input like this, then we should return false because this is invalid format.

4
00:00:48,730 --> 00:01:00,180
Now let's see my solution in pseudocode. All right. Now let's see how my solution might look like. For sake of understanding, let's assume this is our input string.

5
00:01:00,360 --> 00:01:12,930
First, I'll iterate through this string from left to right here we will have a hash table that will map close bracket to corresponding opening bracket.

6
00:01:13,170 --> 00:01:27,490
And also we have a stack here and here. I have the algorithm for the solution. Now let's see how this algorithm works. OK, here for AI from zero to one input minus one.

7
00:01:28,110 --> 00:01:46,500
So for this string, you do work from zero to three, right? Because of this input is four four. One is three. For first iteration of this love, the value of I equals to zero for value, i.e. close to zero.

8
00:01:46,620 --> 00:02:01,470
It points to this bracket in the string. Right. And here we have it condition. If Hasdrubal does not contain key input, I it points to this first character in this string and there is this bracket.

9
00:02:01,920 --> 00:02:14,920
Does this character it just has to be ASCII. No, it does not exist. Then this condition will be false. All right, then you push to this check this character.

10
00:02:14,970 --> 00:02:29,140
All right, then we have this character for the next iteration of AI. The value will be one. When we have equal to one, then it will points to this bracket in the string has the will that contains key import AI.

11
00:02:29,220 --> 00:02:42,360
And that means this character does this opening bracket it just in our heads. Tobolowsky No, it does not exist. Then it will push to the stack for the next iteration.

12
00:02:42,360 --> 00:02:54,440
The value of I will be too. So in this time it points to this bracket. This close brackets has a table that contains this bracket. Does this bracket. It just has how stable.

13
00:02:54,720 --> 00:03:10,740
Yes, it does. So it pops out whatever we have in the stack and it's store in variable, pop this pop function, remove the element from our stack from atop our stack and it's return that value.

14
00:03:11,100 --> 00:03:23,360
And here we call this bracket and you're going to take does pop in this case, this bracket not equal to hash table. Do not get input. Charite I input it.

15
00:03:23,370 --> 00:03:36,540
I is this bracket right we have in our house table and the value against this bracket. We have this opening bracket. So this bracket and this bracket is a match so it will not return false.

16
00:03:36,750 --> 00:03:53,130
Now for next iteration the value of I will be three and it points to this plus bracket and this bracket. It just has table. So it will pop out this this bracket from this stack and it will be stored in this variable.

17
00:03:53,430 --> 00:04:09,000
Now we have real close to this bracket and here are going to take does pop not equal to has to get input charity. So it will points to this input and whatever we have, it has to against this.

18
00:04:09,300 --> 00:04:22,650
We have here this bracket. Right. And this bracket and the pop equal. So, so it is false then it will not return. And now the iteration over and we have your empty stack.

19
00:04:22,860 --> 00:04:35,250
If we have empty stack after all the iteration, that means this is a valid parenthesis. So then we're going to just return standard empty. If we have a stack empty, then it will return.

20
00:04:35,250 --> 00:04:59,340
True. So for this function, it will return just true for this input string. This will return true. All right. Because we have empty stack at the end and the solution takes bigger of in time complexity because you have to visit is character in the screen once the solution takes space complexity.

21
00:04:59,990 --> 00:05:13,310
Of in her end is the length of the given string for the worst case scenario we might have in a number of element in our stack. So space complexity because in hope, this concept not clear.


@@@
1
00:00:00,450 --> 00:00:09,960
Hey, you want some guys or come back to this video in this video, we're going to talk about a recording interview problem string. This is a tech problem.

2
00:00:10,380 --> 00:00:20,940
In this problem, you're given a string. The string is encoded string. You have to decode that string. How should it be called the string? Here we have three.

3
00:00:20,940 --> 00:00:33,720
Then e we have to repeat this here three times. You will repeat this three times. Didn't get triple A.. Then we have to and then your bracket intended bracket.

4
00:00:33,720 --> 00:00:47,310
We have B C here. We have to repeat Besi twice. If we repeat it twice then the string will be represented, something like this. This is our encoded string and it would decode this string.

5
00:00:47,310 --> 00:01:01,530
So we get these strings. So for this input, we have to return these strings. For example, if you're given these strings, we have to decode districts decision encoded string first.

6
00:01:01,530 --> 00:01:15,810
What are have to do first? We have to repeat this twice. We repeat this citywide. We get something like this double C and on the left of to Toussie we have a so let's insert here.

7
00:01:16,650 --> 00:01:29,490
Now we have to repeat s.E.C. Three times. If we repeat s.E.C. Three times then the string will be represented, something like this. So this is the encoded string and this is the decoded string.

8
00:01:29,730 --> 00:01:42,690
For this given encoded string we have to return this decoded string. For example, if we're given this string, we have to decode this strings. First trip to the we have ABC.

9
00:01:43,110 --> 00:01:55,310
There is no nested recist so we don't have to worry about that here. We have to repeat ABC to ITP, to ABC to tonight, then we get ABC, ABC, then we have three KDDI.

10
00:01:56,250 --> 00:02:11,130
So we have to repeat Sidhe three times. So City, city, city. Then we have this string EAF. So let's insert here F so this is all encoded string and this is your decoded string.

11
00:02:11,340 --> 00:02:24,480
You were given this string left to return this string. What we've understood how to decode the given string in this problem. You might assume the given string is ologists invalid.

12
00:02:25,350 --> 00:02:38,850
Now how we can approach this problem when you encountered parenthesized problem we tend to use is check. Yes, this is a problems to solve this problem we have to use to stack.

13
00:02:39,600 --> 00:03:02,520
One is called nonstick and another is called string stack. Let's see how can solve this problem using two stack. The two were given these strings and we have yet to stick, no stick and string stick, and we need to reboot a string builder and it turns a variable and iterate through the string from left to right.

14
00:03:02,890 --> 00:03:21,320
The first character in the string is a tree. This tree's inside a string. So a three ring, three as a character. When it finally does, it will run in love to find out that does it, if that is it, if that is it is a greater than nine.

15
00:03:21,680 --> 00:03:33,390
OK, since we have only one number here, three. So let's insert three to our numbers. And let's move to the next character. The next character is opening brackets.

16
00:03:33,630 --> 00:03:46,290
When you found it opening brackets, what we're going to do, we're going to insert whatever we have in our builder variable to string stack. We have our empty string.

17
00:03:46,290 --> 00:03:56,310
So we have inserted here industry and all set the string builder to empty string, the string builder already empty string. So nothing need to be done here.

18
00:03:57,600 --> 00:04:09,960
Now, let's go to the next character, the next character is a whenever he found a character is in English, all of it, what are we going to do? We're going to insert that character to Sting Builder.

19
00:04:10,080 --> 00:04:27,150
Then let's move to the next character, the next character we see closing brackets whenever we found closing brackets will pop out the top element from string stack, in this case in the string and the sting, all assigned to temp variable we have here in the string.

20
00:04:27,150 --> 00:04:36,300
So let's purported this empty string. Let's assume this empties into this 10th variable since this temp variable is already empty string. So nothing need to be done here.

21
00:04:36,390 --> 00:04:47,040
Now, the next thing we're going to do, we're going to pop out the top element from domestic, and that is three. Now, let's repeat whatever we have at Steam Builder two times.

22
00:04:47,040 --> 00:05:06,630
If we repeat it three times using Loof and we're going to insert it to our temp variable and we're going to spend it. OK, so if we repeat it three times and it happened three, eight to this time variable, then we get something like this, then we're going to change the string builder with the temp variable.

23
00:05:06,810 --> 00:05:19,100
So builder records to people and temp records to empty string and the temp will be reset to empty string because we'll use this temp variable in each statement.

24
00:05:19,140 --> 00:05:30,210
So this temporary is a temporary variable will lose the value when we move to the next iteration. We'll see when we will go through our pseudocode. Then our next character.

25
00:05:30,420 --> 00:05:40,920
Next character is a digit. So let's insert two to our domestic. Then let's move to the next character. The next character is opening brackets. Whenever we found opening brackets.

26
00:05:41,100 --> 00:05:53,220
What are you going to do? We're going to we're going to insert whatever we have at Steenbergen variable to strings. So we're going to insert a two hour string stack and will sit still.

27
00:05:53,220 --> 00:06:05,360
We need to empty string. Now, let's move to the next character. The next character is the English alphabet. So let's insert B to our string builder and we're going to happen to be Torstein Builder.

28
00:06:05,520 --> 00:06:16,350
The next character is C, C, C is English alphabet. So let's so let's insert C to our esteemed builder. Now let's move to the next character. The next character is closing bracket.

29
00:06:16,490 --> 00:06:28,830
Whatever he found, closing bracket. What we're going to do, we're going to pop out the top element from string stack in this case cheaply. And we're going to assign this crippler to tenth variable.

30
00:06:29,130 --> 00:06:41,040
Then the next thing, we're going to populate the top element from nonstick in this case two. And we're going to repeat whatever we have at starting Veldon variable two times using Aluf.

31
00:06:41,250 --> 00:06:56,610
And we're going to appoint Besi by repeating two times to this available temp. So it will be represented something like this, a busy, busy. Now we're going to mutate or change this single variable using this temp variable.

32
00:06:56,700 --> 00:07:09,120
So we're will to go through it Bekesi and will lose this value for temp variable since this is a temporary variable because you are using this variable inside a statement.

33
00:07:09,510 --> 00:07:18,270
When we're done with our current iterations, we'll lose the value. OK, so Tempy goes to empty. Then in the next iteration, we're out of our starting boundary.

34
00:07:18,390 --> 00:07:32,010
So we're done. Now, what are we going to do? We're going to convert or a string builder to string and will return this time. Our answer for this given string is this string Sepehr, given this string of return, this string.

35
00:07:32,400 --> 00:07:43,620
Now, let's take another example for better understanding. Now, let's say we're given this string. We have to check and we have here two variables, string builder and temp.

36
00:07:43,620 --> 00:07:53,250
So let's iterate through the string from left to right. First, we have the character three three the digits. So let's insert three to our nonstick. This is single digit.

37
00:07:53,730 --> 00:08:04,380
If we have a deficit that is greater than nine, we will run enough to get the number and the number in certain nonstick since three, the single digit.

38
00:08:04,470 --> 00:08:19,950
So let's in the three toward nonstick, then let's move to the next guy to the next character is opening brackets whenever he found opening brackets. What will do we will insert is B two skiing's check and it will sit as we do empty string.

39
00:08:20,070 --> 00:08:30,060
So let's insert here empty string since we have is because the empty string and all set as we term this thing, since we have as we go through MDT, nothing to be done here.

40
00:08:30,270 --> 00:08:39,120
Now let's go to the next character. Next character is a is English alphabet. So let's insert a Torstein builder, then let's move to the next character.

41
00:08:39,120 --> 00:08:48,030
The next character is two, two is a desert. So let's insert two to our nom stick. No, let's move to the next character. Next character is opening brackets.

42
00:08:48,270 --> 00:09:02,500
When we found opening brackets, what are we going to do? We're going to insert a whatever we have at is be variable to string STAC. So let's insert here this into to this screen and let's sit as we do empty string.

43
00:09:02,760 --> 00:09:11,700
Now let's move to the next character, next character season. Let's add see to our steam builder, then next character. Next character is causing bracket.

44
00:09:11,850 --> 00:09:26,000
Winnability found closing bracket. What will do will remove the top element from string stack and it will assign that element to 10th variable. So let's pop out this air from this string stack and let's send it to this temp variable.

45
00:09:26,130 --> 00:09:40,140
The next thing we have to do, we have to populate the top element from nonstick, and that is true. So let's pop out to and let's repeat whatever we have at Stringbean available two times using Aluf.

46
00:09:40,140 --> 00:09:51,300
If we repeat see two times we get CESI and let's append Sissi to this temp variable. So s.E.C. Now let's set this time variable to the string builder.

47
00:09:51,480 --> 00:10:03,270
So String Builder equals two s.E.C. And since this is a temporary variable to lose this value. Now let's move to the next character. The next character is closing bracket.

48
00:10:03,570 --> 00:10:13,570
When a closing bracket will out that top element from starting stack and assign that value to ten variable, we have an empty string. So let's put in this thing.

49
00:10:13,590 --> 00:10:23,730
Let's send it to temp variable, the temp variable already in the string. So nothing need to be done here. Then the next thing up to the top level from domestic there is three.

50
00:10:24,120 --> 00:10:35,370
And let's repeat, what we have at is available three times. If we repeat it three times, we get the SC, SC and let's add that reputation for this standard variable.

51
00:10:35,580 --> 00:10:51,410
So we get s.E.C SC, SC and let's set this time variable to still be available so we get steam. With regards to the SC SC, since temp is a temporary variable, so it will lose develop temp variable in the next iteration.

52
00:10:51,600 --> 00:11:03,830
Now let's move to the next character and we see that we're out of string boundary. So we're done now. What are we going to do? We're going to convert this string builder into string and we're going to return this string decision.

53
00:11:03,870 --> 00:11:23,670
We can solve this problem. The solution only takes bigger off in time, complexity, synch, whatever the given string from left to right once. And it all takes off in space complexity because you have to construct to stack num stack is still stick.

54
00:11:23,670 --> 00:11:38,910
Also string builder and temp variable. Actually for the first kid it might takes bigger foreign time complexity. Actually for the first kid it might take be four in space complexity and that's equivalent to Big Ofin because four is a constant.

55
00:11:39,000 --> 00:11:54,930
We can ignore constant in complexity. Analyze it. Now let's see the pseudocode this year for the court to solve this problem. We have this function called string it, take the string in recreating to stack naoum stack and still stack the newer cutting a variable string builder.

56
00:11:55,200 --> 00:12:07,410
Then we're calculating the length of our given string. Then we're running a little for I from zero to lend minus one inside you. We're getting the current character and we're taking the current character Indesit.

57
00:12:07,680 --> 00:12:24,480
Then we're getting the number by subtracting the ASCII value based, obstructing the ASCII value of zero from our current digit, then we're running. Aluf, if our number is greater than ten, then we have to get the number and or inserting that number to the nums.

58
00:12:24,480 --> 00:12:37,980
Take your current character is opening bracket. Then we're going to convert the string builder. Interesting. And we're going to insert that to our strings check and we're going to set a string builder to empty string.

59
00:12:38,250 --> 00:12:49,800
Elusive. If we see our current character is closing bracket, then we're going to populate the top element from our NUM stake and then we're going to populate the top element from our strings and we're going to create a new steam builder.

60
00:12:49,920 --> 00:13:02,220
And here temp is the temporary string builder. And we're running our love to repeat the string builder, repeat times again and we're setting Stingley records to tens.

61
00:13:02,550 --> 00:13:11,340
If not, we found our current character in the English alphabet. We're going to appoint that character to string builder. At the end. It will convert our string builder.

62
00:13:11,640 --> 00:13:25,560
In this case, it should be string builder, not just our string builder to string and will return that. And this is how it works. The solution will take Spiga off in time complexity and we go off in space complexity.

63
00:13:25,740 --> 00:13:36,360
For the worst case, it might take Spiga of foreign space complexity that's equivalent to big of in this region. I'm still in this door, still stick to our given string.

64
00:13:36,360 --> 00:13:50,370
And here we have a skin builder and we have your tenth variable first frame or does it? So let's insert journalistic then we have our opening bracket only you have opening bracket will insert whatever we have at similar to our starting stack.

65
00:13:50,370 --> 00:14:08,970
We have empty. So let's insert your empty and let's set arresting Bellata empty and that already empty. Evil character that's intercounty towards team builder of closing bracket and closing bracket will support from sitting at the top 10 writable timbrell is already empty.

66
00:14:09,240 --> 00:14:18,460
Now, let's pop out the top element from Nomsa. That is true. And let's repeat it right. If we repeat it tonight, if we add that to our team variables, we get to be close to 80.

67
00:14:18,720 --> 00:14:30,660
And that's what we're doing. Using this falloff, then we're going to set this temp to this steam builder, OK? And that's what we're doing right here. And it will lose the developed variable when you move to the next iteration.

68
00:14:30,960 --> 00:14:46,470
Since you're declaring this variable inside this elative statement, then we have this desire to Siletz in such to our numbers. Then we are opening bracket when we found opening brackets or converting letters and will add that to our existing stack.

69
00:14:46,800 --> 00:15:00,390
So that's inside here. And let's add it to empty string. Then we have C, so let's add C to our string builder. Then we have a closing brackets. When you have closing bracket will pop out a couple of interesting Steck and will add that to our team variable.

70
00:15:00,540 --> 00:15:14,070
So let's add here E and A and that's what we're doing right here, will pop out the top element and we're adding that to ten variable. Then we're going to pop out the top element from domestic and we're going to repeat C two times, C two times.

71
00:15:14,070 --> 00:15:28,440
And if we add that to our temp, we get is what is happening here. OK, using this statement, Tim, what happened is B and then we're going to set these temps to this as B variable so we get s.E.C.

72
00:15:28,710 --> 00:15:40,500
And we lose the value of this time variable. So let's remove it in the next iteration will move to the out of string boundaries. So we're done and then we'll convert this building into string and it will return the string.

73
00:15:40,650 --> 00:15:50,250
So for this given input, we have to return this string. This is how we can solve this problem if we have understood this video. Explanation's the source code is attached to this video.


@@@
1
00:00:00,660 --> 00:00:15,090
Hey, yo, what's up, guys? Welcome back to this video in this video. We're going to talk about queue data structure. Queue is abstract data structure similar to stack and like stack queue is open at the bottom end.

2
00:00:15,540 --> 00:00:30,710
One end is all ologist used to in search of data and the other end is used to remove data. Inserting data in the queue is called in queue and removing data from queue is called dequeue.

3
00:00:31,110 --> 00:00:47,610
Here we have some peoples there standing in line. Let's say they're standing in a line and they want to book ticket. The first person who comes to this line first will get the ticket first.

4
00:00:47,820 --> 00:01:02,360
First, this person will get the ticket, then this person will get the ticket and then this person will get the ticket and so on. If we want to add a new person, the person should stand at the end of this line.

5
00:01:02,370 --> 00:01:13,590
So right here and here, we see the first person who will get the tickets. So first in first out queue and data structure works in first in first principles.

6
00:01:13,800 --> 00:01:24,810
The first person who comes first will go out first. OK, in this line we see that this person come first so this person will get the ticket first from the ticket counter.

7
00:01:24,960 --> 00:01:43,530
So this is called FIPA principles. First in, first out. Inserting data is called in queue and removing the array is called a dequeue. If you want to add a new person to this line, then the person should stand to the end and the person from the front will get the ticket.

8
00:01:43,950 --> 00:01:56,580
This is called FEBA Principle and this is the entire concept of queue data structure. Now let's talk about operation in queue. In queue. This operation will add an element to the end of the queue.

9
00:01:56,760 --> 00:02:12,520
Dequeue you do remove an element from the front of the queue is empty. It will check that he is empty in spool. It will check if the queue is full. It will get to the value of the element from the front without removing it.

10
00:02:13,110 --> 00:02:29,910
And these are common operations in queue. Can parfume. That's simple given this queue and we we have inserted that into this cute using this in cooperation it ridicule, it will remove the element from the front and it will retain that element.

11
00:02:30,210 --> 00:02:41,220
If we made this operation, it will check. If the queue is empty, it will return to the queue is not empty, it will return. False is full in this get it will return.

12
00:02:41,490 --> 00:02:53,520
True in the queue is full. If the queue is not full, this operation will return false. This operation will return element from the front without removing the front element.

13
00:02:54,270 --> 00:03:09,970
Now let's talk about the application of queue. We use Q for CPU's scheduling when the data is transferred asynchronously between two processes, the Q is used for synchronization.

14
00:03:09,980 --> 00:03:26,350
For example, I have four pipes, file, Faleiro, etc. for handling the interruption in realtime systems. We use Q in call center phone systems, use cues to hold people calling them in order.

15
00:03:27,270 --> 00:03:44,120
These are the application of Q We have understood what is a Q data structure, how it works, which operation we can perform using cues and the application of cues from the next video we'll start implementing.


@@@
1
00:00:00,870 --> 00:00:12,510
Hey, what's up, guys? Welcome back to this video. In this video, we're going to talk about Kuis implementation options. We can implement cute using Arry and we can implement cute using linguist for our implementation.

2
00:00:12,540 --> 00:00:22,980
We have two types of cues, a linear cue and circular cue for linguists implementation. We have only one type of skill that is linear. Q Okay. And in this section of discourse Alsi linear.

3
00:00:22,980 --> 00:00:33,790
Q And Zaghloul confusing array and linear. Q isn't linked in linear implementation of Arry. We might face some problems and that problem we can overcome using Sakaki.


@@@
1
00:00:01,140 --> 00:00:10,560
Hey, yo, what's up, guys? Welcome back to this video. In this video, we're going to talk about a linear cue using. We're going to implement using arem in this video.

2
00:00:10,590 --> 00:00:20,400
We're going to implement this seven method, create queue, including your peak is empty is will and delete queue. Now, let's start off with create queue.

3
00:00:20,640 --> 00:00:33,480
This is our linear queue is already in your class. Here we have array to variable front and rear front in front of our queue. Rehrmann The end of our queue creates queue in the queue.

4
00:00:33,510 --> 00:00:43,250
Peak is empty is will and delete queue. Now let's start off with create queue method. This will create queue method. This method takes one parameter site here.

5
00:00:43,250 --> 00:01:04,380
We're creating the array and we're initializing from that rate to manager. If we call this method with five, then we're creating an array. This array will treat like a Cloudera structure and we have this variable front and rear the points to minus one and they're unlived on our index zero.

6
00:01:04,920 --> 00:01:15,840
We will empty Cilacap empty segments in Java. Programming language only create an integer array. The area are filled with zero. We're representing empty.

7
00:01:16,020 --> 00:01:29,580
You can consider we have zero in an empty cell for resetting the cell will use the concept of zero all set to zero. But we're not showing you that when you have empty cell you can consider we have a zero.

8
00:01:29,820 --> 00:01:40,140
And let's talk about income method. This method takes on parameter value. Then inside here, checking if the queue is already full, then we will print queue overflow.

9
00:01:40,350 --> 00:01:51,360
If really goes to minus one, that means if the queue is empty, we'll sit front to zero and rare blood splatter will move to the next and will insert our value to our area.

10
00:01:51,360 --> 00:02:08,340
OK, if not, if we have some element in our queue, then we will move to the next and will insert our current element to our queue. If we call this method and queue, cutin will insert data our first cell and we will move on to the next and O'Rear to the next.

11
00:02:08,460 --> 00:02:21,480
You we call this method again and queue with twenty will insert twenty two this cell here and will move to the next. OK, first we'll move here and then insert it.

12
00:02:21,480 --> 00:02:33,510
We call this method again. We will move there here and insert here thirteen. If we call this method again with fording will move o'rear and will insert foreign.

13
00:02:33,510 --> 00:02:48,810
Since we have some elements in our queue then if we call this method again, then we will move to the next and will insert 50. If we call another method with sixty, then it will throw an error cue overflow because the queue is already full.

14
00:02:49,200 --> 00:03:01,950
Joe Incubated works. This method will take speaker of one time and because of one space complexity, discrete documented will take up one time complexity.

15
00:03:02,250 --> 00:03:14,340
But order of in space complex are creating an array of size in. Now let's talk about a dequeue zero decay operation. This method takes no parameter we're taking if really close to minus one.

16
00:03:14,550 --> 00:03:26,570
That means if the queue is empty, that means it becomes empty. It will print queue underflow error. If not, we're going to print the value from our front and we'll set Frontyard Zero.

17
00:03:26,820 --> 00:03:37,320
When he said front of zero, that means we're going to say the value to the default value and we're going to move on to the next if we found front is greater than rare.

18
00:03:37,320 --> 00:03:52,680
In that case, if we delete the value fifty, then all move rear and front to that minus one. If we call this method the Q, it will return the value chain and it said this relative zero and front will move to here.

19
00:03:52,890 --> 00:04:07,980
OK, it print ten when it's returning for this article we can return, but we're just printing the value and we've set it developed with zero and only showing you zero because the default value we create integer array in Java.

20
00:04:08,340 --> 00:04:21,630
Then if we call this matter again the Q print twenty and you do remove this admin's, it will say to zero and it will be moved to this cell. So it will be represented something like this.

21
00:04:21,630 --> 00:04:32,010
And this is how this document works. This method takes picture of one time and because of one space complexity. And let's talk about operation. This is pretty simple.

22
00:04:32,700 --> 00:04:41,400
It's that takes no parameter. We're taking it for equals two minus one. If the key was empty, then we're printing use empty else or printing the value from the front.

23
00:04:41,760 --> 00:04:51,140
We call this method fake. It will print today. It will not remove anything. It will just returned from the top or it will print the value we're just printing here on it returning.

24
00:04:51,240 --> 00:05:12,780
So for this. Q It will print thirty. This operation will take one of one time and space complexity. Now let's talk about is the operation. This operation takes no parameter, you know, checking your phone records to monitor, and if we found for to minutes, then we're returning to be in from this point in two minutes when the queue is empty else or false.

25
00:05:13,190 --> 00:05:25,550
We see that the queue is not empty, front is not minus one. So we call is empty. It will return false since the queue is not empty and this operation will take up on time and big up on space complexity.

26
00:05:25,790 --> 00:05:36,170
Now let's talk about is full operation. If we found really close to that land mine on the Diligenta for this kill, we see where he goes to adult land minus one.

27
00:05:36,180 --> 00:05:45,970
So we call this method. It will return to do already what we have on the left. We see here the two still empty, the first Rouselle, but already using this first two.

28
00:05:45,980 --> 00:05:58,430
So we'll talk about more. What do you talk about? Circular Quay? OK, all the elements from this queue only that we can start inserting from the left. We were removed 14 and 30 from.

29
00:05:58,430 --> 00:06:13,730
Q If we have only 15 also can't insert anything to our queue. That's why we have to line Circular A. We'll talk about that in the next video. This operation will take bigger of on space and bigger up one time complexity.

30
00:06:13,850 --> 00:06:27,830
Now let's talk about the lift cooperation and we're just setting original episode Arietta. Now the area will be deleted from a computer memory. So if we call this function, that will be deleted and this is delayed cooperation.

31
00:06:27,840 --> 00:06:38,810
Super simple, said the original. And this operation will take up one time and big up on space complexity. And this is the linear implementation video explanation.

32
00:06:39,010 --> 00:06:51,800
We have understood this video explanation's I have it has the source code and the source code. We have all the method for linear. Q Using every check the source code for the complete implementation of linear.

33
00:06:51,800 --> 00:07:00,740
Q Using error, we understood this with explanations. You have an issue. If you have any question, let us know. Thanks for watching. I will see you in the next video.


@@@
1
00:00:00,650 --> 00:00:15,700
Welcome back to this video in this video. We're going to implement Circular Quay using area. We're going to implement this SEBEN method for Circular Quay to create queue in the queue.

2
00:00:15,740 --> 00:00:32,510
Peak is empty, Espoo and delayed queue. In the previous video, we saw that when we implement linear queue is an area, we encounter a problem. We have unused cell and that so we can't use and that's not super efficient.

3
00:00:32,720 --> 00:00:44,250
And to solve that issue, we can use circular queue. Now, let's talk about circular. First, we're going to see this method create queue. Then we'll talk about all of the method.

4
00:00:44,280 --> 00:00:58,300
One by one. First, let's talk about create queue the our class again. Here we have this seven method and we have every then front and rear end. This is the side of our area.

5
00:00:58,710 --> 00:01:14,250
This is our great queue method. This method takes one parameter length and here we are creating an area of the given side and then we're going to initialize front and rear to monitor inside equals to lend it.

6
00:01:14,610 --> 00:01:26,250
We call this method with six, then we're going to create an array of length six. This is an area of LENTE six and this area is represented in circular fashion, something like this.

7
00:01:26,250 --> 00:01:37,140
We have index number zero one, two, three, four, five. Initially our area is empty and front and rear is pointing to minus one and the sides close to six.

8
00:01:37,890 --> 00:01:46,800
Now let's see how we can insert data to our queue. Now let's talk about in queue method. This is our incremented. This method takes one parameter here.

9
00:01:46,800 --> 00:01:56,700
First, we're going to check Isbel. If the queue is full organized, imprint queue is full. Will see this method in this video. Don't worry about it then we have else.

10
00:01:57,180 --> 00:02:13,310
If funding goes to minus on that front to Jrome and then we're going to calculate error rate plus one model site, then error rerecords value. If our air goes out of our error boundary, then we will move our career to that first cell.

11
00:02:13,500 --> 00:02:28,110
OK, now let's see how it works. If we call in Cutin now what's going to happen with your queue is empty, so we're going to sit front to zero and then we're going to calculate O'Rear.

12
00:02:28,350 --> 00:02:40,800
So zero modulus six here, Saidi's six zero, Morila six is zero. So real will point to this cell. And here in this cell we're going to insert the value of the value is ten.

13
00:02:40,950 --> 00:02:51,150
So let's insecurity and let's move front and rear to this. So now our ACU is represented, something like this. This is front and this is rear. We have only one element in our queue.

14
00:02:51,390 --> 00:03:09,960
We call again in Q2 and now we're going to calculate a rear area will be evaluated. One point here and we're going to insert here twenty. If we call this matter again with Tarty, we will move to this cell and here we're going to insert tarde.

15
00:03:11,070 --> 00:03:23,370
We call again with forty, then we're going to move area to this. So real plus one. Modula six here size is six, so three modulars, six across to three.

16
00:03:23,880 --> 00:03:37,290
So real point here and here we're going to insert forty. Then we call this matter again a real point here and here. We're going to insert fifty eight to be called this method in Q Sixty.

17
00:03:37,890 --> 00:03:52,650
Then we're going to move here, here and we're going to insert here sixty. This is how incremental works. We have understood this new method. This method takes constant time and constant space complexity.

18
00:03:53,400 --> 00:04:08,130
This create queue method takes ambiga of one time complexity and a bigger of in a space complexity. What is the length of the array? This is a circular kuac in this circle.

19
00:04:08,130 --> 00:04:22,760
Q is represented something like this in a circle. OK, we see this in a circle 10, 20, 30, 40, 50 and 60. This is our front and this is our area. Now let's talk about using the method here.

20
00:04:22,770 --> 00:04:42,480
We're going to check if it goes to minus one, then we're going to print two. If it goes to minus one, that means our Q is empty. If our rate is not minus one hundred and false, if we call this method, this method will return false because for this Q we see rerecords two five, which is not minus one.

21
00:04:42,810 --> 00:04:59,970
So this method will return false. Now let's talk about Espoo method. This is Espoo method. This method takes a parameter. You're going to check if one goes to individuals to and a rerecords to size minus one we see rerecords to size minus one.

22
00:04:59,970 --> 00:05:19,470
There is five sizes, six or six minutes when it's five year. So ostracise minus one. So in this case will return. True. And here we have this if statement if front equals two real plus one then will return true and will get to this is statement after doing dequeue operations.

23
00:05:19,800 --> 00:05:33,830
Now let's see the cooperation so we can make dequeue operations to this CU. You recall this method is well it will return true because this queue is full and will get to this statement later in this video.

24
00:05:34,530 --> 00:05:46,170
Now, let's talk about a documented. This matter takes in a parameter inside here, we're checking if is empty, if this a function return true. That means our queue is empty, the printing queue is empty.

25
00:05:46,180 --> 00:05:55,390
If not, then we're getting the front element and we're printing that element and we're taking it from the rear. Then we're sitting front ecoles to really close to minus one.

26
00:05:56,570 --> 00:06:15,430
Also from the cluster front, plus one more side. OK, if we call this method, this method will print 10 and we'll move on to this element, one, changing the value of this first unit, changing the value of first sale, or just keeping the value we consider the value to the default value.

27
00:06:15,430 --> 00:06:29,830
Zero for Java programming language. But we're just keeping the value and frontal point to this element. This is your front door in our segment. We see it from this note pointing to this element and this is over here.

28
00:06:30,540 --> 00:06:41,650
If we call this method again, it will return to and will move to the next. And then it we call again. It will return front Freundel move to the next, then we call again.

29
00:06:42,130 --> 00:07:04,000
It will return 40 and move to the next. Maybe call again. It will return 50 and then move to the next. Now we see a rear and front is not pointing to the same element and he recinos circle and front is pointing to this element and they said no, this dequeue operation works.

30
00:07:04,000 --> 00:07:15,130
This method will take Spiga up one time and B, go up one space complexity. Now, let's get back to our incorporations. If we call this method intuits 70, then what's going to happen?

31
00:07:15,460 --> 00:07:35,050
Our rear will move to this sill and Hyrule in such seventy at the place of 10. OK, then if we call again, then it will replace this volatility with 80, you recall again with 90, then we will move here and this will all be updated with 90.

32
00:07:35,420 --> 00:07:51,770
If we call again with 100, this one will be upgraded. With 100, we call again with 110. Then this value will be updated with one hundred ten. OK, now we see that responding to this element and responding to this element.

33
00:07:52,070 --> 00:08:07,260
Now let's go back to our Espoo operation. This year is full operations here we see from go to real plus one and we see here our queue is look and this condition is true in this case, a front to rear plus one front.

34
00:08:07,400 --> 00:08:18,200
Let's to a real plus one. So there is four four plus one is front. So it will return. True. And this is the statement of we have understood this statement.

35
00:08:18,800 --> 00:08:31,610
We call this method. This method will return to the zero. This is method works. This works in constant time, in constant this method works in constant time and in constant space complexity.

36
00:08:32,240 --> 00:08:43,370
Now let's talk about the pig operations. It's super simple. First for checking if our car was empty or printing queue is empty unit or just printing the valve from our front and here our 40 60.

37
00:08:43,380 --> 00:08:55,790
So it will print 60. We call this method. It will print 60 units returning the value. We can return the value as well. But we're just printing here. This method only takes up one time and pick up one Espace complexity.

38
00:08:56,360 --> 00:09:08,810
Now let's talk about a new method here. We're just sitting on agriculture now, so our area will be set to now and we're just setting O'Rear and Prodigals to manage one superior.

39
00:09:08,810 --> 00:09:19,410
And our front all points to management and this area will be deleted from our computer memory, OK? And this entire area will be deleted inside our circular queue.

40
00:09:19,430 --> 00:09:29,480
This is the representation. This is just a visual representation of our area. OK, this area, this arrest is treating as a queue. This is how this method works.

41
00:09:29,780 --> 00:09:39,230
And this method will take up one time and we go up one space complexity. What we have understood this speed explanation of we have understood the concept of circular.

42
00:09:39,230 --> 00:09:51,410
Q using circular. Q We can use our unused cell, OK, we're not wasting any computer memory speech. We have understood this method. We've understood what is a circular.


@@@
1
00:00:01,140 --> 00:00:22,700
Hey, what's up, guys? Welcome back to this video in this video. We're going to implement linear cue using linguist in this video. We're going to implement linear cue using linguistic data structure and implement this six method, create cue in Q dequeue peak is empty and delete.

2
00:00:22,830 --> 00:00:38,850
Q Now let's create queue method. Then we'll talk about all of the method. One by one, this is our class. This class contains on onload. This note contains two attributes, a value and a pointer.

3
00:00:38,850 --> 00:00:54,000
Next here we have front and rear of our Q and we have your six method. Now, let's talk about creating you this to create a new method. This method takes no parameter.

4
00:00:54,270 --> 00:01:08,950
And inside here, we're sitting front and rear to null. Now, if we call this method create queue, then we're going to assign a front and a real pointer to null node.

5
00:01:08,970 --> 00:01:35,820
OK, here. Front and rear pointer is pointing to now node. Now let's see incremented this switch our NQ method. This method takes on parameter value. Inside here we're creating a new node, OK, and we're taking it from the gold standard and we're sitting front and rear to the new node elds organising the next class to new node and a rerecords to new node.

6
00:01:36,240 --> 00:01:49,610
If we call this method with ten, then we're going to create a new node and then we're going to move front and rear to this node. So the linguist will be represented, something like this.

7
00:01:49,860 --> 00:02:06,300
This is our kuac. Okay, this linguist is streeting as a cue data structure. We have a front and we have O'Rear. Maybe call this method again with 20. Then here we are creating a new node with value twenty.

8
00:02:06,960 --> 00:02:17,430
And what are we going to do? We're going to see here in Riyadh next to new node. So we're going to connect this pointed to this node and we're going to move earlier to this node.

9
00:02:17,640 --> 00:02:29,070
So the queue will be represented, something like this. We have front end. We have here. This is your front and this is O'Rear. You call this matter again, we tarde.

10
00:02:29,280 --> 00:02:39,210
Then we're going to create a new node and then we're going to assign this point to this note by saying eradiated next Mixteco unit, then we're going to move area to this node.

11
00:02:39,570 --> 00:02:50,970
Then our linguist will be represented, something like this. This is a linguist. This linguist is treating as a queue data structure. We have here front and we have O'Rear.

12
00:02:51,540 --> 00:03:08,200
This is how this new method works. This method takes big up on time and bigger up on space complexity. This method create you. It takes bigger of all time and bigger up on space complexity.

13
00:03:09,310 --> 00:03:20,440
Now let's talk about peak method. This method takes no parameter. You were taking it from the gold standard and we're printing queue empty ELTs or printing the value from our front.

14
00:03:21,380 --> 00:03:35,910
OK, we call this method pick. It will print 10 from the front. Okay. And it will do nothing. It will just print 10. We can return the value 10 from our front node, but we're just printing the value.

15
00:03:36,250 --> 00:03:48,070
You can return it as well. Now let's talk about is empty operations. This operation takes in a parameter inside your checking Euphronios to Nalden when returning true else or returning false.

16
00:03:48,070 --> 00:03:59,370
If we call this method for this lengthiest, then it will return false because the front is not pointing to now node. And we say this is not an empty queue.

17
00:03:59,830 --> 00:04:15,700
That's how it's written. False. This operation takes up one time and pick up one space complexity. This operation, this operation also takes bigger up on time and bigger up on space complexity.

18
00:04:16,630 --> 00:04:28,690
Now let's talk about dequeue operation. This operation, this method takes in a parameter inside. You're watching it for legal. All the printing queue is empty, ELT's, all going to value from front.

19
00:04:28,870 --> 00:04:43,290
And then we're going to move front to the next node and we're checking if it's true now or sitting rear end to now. If we found Franticness Tunnel, then we're setting our real pointer to download it.

20
00:04:43,300 --> 00:04:58,420
We call this method. This method will print and remove the value from our front. OK is a link list and it will return this Vollertsen and it will removed this notebook and this front will be moved to this node.

21
00:04:58,660 --> 00:05:13,210
Then our link list will be represented, something like this. And here we're just moving your front document, not removing this. Not when no Garrick's collector found there is nothing is pointing to this, not this node will be automatically removed by garbage collector from RAM.

22
00:05:13,390 --> 00:05:27,580
So the link will be represented. Something like this. If we call this metal again, it will print twenty and it will move front to this node. So our link is to be represented, something like this.

23
00:05:27,580 --> 00:05:46,540
And garbage collector will remove this node from RAM. If we call this method again, this method will print TARDE and it will move front to now node. Since Rod equals Tranel, this area will be moved to this node as well to this node and allowing this to be represented, something like this.

24
00:05:46,540 --> 00:05:53,690
And there is nothing else pointing to this, not to this note will be removed by garbage collector. So our linguist will be represented something like this.

25
00:05:53,710 --> 00:06:04,600
How is your queue is empty. This operation takes up one time and big up on space complexity and this is all documented works. Hope have understood how the method works.

26
00:06:05,410 --> 00:06:19,090
Now let's talk about the method here. We just in front and right now it will sit front to now and o'rear to null. Then this linguist will be removed by garbage collector automatically.

27
00:06:19,090 --> 00:06:27,700
First it will remove this node because there is nothing is pointing to the node, then this node there is nothing is poured into this node is not a garbage collector in this node.

28
00:06:28,060 --> 00:06:41,350
There is nothing is point to this node. So this note will be removed. A garbage collector and we see our list is empty and this is a garbage collector will delete the cue from IREM.

29
00:06:42,190 --> 00:06:59,500
That means our linked list of if I understood this method, this method will take Spiga up one time and pick up one space complexity of you've understood this very explanation of we've understood how to implement linear cute using linguist Evony course in any situation.


@@@
1
00:00:00,750 --> 00:00:15,990
Hey, you guys all come back to this video in this video. We're going to talk about tree data structure. Tree is a nonlinear hierarchical data structure that consists of nodes connected by Isiah's.

2
00:00:17,980 --> 00:00:31,210
This is an example of a tree we have not and we have left and right child on the left that we have not, and that note contains another left and right child.

3
00:00:31,360 --> 00:00:45,940
And so on. For this note, we have only right child. We do not have any left child for this note. We have left child, right child for this note. We have left child, right child for this note, for this note, for this and for this note.

4
00:00:46,120 --> 00:01:00,500
There is no left and right child. And this note are called LoopNet. And Tufnel is called The Root Note. And we'll talk about that when we will talk about three terminologies.

5
00:01:00,700 --> 00:01:15,340
This is an example of tree data structure errors. Linked list stack and Qs are linear data structures that stores data sequentially in order to perform any operations in a linear data structures.

6
00:01:15,580 --> 00:01:32,050
The time complexity grows as the data size grows. But this is not acceptable in today's computational world. Dewpoint tree data structures allows quicker and easier access to the data as it is in non-linear did a structure.

7
00:01:32,260 --> 00:01:50,860
So we understand that for linear structure we might have problems. Whenever the size grows, our time complexity will be increased for all we need to distracter structures come into the picture to solve that issues we should do one tree data structure.

8
00:01:51,490 --> 00:02:03,880
Different key data structures allow quicker and easier access to the data as it is not only new data structure and is a non-linear structure. This is a true representation.

9
00:02:03,970 --> 00:02:16,120
We can create a tree using legalist or added it a structure and we will see all in this section. Don't worry about that. Now let's talk about different types of tree.

10
00:02:16,360 --> 00:02:29,590
We have many different type of trees, but in this course we will talk about, especially for this five types of tree binary tree binary Star Street will tree Bintliff and try.

11
00:02:30,010 --> 00:02:46,090
We'll talk about that all of this data structure in this course. Now let's talk about applications up created a structure. Binary thirsty data structures are used to quickly check whether an element is present in a state or not.

12
00:02:46,270 --> 00:03:03,040
If is a kind of tree that is used for a heap short. A modified version of tree called Driss is used in modern rooters to store routing information. Most popular databased use tree data structure.

13
00:03:03,490 --> 00:03:22,840
Compilers use a syntax tree to validate the syntax of every program you write, and there are many applications up to data structure in this course. We'll talk about tijeras structure in details in the next video, we will talk about tree terminologies, see in the next video.


@@@
1
00:00:00,420 --> 00:00:12,940
In this video, we're going to talk about three terminologies. First, let's talk about a node in node contains two attributes, a data and reference or pointer.

2
00:00:14,190 --> 00:00:28,810
This is a.. This note contains three data. Here we have two pointers and one data. This is a node up a double length. In order to represent tree, we use every or linked list.

3
00:00:29,340 --> 00:00:47,550
Let's say this is a tree data structure, how this tree data structure is represented, something like this. We have 10 and we have left and right child and on the left restoring the active child and on the right or string the edges of right child, something like this.

4
00:00:48,090 --> 00:01:03,210
And representing zero zero zero two zero zero zero three as the address. OK, and this is how tree is represented. And here this is a node. This is a node and this is a node.

5
00:01:03,660 --> 00:01:18,450
So industry we see Tunisia node 20 is a node and Tara, is it not? Now let's talk about root. What is root? The topmost node arbitrary is called root. This is the root of this tree.

6
00:01:19,080 --> 00:01:33,570
This is the topmost, not the topmost. Note is called the root, not of a tree. Now let's talk. What is what is is is is the linkage between any two nodes here?

7
00:01:33,780 --> 00:01:50,790
This is a link. This is a link. This is a link. This is a link. This one. This one and this one. This all are called is. So we see the link is called is this link are in between two nodes.

8
00:01:51,390 --> 00:02:05,210
So this link are called is now let's talk about live. What is lymph node nodes with no children is called lymph node. Here we see this node forty has no children to this.

9
00:02:05,520 --> 00:02:19,740
If not, this node has no children. So this is a lymph node, this node and this node has no children. So this to note is called lymph node. The next terminology is ancestor.

10
00:02:20,190 --> 00:02:33,600
What is ancestor? Ancestor means parents, grandparents, great grandparent and so on. So what is the ancestor of this node? Forty ancestor of this node, 40 is the parent.

11
00:02:33,600 --> 00:02:53,250
This is the parent. This is the grandparent. This is the great grandparent. So the ancestor of this node 40 is tarde, 20 and 10. The node itself is also the ancestor of the node of the node itself, the ancestor of the node.

12
00:02:53,550 --> 00:03:03,330
So the ancestor of this not forty is forty, thirty, twenty and ten. So you're this sixty is not the ancestor of this node. Forty. The ancestor of this.

13
00:03:03,330 --> 00:03:14,070
Not for this. Forty, three, twenty and ten. What is the ancestor of this node. Sixty. The ancestor of this node. Sixty is not sixty itself also so sixty.

14
00:03:14,070 --> 00:03:28,980
The parent is twenty and the grandparent is ten. So the answer is not sixteen, sixty, twenty and ten. What is the ancestor of this node. Fifty. The ancestral is not fifty is fifty three, twenty and ten.

15
00:03:29,610 --> 00:03:45,690
We understood what is ancestor. Now let's talk about next time terminology. The next terminology is a height of a.. Now let's talk about height up, not height up in what is the length of the path from the north to the deepest note.

16
00:03:46,110 --> 00:03:59,490
So what is the height of this? Not the deepest note we see is fifty or forty. So the height of this note is one and two. We have two aces in between this note and the deepest note.

17
00:03:59,490 --> 00:04:15,240
So the height of this, not twenty, is to the height of this note is one, two and a three. So what is the height of this? Not the height of this note is one, because the deepest note here is this not eighty.

18
00:04:15,540 --> 00:04:27,000
So the height of this not seventy is one. Let's talk what depth of note? The depth of note is the length of the path from route to dunnart. So what is the depth of this note?

19
00:04:27,210 --> 00:04:48,790
Is this we have in between route and this note is two, so one end to so the depth of this note. Sixty is a two. So what is the depth of this note? The images we have in Beirut and to this note is one, two and three, so the depth of this, not 50, is a three.

20
00:04:49,030 --> 00:05:06,640
What is the depth of this note? The depth of this note is to one end to what is the depth of this root node? And there is zero because there is no edges in between root note and this note, because this is the root of understood it and depth up a..

21
00:05:06,850 --> 00:05:19,090
And let's talk about height of tree. What is height of a tree, height of trees, the length of pat from root to the deepest note. This is our root and this is our deepest note.

22
00:05:19,210 --> 00:05:34,090
So the height of this tree is one, two and three. We have three S's. So the height of this tree is tree. Now let's talk about depth of tree. The depth of tree is the same as depth of root, not the depth of root.

23
00:05:34,090 --> 00:05:50,020
Node is zero because there is no edges in-between root root and this node 10 because this is the root node. So the depth of this tree is a zero. We have understood two terminologies in the next video.


@@@
1
00:00:00,790 --> 00:00:19,630
Here you are. Some guys will come back to this video in this video. We're going to talk about three terminologies in this video. We're going to talk about predecessor and successor, predecessor of A. is the immediate previous snowed in in the torso of a binary tree.

2
00:00:20,920 --> 00:00:34,730
And they were given this by military, the end of the tower. So of this pine tree is OK, so we can get this list by traversing this binary tree in order.

3
00:00:35,590 --> 00:00:45,860
So now we say, what is the predecessor of this node nine? So we have to find it. The predecessor of this Node nine. We have to find out first the inner tower.

4
00:00:45,880 --> 00:00:59,530
So this is the end of the terror cell in the in order traversal the immediate previous node of nine is called predecessor. So for this note nine, the predecessor is four.

5
00:00:59,580 --> 00:01:13,400
OK, so the predecessor of this Node nine is for this node ABC. Say, what is the predecessor of this Node six. So first, let's find it six in this in the tower.

6
00:01:13,420 --> 00:01:29,330
So here we find out six and the immediate previous node of six is 12. So the predecessor of this node six is a 12. What is the predecessor of this node 10?

7
00:01:29,530 --> 00:01:49,300
First, let's find out that 10 in this list. And here, see, this is it, 10. The immediate previous node, up 10 is this node, too. So the predecessor of this node 10 is this not to have understood what is predecessor up a node?

8
00:01:49,870 --> 00:02:02,200
Now, let's talk about successor of a node. Now let's talk about successor. Successor. A node is the immediate next node in in order to of a binary tree.

9
00:02:02,530 --> 00:02:14,050
So what is the successor of this node nine. So this is the Node nine and the immediate next node is two. So the successor of this Node nine is this node too.

10
00:02:14,350 --> 00:02:28,300
So the successor of this, not nine, is to now what is the successor of this node six? First, let's find out six in this tower. So here we find out six and the immediate next node is 13.

11
00:02:28,510 --> 00:02:42,640
So the successor of this node six is 13. What is the successor of this node three? First, let's find out three in the tower. So here we find out three.

12
00:02:43,060 --> 00:02:58,600
Now, the next node, the immediate next node of three in this in the traversal is 14. So successor of this node three, is this not 14. We have understood what is predecessor and what is successor.


@@@
1
00:00:00,570 --> 00:00:12,600
In this video, we're going to talk about what is a binary tree, a binary tree is a tree data structure in who is its parent node can have at most two children.

2
00:00:13,380 --> 00:00:26,370
This is an example of banditry. This node has two children. This node has two children, this node, this node. And for this not, there is no children in the definition of binary.

3
00:00:26,580 --> 00:00:48,560
We see that is parent node can have at most two children. So by the definition, we can say this is a binary tree. This is a binary tree, as will this node has two children, this node has two children, this node has two children, this node has no children, this node has no children.

4
00:00:48,960 --> 00:01:01,410
This not seven has no children and is not three has no children. So it follows the definition of binary tree. So this is a binary tree as well. This tree is also a binary tree.

5
00:01:01,800 --> 00:01:13,200
This node has two children, this node has two children, this node has three children. And all lymph nodes we see has no children. This not four has no children.

6
00:01:13,200 --> 00:01:26,640
This node five has no children, does not and has no children. It's not. Five has no children. So by the definition, we can say this is a binary tree. These are the example of binary tree.

7
00:01:26,830 --> 00:01:37,800
Now let's see some more examples. This is a binary tree in this state has two children. This node has two children. This node has two children. This node has no children.

8
00:01:37,800 --> 00:01:54,270
This node has no children. This node has no children. This node has only one children. And this not has no children. In the definition of binary. Two, we see that every node should have at most two children.

9
00:01:54,810 --> 00:02:11,280
This tree is following the properties of binary tree. So this is a valid binary tree. This is also a binary tree this node has on children. This node has one trillion, this node has on children, this node has no children.

10
00:02:11,820 --> 00:02:25,170
So in Notkin has at most two children here. You see this tree node has one children and it is not has no children. So this is a binary tree. This is a binary tree as well.

11
00:02:25,170 --> 00:02:35,760
This is called let skewed binary tree. This node has one children. This node, this node has on children and is not has no children. So this is a valid binary tree.

12
00:02:37,200 --> 00:02:48,870
This is also a valid binary tree. This is called right. Skewed binary tree. We have one million for this node is not has on children. This node has one children.

13
00:02:48,870 --> 00:03:07,140
This node has no children. So this is a valid binary tree as well. What we have understood what is a binary tree in a tree, if we see a node contains at most two children, then you can see the tree is a binary tree.

14
00:03:07,560 --> 00:03:19,820
We have understood what is a binary tree. No, let's see. Some applications are binary tree. Banita is used for easy and quick access to data in a router.

15
00:03:19,830 --> 00:03:44,660
Algorithms. We use binary tree to implement a data structure. We use a binary tree and compiler uses binary tree for building syntax tree. We can validate code using syntax tree and in syntax we use a binary tree of understood what is a binary tree and the applications of binary.


@@@
1
00:00:01,110 --> 00:00:13,770
Hey, yo, what's up, guys? Welcome back to this video. In this video, we're going to talk about different types of binary tree in this video. We're going to talk about full binary tree, perfect binary and complete binary tree.

2
00:00:14,130 --> 00:00:28,040
Let's start off with full binary tree. What is a full binary tree? A binary tree is a full binary tree. If every node has dero or two children, this is a pool banditry.

3
00:00:28,080 --> 00:00:46,050
This nut has two children. This node has two children. This node has two children. This node, this node, this node and this note has no children. That means this full node four, six, seven and three has zero children.

4
00:00:46,200 --> 00:00:57,060
So this is a full binary tree here. This is a full banyan tree as well. This node has two children. This node has two children, and these are lymph nodes.

5
00:00:57,360 --> 00:01:10,740
This node has zero children. So this is a binary tree for this tree. We see this tree is also a full binary tree. This node has two children. This node has two children.

6
00:01:11,280 --> 00:01:25,260
For this node, two, four and five has zero children. So you can say this is a full binary tree. Understood what is a full blown entity. Now, let's talk about perfect.

7
00:01:25,260 --> 00:01:37,440
A binary tree. What is a perfect binary tree? A binary. It is a perfect binary tree in which all the internal nodes have two children and all lymph nodes are at the same level.

8
00:01:38,340 --> 00:01:56,240
This is an example of perfect binary tree. This not has two children and these two not our lymph nodes. From the definition of lymph nodes, we know that lymph node has no children and they say they are in the same level this to live not in the same level.

9
00:01:56,370 --> 00:02:08,580
So this is a perfect binary tree here. This is also a perfect binary tree. This node contains two children. This node contains two children. This not contains two children.

10
00:02:08,850 --> 00:02:22,320
And we have your four lymph nodes. Lymph node has no children and the lymph nodes are in the same level. We see that they are in the same level. So this is a perfect binary tree.

11
00:02:23,490 --> 00:02:32,460
This is also perfect. Bonaduce, this node contains two children. This node contains two children. This node contains two children. This node contains to children.

12
00:02:32,940 --> 00:02:43,890
This node contains two children. For this note, this node also contains two children. And this note is also contains two children. And this are all lymph nodes.

13
00:02:44,000 --> 00:03:00,930
OK, the nodes eight, nine, 10, 11, 12, 13, 14 and 15 are lymph nodes and the lymph nodes are in the same level. So this is a perfect binary tree. We have understood what is a perfect binary tree.

14
00:03:01,740 --> 00:03:19,740
No, let's talk about complete binary tree. What is a complete binary tree? A binary tree is a complete binary tree. If all the levels are completely filled, except possibly the last level and the last level has all keys as late as possible.

15
00:03:20,370 --> 00:03:34,370
This is an example of complete binary tree. This is an example of complete paniccia as well. And here we see the last level has all keys as late as possible.

16
00:03:34,380 --> 00:03:49,530
We see this are the lymph nodes and this is the last level. The last level has all keys as late as possible. So this is a complete binary tree for this tree.

17
00:03:49,530 --> 00:04:07,470
We see that all living are completely filled. OK, this level field and this level is filled as well. But here we see this level is not filled totally, but this level has all keys as late as possible.

18
00:04:07,470 --> 00:04:20,790
So it can say this is a complete binary tree. We have understood what is a complete binary tree in this video. We have talked about full binary tree, perfect binary tree and complete binary tree.


@@@
1
00:00:00,630 --> 00:00:10,450
Here you are, guys. Welcome back to this video. In this video, we're going to talk about implementation of a binary tree, how binary tree is represented.

2
00:00:11,580 --> 00:00:27,490
This is an example of a binary tree. We can implement binary using array or lindqvist data structure. First, let's see how we can implement binary tree is linked list implementation.

3
00:00:28,410 --> 00:00:40,560
Let's say this is or given binary tree and this tree we can create using a link list this it in node of DoubleLine list. Here we have agist of this node zero zero zero one.

4
00:00:40,920 --> 00:00:57,810
This not contains three attributes to pointer and on Deira left pointer and a right pointer is left. Pointer is pointing to Lepp child. The right pointer is pointing to a right child and have edges of this node.

5
00:00:58,170 --> 00:01:16,350
And here we have at this of this node, this is the left child root node, this route node and this is the address of this node. And this note contains three attributes left and the right child here string the edges of the child and here a string that just upright child.

6
00:01:16,820 --> 00:01:30,730
This child is right, child. This node has no left, no right child. This node as well has no child, no right child. The right to end of this route node is this not.

7
00:01:30,840 --> 00:01:45,720
This is the address of the right child in restoring the address of this node. This node has three attributes left and the right child and Adara. And here is the address of the child here staring at the surprise child for this not.

8
00:01:45,720 --> 00:01:55,710
There is no left and right child for this not there is no left and right child we have now. And this is how we can represent a binary tree using legalist.

9
00:01:56,580 --> 00:02:09,190
Understood how we can implement a binary tree using lengthiest in this section of discourse. We'll see how we can create a binary tree using legalist data structure and all made all the standard operations.

10
00:02:09,570 --> 00:02:28,070
Now let's talk about how we can implement binary tree using our data structure. We have their array of eight, and here we have the index number one, two, three, four, five, six, seven, initially will pick the item from index on as route.

11
00:02:28,130 --> 00:02:40,070
So this is our route. No, let's create a root node, the second root node. OK, now the left side of this note will select using this formula array to X here.

12
00:02:40,070 --> 00:02:57,000
X means the current index. So two times only close to two. So it will set the child. Whatever we have at this index to so let's set aside 20. Now, let's find it right.

13
00:02:57,120 --> 00:03:09,820
Child will find it right, child using this formula to express one or two times one plus one equals two, three. So all insert right over here what we have at index three.

14
00:03:10,190 --> 00:03:23,450
So let's insert here today. Now for this note 20. Let's find the child. So two times three to four. So let the child of this, not twenty is whatever we have at index four.

15
00:03:23,660 --> 00:03:38,930
So let's insert here this well of forty. Now, the result of this, not twenty, is to exploit one. That means whatever value we have at index five. So let's insert here fifty now for this Nithari.

16
00:03:39,350 --> 00:04:00,340
The little child is two X, that means three times two. There is six. So whatever value we have at index six, insert as a child of this node thirty. So let's insert here sixty now the right child every two X plus one there is index seven, three times two plus one equals two seven.

17
00:04:00,440 --> 00:04:11,110
So whatever we have at index seven will insert here. So let's insert here seventy now let's find it. Let's end of this node. Forty. So this age forty.

18
00:04:11,120 --> 00:04:28,010
So two times for equals to eight. It is out of every boundary. So insert now as left and as right to express one is nine so it will insert as right child now left title and right side now and seven for the rest of the node.

19
00:04:29,000 --> 00:04:53,660
This is how we can construct a binary tree using Herry. This is how we can implement it by nature. Using array in this section of this course will implement binary tree using linguistic data structure and also using our data structure and all made all the standard operation for legalist implementation as well as for area implementation.

20
00:04:53,930 --> 00:05:13,730
In the rest of this course we will talk about linguists implementation just for this section of this course we will talk about linguists implementation and ARRY implementation linked list implementation is way more efficient than our implementation that we will be using linked list implementation option for the rest of this course.

21
00:05:14,270 --> 00:05:29,040
But for this section of discourse, I will talk about Linklaters implementation and our implementation so it will have a better understanding. Haviv understood how we can implement a binary tree using linguist and our data structure in the next.


@@@
1
00:00:01,200 --> 00:00:18,030
Hey, what's up, guys, all come back to this video, in this video we're going to implement by neutralizing linguistic data structure in this section of discourse will be implementing create a binary tree, insert source delete, not delete binary tree.

2
00:00:18,240 --> 00:00:28,820
And Trevor's method in Traverse Method will traverse that binary tree using this for traversal algorithm in order for your post order and level order.

3
00:00:29,160 --> 00:00:41,760
In this video, we're going to talk about this two method great bunny tree and insert first also in create a binary tree. Then we'll see how we can insert data into binary tree.

4
00:00:42,480 --> 00:01:00,810
Now let's talk about cret binary tree. This is our class binary tree ising linguist. Inside this class we have a node. This node has three attributes value and two pointer left and right here or declaring the root of our binary tree.

5
00:01:01,230 --> 00:01:13,560
And then we have this method. Create a binary tree inside this method or learn to set a root to download. So our root is now node. So this is a binary tree and this is our root node.

6
00:01:13,560 --> 00:01:28,680
Now, look, initially we have this root not null. Now let's talk about insert method. This is insert method. This method takes on parameter value. Inside here, we're creating new node with the value and not checking.

7
00:01:28,690 --> 00:01:52,820
If we're sitting down, we're setting our root to the new node and we're returning by this written statement or just existing from our function call. If Rudy is not true to now, if we have some value in our binary tree, then we're creating a queue and then we're adding the route nodes to the queue and then we're running a world of values, not empty.

8
00:01:52,980 --> 00:02:08,670
We're going to pop out the top element from CU and we're checking if kind of records to know where certain current node dot ellipticals to new node here or just setting the new note to the Lebanon of our current node.

9
00:02:08,670 --> 00:02:21,990
If we see current political sternhell and we are existing from our love using this statement, if not checking if current node that radical Struhl or setting the new note to the right child.

10
00:02:22,300 --> 00:02:34,740
OK, and we're getting from the love. Why this brake statement if this condition is related to. If not, we're adding the left and right Childersburg current not to.

11
00:02:34,830 --> 00:02:49,560
Q And we're doing this process until we hit and have this true condition or our stack is empty. Now let's see how it works if we call this method insertion in this case or are we going to do to create a new node ten.

12
00:02:50,040 --> 00:03:01,950
So we're creating a new node till here, recruiting new node and not checking it initially. Rudys now. So we're going to set a route to this node and we're going to take it from our function call.

13
00:03:02,100 --> 00:03:16,710
So this is our route, right. And the left and right child of this node is now by default. So now we have the root node ten. We call this method insert twenty, then we're going to create a new node twenty.

14
00:03:16,920 --> 00:03:27,900
And we see Rudi's not equal to now. So here we create a new queue. So here you create a queue. And this is our queue and we're going to add our route, not to the queue.

15
00:03:28,140 --> 00:03:40,830
So let's add here the route node ten. Now we see queue is not empty, so we're going to populate that tough element from front of our queue. So here storing the node 10.

16
00:03:40,920 --> 00:03:53,130
So let's pop out this note and we out this note. Now, we have current records to the node ten. That means the root node. Then we're going to check if current not order to got to.

17
00:03:53,130 --> 00:04:05,660
Now we're going to set the new note to the left node here. We see that the current node is now. So let's set the node twenty as the left side to this note.

18
00:04:05,670 --> 00:04:17,160
OK, so let's set here twenty. So we assigned that node twenty as the left side to this route node and then we're going to break. So this loop stop here.

19
00:04:17,280 --> 00:04:29,820
Now we're done with this function call. Now let's call this function again with value tarde. Now what's going to happen? We're going to create a new node with value tarty and we see Rudi's is not equal to now.

20
00:04:29,910 --> 00:04:51,060
So this condition is false. Then we're going to declare a Q and inside this quadrant at the root node there is ten. So let's add Hurtin'. Then we're going to run Aluf, then we're going to promote the front element from our Q So let's support this eliminating from Q And let's check this current node that let equals two.

21
00:04:51,060 --> 00:05:06,890
No, no, the left not of the node. We popped out from our Q the node ten. Now we're going to check the plot of this node ten does. A lipner of this note is, no, no, no, let's take the right note, does the right, honorable or not, is now?

22
00:05:06,910 --> 00:05:26,860
Yes, it is. So let's set the current note to the right child of this. Not so. Let's add here that note party, then our body to be represented, something like this, and they will break the liberal stuff whenever it found this break state, then we're done with this function call.

23
00:05:27,070 --> 00:05:36,330
Now, let's call this function again. We developed 40. Now what are we going to do? We're going to create a new note with value forty. Then we see the root note is still not null.

24
00:05:36,490 --> 00:05:49,900
So we're going to declare a Q and inside this. Q We're going to insert the root node there is to let's incertain now we are running this well if Q is not empty, so are currently constituted current goes to the node ten.

25
00:05:50,170 --> 00:05:59,290
Now we're going to take those. The little note of our current node is now. No. So let's say this condition, this condition is also false. So what are you going to do?

26
00:05:59,320 --> 00:06:10,210
We're going to add the child twenty and the right child three to the Q, so the Q will be represented something like this. In the next iteration, we're going to populate the node twenty.

27
00:06:10,240 --> 00:06:25,210
So this is your current node now, let's say does the little child of this node twenty is null? Yes, it is. So let's insert here the node forty. Now we have in cute Q3 and we have here our breaks statement.

28
00:06:25,330 --> 00:06:35,380
So let's break treatment. All of this a while since we're calling this function, we're done with this function call and our Banerji is represented, something like this.

29
00:06:35,500 --> 00:06:46,090
After performing this function call, whenever we call the instrumental again, the cue will be created. So you can consider the Q is empty. Now let's call the function again with Valla fifty.

30
00:06:46,300 --> 00:07:01,600
Now, what are you going to do? We're going to create a new node fifty and then we're going to declare new. Q This is your new. Q And let's insert here the node ten, so let's insert incertain then we're going to run this value, then we're going to run this year.

31
00:07:01,600 --> 00:07:12,910
We're going to support this node team. Now, this is our current node. Let's propagate and we see the left and the right note is not now. So let's add the left and right turn to this.

32
00:07:13,210 --> 00:07:24,850
So twenty will be added here and today will be added here. Ten is removed already. OK, in the next iteration, going to the front element there is twenty.

33
00:07:25,030 --> 00:07:46,900
So our current current node is twenty nine. On the left side of this note is not now but the right note is now. So let's insert here the node fifty. So you're going to insert that node fifty and the already popped out this in twenty so let's insert here fifty then everybody two will be represented, something like this.

34
00:07:47,230 --> 00:08:01,810
Now let's call this matter again with sixty we're going to create a new node with value sixty. And here let's add the route node to our Q and then we're going to propagate this element from our Q So let's pop out the system now.

35
00:08:01,810 --> 00:08:17,320
This is our current node. Now we see that the left and right is not now. So let's add left and right to our Q So twenty eight will be added here and thirty will be added here, so twenty will be added here and today will be added here in the next iteration of this.

36
00:08:17,320 --> 00:08:28,360
Well if we're going to support this node twenty, so our current node is this node twenty and we see that the left and right channel, this node twenty is not now node.

37
00:08:28,360 --> 00:08:36,780
So what are you going to do? We're going to add the left and right channel to this queue. So let's add in 40 and let other 50. Now, what are we going to do?

38
00:08:36,820 --> 00:08:53,350
We're going to propagate this node three from this. Q Not today is our current node. Now, what are you going to do? We're going to check the left side of this node 30 and there is now so we can insert the node sixty, so let's insert the node sixty, then our money will be represented, something like this.

39
00:08:53,560 --> 00:09:05,080
Now let's call this matter again with values seventy. Now, what are we going to do? We're going to add the note to this. Q So ten will be added here then we're going to support this node ten now this year countered.

40
00:09:05,500 --> 00:09:18,490
Let's put this node ten and let's add left and right channel to this. Q So twenty and thirty now we're going to pop this node. Twenty, so twenty. So this is your current node.

41
00:09:18,520 --> 00:09:29,260
We see left and right side is not now. So let's add left and right Tokuzo for the will be added here and fifty will be added here. Then we're going to support this node today.

42
00:09:29,410 --> 00:09:39,400
Our current node is this node thirty nine. We're going to deliberately decided sixty is not now then left to the right side. The right is now. So we can insert here the node seventy.

43
00:09:39,550 --> 00:09:54,610
So let's insert here the node seventy. OK then our binary will be represented, something like this. So we're done with this function call and then you get this binary tree and this is what we can insert value in a binary tree.

44
00:09:54,790 --> 00:10:09,650
If we call this matter again with eighty then eight will be added here. We've understood the. How this method works, this method will takes Bygrave in time, complexity, and because of space complexity, if you are not understanding how this method actually works.

45
00:10:09,830 --> 00:10:17,660
Try to write it everything on a piece of paper, then it will make sense, even a suggestion. If you have an issue understanding this with the explanation, let us know.


@@@
1
00:00:01,170 --> 00:00:10,910
Hey, yo, what's up, guys? Welcome back to this video in this video. We're going to talk about this method. Now let's see how we can implement this method.

2
00:00:11,400 --> 00:00:23,610
The switch our algorithm for search method. This method will return to our faults. If the given value is exist in that binary tree, then it will return to ELT's.

3
00:00:23,610 --> 00:00:50,460
It will false. This method takes one parameter value in regards to now that we're going to print is empty and we're going to exit by returning false. Then we're declaring a Q and we're adding the root, not the Q and we're running a away live and then popping out the front element from Q And we're checking if we ignore value goes to the given value, then will return to.

4
00:00:50,640 --> 00:01:08,040
If not, we're going to check if that is not null or insert that to. Q And then we're going to check. If the writer is not know that we're going to, then we're going to insert the child to the Q If we see this condition is never ever true then will return just false.

5
00:01:08,490 --> 00:01:22,830
Now let's see how this method works. The two are giving this one literally. And if we call this method string, then what's going to happen here? We're going to declare a Q since the root is not null and here we're going to insert the root node.

6
00:01:22,830 --> 00:01:34,110
So let's insert here the ten, then we're going to populate the root node. So let's talk about this node ten. And now we see this is your current node and we see the current node that very close to value.

7
00:01:34,230 --> 00:01:46,090
The value of this node calls to the given value. This condition is already true. So it will return true for this function call. We will return true now if we call this method with value fifty.

8
00:01:46,170 --> 00:01:56,970
Now let's see how it works. First, we're going to insert the root note to our Q then what are we going to do? We're going to propose this route node. Then we have our current goes to this route node.

9
00:01:57,060 --> 00:02:07,620
Now we're going to develop this node, develop this is Noriko's to 50, so we're going to treat the child as little is now not. So let's add that to Q that the title is null.

10
00:02:07,620 --> 00:02:17,130
Not so. Let's add that to the queue. Now let's talk about the front element that is 20 now. Our current node is 20 does develop, 20 is equal to 15 now.

11
00:02:17,430 --> 00:02:30,300
So let's say the left side does the left and is now not. So let's add 40 to the Q does the right is empty now. So let's add 50 to our Q. Now we're going to propagate this top element tarde.

12
00:02:30,660 --> 00:02:38,980
So let's support this elementary. Now this is your current element and let's take the left and right child and we select child is not now right. That is not now.

13
00:02:39,000 --> 00:02:55,100
So let's add 60 and 70 to the Q six will be added here and 70 will be added here. Now let's talk about this 40 from our Q. Now this is our current Nurhasyim and we selected Reitzell is now and this is not equal to 50, OK.

14
00:02:55,260 --> 00:03:05,370
Here also we should check the value target with 50 and we say they are not equal. So we have inserted 60 and 70 to the Q and appropriate. The front element there is 40.

15
00:03:05,730 --> 00:03:13,040
Now this is our current node and we see left and right is now. So there nothing need to be done here and the value is not equal to four is not equal to 50.

16
00:03:13,080 --> 00:03:25,820
And let's talk about the front element from Q That is 50. This is our current node and we see the value of this is equal to 50. So we find out this value 50 in this tree.

17
00:03:25,950 --> 00:03:38,610
So it will return. True. And we're done. We are returning to using this written statement. This is how this search operation works and we can search a given value in this binary tree.

18
00:03:38,760 --> 00:03:53,530
If the value does not exist in the binary tree, then it will return simply false hope. We have understood how this method actually works. This method will take off in time complexity and we go off in space complexity or we have understood this very explanation.


@@@
1
00:00:00,660 --> 00:00:16,860
Hey, what's up, guys? Welcome back to this video. In this video, we're going to implement this method, delete, not dismantle. Will takes a given value and this method will delete the value from the binary tree.

2
00:00:17,280 --> 00:00:31,820
Now, let's see how we can implement this method. First, let's talk about what is the deepest, deepest node is the last node we get traversing a binary tree in level order Tarasoff.

3
00:00:31,860 --> 00:00:42,750
It would traverse this Binit in level order. Let's find out the last node. So first of all, whatever this node 10, then 20, then 30, then 40, the 50, 60, 70.

4
00:00:42,960 --> 00:00:57,630
So 70 is the last node we found by traversing this Banita in level order. So 70 is the deepest node in this binary tree if we are given this banditti.

5
00:00:57,810 --> 00:01:07,970
Let's find out the last note we found by traversing this binary tree in level order. So first all terrorist and then 20 and 30, then 40, then 50 and 60.

6
00:01:08,130 --> 00:01:20,630
So 60 is the last note we found by traversing this planet and level of the traversal. So 60 is the deepest node ever. Given this binary team, what is the deepest node?

7
00:01:21,240 --> 00:01:36,930
So let's find out that last note by traversing this binary to using 11 other traversal, first of all, then 20 to 30, then 40, 50, 60, 70, then 80. So this is the last minute we get by traversing this binary level or whatever.

8
00:01:36,930 --> 00:01:50,610
So. So 80 is the deepest. Not for this Banita hope. We have understood what is deepest, not now how we can solve this problem. Let's say we want to delete the node 10.

9
00:01:51,060 --> 00:02:02,970
This node, if we delete this node, will get two separate linguists. So it will get this two separate linguist. And immersing the two linguists is not easy.

10
00:02:03,810 --> 00:02:22,730
It's going to be a little bit difficult things that you have to handle, so how can do it? A particular note when you said we have to do it and not first find it the deepest note and will update the note that we have to do it with the value of defense.

11
00:02:23,160 --> 00:02:36,490
So in this case, will update the value chain with the value of Diepsloot. The deepest note in this, Banita, is 70. So we have updated the value of this node 10 with 70, and they will remove the deepest note.

12
00:02:36,910 --> 00:02:50,420
Now we see that we have deleted this node 10 for this vanity letter. You want to delete the node 10 as well. Then what are you going to do? We're going to update this Vallentine with the defense node.

13
00:02:50,670 --> 00:03:04,590
So the defense is 60, so let's update this with 60 and then just remove the deepest node. So we deleted the deficit and we updated the value of our route, not or our desired not with the value of the best node.

14
00:03:04,980 --> 00:03:21,000
We were taking the value of the not because of easy implementation. We can take the value of any lymph nodes for this vanity. Let's say we want to delay the node 10, then we're going to do we're going to find it.

15
00:03:21,000 --> 00:03:31,290
The defense is the defense not. So let's update the value of this node then with the value of the deepest node eighty and then and then just delete the defense node.

16
00:03:31,470 --> 00:03:44,580
So we have deleted the root node, OK, instead choosing the department that we can choose any lymph node so we can choose this node, we can choose this node or again, to this node, that's completely fine.

17
00:03:44,850 --> 00:03:58,770
But for easy implementation, we're choosing the first node. Now, let's say you want to delete this node twenty. Now, let's say you want to update the value of this, not with this node.

18
00:03:59,610 --> 00:04:19,310
Update this with this node twenty, then there is a problem. This to nodes is dependent on this node. So if we delete this note that will have a compact on this two nodes if it does not replace the dependency of destroyed, and that's going to be difficult.

19
00:04:20,130 --> 00:04:33,240
That's why we're choosing the deepest node and we're just updating the value of our desert node. We develop divestment and at the end will remove or delete that node.

20
00:04:33,600 --> 00:04:43,380
Let's say we want to delete the node tarde. Then what are we're going to do first? We're going to find out that this is the defense note. So we're going to update the value of this node.

21
00:04:43,590 --> 00:04:53,380
We develop the best node and at the end we'll just delete the so we will take the node thirty. This is what we can delete it, not in a binary thirsty.

22
00:04:53,760 --> 00:05:05,190
So first we have defined it our desert node in this binary tree. Then you have to find out if it's not. And then we have to update the value of our desert, not with development.

23
00:05:05,250 --> 00:05:19,320
Then we have to delete the defense node. There is three process involved. First, finding the desired node, then finding out that depends node and then deleting the deepest node.

24
00:05:19,950 --> 00:05:38,580
OK, now let's see how we can delete a particular node in a binary tree. This is the pseudocode to delete a particular note from a binary tree. First we're going to check the OR printing trees empty and we're just existing by this written statement.

25
00:05:38,910 --> 00:05:50,490
If not, we're declaring a Q and we're inserting the root not to the Q and running the value of the popping out the front element from Q And we're checking the current value.

26
00:05:50,670 --> 00:06:05,730
If we found a desired node, then we're going to update the value we develop, the best node we can find it. If it's not using this method, we'll see how we can find a note about that for now and then will delete the deepest node and will break.

27
00:06:06,360 --> 00:06:16,770
Then we're going to check. If the child is not, then we're going to add that note to Q If the Reitzell is not now, then we're going to add that note to our Q And let's see how it works.

28
00:06:16,920 --> 00:06:29,700
If we call this method delete node ten, then all declare a Q, then we're going to add the root note to our Q So let's add Hurtin' then let's put this could not this would footnote.

29
00:06:29,880 --> 00:06:38,780
This is your current node and we're going to check the value of this current node. With the given value we see this value ten is equal to the given value.

30
00:06:39,150 --> 00:06:49,650
Now we're going to do we're going to find it the value of the first node. So this is the defense, not the value is eighty. So let's update this value chain with the value eighty and then we're going to do it.

31
00:06:49,650 --> 00:06:59,280
We're going to delete the first note and you'll see this method in this video. Don't worry about this method right now and will delete the defense not using this method.

32
00:06:59,460 --> 00:07:26,180
So this note will be deleted and will break. Enter a. So you reject the notion this is all we can delete a particular note from a binary tree, then our Bunnett will be represented, something like this, or we have understood how to delete a particular node from it, but only three if we call this method again, in this time, we want to delete the node 30 first round at the root root.

33
00:07:26,630 --> 00:07:38,120
So the root is eighty. Now let's add the root not to our cube root, nor is 80. Then we're going to pop out this root. Not so. This is your current node that pops out.

34
00:07:38,570 --> 00:07:53,800
Then you're going to check the value with our given value. It is not equal to 30. So let's add let the child because little is not null 20 and let's add right child reitzell is not now there is 30.

35
00:07:53,810 --> 00:08:07,970
Let's add here the writer 30. Now let's pop out this front element 20. Now this is our current. No, look, we say 20 is not a good start. So let's add legendry child to our cue.

36
00:08:08,090 --> 00:08:22,250
So let's add here 40 and let's add here 50. Now, let's put the front element from our cue. There is TARDE. So this is our current node. Now we see the value of this Notari equals to the given value.

37
00:08:22,400 --> 00:08:32,630
So now we have to find out the deepest node. This is the deepest note that we can find it. And this is the node and we can find out the deepest note using this method.

38
00:08:32,630 --> 00:08:45,010
And we will see in this video we can find it if it's not. And we're going to update this value today with the values seventy. So let's update this value target with seventy and then it will delete the deepest node using this formula.

39
00:08:45,230 --> 00:08:56,540
So let's delete this deepest note and will see this method and then it will break. Then our Banita will be represented, something like this. This is all we can do it a node from a binary tree.

40
00:08:56,770 --> 00:09:10,760
We have understood how to delete a node from a binary tree. This method will takes Bygrave in time complexity Axelle. It will take bigger of a tree in time complexity because of the find out the desired node and if defined, find it.

41
00:09:10,760 --> 00:09:21,860
The defense could then have to delete the deficit node so it takes a bigger tree and time complexity that's equivalent to be of it. And it all takes off in space complexity for that cube.

42
00:09:22,040 --> 00:09:38,570
Now let's see how we can find out the deepest node. This is the method to find the node first we're taking it or printing it is empty and we're exiting by this written statement are declaring a Q and we're adding the root note to the Q and we're setting Carino records to now.

43
00:09:38,660 --> 00:09:51,140
And this current will store the value of the node here. We should have zero dollar node, OK, not current node inside here. We're using Karnad here we have well the value is not empty.

44
00:09:51,170 --> 00:10:04,730
We're popping out the front element from CU. Then we're checking if the liberal is not Nelvis. We're adding the liberals to Q The retaining the right is not now then we're adding the results to the queue at the end will retain current node.

45
00:10:04,730 --> 00:10:14,240
The current node is the deepest node or the last note that you can find it traversing a monetary easing level or whatever. So let's see if we can find it.

46
00:10:14,240 --> 00:10:26,300
The deepest node we call this method first will create a Q and A will inside the node to the school that's inserted. Now let's support this Norten from the Q So this is your current node.

47
00:10:26,430 --> 00:10:36,440
Now we see Latrelle is not null. So let's add reptile to Q then the right side. The right side is not now. So let's add Reitzell to the Q now let's support this front element.

48
00:10:36,440 --> 00:10:45,740
Twenty now this is your current. So twenty's your current node. The left node is not now so let's add here not the right note is not null to that area.

49
00:10:45,740 --> 00:11:00,620
Right. Node 50 and that's different from our Q there is three reason to note. Left is not an outlet adare 60. Right is not. Now let's add here seventy now let's support front note from our Q there is forty.

50
00:11:00,620 --> 00:11:14,030
So our current nor is 40. The left is eighty. That is not nutzoid adhere to Q and the right is now. So we can add that to our Q then let's pop out this top element.

51
00:11:14,030 --> 00:11:26,450
Fifty now this is your current and Lipton right is now. Then our current owner is extreme left and right is not. They need to be done here then. Seventy, the left and right is now so that they need to be done here.

52
00:11:26,630 --> 00:11:37,220
Then we have eighty now this is your current node and the left and right is now so we're done and will return this node eighty to this function call get depressed node.

53
00:11:37,220 --> 00:11:50,840
So we get our defense node from this banditti. This is what we can find out that the first node, this Metrolink's because in time complexity and Bygrave in space complexity into it everything, every single note of our given biology.

54
00:11:50,960 --> 00:12:02,390
And it all takes off in space complexity to construct the cube data structure. We've understood this method. Now let's delete the deepest node. This is the method to delete the deepest node.

55
00:12:02,850 --> 00:12:16,880
Still checking, you've got to know they're printing empty and returning, if not, we're creating a queue and we're adding the tough note to the queue and we have yet to not prevent continued and we're initializing Brebner and continued to unload.

56
00:12:17,040 --> 00:12:40,090
Then we're taking Welches is not empty. We we're saying not to current and current, not to Kudret Pop. And the taking, if left, is now the we're setting that radical Sternhell and were existing ELT's if current, not that radical Sternhell then we're setting the north, setting the left of our current note to now and we're exiting by this written statement IFTTT.

57
00:12:40,410 --> 00:12:49,950
We're adding the left and right Celle to the queue. Let's see how we can delete the deepest note that we call this method. Then first we'll construct a queue that has structure.

58
00:12:50,070 --> 00:13:03,330
First we're going to insert heatin. So let's incertain and here Prevnar equals to current node. So prev all points to node. Initially they are going to pop out the front element from queue.

59
00:13:03,330 --> 00:13:17,340
So let's pop out. And this is your current note. The left and right is not now. So let's add here left and right. It's twenty and thirty. In the next iteration of this one we're going to set priv to this node.

60
00:13:17,610 --> 00:13:28,680
So let's set our tribute to this node, OK? And we're going to populate the front element from queue and we're going to sit. So we're going to set current through this node.

61
00:13:28,890 --> 00:13:44,400
Now we see the left and right of this, not twenty is not now. So let's add here 40 and let's add a 50. Then in the next iteration, we're going to move priv to this node and we're going to populate that element from CU, that is thirty.

62
00:13:44,640 --> 00:13:54,930
And we're going to set current to this node. Hardy. We see the left and right of this node part is not null. So let's insert here sixty and let's insert here seventy.

63
00:13:55,290 --> 00:14:07,980
Then in the next iteration we're going to set to this node. OK, so let's add to this note and let's support the front from our cue. That is forty. So current will point to this node.

64
00:14:08,310 --> 00:14:29,390
We see the lymph node of this node forty. And here we see the letter of this. Not forty is not a now let's check the right note. The right note is now we found it the right there is not a current that radical now and then what we're going to do we're going to say currently because now we're going to sit the left not to now so the left not will be connected to now.

65
00:14:29,790 --> 00:14:40,710
So this will be disconnected and this new will be removed by garbage collector. This is the person that we have removed here. We're using this written statement to exit from our function call.

66
00:14:40,710 --> 00:14:53,310
And this is how we can delete the divestment from a binary tree if we find out the left node is now. If we see here, the node of this, not forty is now, then what are we going to do?

67
00:14:53,310 --> 00:15:06,240
We're going to say that right now. In that case, we removed this note, all said don't do it right equals two now. So this note will be removed. This is what we can remove deepest not from a binary tree.

68
00:15:06,240 --> 00:15:19,470
Well, we've understood this operation delete the best node, this operational text. We go off in time complexity and we go up in space complexity. We've understood this, a explanation, if any, question from an issue understanding this explanation.


@@@
1
00:00:00,990 --> 00:00:12,510
Hey, you guys all come back to this video in this video. We're going to implement delete a binary tree method. This method will delete the entire binary tree.

2
00:00:13,170 --> 00:00:26,920
This is the delete binary tree method. This method takes no parameter insert here. We're just setting records to know whenever we set records to know the entirety will be deleted by garbage collector.

3
00:00:27,150 --> 00:00:41,920
Let's see how late you are given this binary tree. And here this is our root node. If we call this method delete a binary tree, then this route will be set to Knowland.

4
00:00:41,940 --> 00:00:53,800
OK, so this route will set to null node. Now we see there is nothing is pointing to this route. Node 10. So this node will be removed from Rambhai garbage collector.

5
00:00:54,120 --> 00:01:04,410
Now there is nothing is pointing to this node 20 and this node today. So this it will be removed by garbage collector as well. Now we see there is nothing else pointing to this node 40.

6
00:01:04,410 --> 00:01:13,680
So it will be removed by garbage collector. There is nothing pointing to this. Notably, this note will be removed by garbage collector. There is nothing is pointing to this, not 60.

7
00:01:13,710 --> 00:01:24,070
So this note will be removed by garbage collector as well. And then 70. There is nothing is pointing to this node 70. So this node 78 will be removed by garbage collector.

8
00:01:24,480 --> 00:01:41,100
Now we see our integrity is deleted. This is how this Adelita banditry method works. This method all takes constant time and constant space. Complexity of have understood how deleted binary method works.

9
00:01:41,600 --> 00:01:50,910
I have at the source code Jike the source code. If you have any suggestion, if you have any problem understanding this Aveda explanation, let us know.


@@@
1
00:00:00,420 --> 00:00:17,010
Hey, you got some guys in this video we're going to talk about Binelli du jour, so this is not a Korean video. In this video, we're going to see some due to our Seoul algorithm and how the traversal works.

2
00:00:18,960 --> 00:00:36,780
In this video, we're going to talk about pre-euro terror cell in your terror cell and post on a terror cell, there are many ways to terrorize a binary tree, but this three are the major terror cell algorithms and these are adept first terrorist algorithm.

3
00:00:37,110 --> 00:00:55,230
Now, let's see how the actually works. This video is the prerequisite for the next three video of this section working towards a binary search to using these three algorithm using recursively and iteratively for iterative approach.

4
00:00:55,260 --> 00:01:07,050
You have to use is tech in this video. Let's see the tricks involved to this traversal algorithm. First, let's talk about preorder traversal this traversal algorithm.

5
00:01:07,230 --> 00:01:21,560
First process the current node, then it will process the left note, then a right note. And this is applied for every single node of a given binary tree for the traversal first in-process the left.

6
00:01:21,570 --> 00:01:33,000
Not when you're done with the left node, the process, the current node, then the right note. And this policy will be applied to every single node for postulate ourself.

7
00:01:33,000 --> 00:01:48,930
First a process, the left and then right node, then the current node. And this policy is applied to every single node. Now let's see how we can devers a binary tree using preorder in order and post in details.

8
00:01:49,080 --> 00:02:05,300
First, let's talk about preorder traversal in for node, ill for left and after right. Let's suppose that this binary tree and we have to traverse this binary tree using the concept of P or the traversal.

9
00:02:05,580 --> 00:02:18,570
This is our current node. OK, this is our Regenhard. First we have here the node fristrup to process the node, this current node, then the lieutenant of this noted in the right note of this node.

10
00:02:18,780 --> 00:02:30,690
First, let's process this note. First we process this node so we get the value of this, not one. So we're done with this current node. Now let's go to the left.

11
00:02:30,990 --> 00:02:43,670
We have to process the left note. Then we have to process that right node and we can do this using recursion or we can do this using loof. Now, let's go to the left of this node and this is the left.

12
00:02:43,720 --> 00:02:57,330
Not so we moved to the node. So let's remove this when we're done with the left, then will back to this node for this node led process, that node to first.

13
00:02:57,900 --> 00:03:12,590
So let's add to to our list. We have process this node. This is our current node. Now let's go to the left node, then we'll move to the right node. So first we have to process the end of this development of this node is for.

14
00:03:13,080 --> 00:03:27,770
So we moved to the node. So let's remove this left here. Let's process this node for. So if we process this, not for it, we get the value for so let's remove this now.

15
00:03:28,830 --> 00:03:40,800
We have to move to the lieutenant of this, nor the lieutenant of this, nor is this not so we moved to the lieutenant. We're going to remove this left from here and here.

16
00:03:40,800 --> 00:03:53,010
Let's process this note so we get the valuate. And let's remove this note, since we have processed this note, then let's go to the left, Leptis now. So we're done.

17
00:03:53,370 --> 00:04:05,980
Let's go right and right is we see right now. So we're done with that right note as well. This will be done is in recursion or using it as Dec four is recursive called stack.

18
00:04:06,030 --> 00:04:28,480
We have new straight for every single recursive function. Call in that state will have that left, right and the current node for every single node. When we're done with the leftmost load, then back to this node for and here we see we have the right to node and this note is not processed and here we see it.

19
00:04:28,500 --> 00:04:39,570
We have the right node. So let's go to the right note and let's proceed the right note and the right note is nine. So let's process this node. So we moved to the right note of this node.

20
00:04:39,570 --> 00:04:52,560
So let's remove this right from this node. And here let's process this node nine so it will process. We get this value nine. Let's remove this. Now let's go to the left Leptis analysis node.

21
00:04:52,710 --> 00:05:06,830
So let's remove the left and the right and the right is not as well for this node. So we're done with the left side of this node two. Now let's go to the right subtree and this is our right subtree.

22
00:05:07,080 --> 00:05:19,440
So since we moved to the right, we will remove the right from here. So here we have this node five. Let's process this node. Every process does not. We get the value of five.

23
00:05:20,130 --> 00:05:30,840
Then let's go to the left of this note. That is ten. So let's remove this left from here. Here, let's process this node process. This note, we get the value chain.

24
00:05:31,740 --> 00:05:45,090
Let's remove it from here and let's go to left and left now. So we're done right is not as well. So let's remove this. So we're done with the left side of this node five.

25
00:05:45,240 --> 00:05:58,820
Now let's go to the right septillion right subtree. Is this not even so let's remove this are from here since we moved to the right step three year. Let's process this note so we get even.

26
00:05:59,190 --> 00:06:09,480
So let's remove this in now. We have to visit the left node is now also will just return. And here the right note is not as well. So it will just return.

27
00:06:09,840 --> 00:06:23,220
At this point we see that we have done with the about root node. So we're done with the left. Let's go to the right subtree. So this is our right node of this root node.

28
00:06:23,400 --> 00:06:36,660
So let's remove this right from here and here. Now let's process this node three. So let's add three to this list. We process this node three. Now, let's go to the left this year.

29
00:06:36,690 --> 00:06:48,450
Let's not let's process this node and let's remove here illegally. We process this note. We get six, then let's go to the left of this node and the zero left node and let's process this note.

30
00:06:48,450 --> 00:07:00,440
We get twelve. So let's remove this node as well. Since you moved to this node, to the left of this node six. So we have to remove this as well. And here, let's go to left.

31
00:07:00,450 --> 00:07:09,570
A left is now, so we'll just return. The right is not as well as business will return. And we're done with the lips of two of this node six. No, let's go to the right subtree.

32
00:07:09,840 --> 00:07:22,140
This is the right subtree. So let's remove this hour since we moved to the right subtree and let's process this node thirteen. So let's add this to our list, Tartine.

33
00:07:22,680 --> 00:07:32,700
So let's remove in then let's go to prison. Also will return, right is not as well to all return. So we're done with the laboratory of this node three.

34
00:07:32,970 --> 00:07:52,880
Now let's go to the right subtree and this is our right subtree. And let's remove this hour since we moved to the right up to here, let's process this node seven, let's add seven here and we're done with the current node and let's go to the left this node and let's remove it.

35
00:07:53,060 --> 00:08:06,680
Since you move to the left and let's process this note. We get 14. So let's remove in Leptis now, total return right now. So it will return as well. Now, let's go to the right of this node seven.

36
00:08:06,680 --> 00:08:19,460
That is 15 since you moved. Right. So let's remove this are in here. Let's process this node 15. So let's add 15 to this list and Leptis now. So let's remove it.

37
00:08:19,460 --> 00:08:30,260
Right is not as well. So let's remove it. This is our period of Tabassum techniques. First, we processed the current node, then we process the left node, then the right note.

38
00:08:30,470 --> 00:08:44,600
And these policies as applied to every single node. And this is called Purita. We get this list one two four eight nine five, 10, 11, three, six, 12, 13, seven, 14, 15.

39
00:08:44,900 --> 00:09:05,340
This is something like this. One to then not for. Then eight, then five, then 11, then three, then six, then 12, then this note 13, then seven, 14 and then 15.

40
00:09:05,410 --> 00:09:15,250
And this is the direction of the terror. So we understood that techniques are pure, the terror cell. Now let's talk about the techniques of the terror cell.

41
00:09:15,680 --> 00:09:26,550
Now we're going to talk about, you know, the terror cell. The formula here is that first of the process, the lip, not then the current, then the right note, and these policies will be applied to every single node.

42
00:09:27,430 --> 00:09:50,700
Let's consider this document binary tree. There's a root node. So before processing, this node will process the lipner. So let's move to the left. And here before processing is not to let's move to the left for and before processing this not let's go to the left and the left of this node for is this node eight, we will present this node eight.

43
00:09:50,710 --> 00:10:04,540
Let's go to the left and the left is so it will just return. That will process this node eight. So let's add it to list. So a process, this node now let's go to the right of the center and right is now.

44
00:10:04,550 --> 00:10:15,190
So it will just return. So we're done. We have process the left of this note for now. Let's process this node. So let's add here for so let's remove this.

45
00:10:15,190 --> 00:10:27,310
And now let's go to the right note of this node. And there is nine. So we moved to the right note. Now let's move to the node of this node nine. And there is now also it will just return.

46
00:10:27,610 --> 00:10:37,830
And then we have this node in let's process this node so impressive, this node, we get nine. Now, let's go to the right note of this node and there is now.

47
00:10:37,960 --> 00:10:51,670
So let's return for this node and we're done with the LoopNet of this node two. So now let's process this node to even process this. Nor do we get to now let's remove this here and now.

48
00:10:51,700 --> 00:11:02,650
Let's process the right of this node two and the right of this node to is five before processing this node five. Let's process the lymph node and the left of this node is ten.

49
00:11:02,660 --> 00:11:12,670
So let's remove this. We're going to move to the left. So let's remove this L and before processing this node, let's go to the left and left is now two will return.

50
00:11:12,850 --> 00:11:24,730
Now let's process this node ten. So let's add 10 to our list then let's go to the right and right node is now. So let's remove this hour as well. So we're done with the Livnat of this node five.

51
00:11:24,730 --> 00:11:43,250
No, let's process this node five so you get five. Now let's move to the right note of this node, and that is 11. And let's remove this node R and let's remove this R and now for this node before processing, this note will go to the left and left is now.

52
00:11:43,270 --> 00:11:55,100
So it will return the let's process this node 11 so it will add 11 to our list. Then let's go to the right and the right note is null. So it will just return at this point.

53
00:11:55,120 --> 00:12:07,130
We see that we are done with the left en route node. Now it's time to process our route, not be processed. This through not we get one. We processed our route node.

54
00:12:07,300 --> 00:12:23,950
Now let's go to the right note and the right node. So let's remove R from here and here before processing this note. Let's go to the left and our left node is this node six and before processing this node six.

55
00:12:23,950 --> 00:12:34,390
Let's go to the left here. Let's remove this as well. And here we were processing this node. Let's go to the node and lymph node is now two. It will just return.

56
00:12:34,390 --> 00:12:44,380
Then let's process this, not trilled. If we pursue this node, will we get trilled? Now, let's go to the right note of this No.12, and there is no answer, it will just return.

57
00:12:44,390 --> 00:12:56,390
So we're done with the safety of this Node six. Now, let's put it this Node six, it is not yet six. Now, let's go to the right note of this node six and there is 13.

58
00:12:56,990 --> 00:13:06,900
So let's go to the right note of this Node six. And there is starting. And here we were processing this node today. Let's go to the left left now so it will return.

59
00:13:07,430 --> 00:13:20,810
Now we have in so let's process this node 13, that area 13. Let's remove it and let's go to the right and the right is now. So it will just return. So we're done with the left subtree of this node is three.

60
00:13:21,020 --> 00:13:31,310
Now let's process this node three, this node, we get a three year process, this node three. So we're going to remove and now let's go to the right to node.

61
00:13:31,490 --> 00:13:42,050
And this is our right node. And here we were processing this not let's go to the left node and the left node is this not 14? And they'll be processing this node for the.

62
00:13:42,050 --> 00:13:50,560
Let's go to the left, Leptis now. So let's process this node and then we get 14. Now, let's go to the right note. And right now, the additional funding is now.

63
00:13:50,600 --> 00:14:01,030
So it will return. So we're done with the lives of this Node seven. So now let's process this node seven so you get seven. Now let's go to the right of the business seven, and that is 15.

64
00:14:01,310 --> 00:14:09,970
So let's go to the right note and this right node and let's process the LoopNet of this node. And there is now. So it will return. And let's process this note.

65
00:14:10,250 --> 00:14:23,120
Then we will get 15. Now let's proceed. The right note and the right note is now. So let's remove R and this is how we can traverse a binary tree in order to Owasso.

66
00:14:23,360 --> 00:14:33,650
And this is how you know, the traversal works for us to process the LoopNet. Then we process the current node, then the right note and this is how it works.

67
00:14:33,740 --> 00:14:46,280
Whichever is this binary tree using the traversal. Then we get this. We have understood this concept. If you are not understanding these explanations, I will encourage you to go through it with their own examples.

68
00:14:46,460 --> 00:14:56,560
Now let's talk about posted a traversal for post on the tower. So we are going to process the left node first, then the right note, then the current node.

69
00:14:56,900 --> 00:15:08,000
Let's see how it works for that. Let's take this one as an example. This is our root node. We have to process not first, then. Right. And then the current node.

70
00:15:08,120 --> 00:15:21,860
So let's go to the left of this node one, this little lip node of this node one. And now let's go left again. This is our left, not of this node to now let's go to the node again and here let's go to the node again.

71
00:15:21,860 --> 00:15:38,920
And we see that the letter is now also we will just return then let's go to the right note and right node is not as well. So let's return. And now we're going to process this node so we get that value valuate and we're done with this node.

72
00:15:39,200 --> 00:15:49,700
Now, let's go to the right note of this node four and there is nine. And here let's remove this are removed to the right note. And let's go to the left.

73
00:15:49,700 --> 00:16:00,410
Leptis, now, let's go to the right. Right is not as well. And let's process this node that we get nine by processing this node and we're done with the left.

74
00:16:00,410 --> 00:16:12,440
And right now let's process this node for so we get the value for and this concept will be applied to every single node. We're going to remove this node since the process, this node.

75
00:16:12,630 --> 00:16:23,390
Now, let's go to this node two and here we have to visit the right note. We will processing this node. So this is our right node. And let's remove R from here.

76
00:16:23,750 --> 00:16:32,990
We will processing this node. Let's go to the left of this, not five and there is ten here. I'm going to remove L and here before processing this note, let's go to the left.

77
00:16:32,990 --> 00:16:44,180
Left is no no let's go to the right. Right is not as well. So we'll just return and now let's process this. Not ten so we get ten. So we're done with the left of this node five.

78
00:16:44,420 --> 00:16:53,900
Now let's go to the right subtree. This is our right of this node five. Let's remove it since you move to the right note. And here let's go to the left.

79
00:16:53,900 --> 00:17:09,200
Left is now two will return. Let's go to the right. Right is now as well. Now let's process this node. Even if this not even when we get it, when we see that we have processed the left and the right of this node five, now it's time to process this node.

80
00:17:09,410 --> 00:17:20,030
If a person this not, we get five. At this point, we process the left and right subtree of this node to process this node, to process this, not to get to.

81
00:17:20,330 --> 00:17:31,940
Now, let's remove this in here. We see that we have processed every single load in the left side of this route node. Now, let's go to the right note. This is our right tree.

82
00:17:32,390 --> 00:17:47,990
And here let's remove here are in the let's go to the left. And this is our let's note of this note three, let's go to the left again and to each lieutenant of this, not six and no, let's go to the left again.

83
00:17:48,530 --> 00:18:02,010
Then it will return now. Then we have here are so let's go to the right at right is not as well. So let's process this node. Then we get trilled. So we're done with the left subtree of this node six.

84
00:18:02,030 --> 00:18:12,140
Now let's go to the right, the right of this Node six. So let's remove R from here and let's go to the left. Left is now. Right is now. So let's proceed.

85
00:18:12,140 --> 00:18:24,260
There's no return. So we get the Valot Harding and we're done with the left and right side of this node six. Now let's process this node so we get six and let's remove it.

86
00:18:24,830 --> 00:18:34,520
Now, let's go to the right of this node three and this is the right hand of this node three before process. This not. Let's go to the left. The left is fourteen.

87
00:18:35,030 --> 00:18:45,890
So let's remove your L and before this node four, let's go to the left. The left is now. Let's go to the right. Right is not as well. And let's process this not then we get fourteen.

88
00:18:46,730 --> 00:18:58,340
We have processed the lipner. Now let's go to the right note. So let's remove this node. Ah now let's go to the right of the business seven and there is fifteen and here let's go to the left.

89
00:18:58,340 --> 00:19:08,630
Left is now let's go to the right. Right is now as well. So let's process this now we get fifteen now we're done with the left and the right subtlely of this node seven.

90
00:19:08,720 --> 00:19:19,610
So let's process this node. So let's process this, not even process this. Now we get seven. And here also when we move to the right, we have to remove it.

91
00:19:19,940 --> 00:19:30,620
So we proceed this not seven now for this node, we process the left and right subtree. So now let's process this node so there's not going to get a three at this point.

92
00:19:30,620 --> 00:19:43,640
We see that process, all the node in the laboratory and all the node in the right for the root node. It's time to process this node. If a person does not, then we get one and let's remove in.

93
00:19:43,940 --> 00:20:00,770
So we get this list and this is how we can traverse a binary using posterior traversal. So in this video, we saw how to traverse a binary tree using preorder traversal in the table and posted a TOMMASEO in this section.

94
00:20:01,010 --> 00:20:22,520
We will see how we can implement the periodic table so the table and post to the terrazzo recursively and iteratively. If we implement this three traversal algorithms using recursively and intractably, then you will have an easy time solving problem der recursively or iteratively.

95
00:20:23,030 --> 00:20:35,210
First, I highly recommend you to understand the pre order in order and post to the tower. So when you are understanding the order in order and post to the tower, so then move to the next video.

96
00:20:35,390 --> 00:20:58,100
In the next video we discussed about Puru traversal, then we'll talk about in the traversal, then we'll talk about postulant traversal and you will see how we can implement pre order in order and posted a traversal in details what we have understood, the concept or the tricks for order in order and posterior Tyvaso.


@@@
1
00:00:00,990 --> 00:00:16,580
Hey, what's up, guys, in this video, we're going to solve a coding interview problem, binary tree preorder traversal. Given the route of a binary tree return the preorder traversal of its nodes values.

2
00:00:18,280 --> 00:00:30,400
So we're given a binary tree and we have to traverse the binary tree in order. Let's take an example. This is a binary tree and this is the root node.

3
00:00:30,430 --> 00:00:44,410
We have to traverse this binary tree in order to. So first we have to visit the leftmost node. So this year will read node. So we'll add this one to a list.

4
00:00:44,800 --> 00:01:04,200
So first one, then we'll go to the left. This is the left of this node one. So let's add here to the decision where lipner of this node to sell it at this node for and see the letter is now when you found left node is now will move to the right note.

5
00:01:04,540 --> 00:01:21,550
And here you see the right note is null as well. When you found left node and right node is now will visit the nearest right node and the nearest right note for this node is this note.

6
00:01:22,990 --> 00:01:40,630
So we'll add five to our list now. Let's go to the left, not left is null and right is not as well. So now what is the nearest right node of this? Not five and the nearest right node, is this destroyed?

7
00:01:41,140 --> 00:01:53,860
Or in other words, you can assume that when he found the left and right node is now for a specific node, we will go back. So far this node will go to this node.

8
00:01:54,340 --> 00:02:06,640
And for this not the right note is already visited. So let's go back. Then we'll move to this node and hear the right note, is this not? So let's add this node to enlist.

9
00:02:06,790 --> 00:02:17,680
And here we're adding the node value, not that node itself. Then let's go to the node decision. Let's not so let's add six to our list. And the node is now right.

10
00:02:17,680 --> 00:02:35,080
Node is not as well. So let's go to this node and let's add seven. And the node is now and the right note is now as well. So we have visited every single lot of this binary tree using preorder traversal how future terrorism works.

11
00:02:35,290 --> 00:02:46,270
First we visit the leftmost note when it found the lymph node is null, only then will visit the right note that first we have visited all the lymph node.

12
00:02:46,280 --> 00:03:02,660
Then when we found it Nalut, we move to the right note. And this is the direction of Premotor traversal first visit this node one, then this node two, then four, then five, then three, then six, then seven.

13
00:03:03,040 --> 00:03:12,790
So for this given input, we have to return this list for better understanding. Let's take another example now. Let's assume we're given this binary tree.

14
00:03:13,540 --> 00:03:28,000
We have to traverse this binary tree in order. So first we'll visit the leftmost node. This is our route node. So let's add one to our list now. Let's go to the left, not the left one, is this not?

15
00:03:28,420 --> 00:03:49,760
And when we're done with the left, not only then will move to the right note. And this is true for every single node. So let's add to to our list. Then let's go to the left not and this is our left not for so let's add forward to our list and we see let not is not.

16
00:03:49,830 --> 00:03:59,930
Let's go to the right note. And right now it is not as well. So let's go back and visit this node five. So let's add five to our list then let's go to the left.

17
00:03:59,930 --> 00:04:10,850
Not Lebanon is eight. So let's add age to our list then. The Lebanon is not right. Node is now. Let's go back and the right note of this node five is nine.

18
00:04:11,060 --> 00:04:32,990
So let's add nine to our list. Then let's go to the left of this node nine and this is 11. So let's add 11 and the left and right of eleven is now. So let's go back and write a note of this node is even so let's add even then we have the LoopNet of this, not eleven is twelve.

19
00:04:33,140 --> 00:04:48,990
So let's add here twelve and the left and right of this node twelve is now. So let's go to the right note of this node eleven and there is thirteen. So let's add 13 to our list and the left and right of this, not thirteen is now.

20
00:04:49,400 --> 00:05:07,790
OK, so let's go back to the root node. Since we have visited all the node in the three of this node, one so visited all the node in the left subtree. Now let's go to the right subtree and here we have three.

21
00:05:07,790 --> 00:05:19,520
So let's add three to our list. Then let's go to the left and there is six. So let's add here, six left and right is now. So let's go to the right note of this node three and there is seven.

22
00:05:19,670 --> 00:05:46,730
So let's add here seven and the left and right up seven is now. So we're done. We have visited all the node in this binary tree using pre the tower. So so the direction of the traversal is this first visit one, then two, then four five eight nine eleven, eleven, twelve, thirteen, then three, six, seven.

23
00:05:46,860 --> 00:06:02,000
So this is the priority reversal for that first tower. So we have three types of traversal prior to traversal in the tower. So and postulate Owasso and in this video we're covering the period traversal.

24
00:06:02,180 --> 00:06:17,000
So if you were given this binary tree, we have to return this list and this is the periodic table of this binary tree. Now, how we can solve this problem, we're going to solve this problem recursively and iteratively.

25
00:06:17,210 --> 00:06:28,790
First, let's see how we can solve this problem recursively this age. Our algorithm to solve this problem. And this is our given binary to, for example, first, let's review the algorithm.

26
00:06:29,360 --> 00:06:41,990
First, we have this function periodic table that takes the root of a given binary tree. Then we have list. This list will hold our answer. Then we're calling this function the effort with the root and the list.

27
00:06:42,140 --> 00:06:54,920
This function will visit all the node in preorder traversal this function, all servers, all the node in preorder, and it will add all the node value to the list variable at the end or returning the list.

28
00:06:54,920 --> 00:07:17,150
And this is our defense function. This function takes two parameter node and list. We check if routinely to know the idjit. If not is not equal to now, then we're adding the current node value and then we're calling, we're calling the defence function with no date left and list and then we're calling with that right and list.

29
00:07:17,390 --> 00:07:29,660
Now let's see how it actually works. This is our root node. So first visit the leftmost node first. So we have this node one and this note is not a download.

30
00:07:29,810 --> 00:07:44,600
So we'll add this value one to a list. So let's add one to a list. And this is the list. Then I'll let node. This is our LoopNet. When we're done with this, not only then will move to the right node.

31
00:07:45,530 --> 00:08:01,160
Now, let's add this value to to the list because this node is not involved. So let's add to the list. So two will be added here then let's call this defense function again recursively so we'll move to this node.

32
00:08:01,250 --> 00:08:15,260
So let's add this node value to our list, because this is not a node. So let's add here then. We have now load. So for now, just return this written statement or just exit then.

33
00:08:15,260 --> 00:08:26,990
Right node. Right node is not as well. So we're done. Let's go off. In this case, we're calling this defense function node that right. In this case, you're calling this function with no dot.

34
00:08:26,990 --> 00:08:40,230
Right. This is your current node and the value of this node is five and this is not a lot. So let's add it to our list then. Let's go to the left. We're calling this function with no dot left.

35
00:08:41,390 --> 00:08:53,330
So Lipner is a this is your current note, and this is not a download, so let's add this valuate to our list, then we have this not on the list. So legit.

36
00:08:53,510 --> 00:09:06,220
And for this function call, we have this knowledge. So here now, let's go to this ARITE note. And for this a right note, we see that this note is not a note.

37
00:09:06,230 --> 00:09:21,650
So let's add nine to our list and let's go to the left and left, nor is scanned and this is on another. So let's add 10 to our list. And we see that the note of this note is now in the right note is not as well.

38
00:09:21,800 --> 00:09:33,500
So the function call will edit for download. Now, let's go to this note. And this is 11. And this is not to download to let add it to our list 11. Then let's go to the left node.

39
00:09:33,510 --> 00:09:48,620
And this is our Whipsnade 12 and this is not another. So let's add this value to our list. We see that the left and right note of this note is also the function call selected for Knowland for left and right of this node.

40
00:09:48,800 --> 00:10:01,680
Now let's go to the right and right. Node is 13 and 13 is not another. So it added to our list. The left and the right note of this node is null, so the function will exit.

41
00:10:03,260 --> 00:10:24,000
So we have a process that lets out of this node one. Now let's go to the right subtree and this is our right subtree. So on the right, we have this node three, since we're done with the left touchup does not one to all move to the right subtree in this case or calling this function DFS?

42
00:10:24,030 --> 00:10:33,580
No, that's right. So this note is not an all out. So let's add three to our list. Now let's go to the left node. Left node is six. Six is not another.

43
00:10:33,590 --> 00:10:45,410
So that added to our list. And the left and the right of this node six is now also it will exit the function call for left and right now let's go to the right note.

44
00:10:45,410 --> 00:10:58,310
This is a right note. This is not a lot. So let's add seven to our list and the lipner is now also it will exit by this written statement and the right note is not as are also agreed by the written statement.

45
00:10:58,490 --> 00:11:12,470
So we're done with this recursive function call and we have visited all the node in this binary tree and we get this list and this is the node value for preorder traversal and this is to help the other tower.

46
00:11:12,470 --> 00:11:20,090
So it works and this is how we can solve this problem recursively. This is not a hard problem. If we try to do it on example's, then it will make sense.

47
00:11:20,630 --> 00:11:34,220
I encourage you to go through with this pseudocode, using your examples, try to draw everything and try to write every recursive function call. Then you will see how it actually works.

48
00:11:34,490 --> 00:11:47,150
If this is your first time, then I highly recommend you to go through it with your own examples and try to write out every single function. Call on a piece of paper that you do makes sense.

49
00:11:47,540 --> 00:12:02,960
The solution will take bigger off in time complexity. What is that number of nodes in the given tree? And it also takes bigger of in space complexity for the recursion called stack who are calling this function DFS recursively.

50
00:12:03,230 --> 00:12:14,810
If we include our answer list to the complexity analyses, the interspace complexity should be bego up to in. And that's equivalent to the graph in what we have understood.

51
00:12:14,980 --> 00:12:32,570
The piata traversal technique recursively. No, let's see how we can solve this problem iteratively. Let's suppose that we are given this brain energy and this is your algorithm for integrative approach and this is our Steck to solve a key problem using unity of approach, we have to use aztek.

52
00:12:32,690 --> 00:12:42,470
Let's see how we can solve this problem. Before that, let's review our algorithm. First, we have this functional product that takes the root node of a given binary tree.

53
00:12:42,470 --> 00:12:52,430
Then we have our list and then we're creating a stack and then we're checking. If the current node is not able to know, then we'll add that not to our list.

54
00:12:52,850 --> 00:13:10,520
Let's consider this is our list and this list all and this list all store the node values, then rechecking it. The right note current Pickerington is not to Nalden will add that note to our stack in the stack will also just add the right node.

55
00:13:10,670 --> 00:13:21,890
If the right note is Noriko's to now, then we're going to check if the lip node is now and its tag is not empty, then will pop out the top node from Steck.

56
00:13:21,920 --> 00:13:36,190
If not, then we're going to set the alert, not as our current node at the end will return our list. Now let's see how this actually works. So this is our root node and this node is not it now?

57
00:13:36,200 --> 00:13:47,160
Not so. Let's add the value of this not to. One, then let's say the right note and we see the right note is three and the right note is not in download.

58
00:13:47,220 --> 00:14:04,230
So let's add this node three to our stack here. We're storing the node, not just the value. OK, then let's go to the left node sent a letter is not an alert will move to the left node and we see that this note is not an A..

59
00:14:04,360 --> 00:14:24,230
So let's add the value of this note to our list. And the writer of this note is five, and that is not now. So let's add this node five to a stack. We're starting here, the node, not the value of a node, OK, then let's move to the left node sent the letter, is not it now.

60
00:14:24,780 --> 00:14:38,010
So this is our current node for this note that we see that right node is now, so it will not add the right to twistex is the right note is invalid. Now let's go to the left and we see on the left we have now not as well.

61
00:14:38,190 --> 00:14:52,140
If we have the results to now node, then what we'll do we'll check. If our stack is not empty, then we'll pop out the top element from Stack in that kid or we're going to pop out this element five from the stack.

62
00:14:52,320 --> 00:15:03,420
And before that, since we visited this node for. So we'll add this note to our list. Now, let's talk about this node five from the stack. We have proposed the node five.

63
00:15:03,450 --> 00:15:18,620
So this is our current node. And we say that this note is not a now node since this node is not a node, will add the value of this note to our list. Then until the right node in the right note is not an add that not to our list.

64
00:15:18,750 --> 00:15:29,210
So let's add here nine years to the node and now let's go to the left node and we see the left note is not a download. Since then, let node is not another.

65
00:15:29,220 --> 00:15:37,650
So let's go to the left node, the southern Lebanon and we see the right note is another. So we're not at that, not touristic. So let's go to the lymph node.

66
00:15:37,650 --> 00:15:52,020
We see the left note is now. Before that we have to add Disvalue eight to our list. Since this node is not allowed on the left, we have this node. Now, if we found the results to null, we will check the stack.

67
00:15:52,020 --> 00:16:03,120
Each stack is not empty, will return the top element and will remove that element. So it will pop out this Node nine and move to this node. So let's remove this note.

68
00:16:03,420 --> 00:16:15,030
And now nine is our current node. Since nine is not enough not to let add nine to our list and see that the right note of nine is not in order to let add element to our stack.

69
00:16:15,210 --> 00:16:27,120
Now we see the node is not included, so it will move to the node. This is your current node since this note is not. And also let add this note to our stack and here we see the right note is Knowler.

70
00:16:27,130 --> 00:16:39,420
So it will not add this to our stack and we see that Lebanon is a node. If we found the Lebanon is not and stack is not empty, that will pop out the top element from Stack and will move to the node.

71
00:16:39,600 --> 00:16:51,540
And in this case it will support the node eleven from the stack and will move to this note element. So this is our current node, since this node is not a knowledge that will add this note to our list.

72
00:16:52,170 --> 00:17:05,570
And for this note, we see that the right word is not an alert. So let's add the right node, Taryn, to our stack. Now let's go to the left node. Since the left is not another traditional current node, we see this node is not another.

73
00:17:05,580 --> 00:17:21,840
So let's add tilt to our list then let's take the right note and the right note is now not so will not add another terrorist attack. Then we will move to the node and the left not is another word since the letter is an alert and stack is not empty.

74
00:17:21,840 --> 00:17:36,380
So it will return the top element from Stack and it will move to the node in the schedule. Visit this not tareen and will pop out this node for this node we see it is not is not not to let added heart into our list here.

75
00:17:36,390 --> 00:17:45,750
You see the right note is so it will not add that note to our stack. Now let's go to the left node and we see the left note is a lot and our stack is not empty.

76
00:17:45,750 --> 00:17:56,530
So it will return the top element from Stack and will move to that node. So let's talk about three and let's go to this node for this. Now that we see that right node is not a download.

77
00:17:56,550 --> 00:18:10,290
So let's add the right note seven to our stack and we see the left node, is not it? Now, let's move to the left node. Since you have visited this node three, we must add this note to our list.

78
00:18:10,470 --> 00:18:19,690
Now we see the letter is not a null. Also, let's call it. It's not your current node. And the right note is not only to add this notorious stick. We say that this note six is not included.

79
00:18:19,710 --> 00:18:29,880
So let's add this note to our list six. Now we see the right note is that Knoller's. So it will not add this note to our stack and the left note is now a lot and stack is not empty.

80
00:18:29,880 --> 00:18:41,820
So it will return the top element from Stack and that is seven. We promote the top note from Stack and it will move to this node seven. Right. And here we visited this not seven.

81
00:18:41,820 --> 00:18:54,150
So let's add this Node seven to list and the right note is now two will not add this notorious stack and the node is now and our stack is empty, so it will not visit anymore node.

82
00:18:54,690 --> 00:19:13,890
We have visited every single note of this binary tree in the traversal and this is the algorithm for peo traversal and this is how it works. What we have understood the concept of pure terror so iteratively the solution one to speak of in time.

83
00:19:13,890 --> 00:19:23,990
Complexity what. It is the number of nodes in the given tree and the solution text bigger of two in space complexity to construct the stack and to construct our list.

84
00:19:24,320 --> 00:19:37,490
So the overall space complexity is bigger in that order of in and this is how we can traverse a binary tree in order. So this is the periodic table of a binary tree.

85
00:19:38,030 --> 00:19:49,900
In order to understand, in order to sink your head around to this problem, you have to try it with a couple of examples. Then it will make sense. I highly recommend you to go through it with your own examples in this video.

86
00:19:49,970 --> 00:20:00,920
We have solved this problem recursively and iteratively, whether you've understood this concept. If you have any questions, if you have any suggestion, let us know.


@@@
1
00:00:01,590 --> 00:00:15,590
A lot of guys right in this video. We're going to solve a creative problem, binary tree in order traversal given the root of a binary tree returned in the traversal orbit nodes values.

2
00:00:16,710 --> 00:00:45,090
For example, if you're given this binary tree, then you have to traverse this binary tree in order here. Have no first will process this node eight, then will process this node for this node nine, then two, then 10 five 11 one 12, then this node six.

3
00:00:45,480 --> 00:01:13,810
Then this node 13. Then this node three. Then this node 14. Then seven, then 15. OK, and this is called in the Tower. So first we have to process that, let not then the correct then the right note, and these policies will be applied to every single node if you are not understanding in the tower.

4
00:01:13,820 --> 00:01:25,370
So I highly encourage you to was the first video in this section. Now let me show you how we can solve this problem recursively. Then we'll see how we can solve this problem.

5
00:01:25,490 --> 00:01:37,830
Iteratively using it steck. Now let's see recursive approach. This is our recursive algorithm to solve this problem. First, let's review this algorithm, then we'll see how it works.

6
00:01:38,420 --> 00:01:48,050
First, we have this function in order to our cell that takes the root of a human body. And then we have our list. This list, this list will hold our answer.

7
00:01:48,470 --> 00:01:58,760
Then we're calling this function helper with root and the list. Then we're returning the list this year. Function definition helper. It takes two parameter node and list.

8
00:01:59,090 --> 00:02:14,460
Then we're checking if the records to know. Then by this original statement, idjit, then we're calling. We do not reflect and list recursively. Then we're adding your current node to the list and then we're calling.

9
00:02:14,480 --> 00:02:27,800
We don't know that right and list. Now let me show you how it works here. This helper function will call recursively and you know that it becomes invalid.

10
00:02:28,040 --> 00:02:39,130
Now let me show you how it works. So first we have this arachnoid on the left of this not root. We have the node two on the left up to we have the node four on the left of four.

11
00:02:39,140 --> 00:02:50,740
We have not eight. And on the left of Node eight, we have now selected for this function. Call for this node, OK, because not at liberty close to now.

12
00:02:51,020 --> 00:03:00,500
Now, let's process this note. We're going to process this not by this statement list, but adding on that. Well, so let's add this note value to a list.

13
00:03:00,860 --> 00:03:13,130
Now, let's go to the right of this, not the right of this node is now. So the function call will get by this written statement. Then let's go to this node and we're going to process this node.

14
00:03:13,280 --> 00:03:27,350
And here we're going to add the node value for to our list. Now, let's go to the right of this, not the right of this, nor is this not nine a.m.. Let's go to the left, Leptis now.

15
00:03:27,530 --> 00:03:38,690
Now, let's process this not in processing minute. We're adding the not value to the list. So let's add the nine to this list. Let's go to the right right now.

16
00:03:39,020 --> 00:03:50,120
So it will just idjit by the written statement right there on the left side of this note to the wait times to process this note. So let's add this note to the list, then.

17
00:03:50,120 --> 00:03:59,200
Let's go to the right of this note. On the right, we have this note, five on the left of this note five. We have this note. Turn on the light up. Ten we have now.

18
00:03:59,540 --> 00:04:09,230
Now, let's process this note again. Let's add the value to here. Now, let's go to the right. Right is now to function. Will edit. Then let's process this node five.

19
00:04:09,920 --> 00:04:21,190
Let's add the value of five to the list. Now, let's go to the right of this, not find the right of this node five is 11, and let's go to the left of 11.

20
00:04:21,620 --> 00:04:36,770
There is now the function, call it. Then let's process this. Not we get 11 and let's go to the right right now. So we're done with the left subtree of this, not one right now.

21
00:04:36,770 --> 00:04:46,570
It's time to process this note. We process this note. We get the value one. Now, let's go to the right of this node, one that is three. Let's go to the left of this note.

22
00:04:46,580 --> 00:04:57,310
Three, that is six. Now, let's go to the left of this node six and there is twelve. And the left of this, not twelve, is now. So the function will exit.

23
00:04:57,320 --> 00:05:17,900
Now, let's let's add the node value to add to the list. Now, let's go to the right of this, not the right is now it will aget then let's process this Node six now let's go to the right, right is this node 13 and let's go to the left of this node 13.

24
00:05:17,900 --> 00:05:29,710
That is now the function call will exit. Now, let's add that note value to the list. Starting now. Let's go to the right. Right is now the function will edit here.

25
00:05:30,320 --> 00:05:40,970
Now, let's process this node three now. Let's go to the right of this, not the three and that is seven. Now, let's go to the left of this, not seven. That is fourteen.

26
00:05:41,420 --> 00:05:53,480
And let's go to the left of this, not four in there is now and then let's add another fourteen. Then let's go to the right of this node foreign that is known to function call it will exit.

27
00:05:53,780 --> 00:06:09,440
Now, let's process this node seven. Now let's go to the right of businessman and there is 15 and let's go to the left, that is now also the function called Will Exit and let's add this note value to the list.

28
00:06:10,220 --> 00:06:20,600
And now let's go to the right and right is not a phone call. It will exit. So we have to reverse this binary actually using in order traversal techniques.

29
00:06:21,250 --> 00:06:40,030
We have understood that in order terrazzo. This is our recursive solution and this is how it works. Eappen understanding. I highly encourage you to go through with your own examples and try to write everything on a piece of paper to see things how it works.

30
00:06:40,340 --> 00:06:53,840
We have a lot of recursive function call. If you are not familiar with recursion, then I will highly encourage you to write out all the function, this piece of paper so you can understand it better.

31
00:06:54,470 --> 00:07:06,890
The solution will take off in time complexity. It is the number of nodes we have in the given tree and it will take off in space complexity. For the recursion called stick.

32
00:07:07,880 --> 00:07:18,490
We've understood the recursive solution. Now let me show you how we can solve this problem iteratively. This is our iterative solution to this problem.

33
00:07:18,650 --> 00:07:29,510
Your algorithm? No, let's review the algorithm first, then we will see how it works. First we have the function in order traversal that takes root of a given binary.

34
00:07:29,840 --> 00:07:45,230
Then we have the result list here. Then we are creating a stack to solve every problem we have to use. Aztek then our current node is a root. So first our current node is root, then this.

35
00:07:45,280 --> 00:08:02,660
Why live? If the current node is not equal to no end stack is not empty, then we're going to check. If current element is not now, then we're going to push that element to stack and then we're going to move to the left and then we'll pop out the top element from Stack.

36
00:08:02,660 --> 00:08:15,980
Then we're adding the value of the population to our result list. Then we're moving to the right note at the end, unreachable that result list. Now let me show you how it works.

37
00:08:16,190 --> 00:08:26,990
Our current law is one. First, we'll add the node, one to stack, then we're going to move to the left node. So we're done with this node. Let's move to the left node.

38
00:08:26,990 --> 00:08:41,240
And this is our lips node. We see this not is not Egleston. Also, we'll add that node to our stack. Now let's go to the left of this node two and on the left we see we have this node four and this is not a now node.

39
00:08:41,390 --> 00:08:55,660
So let's add the node juristic. We're adding the node to stack, not the value. OK, now let's go to the left of this node for and on the left we have this node eight and it is not now load.

40
00:08:55,730 --> 00:09:09,080
So let's add it to our stack. Now, let's go to the left of this Node eight and we see that on the left. We have it now. Not when you found now node on the left will pop out the top element from Stack.

41
00:09:09,350 --> 00:09:23,210
And if we proposed this node from this stack, then we get this, not eight. OK, now if we add the value of node, the report from Stack, the first value is eight.

42
00:09:23,360 --> 00:09:51,860
Now we're going to move to the right and on the right we see that we will now node. So we have processed this node and let's go to the right. And also we have to remove this from our stack and we see on the right we have it now since we have the right now not so there's a relative will not run and this one will run because Stack is not empty and this relative will not run because the current node is it now node.

43
00:09:51,950 --> 00:10:08,770
So it will support element from Stack. So we get the nod for and let's add the value to our list. And let's pop out, we have processed the current node, now let's go to the right of this Node four and on the right we see it.

44
00:10:08,770 --> 00:10:18,400
We have not nine. Nine is not a download. So let's add this nine to our stack. Then what I'm going to do, I'm going to move to the left of this node nine.

45
00:10:18,700 --> 00:10:30,850
OK. And on the left, we see it live in L.A. when you found on the left now node, then we'll pop out the top element from Stack so it will pop out this nine from Stack.

46
00:10:31,180 --> 00:10:47,860
Then we're going to add this node value to our list and remove that from stack and let's go to the right. Right is now as well. Then what I'm going to do when you found right to now then will pop out the top element from Stack.

47
00:10:48,070 --> 00:11:01,620
So let's pop out this element from Stack and let's add the value of that element to the list. So we have processed this node two. Now we're going to move to the right and the right of this node is this node five.

48
00:11:01,630 --> 00:11:11,770
And this note is not a now not. So let's add this not to our stack. Now, let's go to the left of this node five on the left of this node five, we have this node ten.

49
00:11:12,040 --> 00:11:30,760
Now, let's add this node turn to our stack since this note is not a download. So we're going to add 10 to a stake. And now let's go to the left. On the left, we see that now when he found it now will pop out the top element from Stack and it will add the node value to our stack.

50
00:11:31,000 --> 00:11:43,900
So we pop out the node ten from Stack. We get here ten and we'll add that Vallentine to that list. And then let's go to the right of this node 10 on the right.

51
00:11:43,900 --> 00:11:53,740
We have now learned when you find now node on the right so it will pop out the top element from Stack. So let's pop out this element from Stack and let's add the value to our list.

52
00:11:54,040 --> 00:12:07,810
So we have processed this node five. Now let's go to the right of this, not five and that is 11. 11 is not it now. So let's add 11 to the stack, restoring the node, not the value.

53
00:12:07,810 --> 00:12:18,760
OK, there on the left of 11, we have now when you found that left now will pop out the top element from Stack and it will add the value of that node to our list.

54
00:12:18,970 --> 00:12:45,800
So let's add here, 11 and 11 from here. We have processed this node even now. Let's go to the right of this, not 11. And we see on the right we have now when you found now on the right, we will support the element from Stack in the stack is not empty, so will support this node one and we will add the value of that node to our list.

55
00:12:45,910 --> 00:12:59,410
So here we see we have processed this node. Now let's go to the right. On the right we have this node three. Two is not another. So let's add that to our stack and let's go to the left of node three.

56
00:12:59,740 --> 00:13:14,060
And on the left we see six. Six is not enough not to let add six to our list. Now let's go to the left of six and on the left of six, we have this node 12 and two is not now lateraled.

57
00:13:14,170 --> 00:13:27,190
Add that to our stack. Now let's go to the left of twelve. We see now when you found out the top element from Stack. So if you want to get the valid twelve, let's add twelve to our list.

58
00:13:28,650 --> 00:13:43,960
So we have processed this, not 12. Now let's go to the right right now so it will pop out the top element from Stack, so will pop out this Node six. And I will add that to our list and by this line here, OK.

59
00:13:44,280 --> 00:14:00,510
Registered at Green Dot. Well, so we have processed this node six. Now let's go to the right writers, 13, 13, 13 is not enough not to let add third into our stack and the left of 13 is a download.

60
00:14:00,690 --> 00:14:13,180
So let's pop out the top four element from Stack and we'll add that element to our list. So let's add here 13 and let's pop out this. Starting in the process, this not tiring.

61
00:14:13,240 --> 00:14:25,960
OK, now let's go to the right right now. If we found right is now will pop out the top element from Stack if Stack is not empty. So let's talk about this element from Stack and let's add it to this list.

62
00:14:26,260 --> 00:14:37,960
And here we are processed this node three. Now let's remove this node from the stack and let's go to the right of this node three and there is seven. Seven is not.

63
00:14:37,990 --> 00:14:54,420
Now, let's add seven to our stack and let's go to the left of seven. And that is 14 and 14 is not a now that will add four into our stack. So we'll add four and touristic on the left of 14.

64
00:14:54,670 --> 00:15:03,850
We have now node. So it will pop out the top element from Stack and it will add that to this list. So let's add 14 to this list and let's pop out this morning.

65
00:15:04,520 --> 00:15:15,880
So you process this node 14. Let's go to the right right now. So let's put the top element from Stack. So we'll add seven and let's remove this element seven from here.

66
00:15:16,090 --> 00:15:28,270
So we are processed this node seven. And let's now let's go to the right of this, not seven. And that is 15. 15 is not now. So let's add 15 to our stack and let's go to the left.

67
00:15:28,660 --> 00:15:43,360
On the left, we see we have it now node. So we'll put the top element from Stack and there is 15 to let add 15 to our list and let's remove that element from our stack and process this node 15.

68
00:15:43,930 --> 00:16:00,160
And now we have right right now this node 15 and our stack is empty. Epiphone right is null and Stack is empty, this world of will stop executing Kynan is now.

69
00:16:00,370 --> 00:16:09,520
So it's not good to know this condition is felt here and this condition is false here. So this one Leubsdorf here and we're done and this is how it works.

70
00:16:09,520 --> 00:16:21,910
And we have understood that without explanation. The concept is that first you first visit the leftmost note by adding all the not from a root to the leftmost, not to a stack.

71
00:16:22,120 --> 00:16:33,400
We never found the left. What is it now then. All the top node from Stack and all add the nodes value to our list and we move to the right of our popped out node.

72
00:16:33,400 --> 00:16:46,270
And if we found right node is now, then also will pop out the top element from Stack. If Steck is not empty and this is how we can solve this problem, the solution will be go off in time.

73
00:16:46,270 --> 00:17:00,320
Complexity is the number of nodes we have in a given binary tree and the solution will take off in space complexity to construct that stack. This is how we can solve this problem iteratively.

74
00:17:00,650 --> 00:17:16,900
Have you understood the value explanation in this video? We have discussed about recursive solution and intuitive solution. We've understood, but if you're not understanding any of them, I would highly encourage you to go through with their own examples.


@@@
1
00:00:00,810 --> 00:00:13,920
Hey, what's up, guys, right in this video, we're going to solve a coding interview problem, binary tree poster traversal, given the root of a binary tree, return the post order traversal up.

2
00:00:13,920 --> 00:00:28,110
It's not values. Now, let me show you how we can solve this problem. For example, if you're given this binary tree, we have to traverse this binary tree in post order.

3
00:00:28,740 --> 00:00:52,920
Here we have no. First, we have to process this Node eight, then this node nine. Then this node four. Then this node 10, then 11, then five, then seven, then 12, then 13, then 10, then 14, 15.

4
00:00:53,950 --> 00:01:07,980
Seven, three and one now in this video, we're going to solve this problem recursively and iteratively first we're going to see how we can solve this problem recursively.

5
00:01:07,990 --> 00:01:23,670
Then we'll talk about iteratively. If you're not understanding first order Tabassum four is not. We have a policy here. Infonet are four, right? Not for the current, not for every single node.

6
00:01:23,690 --> 00:01:33,910
This policy will be applied for this node. First review process, the left, not the right, not then the current node. And this policy will be applied to every single node.

7
00:01:34,090 --> 00:01:49,450
If we apply this policy, then we will get this list. If you're not understanding, I request you to watch the first video to this section. No, let me show you how we can solve this problem recursively.

8
00:01:50,290 --> 00:02:04,330
This is our recursive algorithm to solve this problem. First, let's review this algorithm, then we'll see how it works for us to have this function post or a so that takes root up a given binary tree.

9
00:02:04,330 --> 00:02:22,330
Then we have list this list all store the answer. Then we're calling this function helper with a root and list the node returning the list. This helper function will traverse the bunny tree and will construct the list using preorder terrorism techniques.

10
00:02:22,690 --> 00:02:34,570
And here we have this function definition helper. This function takes node and the list as input. And here we're going to take the current node is equal to now then will return.

11
00:02:35,670 --> 00:02:51,000
They're calling the function recursively that let the list when it encountered now not on the leftmost, not the normal, call it with the right note and then we're adding the current value to the list.

12
00:02:51,510 --> 00:03:08,580
Now, let me show you how this actually works. First, we have Ehle, so we have to process the node first. So let's go to the left of this node, one recursively calling this helper function, OK, and have to move to the left of this node two.

13
00:03:09,000 --> 00:03:26,220
So the left of this note to his four and the left of this node four is this node eight. And the left of this node eight is now when he found a little bit of a node is now will it did that function call using this written statement?

14
00:03:26,680 --> 00:03:38,340
Now let's go to the right. On the right we have now node where he found now node will just return. That meant all exit then whole process this not see, we process this node.

15
00:03:38,340 --> 00:03:50,410
Our node value is eight. So we're done with the legend of this, not for now. Let's go to the right of this node. On the right we have this node. So now let's go to the left.

16
00:03:50,470 --> 00:04:02,690
Left is now and right right is not as well known. Let's process this node so we get nine. Now we're done with the left and right, none of this, not for now, let's process this node.

17
00:04:02,900 --> 00:04:15,530
So let's add the value for Tonalist. Now, we're done with the little of this note to note, let's go to the right note and here we have this right note five.

18
00:04:15,970 --> 00:04:31,650
Now, let's go to the left of this. Note five. And there is no let's go to the left lefties now and right now, now, let's process this. Now that we get 10, 20 found left now or right now, the function call will Edgett.

19
00:04:32,400 --> 00:04:42,950
We turn to the left and let's go to the right. Right. Well, let's go to the left. Left is now right is not as well. Let's put this note so we get value 11.

20
00:04:44,140 --> 00:04:57,640
Then let's process this, not five, let's add here, five now we're down to the left and the right safety of this not to let's process this node so we get to now we processed the left of this node one on.

21
00:04:57,640 --> 00:05:06,400
Let's go to the right side of this node one. So let's go to the right subtree here. We have this node three. Now let's go to the left. On the left, we have this node six.

22
00:05:06,400 --> 00:05:16,480
Let's go to the left. On the left of six, of this node twelve. And let's go to the left of this node twelve. That is now. So it did right. A misnomer is null as well.

23
00:05:16,480 --> 00:05:31,480
So Edgett. And then we have this current let's process this note. We get the value twelve. Now let's go to the right of this node six. Since you processed that, let's up to this node six.

24
00:05:31,480 --> 00:05:47,150
Let's go to that right on the right we have this node thirteen. Let's go to the left of this node 13. And on the right of this note, we have 13. So let's add now we have to process this note.

25
00:05:47,320 --> 00:05:59,820
Let's add to our entire list. At this point, we see we have processed the left and right subtype this node. Now let's process this node so we get that value six.

26
00:06:00,520 --> 00:06:12,220
Now, let's go to the right of this node three. If we move to the right, we get this node seven. Now let's go to the left of business seven. We get this node forwarding that to the left.

27
00:06:12,220 --> 00:06:26,680
Left is now right. It's now. Let's process this node fording. Let's add here. Fourteen now let's go to the right of this node seven there is fifteen. Let's go to the left of this, not fifteen that is now in there to remove this.

28
00:06:26,980 --> 00:06:39,850
And on the left of this fifteen we have now and on the right we have now. So now let's process this note that we get fifteen. OK, now we have process the left and right to this node seven.

29
00:06:40,390 --> 00:06:50,200
Now let's process this node so we get seven. Now we we see it. We have process the left and right subtree of this node three and let's process this node.

30
00:06:50,440 --> 00:07:00,790
You process this note, we get three. Now, at this point we have done with the left and the right set up on route node. Now let's process this not even process.

31
00:07:00,880 --> 00:07:22,900
There's not we get one, OK? And we have processed all the nodes in this binary tree. This is how we can solve this problem. Using recursion. If you need understanding, try to go through with your own examples and try to write it every single recursive function call on this piece of paper, then it will make sense.

32
00:07:23,290 --> 00:07:36,390
This solution will take bigger of in time complexity. What is the number of nodes we have in the given tree and it will take off in space complexity for the recursive call stack.

33
00:07:37,120 --> 00:07:47,770
Now let me show you how we can solve this problem. Iteratively for iterative approach. We have to use a stack. This is our recursive algorithm to solve this problem.

34
00:07:49,030 --> 00:07:58,120
First, let's review the algorithm, then we'll see how it works. First, we have this function post order traversal that takes the root of a given banditti.

35
00:07:58,600 --> 00:08:12,820
Then we released this list on hold. Our answer, then we are declaring a stack. Then we're going to check if we're going to return the empty list and then we're going to insert the root, the root node touristic.

36
00:08:12,820 --> 00:08:28,660
So we're going to insert the root, not one our stack. Then we're going to check. If Stack is not empty, then we're going to pop out the element from top and then we're going to add the value to that list from the end.

37
00:08:29,440 --> 00:08:40,270
And then we're going to check if the left is nobody else to now, then we're going to push the left and the right is not going to push the right. And then we're returning the list.

38
00:08:40,540 --> 00:09:03,250
The overall idea here is that first we'll insert the root, not juristic. Then we will check if the left is not empty, will insert to stack. And if the right is not empty, then it will insert to the stack and then pull out the right and insert the left and right and then out the right will insert the left and right.

39
00:09:03,490 --> 00:09:19,660
And we'll keep doing this process until we have traversed all the nodes in a given tree to everything simply means visiting in nodes. OK, now before we start solving this problem, let's see a pattern here.

40
00:09:19,690 --> 00:09:56,590
We see that on the bottom. We have one and here we have a pat one tree, then 15, 11, then ten, nine, eight. Then seven, six, five, four, three, two, one, and we see a direction here, OK, and this is something like a terror cell or other terror cell, whichever's the human binary tree from the left side or something like this in order, whatever the argument is, something like this.

41
00:09:57,950 --> 00:10:25,910
Right this direction, OK, in preorder. And here we see that, here you see that if we add one from the end, very end, then at the end one, then three, then seven, then 15, then 14, then 13, six, something like this at the end one, then three, then seven, then 15 and so on and so forth.

42
00:10:26,210 --> 00:10:44,630
Then we'll get our answer in post order traversal. And that what we will do using iterative approach will the route on the stack first, then proposed route and will insert left and right and will pop out the top.

43
00:10:45,440 --> 00:10:56,990
That means the right and then we'll insert left and right and we'll be doing the opposite until we have traversed all the nodes and we'll be adding the no.12 from the very end.

44
00:10:57,290 --> 00:11:10,910
Now let me show you how we can solve this problem iteratively. And this is the core intuition. Now, first, what I'm going to do first I'm going to support this node and I'm going to add it to a list from the end.

45
00:11:11,050 --> 00:11:25,280
OK, one. So we have to process this one. Then what are we going to do? We're going to add the late node and the right note and we propose that not one from Stack and will add two and three.

46
00:11:25,650 --> 00:11:39,770
We're adding the node, not the nodes. OK, then what are we going to do? We're going to pop out the node three from Stack. OK, we're going to pop out the top element from Stack and that is three.

47
00:11:39,950 --> 00:11:54,110
So let's add it to the list in reverse order. OK, from the right to left now, we're going to remove this node three and let's add the left and right to stack six.

48
00:11:55,770 --> 00:12:09,780
And seven. Now, let's out the top element from Stack, that is seven, so let's add it to our list. And then for that note, seven, the left is not now to let's add to our stack.

49
00:12:10,860 --> 00:12:33,260
Fording, this is not not a value, OK, and right is not now to it, add 15 to our Steck. Now we're going to pop out the top element, and that is 15. So let's pop out 15 and let's add 15 to our list in reverse order from right to left.

50
00:12:33,620 --> 00:12:45,470
So we have processed one three seven 15 and we see Leptis now. So why not push left the stack and we see right now so will not push right to that stick.

51
00:12:45,860 --> 00:13:05,700
Now, what are you going to do? We're going to pop out the top element from Stack, if left and right, both now and Stack is not empty. So let's put that top element from Stack 14 and let's add it to our list and let's see if the light of 14 is normal.

52
00:13:05,720 --> 00:13:16,660
And we see now to not add this to the stack and the right is now also will not add this to the stack. So so process does not 14 and we select and right.

53
00:13:16,670 --> 00:13:36,250
Is now. So we will pop out. The top element from stack in the stack is not empty and we stack is not empty. So let's pop out this element. But the node from stack we get six, let's add here six and let's remove it from Stack and the left of six is 12.

54
00:13:36,440 --> 00:13:53,170
So 12 is not now. So let's add 12 touristic and the right of six is 13. 13 is not null to let add 13 to our stack. Now what are you going to do? We're going to pop over the top element from Stack and that is 13.

55
00:13:53,300 --> 00:14:05,090
So let's add it to our list in reverse order from right to left. So we have 13 left of 13 is null and right of 13 is now. So we can't add left and right or stack.

56
00:14:05,750 --> 00:14:20,420
If we found a left and right is now will pop the top element from Stack IV stack is not empty. So let's pop out twelve. He will pop out twelve then we get the value twelve and the left and right note of this node twelve is now.

57
00:14:20,430 --> 00:14:28,940
So we can add that to our sweet process. This not twelve. Now what are you going to do? We're going to pop out the top element from stack in the schedule about two.

58
00:14:29,180 --> 00:14:44,000
So let's add to add to our list and let's remove two. And on the left of two we have not for four is not now. So let's add for touristic and the right is not included as well.

59
00:14:44,000 --> 00:15:00,530
So let's add five to that stack. Now, what are you going to do? We're going to pop out the top element from Stack that is five. So let's add five to our list in reverse order and let's pop out five and the left of five is ten.

60
00:15:00,530 --> 00:15:10,220
Let's add two to stack. Since ten is not a load, then let's add the right node. Right node is 11. Now, what are we going to do? We're going to pop out the top element from Stack.

61
00:15:10,280 --> 00:15:22,370
So we're going to pop out even now. We're going to now the left of eleven is now and the right is now. So we can add that two stack and stack Epiphone left and right.

62
00:15:22,610 --> 00:15:35,450
Open order is now. It is not empty. Let's pop out the top element. That is ten. So let's add here ten to our list and let's be about ten from Stack. And we see that we process ten as well.

63
00:15:35,810 --> 00:15:50,060
The left and right up ten is now. So we will the top element from Stack and with this stack is not empty. So let's put this element four and will add to our list and we see that the left and right a pop out element is eight and nine.

64
00:15:50,060 --> 00:16:02,750
So let's add them to the stack. Since they are not now eight and nine, we're going to pop the top element and that is nine. So let's add so let's add nine to the list and let's pop out this note.

65
00:16:02,750 --> 00:16:12,290
And we see a left and right is now. So we can't add that and process this node nine center left and right up. This Node nine is now we're going to out the top element from Stack.

66
00:16:12,500 --> 00:16:28,130
So let's pop out this element eight and let's add it to our list. So we get this list and the left and right of this element is not. So will the Taliban from Stack, since that stack is empty, we can't pop out anymore.

67
00:16:28,400 --> 00:16:42,500
And we are done. We are processed all the nodes. We have processed all the nodes in the given binary tree using post other terrorist techniques. And we get this list and this is how we can solve this problem.

68
00:16:42,710 --> 00:16:59,330
What we have understood, this explanation, the solution will take because in time complexity, it is the number of nodes we have in the given binary tree and this will takes off in space complexity to construct that stack.

69
00:16:59,630 --> 00:17:16,160
In this video, we have solved this problem recursively and iteratively. Have you understood the both approach? If you are not understanding any of them, I highly encourage you to go through with your own examples and try to write everything on a piece of paper.

70
00:17:16,310 --> 00:17:26,360
Then you will see how it works. Have you understood this video explanation? If you have any question, any suggestion, let us know. Thanks for watching this video, Altium.


@@@
1
00:00:00,660 --> 00:00:15,060
Hey, what's up, guys? Welcome back to this video. In this video, we're going to solve a coding interview problem binary tree level of the traversal, given the root of a binary tree, return the level of the traversal orbit nodes values.

2
00:00:15,840 --> 00:00:31,110
For example, if you're given this binary tree, you have to traverse this binary tree in level order. That means first you have to traverse this node one, then this node two, then three, then four, five, six, seven.

3
00:00:31,110 --> 00:00:45,350
Something like this one, two, three, then five, six, seven. So if you're given this binary tree in industry, we have three levels and we have to return this list at level zero.

4
00:00:45,360 --> 00:00:56,710
We have only one node at level one. We have two, not two and three. And at level two, we have four nodes. So if we were given this binary tree, we have to return this list.

5
00:00:57,390 --> 00:01:18,460
For example, if we're given this binary tree in this binary, we have four levels, level zero, level one, level two and level three, and would be towards this node in level of traversal, first one, then two, then three, then four, five, six, seven, then eight, nine, 10, 11, 12, 13, 14, 15.

6
00:01:18,660 --> 00:01:30,180
So if we are given this binary to operate on this list at level, we have one note at level one, we have two nodes two and three. At level two, we have not four, five, six, seven, eight.

7
00:01:30,180 --> 00:01:40,800
Level three, we have nodes eight, nine, 10, 11, 12, 13, 14 and 15. In this video, we're going to solve this problem recursively and iteratively first.

8
00:01:40,800 --> 00:01:55,700
Let's see how we can solve this problem recursively. Then we'll see how we can solve this problem iteratively. First up, understanding, let's assume we're given this binary tree, this is level zero, this is one and this is level two.

9
00:01:56,250 --> 00:02:05,850
Now we're going to construct a list and inside that list will store another list. So let's traverse this Bonaduce first alternative, which is not one.

10
00:02:06,150 --> 00:02:19,380
And in this level, we have only one node. So we'll construct a list inside this list at index zero by mapping to this level zero. And let's add this to our list.

11
00:02:19,830 --> 00:02:32,810
Now let's go to the left. On the left, we have this node to let us construct a new list at index one. And let's add the value to our list. Now let's go to the left and the left.

12
00:02:32,820 --> 00:02:43,920
We have this node for and let's construct a new list at index two. And let's add this note value to the list on the left and on the right of this note, for we have no nodes that we do have now.

13
00:02:43,920 --> 00:02:54,990
Node for now will just return, will do nothing. Now let's go to the right on the right of this node five five is located at this level two. So let's add this node five to index two.

14
00:02:55,560 --> 00:03:09,960
So five will be added here. Then this note, this node is located at level one two. Let's add this note to index one. Three will be added here. Then this node six six is located at index two.

15
00:03:10,140 --> 00:03:25,970
So let's add six to our list of index to seven is located at level two. So let's add seven to our list of index to seven will be added here. And this is how we can solve this problem recursively for better understanding.

16
00:03:25,980 --> 00:03:36,480
Let's take another example. Let's say we're given this binary tree as input, have to traverse this binary tree in to terrorism and to return the node values in level order terror.

17
00:03:36,490 --> 00:03:45,450
So we have your four level, level zero, level one, level two and level three. Now let's construct a list. That list will store node values in the tower.

18
00:03:45,450 --> 00:04:01,780
So let's traverse this note first of this route and let's process this node. This node is located at index zero at Indexical. We're going to create a new list and in that list or insert one at index zero and that index maps to that level number.

19
00:04:02,590 --> 00:04:15,660
Now, let's add one to this index zero. Now let's go to the left. On the left, we have this node to now let's create a new list at index one and let's add the nodes value at that list.

20
00:04:15,870 --> 00:04:37,830
So let's add the node value to this list. When we encountered this node will find out our index number, then we'll add that node values by getting the list of index one and we can manage the index by recursion called Stack and will soon will go through the pseudocode in its recursive function called Stack.

21
00:04:37,830 --> 00:04:50,970
We have a new state in that state. We will have the live in no way that level number. We can accept any of the list inside this list and we can add to that list the nodes value.

22
00:04:51,020 --> 00:05:00,660
OK, now let's go to the left and let you have this node for. That's good. A new list at index two. And let's add this reliford to that list. And let's go to the left again.

23
00:05:00,660 --> 00:05:14,670
We have this Node eight. Now let's create a new list at index three. And let's add this note, value eight to that list on the left. We have now so well written on the right we have now will return that Mitt will just exit, will do nothing.

24
00:05:14,710 --> 00:05:26,070
Let's go to the right note. On the right note, we have nine. So let's add nine in the list of index three. So let's add here nine and let's go to the node five.

25
00:05:26,850 --> 00:05:39,240
Five is located at level two. And let's add in the list of level to the node five. So five will be added here. Then let's go to the left then is located at level three.

26
00:05:39,240 --> 00:05:51,570
So let's add ten to this list. Ten will be added here on the left. We have not all get on the right. We have now selected now this node, this node is located at level three.

27
00:05:51,570 --> 00:06:02,190
So let's add this note values to index three. The left and right of this node 11 is now it will just exit for that node will do nothing. Now, we are done with the left side of this.

28
00:06:02,190 --> 00:06:14,850
Note one. Now let's go to the right subtree. On the right note, we have this node three. This node is located at level one. So let's add this node at index one and we can get the index number.

29
00:06:14,850 --> 00:06:28,010
That means the level number in recursion called stack also old. We'll see how we can get that one. We go through our pseudocode and let's add this value three two index to the list of index one.

30
00:06:28,410 --> 00:06:46,550
So three will be added here, then six six will be added to this list, then twelve will be added to this list of index three. The entire interim will be added to this list of index three, then seven seven will be added to this list of index to then.

31
00:06:47,470 --> 00:06:58,190
40 will be added to this list of industry, then 15 people will be added to this list of index three. This is how we can solve this problem recursively.

32
00:06:58,430 --> 00:07:14,880
We have understood the intrusion. Now let's see how we can implement this solution using pseudocode. This is also the code to solve this problem. And for the sake of understanding or assuming that we are given this binary tree, first, we have this function called level or at that function takes the root of a given binary tree.

33
00:07:15,120 --> 00:07:27,580
Then we're creating a list and then calling the function level helper with list root and zero. This zero is the level number. OK, and then when returning the list, this function will concentrate our results.

34
00:07:28,170 --> 00:07:37,980
This is our function definition level helper. This one takes three parameter list, root and level. The node checking even our current node is now will just return.

35
00:07:38,010 --> 00:07:54,120
That means we're exiting from the current function called using this written statement. If the level is greater than records to list that site, then we will create a new level and insert that level to our list and we can get the index number of that list by the level number.

36
00:07:54,330 --> 00:08:04,740
And we're managing the level number, using this recursion call, using this recursion function, call level plus one and your checking and here list should get level.

37
00:08:04,750 --> 00:08:20,430
We're getting the current level and we're adding the right not to the right level. And then we're calling the function recursively left and right. Initially we have this route node and we're going to add the root note to a list and we'll create that list right over here.

38
00:08:20,430 --> 00:08:32,520
New level. Let's add a new list here and let's add the node one at index zero. Then we have this node at level one. That's good. A new list at index one.

39
00:08:32,530 --> 00:08:52,650
Let's inside this node to and we're inserting using this statement and then this node for at index two, we have no list. Let's put a new list and let's insert this value of this node for to this list, then this node five, that's insert five to this list, then this node three.

40
00:08:52,650 --> 00:09:04,290
Let's insert this to this list of index one, then six six will be added to this list, appendix two, then seven seven will be added to this list of index two.

41
00:09:04,890 --> 00:09:16,920
Well done. This is how we can solve this problem of we have understood this solution and this is the recursive solution for this problem. The solution will be off in time complexity.

42
00:09:17,280 --> 00:09:36,180
What is the number of nodes we have in the given a tree? And the solution will be up to in space complexity to construct the output list and for recursion called stack and outer space, complexity is bigger of in it is the number of nodes we have in the given tree.

43
00:09:36,420 --> 00:09:49,710
Even in understanding. I'll introduce you to go through with your own examples that it will make sense. Now let's see if we can solve this problem iteratively right now we're going to go through the integrated approach to this problem.

44
00:09:50,070 --> 00:09:59,490
First thing about understanding, let's assume we're given this binary tree and we have a cube to solve this problem. We have to use a cube most of the time.

45
00:09:59,490 --> 00:10:09,840
When you solve a key problem using a loof, we have to consider using the stack or cube. Let's see how we can solve this problem. First, we have this root node.

46
00:10:10,050 --> 00:10:21,990
Let's add this to our cube now and now we're going to create a new list. This is our new list and it goes to one count equals to one means at current level, we have only one node.

47
00:10:22,590 --> 00:10:36,990
And let's create a new list right over here. And let's add one to this list and let's support this node. Let's add left and right, not to our Q So two will be added here and three will be added here.

48
00:10:37,470 --> 00:10:49,830
Now count all be chance to add two because at our current level we have two nodes. Now what are we going to do? We're going to promote this node and we're going to get a new list and in the list insert this, not value two.

49
00:10:50,010 --> 00:10:59,430
And then we're going to add the left and right node of this node two to our queue. So let's add here four and let's add it five properties, node three.

50
00:10:59,430 --> 00:11:12,930
And let's add this note to our list right over here. Then we're going to add the left and right, all of this note the three to our Q So six and seven now can't all be changed to four because now we have four.

51
00:11:13,050 --> 00:11:24,630
Not in our queue because you have four notes in the new level. Now, what are we going to do? We're going to populate this node for and we're going to create a new list and we're going to add that node value to our new list.

52
00:11:25,080 --> 00:11:44,910
The left and right is now also we can't add a lot to our cube. Then five, let's add the value of this node five Tonalist, then six. Let's add develop this node six tribalist left and right of this note, six are now also we can't add knowledge to our cube.

53
00:11:45,890 --> 00:12:00,400
They have seven let's pop out and let's add to our list and we're done, and there is no empty when your queue is empty. We're done with that problem for this given one year to have to return this list of list.

54
00:12:00,790 --> 00:12:11,680
This is for level zero. This is for level one and this is for level two. Now, let's see the iterative algorithm to solve this problem. All right. This is your iterative algorithm to solve this problem.

55
00:12:11,680 --> 00:12:22,670
First of dysfunctional level order, dysfunction takes the root of giving money to the list, taking it Imperial Tunnel or returning the in the list. Then we're creating a queue.

56
00:12:22,690 --> 00:12:32,350
This is your queue. Then we're adding the first in order to our queue. That's at our first node and our list. Initially we created this list. Let's say this is our list.

57
00:12:34,110 --> 00:12:44,760
Then, while the value is not empty, secure is not empty, we have honor in the queue. Now we're going to create a new level that means a new list to our list.

58
00:12:45,150 --> 00:12:55,690
And we're going to pull out this note from queue and add that value to our new list. And then we're going to add the left and right of this, not one to our list, two and three.

59
00:12:56,310 --> 00:13:15,420
Here we have count counting electrocuted sites. Count means at current level how much note we have. OK, then we're running this, Aluf, and then we're pulling out the node and we're adding that note to our current list and checking if the lymph node is not null or adding to the queue.

60
00:13:15,600 --> 00:13:30,120
If the writer is not, then we're adding to the queue at the end or adding the level to our list. And this is the level that we added to our list. Now we have in the queue two nodes here is not empty and we have to node and we created a new list.

61
00:13:30,420 --> 00:13:41,940
This is our new list, canonical to two. That means we have to not at the current level. So let's put two and let's add to to our list and let's add the left and right up to to our queue.

62
00:13:42,210 --> 00:13:53,430
So we have added four and five to work. Now, let's put this node three. Let's add the value to our list and then let's add the left and it of three to our cube, six and seven.

63
00:13:53,880 --> 00:14:10,500
Now we see that on the account. We have four nodes here is not empty. Now let's create a new level here. We're going to create a new level and then countercurrent equals to four because at that level we have four nodes and they were pulling out the first from our queue.

64
00:14:10,500 --> 00:14:22,850
So let's add four to our list then the left and right is now. So so we can't add the number to our queue. Then we have five, let's add five to our queue and left and right of five is now.

65
00:14:23,250 --> 00:14:36,420
Then let's pull out this note that add six to one list, then seven, let's put out seven and let's add seven to our list. And then we're returning this list of list and this is the list of list.

66
00:14:36,560 --> 00:14:48,930
OK, this is how we can solve this problem. Iteratively we have understood this video explanation. The solution will takes off in time complexity and is the number of notes we have in the given binary tree.

67
00:14:49,260 --> 00:15:02,010
And the solution only takes we go up to space. Complexity is the number of nodes we have in the given tree. It takes to in time complexity because we're constructing a queue and we're constructing our result list.

68
00:15:02,640 --> 00:15:15,990
The overall space complexity is bigger often because two is a constant right. Guys, this is my solution to this problem. We have understood that recursive and iterative solution to this problem.

69
00:15:16,330 --> 00:15:28,460
If any question of this addition, let us know. I trust the source code to this video. Check it out. If you have any suggestion or if you have any problem in understanding this video explanation, let us know.


@@@
1
00:00:00,870 --> 00:00:15,820
Welcome back to this video. In this video, we're going to implement a binary tree using our data structure in this section of discourse will be implementing this operations driven parfum in a binary tree.

2
00:00:16,470 --> 00:00:30,300
In this video, we're going to talk about this to operation, create a binary tree and insert value. And then we'll talk about the left node delayed binary tree and then we'll talk about Trevor's operation.

3
00:00:31,020 --> 00:00:42,630
And in this terrorist method, we're going to implement four types of terror cell in order for you. Order, post order and order. Now let's talk about grid, binary tree and insert operation.

4
00:00:43,380 --> 00:00:58,620
This it by using our required in this class, we have an array and we have a variable last used index for our implementation. Side of the tree is fixed.

5
00:00:59,130 --> 00:01:15,420
We cannot chance that side of the tree once we have created the tree. This method credibility takes a parameter site inside here. Inside here we're creating an array new inside splodge one.

6
00:01:15,850 --> 00:01:27,100
We're creating an array of sitesi splodge one because we will not use the first cell. Then we have this last used index that is zero initially and we're printing here.

7
00:01:27,220 --> 00:01:37,790
Tree is created. If we call this method creates binary tree with Serban, then will create an array of lente eight where we have index from zero to seven.

8
00:01:38,520 --> 00:01:59,250
Initially we can consider our tree is now because the R is empty, will not insert any value to the first index that we're choosing. The last used index equals two zero zero zero is the index of this cell and will not use this cell while implementing the binary tree.

9
00:01:59,250 --> 00:02:16,870
Using Arry we can consider this null is a recruitment center is empty. Now let's see insert method. This intermediate takes on parameter value inside your checking, if truthful, will implement this method in this widget.

10
00:02:16,890 --> 00:02:29,280
Don't worry about that. If this method return to the overprinting trees for previously we mentioned that for an implementation of the structure, side of tree is fixed.

11
00:02:29,850 --> 00:02:44,250
We cannot change the site once we have created the tree using added to the structure and then it will return here. If the area is not full, then we're inserting the value to the last used index plus one.

12
00:02:44,430 --> 00:03:00,060
So we'll insert the value from this position. That means from this index one and then or increasing the index by one. Now let's see how the tree data structure represented logically.

13
00:03:00,660 --> 00:03:25,110
And we'll use this formula to construct the logical tree data structure from this array in incompetency. We all have the error, OK? And logically, we'll have a tree representation using this formula and will choose the element from index one as the root note and then it will apply ellipticals to this formula and right.

14
00:03:25,110 --> 00:03:37,400
Chillicothe's to this formula here. X is the current index. If we call this method, insert ten then you insert here ten, then in logical representation will have ten.

15
00:03:37,890 --> 00:03:50,370
Ten is a root. Not OK. If we call this method with twenty then we're going to apply this formula. Leyb Child Editrix here we will insert the value twenty to this.

16
00:03:50,370 --> 00:04:06,660
So at index two and in logical representation we will have added two X here. X is the index of Perugino. That is one, so 2x is two. So it will get this value and insert that value to the left child of this binary tree.

17
00:04:06,930 --> 00:04:21,840
So all in such twenty to the left child, if we call this function again with tarde will enter through to this, to the sale at index three and then we are going to assign the value party as the result of this route node ten.

18
00:04:22,380 --> 00:04:34,280
So. Right. Chillicothe's to every two experts on here X Index one, so Twiggs plus one is three. So we will take this value tarde insert to the right child of this roots node.

19
00:04:34,380 --> 00:04:44,400
Then logically the banditti will be represented. Something like this. If we call this method with forty then we're going to insert forty at index four will consider this root node.

20
00:04:44,640 --> 00:04:57,330
So the child is Arijit X index up twenty is two, so two X is four so it will insert forty. Is the left child of this node twenty. So let's add for it right over here.

21
00:04:57,480 --> 00:05:15,440
If we call it again then all. Instead of 50 right over here and will insert 50 to the right of this root node to their current route, and we can get the index of this element 50 by two X plus one, two times two plus one is five.

22
00:05:15,670 --> 00:05:28,880
Maybe call this method again with 60, will insert 60 at index six. And we're going to apply this one child of thirty three X that is six. So let's insert six years.

23
00:05:28,880 --> 00:05:41,330
The left hand of this node hardy we call again with 70, then we'll insert 70 right over here and we're going to apply this formula by considering today's a root node.

24
00:05:41,900 --> 00:05:56,090
Current root, not so three times two plus only seven. So insert here 70. So insert your 70 and the left of 40 is to X and that is eight. That eight is out of every boundary.

25
00:05:56,090 --> 00:06:09,950
Soldiers three then we can consider null. And the right number is also now two times four plus one equals two nine. That is our area boundary. So again, consider Lebanon right now for 40, 50, 60 and 70.

26
00:06:10,100 --> 00:06:20,570
This area will be stored in computer memory. But logically, that tree data structure will be represented something like this. This is the logical representation of our data structure.

27
00:06:20,880 --> 00:06:35,900
We have understood how insert method works. This method takes up one time complexity and because of one space complexity, this method krit by nature will take up one time complexity and B go up in space.

28
00:06:35,900 --> 00:06:53,420
Complexity in is the side of that array. Now let's talk about Espoo method. This method will return to our false if added lente minus one equals to last used indexing already and two L2 will reinforce if we call this function is for this given binary it will return.

29
00:06:53,420 --> 00:07:03,690
True, because the site of our error is full of understood this civil explanations. Even if you are understanding this Swedish explanation, let us know.


@@@
1
00:00:00,570 --> 00:00:12,660
Welcome back to this video. In this video, we're going to implementing this method sers the search service method and first up, understanding, let's assume we're given this error.

2
00:00:12,930 --> 00:00:25,360
This these is treating as tree data structure because you're implementing a tree is being added to the structure. This is the area and this is the logical representation of this area.

3
00:00:25,800 --> 00:00:40,610
How can such a value in a tree data structure when we implement a tree using error? This is the algorithm for search operation. This method takes one parameter value inside.

4
00:00:40,620 --> 00:01:00,060
Here we are running a loop from index onto the last used index. And here the last used index is a seven. Here we're searching from index one to the last used index one starting from index zero zero is unused index first.

5
00:01:00,060 --> 00:01:09,990
We're going to check from index one. If we call the method with value 20, then what? It will return first. We see ten in the next iteration of this love.

6
00:01:09,990 --> 00:01:28,540
We see we have 20. So it will return the index of of the value twenty. That is to. So it will return to it because this method with 70 and first will check with Tin Tin is not equal to 70 in 2020 is not equal to 70 the entire day today is not equal to 70.

7
00:01:28,840 --> 00:01:50,380
Then 44 is not equal to 70, 50 to 70, 60 or 70. And we see 70 equal to 70. So it will retain the index seven for this function call. It will retain seven because this function with 80 with the 80 do not exist in this area.

8
00:01:50,860 --> 00:02:13,750
So you can say 80 is not it just in this binary tree. So we'll just return minus one. This is how this method works. This method will take off in time complexity and a bigger off in space complexity where it is the number of nodes we have in the binary tree.


@@@
1
00:00:00,840 --> 00:00:16,770
Here you lots of guys will come back to this video in this video. We're going to implement this operation, delete and not dismantle. It all takes a values input and it will remove the value from the binary tree lettieri into that.

2
00:00:17,460 --> 00:00:31,040
This is the sort of code to delete a particular node from binary tree. For sake of understanding, let's assume we're given this area and this array is represented as tree, something like this.

3
00:00:31,680 --> 00:00:43,890
This method takes on parameter. Inside here, we're finding out the location of the given value. If the value does not exist in the tree, then this metatarsus will return minus one.

4
00:00:44,370 --> 00:00:55,200
We already saw this method. If the method region minus one, that means the value does not exist in the binary to the old print value doesn't exist and we will just return.

5
00:00:55,470 --> 00:01:11,240
If not, we're going to get the deepest note. That means the last element from array and will update the value at the desired position and will move the last used index to the left without modifying the value.

6
00:01:11,490 --> 00:01:20,760
We can modify the value or we can change the value to the default value, or we can skip the value here or just is keeping the value. Let's see how it works.

7
00:01:21,150 --> 00:01:33,840
If we call this method delete node with thirty, then first, what are you going to do? We're going to find it the index of thirty and that is three. Then we're going to find out the deepest node.

8
00:01:33,840 --> 00:01:46,860
That means the last element for error there is seventy. So this element and here this node and then we're going to update the value tarty with the value of the best node.

9
00:01:47,190 --> 00:02:01,340
So let's start with seventy and then we're going to skip the last used index. So last index will move to this element so we can consider seventy do not exist in the tree or just keeping the value.

10
00:02:01,350 --> 00:02:12,480
OK, we have that node from index on to the index six so that I will be represented something like this and the logical tree will be logically represented, something like this.

11
00:02:12,780 --> 00:02:30,540
The right note of seventy is now. We have deleted the node 30 right here. We updated the value of this node today with seventy. If we call this method with sixty, first we're going to do we're going to find it the index of this node six, that is six.

12
00:02:31,140 --> 00:02:45,390
And then we're going to find it the defense node. And that is this note itself that we're going to just skip that we need to be done here and also to develop sixty sixty using this statement and we will move this last used index to this previous cell.

13
00:02:45,810 --> 00:02:58,680
So let's keep the current value. And logically, we can consider there is no node called sixty. So that will be represented something like this, and the area will be represented, something like this.

14
00:02:58,830 --> 00:03:11,070
This is just a logical representation of this area. And we skipped these two items. This is the lead node method works here. We're taking the deepest node.

15
00:03:11,250 --> 00:03:23,070
We can take any lymph node as well. But for easy implementation, we're taking the deepest node. That means the last element from our area and updating the available desert, not with the deepest node.

16
00:03:23,470 --> 00:03:36,330
We have understood this video explanation. This method will take because of in time complexity and it will takes constant space complexity. We have understood this method.


@@@
1
00:00:00,690 --> 00:00:12,760
Hey, what's up, guys? Welcome back to this video. In this video, we're going to see this method delete binary tree. This is the method. This method takes no parameter inside here or just sitting at to now.

2
00:00:13,200 --> 00:00:28,820
So how the arrow would be delighted when he said are equal to now for the sake of understanding, let's assume or given this array and this are is creating as Tillett a structure and this is the logical representation of this area.

3
00:00:29,310 --> 00:00:51,960
The area is pointing to the first element. The array variable is pointing to the first element of the array, and it works like a pointer. The arrow is pointing to the first element when we say our equals to now, the area will not point to the first element at pointer and it will point to null.

4
00:00:52,350 --> 00:01:04,290
So there is nothing is pointing to the first cell. So the arrow will be deleted. Since the arrow works in contiguous fashion, the entire area will be deleted by the garbage collector.

5
00:01:05,460 --> 00:01:17,210
So that link will be deleted from RAM and the arrow related as well. When he said, Eric, it's true now and this operation will take up one time complexity and pick up one space complexity.


@@@
1
00:00:00,690 --> 00:00:10,950
Hey, what's up, guys? Welcome back to this video. In this video, we're going to traverse binary tree using preorder terrazzo controversy, binary tree using preorder traversal.

2
00:00:11,550 --> 00:00:27,030
First thing about understanding, let's assume we're given this binary tree first. Let's see what is a priority in priority. EVERSOLE First, we'll visit this not 10, then 20, then 40, 50, then 30, 60, then 70.

3
00:00:27,760 --> 00:00:55,130
This is called the Turso. You're understanding what is a priority? Our reception in this video where you've talked about Phyu Order in order and post or a terror cell in details and how the tricks really works, even if understanding highly incurs to us that video, people giving this binary tree, we have to return this list first 10, 20, then 40, 50, 30, 60, 70.

4
00:00:55,830 --> 00:01:27,780
Now, let's see the algorithm. This is the algorithm for preorder traversal. It takes the index index is the index of first element and there is one. This is the root NORCOM and the index is greater than last used index or just returning that or existing by this written statement, even overprinting the value from our current index and recalling period two times index and calling preorder two times index plus one.

5
00:01:28,050 --> 00:01:38,720
It is something like lit and this is something like a right that we call this method provider with index one. This is the index of root note. This is our rudiment.

6
00:01:38,850 --> 00:01:49,740
So let's print the value chain now. Let's go to the left to dump's index two times one is two. So that value is twenty. The left up twenty is two times two.

7
00:01:49,740 --> 00:02:02,970
That is four and there is forty year old print twenty then will print forty then let's print forty because two times two is forty then two times two plus one there is fifty.

8
00:02:02,970 --> 00:02:19,870
So let's print fifty then for this note two times one plus on the Restudy let's print the lepidoptera is sixty two times three six. So sixty. Let's print sixty then two times three plus one.

9
00:02:19,870 --> 00:02:31,050
That is seven at indexed seven we have seventy so let's print seventy. So by traversing this binary tree using preorder traversal we get this list and this is how this algorithm works.

10
00:02:31,370 --> 00:02:42,510
We have understood how this algorithm works. If it is understanding, I highly encourage you to try to understand this algorithm by taking some examples.

11
00:02:42,960 --> 00:02:55,530
The solution will take Spiga of in time complexity and it will takes Bygrave in space complexity as well for the recursion called stack. Or it is the number of nodes in a given binary tree.


@@@
1
00:00:00,480 --> 00:00:09,540
Hey, what's up, guys? Welcome back to this video in this video. We're going to talk about in order to rustle up a binary tree, if you're not understanding, awarded the immunity.

2
00:00:09,720 --> 00:00:27,630
So in this section of this course, we have a video. What we have talked about, preorder in order and post or traversal in details in Inanna traversal first always visit is not 40, then 20, then 50, then 10, then 60, then 30, then 70.

3
00:00:28,150 --> 00:00:39,150
So if we're giving this binary to operate on this list and this is the list we can get by tracing the binary tree using in order to sell. Now let's see the algorithm.

4
00:00:39,390 --> 00:00:51,390
This is the algorithm of the traversal. This method takes one parameter index, the index approved node. Then we're checking inside. If index is greater than last used index, then we're returning.

5
00:00:51,630 --> 00:01:03,030
If not, then we're calling it in order to index when we visited the leftmost node or printing the value of leftmost node. And then we're calling with two times index plus one.

6
00:01:03,030 --> 00:01:15,870
This is something like. Right? This is something like lit. And this is something like. Right. This is our root node. Then two times one is two. That is twenty in this function call.

7
00:01:16,080 --> 00:01:28,680
Then again, two times two is for there is forty eight index where we have 40. The left is now the whole process. This note, let's process forty, let's print forty then.

8
00:01:28,680 --> 00:01:40,190
Right right now it will just return. Now we process the letter of this not to let this note. So let's print twenty then let's go to the right. Right. Fifty, let's print fifty.

9
00:01:40,500 --> 00:01:51,840
Now we see it. We process the left of this note ten. Now let's process this, not ten then let's go to right now. Let's go to left and the left is now so let's print sixty.

10
00:01:51,840 --> 00:01:59,610
Right is not as well. Now let's print this note today. Since your process left note of this note today. Now let's go to the right and there is seventy.

11
00:01:59,610 --> 00:02:08,670
Now, let's suppose it is not seventy. This is what we can traverse a binary tree using in order tower. So this is just a logical representation of this area.

12
00:02:08,850 --> 00:02:23,490
And we can construct this tree using this robot child and right child and to it to explore its own. And by taking the valid index one as a root node, we've understood this method in order traversal.

13
00:02:23,790 --> 00:02:34,170
We have understood this method. This method will take Spiga of in time complexity and it will take Spiga off in space. Complexity of have understood this very explanation.


@@@
1
00:00:00,300 --> 00:00:10,430
Hey, what's up, guys? Welcome back to this video in this video. We're going to implement post or a for celebrities Berlusconi. Let's assume we're given this binary tree.

2
00:00:11,250 --> 00:00:24,550
First, let's talk about what is a post on a terror cell in post or a terror cell post will process this node 40, then 50, then 20, then 60 and 70, then 30, then 10.

3
00:00:25,200 --> 00:00:37,700
The concept here is that will process the current node, apple processing, all the left and right child, even understanding what is opposed to the terror cell within this section.

4
00:00:38,100 --> 00:00:48,690
What we have talked about, pre order in order and post order to our cell in details. Now let's see the algorithm. This is the algorithm upholsterer traversal.

5
00:00:49,260 --> 00:01:00,900
This method takes the index of root node here, checking inside here or checking if index is greater than last used index region. It will call with two times index.

6
00:01:01,200 --> 00:01:16,860
And in order to dump's index one, this is lit and this is right here and here. Collinwood right node. And you're processing the current node when we have processed all the left and right child up a particle A..

7
00:01:17,560 --> 00:01:29,610
So first we have ten, then two times index is two because two terms on its two, then two times two is for so all visit to this note and the left is not all written.

8
00:01:29,610 --> 00:01:39,810
Right is now. So now let's process this node. We perceive the left and right. So we call this method post order with the index approved node it will print first.

9
00:01:39,810 --> 00:01:52,350
Forty three percent the left of this node twenty. Now let's go to the right and the left and right is now. So let's process this node. Let's print 50 year process left and right end of this, not 20.

10
00:01:52,350 --> 00:02:03,660
So let's process this node. Let's print twenty one node calculating index for every single note you calculate index of every single note, then you get bored.

11
00:02:04,080 --> 00:02:16,740
You can calculate that using this algorithm. Okay, that's super simple to index and two times index plus one we are processed all of this, not 10. Let's put this right note here.

12
00:02:16,750 --> 00:02:27,030
Now let's put this here left note. This is left and let us know right is now. So let's process sixty. Let's print sixty. We're done with left child of business today.

13
00:02:27,060 --> 00:02:42,570
Let's go to the right. Left is now right is now also to the. And now let's print seven. This entire process left and right right now let's bring Dissinger processed left and right set up today for this should not we are process the left and the right child.

14
00:02:42,570 --> 00:03:02,900
So let's print the current ten. And to have done this, how this post automated works, this method will take off in time complexity and bigger of in space complexity, you can calculate the index using this form Rotterdam's index two times index plus one.

15
00:03:03,110 --> 00:03:19,490
That is super simple. When you're processed left and right, it will processed the current note. And this is what we can get this list of if understood this Aveda explanation, even if you understanding the better explanation, let us know.


@@@
1
00:00:00,540 --> 00:00:08,970
Hey, yo, what's up, guys? Welcome back to this video. In this video, we're going to see the level of the torso of a binary tree. Let's see how we can do that.

2
00:00:09,150 --> 00:00:25,990
This is going to be super simple. First, let's assume this is you given a tree. What is a terror cell in a terror cell? Whichever tree level one level first this level 10, then 20, then 30, then 40, 50, 60, 70.

3
00:00:26,340 --> 00:00:38,520
So this is a level. This is a level. And this is a level 10, 20, 30, 40, 50, 60, 70. Now, let's see the algorithm. And this is super simple algorithm.

4
00:00:38,850 --> 00:00:51,410
We're just iterating from index onto to the last used index from index one to this index seven. If we call this method level order will travel from index onto index seven.

5
00:00:51,420 --> 00:01:08,960
First will print ten, they will print 20, then 30, then 40, then 50, 60, then 70. And this is the level order traversal of a binary tree. This is super simple.

6
00:01:09,150 --> 00:01:29,980
So we see that level of a terror cell of a binary tree is super simple. When we implemented binary tree using every or understood this method, this method all takes off in time, complexity and constant space complexity of we've understood a level of a traversal.


@@@
1
00:00:00,510 --> 00:00:20,700
Hey, yo, what's up, guys? Welcome back to this video in this video. We're going to talk about what is binary state data structure. Now let's talk about binary thirsty data structure, binary thirsty or in short, BSG is a binary tree in which all the node follows two properties.

2
00:00:21,580 --> 00:00:38,010
The left subtree up A. has a key lesson to its parent, Norske. And the right city of L.A. has a key greater than to its parent, Norske, these are the two properties of binary society.

3
00:00:39,040 --> 00:00:53,470
This is an example of binary thirsty for this, not the value of liberatory. Is Leavesden and the Bill of Rights. A tree is greater than so this not for the properties of binary thirsty.

4
00:00:53,800 --> 00:01:14,160
And these two nodes are live nodes, so it will not apply the properties to Livnat. This is an example of binary search. This is a valid point and essentially all the nodes follows the properties of binary sastry except the lymph node.

5
00:01:14,940 --> 00:01:26,110
This is not a binary search history because the value on the left subtree is greater than value. On the right, Sebti is also greater than. So this is not a valid binary search.

6
00:01:26,920 --> 00:01:40,360
Now let's see some more examples. This is an example of binary t know. Let's see whether this tree is a valid binary society or not. First, for this, not that value.

7
00:01:40,360 --> 00:01:54,250
On the left are three three six four seven one and the value are less than the value of root node and the value on the right tree is greater than eight, 10, 14 Tareen.

8
00:01:54,430 --> 00:02:05,020
So this not this node is following the properties of binary thirsty for this node lives up to its lasdun and the right subtree is greater than six for seven.

9
00:02:05,020 --> 00:02:22,750
And for this node, the left and the right subtree is greater than and this three are live nodes. Then for this node there is no node selected. The right, not the right one is greater than this apparent node.

10
00:02:22,750 --> 00:02:36,400
So this note is following the properties of binary DST. Now this note, there is no right node. The lymph node is less than this parrothead 14. So this is following the properties of by necessity and this is Livnat.

11
00:02:36,550 --> 00:02:54,550
So you can see this is a valid binary circuitry ever given this binary let's requited this minority is a valid binary. So still not there is no left, not for every single note of this binary tree and the right note are greater than the parent node.

12
00:02:54,940 --> 00:03:05,500
So this is greater than the node one. So this is following the properties of precisely. This node is also finding the properties of binary sastry, this node, this note as well, and this is Livengood.

13
00:03:06,610 --> 00:03:26,300
So this is a valid binary syste we can see. We were given this binary tree, we see there is no right child of any nodes and the left side are greater than the parent, two is greater than one year, three is greater than two for his residency.

14
00:03:26,600 --> 00:03:37,640
Four is greater than three. So this is not a valid binary search string. This is invalid binary thirsty. This tree is not falling. The properties of binary search that tree.

15
00:03:37,880 --> 00:03:51,890
This tree is not a binary circuitry. If you are given this binary tree in this binary, we see the left of this node five is less than the left turn of this, not for is less than four.

16
00:03:51,890 --> 00:04:01,280
And the left side of this node three is less than that is two. And the left hand of this, not two, is less than two. And this is Livnat. So we can say this is a valid binary circuitry.

17
00:04:02,720 --> 00:04:15,020
Now, let's see some more examples. That's the way that this is a valid British astronaut, this note is the properties of binary system. All the NFL on the left is less than all.

18
00:04:15,020 --> 00:04:27,860
The NFL on the right subject is greater than for this. Not all the NFL and the lesbian and all the NFL on the right subject is greater than. So this is one of the properties of, as you know, for this, not six.

19
00:04:28,570 --> 00:04:36,290
There is no right note. And the note is less than the one on the left subject is less than and for right subtree. So nothing needs to be done on the right.

20
00:04:36,920 --> 00:04:52,070
So nothing need to be done for the right subtree. So there's is one running the properties of Bonynge. Sixty one, four and nine is Livnat. We need to apply the properties of binaries in the lenard's so you can say this is a valid binary sastry.

21
00:04:52,610 --> 00:05:04,340
If we were given this binary tree and the one on the left side of this eight is less than Valinda right up to is greater than. So this is putting the Proposition 187 still there for this node.

22
00:05:04,520 --> 00:05:17,210
Well, on the left subtree is less than a value on the right is not greater than we see here. Two is a less than three. So this note is not following. The properties of Binary says this is not a valid binary.

23
00:05:17,210 --> 00:05:37,130
Sastry, we have understood what is a binary Sastry. Now, you might ask why we need a binary Sastry. Now let's talk about Saaz operation. In an area when it serves an element in an array, it takes because in the worst kids and for linguists it will also take Spiga of in time complexity.

24
00:05:37,760 --> 00:05:59,780
When is binary circuitry? The search operation will takes longer the time, complexity and this Idjwi binary statistic came into the picture. If we have a huge dataset, if we use Arry or linguist, then it will takes a lot of times to source an element in array or in a data structure.

25
00:06:00,320 --> 00:06:14,390
But if we store the large dataset in a binary society, then we're going to find out the desert element in logarithmic time complexity. And it's oyamel faster than linear time complexity.

26
00:06:14,630 --> 00:06:24,830
And this is why we use binary circuitry. We've understood what is a necessity and why do we need to learn by necessity. Thanks for watching this video.


@@@
1
00:00:00,360 --> 00:00:12,810
Hey, yo, what's up, guys? Welcome back to this video. In this video, we're going to implement this to Method Create Boundaries, Erste and insert using this method, we can create a binary society.

2
00:00:12,810 --> 00:00:23,990
And using this insert method, we can insert data into a binary thirsty. Now, let's say you can create this two method. This is the class. This class contains a note.

3
00:00:24,000 --> 00:00:39,210
This node has three attributes value and to point to left and right here we have a route node and this is our Create BSD method. This method takes the parameter inside your setting route to Knowland.

4
00:00:39,870 --> 00:00:52,170
If we call this method create pastie, then we'll create in now node and route will points to now node. Now let's talk about insert method. This is the insert method.

5
00:00:52,170 --> 00:01:05,670
This method takes on parameter. And inside here we're calling this insert method with this two parameter root and develop. And this is the method insert current node and Avello.

6
00:01:06,240 --> 00:01:37,780
We're using our programming language. Here we have a different number of parameter, OK, so you can use the same method inside your checking if current Noriko's to Nalden or returning neonate by creating a node with the given value else, if you're checking if the well of current node is greater than the given value, then we'll call the insert method recursively and all insert the data to the left not and will retain the current node.

7
00:01:38,380 --> 00:01:50,350
If not, we're going to call the insert operations or the insert method with the right note and we're going to insert that node to the right child and we're returning the current node.

8
00:01:51,010 --> 00:02:05,810
Now let's see how it actually works. First, if we call this method with eight, then we'll create a Node eight initially left and right pointer all points to now node here in four null.

9
00:02:06,250 --> 00:02:17,890
And this is our root node. OK, so if we call this method inside to evaluate, then we call this method insert with the route node initial is now and validate.

10
00:02:18,130 --> 00:02:35,980
So Kintyre equals two now then will return this new note by creating the node with the given value. So this is our route and we call this method again with insert three, then we'll call this insert method with the root node and with the given value.

11
00:02:36,370 --> 00:02:54,130
Since the current node is not equal to now, will check the value of our current node. If the valuable current one is greater than the given value, then we'll call this function recursively and will insert the value of the tree to the left child of our current node.

12
00:02:54,540 --> 00:03:05,870
So we'll call this method again with the child and with the value. The left side is now also we'll call it insert null and a tree. So in this case, it will return just three.

13
00:03:06,220 --> 00:03:15,910
So let's create here a new node three. And this note will be returned to by this function and will insert this note to the left child of this node eight.

14
00:03:16,090 --> 00:03:34,030
So three will be attached to this left pointer. So let's add here three and the left and right pointer of three by default null. So lets it in four. Now I recall this matter again with nine.

15
00:03:34,630 --> 00:03:45,790
Then we'll call this insert method with the root eight and with the value nine. And here current node is not equal to null and the value of current node is not greater than value because.

16
00:03:45,970 --> 00:03:56,080
Because it is not greater than nine. So it will move to this ELT's statement and also call this method with root that right. And that is now and the value nine.

17
00:03:56,230 --> 00:04:11,290
So it will create a new node here, nine and the nine will be attached to this right pointer of this node eight. So let's add here nine and a left and right child of nine is now by default.

18
00:04:12,010 --> 00:04:20,990
Now, let's call this matter again with one. Now we're going to call this method with the root node eight and with the value. One current note is not Egleston.

19
00:04:21,010 --> 00:04:32,620
Also, the current node is greater than one. Eight is greater than one. So let's call this method recursively, then we'll call it with three and with the value one.

20
00:04:33,160 --> 00:04:47,980
And then we see three is greater than one. So we'll call this insert method again with the left of this node three that is now also with and one and that will create a node with one and two will attest that node to this little child.

21
00:04:48,100 --> 00:05:04,660
So let's add here one and the left and right of one is now by default, this function will return the root node. OK, then let's call this method with six.

22
00:05:04,660 --> 00:05:18,480
Then we will call this method with the router eight and with the value six. So kinder is not external current node. That value is greater than value because it is greater than six.

23
00:05:18,520 --> 00:05:35,440
So let's go to the left. Leptis three, let's call it three and six. Then we see three is not greater than six. So it will move to Elsas statement and here will create a new node with Value six and will attest that Node six as the right child of this Node three.

24
00:05:35,440 --> 00:05:54,820
So let's add here three. So let's add here six. The left and right child of six is now by default. So let's add here in and let's add here in. So we're done by this written statement already in the root node and recurse back to that tough node.

25
00:05:55,270 --> 00:06:04,430
It will recurse back to the root node and it will return the root node, OK, and the root note will be attached to this root pointer and there is eight.

26
00:06:05,110 --> 00:06:19,050
Now let's call this method again with ten in this case. We see. Current value is greater than its faults, it is not greater than 10 will move to the right and they will call it with nine and 10.

27
00:06:19,360 --> 00:06:38,170
And in this case, we see that the value of this node nine is not greater than 10. So we call it the writing of this Node nine and with the value 10. So this value 10 will be added to the right of this node nine.

28
00:06:38,200 --> 00:06:56,900
So let's add here, 10 left and right of ten is now. So let's add here now and let's add here now and it's functional only recurse back to the root node and the router will be returned to this by this function call and that will be attached to this pointer route.

29
00:06:57,640 --> 00:07:19,180
OK. This is our root node and this note will return this idea how this insert method works. This method will takes time, complexity, bigo of in and space complexity because in fact the recursion called stack of understood grid besty and insert method all the times the source code to this video.


@@@
1
00:00:00,850 --> 00:00:12,070
A lot of guys will come back to this video in this video. We're going to talk about Trevor's operation in a minor disaster in the previous section of this course.

2
00:00:12,250 --> 00:00:29,510
We have talked about in detail a order preorder in order and post order traversal the process exactly the same. If you want to learn to sing Banditti or Bonaly thirsty, go to the bathroom to section in that section.

3
00:00:29,530 --> 00:00:43,000
We have talked about in details in this video, we'll just review that for traversal algorithm, terrazzo priority reversal in other traversal and post audit hours.

4
00:00:43,420 --> 00:00:59,080
Now let's talk about them first. Let's talk about preorder traversal. This matter takes the route of a given binary star stream and inside your checking, if you will just read and this is our base case and printed develop available route node.

5
00:00:59,080 --> 00:01:11,400
And then we're calling it left child and then we're calling it a rightsized. If you're given this country's history and if you call this method, then will traverse this binary search through something like this.

6
00:01:11,420 --> 00:01:23,650
First aid, then three, then one, then six, then for the nine. And this is the direction of pre-euro terror. So I'm not going to go through the source code.

7
00:01:24,110 --> 00:01:41,450
I highly recommend it to go to that Bannerjee section to see how primitive traversal works in details of what you talked about, the recursive approach, as well as the iterative approach this putative traversal takes because in time complexity and because of its complexity.

8
00:01:41,840 --> 00:01:54,780
Now let's see the next two traversal algorithm in order to Eversole. This is in order traversal algorithm. This is another method. This method takes the root of a given binary search street and its ideology.

9
00:01:54,920 --> 00:02:14,060
If you recall, true, now that we're returning, this is Biscuit and they're calling it less arbitrary, then opening the current node and then we are calling it a right subtree for us to process all the lips and the whole process, the current node, the whole process, the right subtree.

10
00:02:14,780 --> 00:02:29,450
If you are given this binary search tree and if we call this matter in order, then you have to traverse this binary thirsty, first one, then three, then four, then six, then eight, the nine.

11
00:02:29,780 --> 00:02:42,170
And this is the direction, OK? And this is the list that are going to get by terrorists in the binary 60 is in order traversal what we have understood what is in your traversal algorithms.

12
00:02:42,560 --> 00:02:52,820
And this algorithm will take zwigoff in time, complexity and go in space complexity. Now let's talk about the Next G traversal algorithm post or the traversal.

13
00:02:53,270 --> 00:03:10,400
This is post or traversal algorithm. We're calling it the root node and this is your biscuit's. If we're returning the left subtree, the rights attorney and the developer, current node first processing all the laptop, regional processing, all the right.

14
00:03:10,790 --> 00:03:28,940
Then we're processing the current node, for example. We're giving this binary certainly we call this method. Then we will traverse this binary search stream, first one, then four, then six and three denying than eight.

15
00:03:29,210 --> 00:03:38,520
And this is the direction. And this algorithm will take Spiga off in time complexity and we go off in space complexity. Haviv understood what is a post or whatever.

16
00:03:38,560 --> 00:04:06,170
So now let's talk about level traversal algorithms. This is level or whatever traversal algorithms. This matter takes the root of a given by Natsheh this year if conditions if you not returning the recording AQ and we're adding adding that value to the queue and running a while if Welches is not empty, we're popping out that element from Q here, popping out the front element from Q And we're bringing that element and the note taking.

17
00:04:06,170 --> 00:04:37,190
If the child is not, let's add that to. Q And if the right set up our current note is not equal, let's add that to our Q Ibargen. This binary search typical this method, then we should return this list in the traversal, whichever available for this level and this level, then this level of this level, the first eight, then three, the nine, then one, then six, then four eight three nine one six four.

18
00:04:37,700 --> 00:04:47,330
And this is the direction of we've understood what is the level of the algorithms and this algorithm will take off in time, complexity and because in space complexity.

19
00:04:47,870 --> 00:05:00,050
In this video we are just reviewing the turtle algorithms. If you want to understand or you want to see the detailed explanations, if you want to see the detailed explanations, please refers to the section.


@@@
1
00:00:00,470 --> 00:00:12,740
Hey, you guys all come back to this video in this video. We're going to implement this service method. Let's see how we can implement this method. They see this through the court of service method.

2
00:00:13,190 --> 00:00:25,820
This method takes one parameter value inside here. We're calling this method service with route and value. And here we have the service method. This method takes to a parameter here, current node and velho.

3
00:00:26,570 --> 00:00:41,840
If current node is equal to null, then overprinting value not found and it will return null ELT's. If current node not very close to value then will print Valov found in Besty and will return the current node.

4
00:00:42,440 --> 00:00:56,690
If not, we're checking if the well of current node is greater than value. They will call the method sers with the left. Certainly. If not, we will call the method with a right subtree.

5
00:00:57,290 --> 00:01:11,260
For example, if you're given this binary sastry, if we call this method six, first will check with the root value does eight equals to six will check eight by this statement.

6
00:01:11,810 --> 00:01:21,320
Correct. That very close to value we see six is not equal to eight. Then we're checking if the available node is greater than the given value. Yes it is.

7
00:01:21,680 --> 00:01:34,030
Then we will move to the lips of three will call with this node. In that case we see that six is not equal to three and we see value of current node is not greater than the given value.

8
00:01:34,190 --> 00:01:44,440
So we'll call it with the right subtree. In this case, we'll call with this node. Now we see the value of our current node is equal to the given value.

9
00:01:44,660 --> 00:02:00,620
So all print found in Basti and will return this node will be understood how the source method works. You see that in order to search this value, we compare this value with just a three nodes.

10
00:02:00,620 --> 00:02:19,250
OK, why not checking every single nodes? If we call this method again with fourteen, then what's going to happen? First we're going to call with the root node and foreign and we see four is not equal to eight and eight is less than fourteen to call with this right subtree.

11
00:02:19,700 --> 00:02:45,260
There is no records to fourteen to all the right subtree. And then we found here fourteen. So we'll print Avello found in Bisdee. If we call this method with Searsport that will call this search method with current node and Vello character is our root node initially and we see eight is not equal to force that will call it let's apply since the value is less than eight.

12
00:02:45,830 --> 00:02:58,460
Then you see four is not equal to three. So call with the rights of TI, which is six is not go to four will call with the present, six is greater than four and here we see four is equal to four.

13
00:02:58,460 --> 00:03:21,230
So it will print the value found in Besty and it we see that we compare with forward on checking every single node. If we have a huge amount of nodes in a given binary thirsty, then we do not have to check every single nodes to find out a value in a binary society, to find out a value in a binary society.

14
00:03:21,800 --> 00:03:32,990
If we call this method source, we know that's what's going to happen. Will call this method with eight and twenty eight is not equal to twenty and it is less than two, let's call it.

15
00:03:32,990 --> 00:03:47,150
Right. And here we see Denise in go to twenty, let's call it right. Subject to this in regards to fourteen. So that's called right. Iritis null whenever we found now node as our current not not found and all written.

16
00:03:47,150 --> 00:04:02,180
Now this is how it works. This is something like binary stars and binary search works exactly like this. All right. We've understood how resource Avella in a binary search efficiently.

17
00:04:02,630 --> 00:04:16,370
And this is why binary search sticking to the picture. We can search in a binary sixty in logarithmic time complexity. The time complexity is all log of in and the space complexity as well.

18
00:04:16,370 --> 00:04:32,500
Or log of in for the recursion called stack. OK, now how we get this time complexity. We break down every single line. We have to come, we have to compute the time complexity for the method source.

19
00:04:32,840 --> 00:04:43,760
Here it is the number of nodes we have in a given Bernini's history here are calling the binary search to the left part, if not equally with the right part.

20
00:04:44,030 --> 00:04:59,920
So it is esteve. Our T becomes a small here with the left or the right subtree will not back to the right, up to your left subtree. Once we get to that left or right, if we apply here back subsid.

21
00:05:00,360 --> 00:05:16,110
Method, then we'll get this time complexity or log in and of log in. We have a section in this course starting in certain sections, please check the video binary search in Bannisters.


@@@
1
00:00:00,510 --> 00:00:09,930
Hey, yo, what's up, guys? Welcome back to this video. In this video, we're going to talk about Late Note. So let's implement this method. Let's not for boundaries history.

2
00:00:10,560 --> 00:00:26,520
In the previous section of discourse, we saw that how to delete a node from a binary tree. But this is a binary society where we have the value on the left subtree or lasdun and the value of that right subtree are greater than the parent node.

3
00:00:27,600 --> 00:00:40,380
Now, let's see how we can implement this method. This is the pseudocode to delete node from a binary thirsty. We're calling this method with root and value inside here or taking or printing.

4
00:00:40,380 --> 00:00:53,340
Reller not found and we really know if the value of ruiner is greater than value, then we're calling it left subtree. If the value of root node is less than value, then we're calling it right subtree.

5
00:00:53,940 --> 00:01:13,840
If we find out the value in our binary 60, then we have to delete the current node. In that case, we're going to check if we have lipin right child for our current node that we have to delete, then we will apply this formula else.

6
00:01:13,860 --> 00:01:29,760
If if we see the current node has only left child, then we will apply this formula. If our current node has reject the null, apply this formula. If the current owner is a not, then we'll apply this formula to decode Sternhell and it will return root.

7
00:01:30,000 --> 00:01:45,210
This is the minimum method. This method takes root given by the tree and this method will retain the minimum node in a tree or a could in a subtree. For the sake of understanding, let's say we're given this binary sixty.

8
00:01:45,780 --> 00:01:57,320
First, let's see the intuition how we can do it. Not until we want to delete this node at three. Then we're going to do we're going to find the minimum value on the right side of this node three and there is four.

9
00:01:57,510 --> 00:02:08,120
So we'll take this value and we'll update the value of this node three with the minimum value on the right of this Node three. And then what we'll do, it will delete this note, OK?

10
00:02:08,670 --> 00:02:20,070
And it was set to null. And now we see that this node three has deleted and we see that this binary sastry is a valid binary 60 after deleting the node three.

11
00:02:20,790 --> 00:02:32,850
The subject is not for is less than the right subject is not for is greater than this is how we will delete it. Not from a binary thirsty. Let's say we want to delete the node eight.

12
00:02:33,360 --> 00:02:57,570
This is a root node. Then what are we going to do? We're going to find out the minimum value on the right side of this node eight and there is ten. So I better value eight with ten, and then I will delete this number 10 and will connect this not to this, not 14, and we see that this is a valid but it is a stupid letting this route not develop.

13
00:02:57,580 --> 00:03:09,010
The right subtree are greater than the value on the lives of our lives then. Now let's see how we can delete a particular node from this binary circuitry using this pseudocode.

14
00:03:09,370 --> 00:03:20,650
If we call this method delete node three, then we'll call this method with the root and with the value tree. By this method here we're checking every Gholston route is not equal to null.

15
00:03:21,250 --> 00:03:32,890
And here we're going to check this if condition Route eight is greater than the given value. So we'll call it subtree. Now, we will call this method with Leptospira and with military.

16
00:03:33,610 --> 00:03:45,490
Now we see three equals to three. So now we're at this yield statement. Now we're going to check does the node three has left and right? Yes, it has left and right.

17
00:03:46,240 --> 00:04:00,610
Then what are going to do? We're going to find out the minimum node on the right of this node, a three and we'll set ten variable to this route. The minimum value on this right subtree is for how we can find it here.

18
00:04:00,610 --> 00:04:14,920
Will call this method minimum with ten for that. Right. So we'll call this method temp that right. This method will return the node four by this method minimum, this method minimum will written the node for.

19
00:04:15,310 --> 00:04:28,810
So we'll update this value of this node with four. So let's update this will wait for the roll call. This method will write the truth so it will address something to this right child or to the right pointer.

20
00:04:29,380 --> 00:04:44,920
We'll call it with six and four. If we call it six and four, we see six is greater than four. So we'll call it let the Leptis this note for itself. So we'll call it for and for now we see this deliberately.

21
00:04:44,920 --> 00:04:55,330
So it will set this node as null since this is a root node by this root equals two. Now statement, then I will return the root. This is our current root.

22
00:04:56,020 --> 00:05:10,050
So this root will be returned to this function. Call root. This will return the root network. Current root is now since we have already got Sternhell so the null will say to the left of this node six.

23
00:05:10,060 --> 00:05:28,750
So all said rototiller records to null is also this little child of this not as null then recurse back in the previous recursive function call it will return the node six and the node six will be attached to the right of our current two.

24
00:05:28,750 --> 00:05:41,080
That is this note for we have updated with for the value of this not or four. So it will this node six, the return of this not for and there is already this node six and this is what we can do.

25
00:05:41,110 --> 00:06:00,910
It is not for boundaries are still understood. Our related note from a binary certainty. And we take the minimum value from the right subject of a desired node and or updating the value with the minimum value on the right subtree and or deleting the minimum value from that tree.

26
00:06:02,120 --> 00:06:14,380
This is what we can delete a note from a binary 60. Now, let's say we want to delete this node eight nine. We call this method the letter with eight. We want to delete the root node.

27
00:06:14,380 --> 00:06:30,850
Let's can do with that. So we find out the so we have found the node that need to be deleted. That is the root node. Now, directly on this ELT's statement here we see the router has left and right.

28
00:06:31,930 --> 00:06:40,870
So we're going to do we're going to set ten as this route will take them to this route node and then we'll find out the minimum one on the right. And there is ten.

29
00:06:41,140 --> 00:06:51,750
So let's update the value eight with ten. Now, what are we going to do? We're going to set the right of this node ten. So what is the right child of this node 10?

30
00:06:52,290 --> 00:07:03,870
We don't know, right? So we have to set the right child up to a desired node. The boundaries Erste must follow the properties of boundaries history. After deleting a desired node.

31
00:07:03,870 --> 00:07:13,700
The tree must follow the properties of a binary sorcery. They're going to call it Roulet, right. Which is not invalid in here. We have to delete this node, OK?

32
00:07:14,310 --> 00:07:23,610
If we call it with an intent, then we are again on this earth statement. Here we see it. We don't have any left child. So we have on the right, Charles will set records to do that.

33
00:07:23,610 --> 00:07:33,810
Right. So we're going to set here records to root dot. Right. So this is our current route. OK, then we're going to set here records to do that. Right.

34
00:07:33,840 --> 00:07:48,230
So we're going to move this route to the next to the right track. We're going to move the route to the right child and at the end here, the route. So it will return the route that brings this node and this note will return to this route.

35
00:07:48,230 --> 00:08:12,040
It right. That means to the right of this node 10. So at this link to this node. OK, this node for so we have at the link to this node 14. So in the previous recursive function call all at the right point, pointed to this node 14 by skipping this node 10.

36
00:08:12,570 --> 00:08:28,570
All right. And this is all we can do. This node and in the previous recursive function call will return this route node. This is how we can delete a desert node from the boundaries are still maintaining the properties of binary thirsty hope.

37
00:08:28,580 --> 00:08:37,480
We have understood how this method actually works. We've understood this explanation. You have an issue understanding this with explanation, let us know.


@@@
1
00:00:00,530 --> 00:00:16,490
Hey, what's up, guys? Welcome back to this video. In this video, we're going to talk about the binary search operation. Let's you were given this binary circuitry and this is the algorithm to delete binary circuitry deeply involved.

2
00:00:16,640 --> 00:00:34,090
Or if we call this method, then this route all set to now. OK, so let's disconnect this root pointer ruleset to download. Now, garbage collector will automatically remove this node since there is nothing is pointing to this Node eight.

3
00:00:34,760 --> 00:00:43,220
So this node will be removed by garbage collector. Now we see there is nothing is pointing to this route. Not so the student will be removed by garbage collector then.

4
00:00:44,210 --> 00:00:57,680
We see that there is nothing is pointing to this Node three and to this node 10, so this node three and 10 will be removed by garbage collector. Then we see that there is nothing is pointing to this, not one, so this will be removed by garbage collector.

5
00:00:59,030 --> 00:01:07,190
There is nothing else pointing to this note as well. There is nothing is pointing to this note as well. So this note six and these notes 14 will be removed by garbage collector.

6
00:01:07,200 --> 00:01:18,800
Then this note for this note, seven is not turning. It is not responding to this note for seven and 13. So so the note for seven 13 will be deleted by garbage collector.

7
00:01:19,670 --> 00:01:32,870
So our interplanetary disaster is the latest episode to reconstruct. This is how this delicate operation works. This operation will take off on time, complexity and bigger up on the space complexity.


@@@
1
00:00:00,540 --> 00:00:17,160
Hey, you guys all come back to this video in this video, we're going to talk about a binary if heave data structure is a complete binary tree that satisfies the heap property, if that structure also called binary.

2
00:00:18,150 --> 00:00:33,490
Now, let's see here, properties value of any given node must be less than the value of its children. And this is called meaning and value of any given node must be greater than the value of its children.

3
00:00:33,720 --> 00:00:57,640
And this is called Max. If we have two types of sheep, one is Minifie and the other one is massive. Binary HEVE is a complete tree. It means that all levels are completely filled, except possibly the last level and the last level has all keys as late as possible.

4
00:00:58,450 --> 00:01:16,280
We've understood what is a data structure. Now let's see some example. This is the definition of meaning and this is the definition of Max. If this is an example of meaning, value of any given node must be less than the value of its children.

5
00:01:17,280 --> 00:01:30,420
So the value of this Node eight is less than the value of all the children. And the value of this node is less than the children value of this node, less than the value of its children.

6
00:01:30,960 --> 00:01:53,940
For this not develop this node is less than of it. Children and this are called lymph node, which 565, 16, 50 and 60. These are all lymph nodes. This is called M.F. and this is an example of massive value of any given node must be greater than the value of its children.

7
00:01:54,480 --> 00:02:07,020
Survival of this node is greater than children of this node is greater than the value of its children. Business is greater than the children. And develop this node 22 is greater than the value of its children.

8
00:02:07,830 --> 00:02:26,580
And these are live nodes. So we can say this is a massive Haviv understood. What is the meaning and what is a massive. Now let's talk about application of binary HIF binary is used while implementing priority queue.

9
00:02:27,150 --> 00:02:42,000
Dextrous algorithm uses binary HIF and he algorithm uses binary. If this is a sorting algorithm, will talk about the sorting algorithm in the sorting algorithm section of this course.


@@@
1
00:00:00,660 --> 00:00:11,440
In this video, we're going to talk about binary chief implementation option, we can implement binary if is error or we can implement binary using linguist.

2
00:00:12,180 --> 00:00:29,470
We have this six standard operation that we're going to perform in a binary if creative peak extract site, insert and delete. If there is no problem when we implement the binary HIF is in error.

3
00:00:30,300 --> 00:00:47,190
But there is a problem implementing binary using linguistic data structure for linguistic data structure. This extract operations create a problem. This extract operation will take Swadling implementation, a linear time complexity.

4
00:00:47,730 --> 00:01:03,950
But for an implementation, this extract operation will takes a logarithmic time complexity that we will choose Arabised implementation of binary if only this will never use linguists implementation of binary.

5
00:01:03,960 --> 00:01:22,350
If we have two types of heap's meaning. And Max, if this is an example of McNiff and this is an example of massive, if we extract this Node eight, then what's going to happen will remove this node, OK, and we will take that the first node.

6
00:01:22,920 --> 00:01:39,930
That means the last minute we get by traversing the binary HIF using level order traversal. And this is the last note and we can update the value of this route, not with this divest node, and then will reduce the deficit load.

7
00:01:40,680 --> 00:01:51,840
If we do this using linguist data structure, that means if we implement binary using Linklaters data structure, then the extract operation will take a linear time complexity.

8
00:01:52,260 --> 00:02:13,590
And that's not what we want. We want to extract Haid not from binary tree in logarithmic time complexity when we implement Bintliff. Is that a structure we can get the last element easily using using a variable last used index or something like that.

9
00:02:13,830 --> 00:02:27,540
But for linguists implementation group to traverse the binary HIF to get the last node or the defense to node. Right. And that's all we will see in this section of this course.

10
00:02:28,050 --> 00:02:40,310
When you implement extract operation, we've understood we should switch Arabised implementation instead of lengthiest best implementation. Thanks for watching this video.


@@@
1
00:00:01,130 --> 00:00:21,700
Hey, yo, what's up, guys? Welcome back to this video. In this video, we're going to talk about binary data structure. In this video, we're going to implement this to method creative and insert this method creative will create the Heffter structure and this insert method will insert data into binary heap.

2
00:00:21,950 --> 00:00:45,650
Now, let's see how we can implement this true method. This is our class HIF using array inside here we have array and we have a variable site. This method creative will take the site as input inside here or creating binary HIF of site size Flach one and then we're setting this variable size to zero.

3
00:00:46,990 --> 00:01:03,320
If you call this method creative with seven, they will create an array of length eight have index from zero to seven and size is zero initially. OK, I will not use our first sale for easy implementation.

4
00:01:04,000 --> 00:01:16,100
We have no element in our area so we can consider our heavies. Now this method takes up one time complexity and bigger in space. Complexity is the length of the given array.

5
00:01:16,420 --> 00:01:29,260
Or we could say the side of our hip. Now let's talk about insert method. This method takes one parameter value inside here or inserting the value in order to give that a structure, increasing the site.

6
00:01:29,440 --> 00:01:56,170
And then we are calling this method. If we find them too tough, we decide, OK, that means the index of our current inserted data. Indore, if we have here, this formula goes to our 2x so they to our two experts on the value at index one is our root node and here X is the index number and insert 10, 20, 30, 40, 50, 60 and 70.

7
00:01:56,170 --> 00:02:07,420
Inner binary 15 are binary will be represented, something like this. And this is a representation of this area in computer memory will stored the array logically.

8
00:02:07,420 --> 00:02:23,170
The array will be represented as binary if something like this. This is the logical representation of our binary data structure. This method will text because of log of in time complexity and because of log of in space complexity.

9
00:02:23,440 --> 00:02:43,390
Now let's talk about if I bottom to top method and let's see how insert method works. This is different. If I burn the top method, this method takes this method takes the index as input and heretically indexes literally go to one then were returning because you have only one node or we have not been able to do nothing.

10
00:02:43,630 --> 00:03:02,020
Then here we find it. The parent node, if we see the currently inserted node is a list, then the parent node, the swap them and then we have to call the hipwell bottom to top and do our currently inserted element get the correct position in the binary with no worry about that.

11
00:03:02,090 --> 00:03:13,060
Now we're going to see how it actually works. If we call this method insert six, then we're going to we're going to insert six right over here and will increase the site and will call the Sleepify method.

12
00:03:13,330 --> 00:03:29,020
And we'll call this method with the index of six that is on and we see in X equals to answer already and we will do nothing. Then let's call this method again with four so all inside, four right over here and four will be assigned to the left hand of this node six.

13
00:03:29,440 --> 00:03:47,350
So four will be assigned right over here. The arrow will be represented. Something like this is in this formula. The value at index on is not and the left tentacles to Twiggs and that is to let let's do if I bottom to tough if we call this method with the index after that is two.

14
00:03:47,740 --> 00:04:05,170
So let's find it the parent and the index of parent is one we get by dividing the index of four by two. Now we're going to compare the current node value and the parent node value and we see four is less than six.

15
00:04:05,500 --> 00:04:20,620
So we're going to swap. If we solve this to node, then four will move at the pace of six and six will move at a place of four. And in our area we will swap this to value so four all move here and six will move here.

16
00:04:20,800 --> 00:04:32,470
And this is the representation of this array as binary. He will call this method again with the parent, that being the index one for the next recursive function call indexical to one.

17
00:04:32,470 --> 00:04:44,950
So it will just return or it will just aided by this written statement. Then let's call this method again with five. So let's insert here five. Right, Citrix plus one, two times one plus one is three.

18
00:04:44,950 --> 00:04:58,680
So let's insert as a right child right over here. Now let's call this he biffy bottom to top method with index three. And we see that the parent node is less than this current node.

19
00:04:58,690 --> 00:05:10,930
So this is false. Will call with parent, parent is four and indexes one. So it will just it did by this written statement. Then we are going to call this intermittent again with one.

20
00:05:10,930 --> 00:05:28,180
So let's insert as left hand of this node six right over here, two times two is four. So we're going to insert here one. Now, let's call this bottom to top with the index for and we see that parent of one is six and six is greater than one.

21
00:05:28,180 --> 00:05:45,940
So let's swap them one column of here and six will move here and here will solve one in six, six more here and one will move here for the next recursive function will call with the index to and we see the parent is of index.

22
00:05:46,070 --> 00:06:02,120
One, and we see parent is greater than the current, not so let's swap them if we swap for one for all, move here and one will move here and it will solve this four and one one will move here and four will move here.

23
00:06:02,240 --> 00:06:22,730
And we're done with this function. Call then roll, call it with the index of root node. That is one. So we'll just aided by this written statement. Now let's call this meeting again with seven seven will be inserted as the result of this node for right over here and in your area right over here.

24
00:06:22,970 --> 00:06:34,070
The index of four is two. So two X plus one, two times two plus one is five. So that indicates why we have seven inserted here as. Right. Channel seven.

25
00:06:34,560 --> 00:06:50,240
Now let's call the heavy fi bottom to tough with index five. And we see that seven is in its correct position. If we call this extremely bloated fault, then we'll call with the index of this, not for that is two.

26
00:06:50,450 --> 00:07:01,540
And we see the parent of this, not four is one of index one and four is in its current position. The call with the index uprootedness that is also just affected by this written statement.

27
00:07:01,850 --> 00:07:12,830
Now we're done with this call, insert seven. Now let's call again with two. So we're going to insert right over here to index of five is three times two is six.

28
00:07:13,010 --> 00:07:22,850
So will insert to right over here and our binary will be represented, something like this. Now, let's call this here if I want to. Tough with index six.

29
00:07:23,210 --> 00:07:37,280
So the parent of this node two is this not five. So six divided two is three. So this node five, that's what this five went to, to move here and five will move here.

30
00:07:37,700 --> 00:08:05,240
Here also are five and two. So let's solve two and five. Let's call this biffy method with the index three and we see that two. It it, it creates position, then we'll call it with the index of the Sutent and then illustrated by this written statement then if we call this method again with the three, so let's call with three and let's insert here three, three times two plus one is seven.

31
00:08:05,800 --> 00:08:19,220
So we have inserted as a child and we see three is in its correct position because three is greater than the two we had done. This is how we can construct a binary data structure.

32
00:08:19,380 --> 00:08:39,200
This is the array and this is the representation of binary data structure logically. OK, this is a logical representation. This method before I bought into tomfool takes logoff in time, complexity and logoff in space complexity for the recursion called stack.


@@@
1
00:00:00,580 --> 00:00:11,500
Hey, what's up, guys? Welcome back to this video in this video. We're going to implement this three method site pick and is empty. Now, let's talk about that first.

2
00:00:11,510 --> 00:00:23,540
We're going to talk about sites. This method takes a parameter and it's just reading the site. And the site is index number. That means the last used cell there is seven.

3
00:00:24,010 --> 00:00:36,130
So for this given binary, if you call this method site, we have to do it in seven. If we call this method is empty, absolute and false, because this binary half is full.

4
00:00:36,520 --> 00:00:49,720
This one is not empty. Obviously the size is zero, less than zero. That means our binary here is empty. So we call this is implemented a return false for this given binary heap.

5
00:00:50,290 --> 00:00:59,800
You recall this method pick the representing tinnies, the value of node, great subdivision, the value chain. We have to do nothing. We have to just return it.

6
00:00:59,800 --> 00:01:11,260
If we see the site is zero zero, then empty print value does not exist. This method site will take Spiga up one time and pick up one space complexity.

7
00:01:11,660 --> 00:01:21,640
This method is empty. Also takes big up on time and big up one space complexity. And this method pick as well will take up one time and one space complexity.

8
00:01:22,120 --> 00:01:30,340
We have understood this very explanation. Even if you are understanding this very explanation, let us not. I have a test the source code to this video.


@@@
1
00:00:00,680 --> 00:00:10,280
Hey, what's up, guys? Welcome back to this video. In this video, we're going to talk about the method extract. Now let's talk about this method extract.

2
00:00:10,310 --> 00:00:21,600
This extract method will return the will of Hadnot and it will remove the head not from our data structure. Now, let's see how we can implement this method extract.

3
00:00:22,460 --> 00:00:31,550
This method is going to be a little bit difficult. Don't worry about that. We'll talk about don't worry about that. We'll talk about every single details of this method extract.

4
00:00:31,910 --> 00:00:43,070
This is metal extract. This method takes in a parameter inside here, which if you go through the normal reckoning, minus one, returning minus one means that binary half is empty.

5
00:00:43,640 --> 00:00:59,150
Then we're extracting the value extracted through every one, the value from index one. Then we're going to replace the value at index one with the deepest note, OK?

6
00:00:59,180 --> 00:01:11,060
That is the last note in our area. Then you are decreasing the side. We're just skipping the last node. That was the last element in the last element or just skipping the last element.

7
00:01:11,300 --> 00:01:24,730
Then we're calling this a biffy top to bottom method with index one with the index uproot, not because we have updated the value of root, not with the deepest node.

8
00:01:24,860 --> 00:01:41,580
So we have to help you find the binary data structure we find will return the extracted value about during this vivify top to bottom. After recording this horrified top to bottom method, we are going to return extracted value.

9
00:01:42,200 --> 00:01:53,480
This is the method. If you fight top to bottom, this method takes the index. That means the index of our roots node. Then we're finding out the left and right chart and then we have to find it.

10
00:01:53,480 --> 00:02:11,380
The smallest child epoxide is less than left. That means our current node has no child in that case or just affected by this written statement. If we see current node has only left child, then we will compare the value with a little child.

11
00:02:11,900 --> 00:02:28,160
If the venerable root node is greater than the left child, then we have to swap. If we see the value of our root node is greater than the value of our left child, then we have to do a swap using this statement here.

12
00:02:28,170 --> 00:02:39,560
OK, then we go to our index and in this second to the left and ellipticals to temp. If we see the current node has left and right, then have to find it the smallest child.

13
00:02:40,550 --> 00:02:52,540
If the left is less than right, then up to said let the smallest child variable else the smallest child equals to right here only checking, only checking the right child.

14
00:02:52,550 --> 00:03:13,520
Because if a particular node has a right child, that means the node has two trials. That means the node has two child left and right. Here we are checking if the developer root node is greater than the value of the smallest child, then we have to do a swapping using this formula.

15
00:03:14,300 --> 00:03:25,950
And then we're calling this and then we're calling this biffy top to bottom with the smallest child. After doing that swapping here. Smallest child is the index number.

16
00:03:26,040 --> 00:03:36,470
OK, not the value of node. This is index number. Now let's see how it works. If we call this method extract what is given minority, then it will return ten.

17
00:03:36,740 --> 00:03:48,950
How? Let's see. First we're going to check the sites. I use the results to zero. Then we extracted development would not that is ten. And then we're going to update this value.

18
00:03:48,950 --> 00:04:01,160
We develop the best node, then we're going to update the value of this ruiner with the deepest, deepest node is seven. They're going to get by using the adding the last value from our three and there is seventy.

19
00:04:01,250 --> 00:04:21,870
So let's update this value now. Let's update this value with seventy in our area. Will update the value seventy right here. Here until the last minute will just skip the last element that will decrease our side, our side is now six, so we'll just skip this node.

20
00:04:22,740 --> 00:04:34,260
So the right of today is now. Then the world will do vivify if. If I hear first we're going to take the child first. We're going to check if the character has no child.

21
00:04:34,410 --> 00:04:45,240
The character has left. And right now we're going to check if the current node has no child is his fault. Then we're going to check if the current node has only left child.

22
00:04:45,600 --> 00:04:54,900
No. This is also false. Then we're going to check if current node has left and right with the current nor has left and right child. This is your current node 70.

23
00:04:55,530 --> 00:05:05,490
Since we have left and right child, we have to find it. The smallest child, the smallest child is 20. Now we're going to check 70 and 20 within 70 is greater than twenty.

24
00:05:05,490 --> 00:05:19,380
So organized to have it resolved will update the value twenty with seventy and then we're going to update the value seventy with twenty. So we have updated the values in the twenty and here we have updated the value to integrate 70.

25
00:05:20,250 --> 00:05:32,790
And in our area, what we're going to do, we're going to swap this to twenty and seventy in retrogress of twenty. So twenty all Maria and seven. Two more here.

26
00:05:33,400 --> 00:05:45,350
So twenty move here and seventy move here. So twenty goes here and seventy goes here. And this is just the logical representation of this area. Then we're going to call this method with the smallest child.

27
00:05:45,370 --> 00:06:02,850
Smallest child is this child. Seventy smallest child. The index of this node twenty now this node we have updated with seventy so we're going to call it with the index to now we see this node has two child left and right.

28
00:06:02,970 --> 00:06:17,850
The minimum is forty now let's say of seventy. And for the U.S., seventy is greater than forty using this formula so that two of them seventy will move here and forty will move here and in our area.

29
00:06:18,540 --> 00:06:38,390
We're going to swap seventy and forty. So here we're going to update forty with seventy and here we're going to update seventy with forty. So we have ablated, we developed and here we develop 70 now we're going to call this method again with the index of 70 that is full.

30
00:06:38,860 --> 00:06:49,390
And in this case, we see that there is no left and right child of this node, 70. So this unified top to bottom function will exit by this written statement.

31
00:06:50,020 --> 00:07:02,650
So we have extracted the value chain from our binary. And then we made this function call here before I top to bottom. This is how this extract operation works.

32
00:07:03,010 --> 00:07:13,480
If we call this extract method again, in that case, it will return 20 and it will update it with 60 and we will remove 60 and then we will just swap 60 and 30.

33
00:07:14,520 --> 00:07:45,120
It seems to raise the minimum child and that is going to be easy. Now let's see how we can do that. Maybe call this method, extract the religion 20, maybe call this method, extract again the intelligent 20, and then we're going to get the person that is 60 in here, 60, and it will be 20 with 60 year old aged 20 with 60 and will remove 60 and will give this element in the new age about 180.

34
00:07:45,120 --> 00:07:55,960
He will be evaluated at five. Then we will call this method. He will fight top to bottom. So in that case, we will find it the left and right child. So in this case, we see that we have left and right.

35
00:07:55,980 --> 00:08:08,160
Also, the minimum is 30. Now, let's have it resolved today and 60 today will move here and 60 will move here. OK, if we call again, this is right up the bottom with six to see.

36
00:08:08,160 --> 00:08:19,380
There is no left and right child. So this function will just by this written statement, then we're done and here we are swapping 30 and 60 unreferenced all take 60.

37
00:08:19,380 --> 00:08:33,420
And I bet this well, 20 with 60, then we'll just have 60 and thirty six to move here and then 30 will move here. OK, we've understood how extract operation works.

38
00:08:33,630 --> 00:08:49,050
I have a test, the source code to this video. Check the source code. This extract operation will take spig of log of in time complexity and it will also take Spiga of log of in space complexity for the recursive call stack of.

39
00:08:49,050 --> 00:08:56,370
If I understood this with the explanation, if if you have an issue understanding the speed explanation, let us know. Thanks for watching. I'll see you in the next video.


@@@
1
00:00:01,120 --> 00:00:12,640
Hey, yo, what's up, guys? Welcome back to this video. In this video, we're going to implement this method, deal it if it is going to be super simple, this method going to be super simple.

2
00:00:13,300 --> 00:00:23,960
This is the method here. It will take us inside here. We're just sitting at it. Now, the acronym is a pointer that points to the first tilt to the area.

3
00:00:24,620 --> 00:00:39,950
It said, I do now. Then the pointer will be changed to null. The acronym is appointed to the first seal of the area, so the array name is not pointed to now and there is nothing is pointing to the first.

4
00:00:39,960 --> 00:00:54,640
So we know the area is represented in contiguous fashion. So the entire area will be delivered by garbage collector since we're implementing binary HIF using area in the area that we're tilting the binary here.

5
00:00:55,320 --> 00:01:06,230
This is just the logical representation of the area. What we have understood this reader explanation. This meant a textbook of one time complexity, big up on space complexity.

6
00:01:06,790 --> 00:01:14,820
We have understood this very explanation, even if you understand it is the explanation. Let us know. Thanks for watching this video. I'll see you in the next video.


@@@
1
00:00:01,240 --> 00:00:33,000
Hey, you guys all come back to this video in this video. We're going to talk about a will to get a structure. If all three is a self balancing binaries, history in who is is not maintained, extra information called a balance factor, whose value is either minus one zero or plus one balance factor of a node in an anvil tree is the difference between the height of the tree and the height of the right subtree of that node in every tree.

2
00:00:33,370 --> 00:00:47,010
If the balance factor of node is not at minus one zero or plus one, then the tree is not avil tree because that node is not falling the properties of Aviel tree.

3
00:00:47,680 --> 00:00:58,880
So the value of balance factor should always be minus one zero plus one balance factor records to a height of left subtree, minus height of a right subtree.

4
00:00:59,050 --> 00:01:18,190
This is a formal definition of a real tree. Now let's see some examples. This is an example of a tree. We have balance vector for every single node. The balance vector for this node five is one because the height of this node is two.

5
00:01:19,000 --> 00:01:33,860
This is the left subtree. The height is two, one and two. And the height of rights is one, this is the right subtree, so to minus on is one. So the balance factor of this, not five, is one.

6
00:01:34,400 --> 00:01:46,820
So this note is falling the properties of deviltry then for this note. The high level of subtree is zero, the height of right sector is one zero, minus one is minus one.

7
00:01:47,620 --> 00:02:09,190
And these are live not for live, not the values zero by default, because for LoopNet there is no left and right subtree. Then for this not the value is one, because the height of subtree is zero zero minus the height of a right is minus one, since there is no right subtree.

8
00:02:09,190 --> 00:02:18,510
So the value is minus one. So the balance factor of this, not four, is one. Then for this not the leptospira is minus one and the right subtree is zero.

9
00:02:18,670 --> 00:02:35,330
So minus one minus zero equals to minus one. So the balance factor for this, not six, is minus one. So we can say this is a valid deviltry because the balance factor for every single node, either minus one zero or plus one.

10
00:02:35,860 --> 00:02:48,580
Now let's see another example. This is an example of a real tree. We have calculated the balance factor for every single node. The balance factor for this node is one the height of lives up to is too high.

11
00:02:48,580 --> 00:03:00,700
The private sector is one, two, minus one is one for this, not one as well. The height of the tree is on the height of right substories zero. So one minute zero is one reason for this, not zero.

12
00:03:00,880 --> 00:03:12,120
The height of writes up three zero zero zero zero. These are live not for LoopNet. The balance factor is zero. And for this net the balance factor is zero.

13
00:03:12,340 --> 00:03:31,750
So we can say this tree is falling. The properties of Aviel Tree and Aviel tree is a binary society as well. If a tree do not falling, the properties are binary thirsty then we cannot say that tree is a real tree because it will.

14
00:03:31,750 --> 00:03:46,960
Tree is a binary tree. What? We have extra information and that is a balance factor. The values on the left subtree is less than the values on the right side are greater than for every single node, for this tree and for this tree.

15
00:03:47,110 --> 00:04:02,140
So we can say this through tree is every tree we have understood what is a tree. Now, you might ask why we need to learn Aviel Tree. That's a great question in binary.

16
00:04:02,150 --> 00:04:16,930
Firstly, insertion operation takes linear time dilation operation takes linear time and search operation takes logarithmic time. Complexity for Aviel tree insertion and deletion operation takes logarithmic time.

17
00:04:16,930 --> 00:04:35,200
Complexity and search operation takes longer time complexity as well. And this is similar to by necessary. And here we see that for insertion and deletion operations we can improve the time complexity from linear to logarithmic.

18
00:04:35,710 --> 00:04:54,700
That's a use gain and this is why it will three come into the picture. And this is why we should learn every tree using every tree. We can improve time, complexity for insertion and deletion operations from linear time, complexity to logarithmic time complexity.

19
00:04:55,150 --> 00:05:10,360
What we have understood why we should learn every tree. Now let's see the application of deviltry for indexing a large records in database that we use avil three and four sourcing in large databases.

20
00:05:10,480 --> 00:05:25,010
We use this deviltry. This other two use cases and there are many use cases of three of we have understood what is a real tree and why we should learn every tree.


@@@
1
00:00:01,270 --> 00:00:20,890
Hey, yo, what's up, guys? Welcome back to this video. In this video we're going to implement to method, create a real tree and create a filtering method, will create a real tree and says method will search for a value in that every tree.

2
00:00:21,280 --> 00:00:38,530
Now, let's implement this to method. We have calculated the violence factor for every single note, OK? For this nonviolence, for this not minus one, for this, not minus one for this, not minus one and zero for the lymph nodes.

3
00:00:39,220 --> 00:00:53,700
Now let's see with a method. This class, avil three inside here, we have a note, the note of every entry contains four attributes value, height and left and right pointer.

4
00:00:54,010 --> 00:01:06,430
Here we have the root of evil three, and we have this method great a will try. This method takes no parameter inside this method. We're just setting route to now.

5
00:01:06,880 --> 00:01:29,470
OK, this method will take us Bego off in time, complexity and bigger in space complexity. Here we have a root of all evil three. Then we have this method create a will try this method takes the parameter inside here we're setting root to now and this method will take up one time and big of one space complexity.

6
00:01:29,980 --> 00:01:53,320
Now let's see this search method. If a value exist in a given Aviel tree, then you do return to the value do not exist. It will return false. Now let's talk about search method, the assessment that will take a value as input and it will return that not in the not just in the eval tree.

7
00:01:53,860 --> 00:02:08,440
If the node doesn't exist, it will return. Now, this is the algorithm for Sarsae method. This method takes on parameter value. Instead, you are calling this search method with root and value decision helper method.

8
00:02:09,130 --> 00:02:17,820
This method takes two prominent node and disvalue. Initially, node is the root node and values the given value inside your checking if the results will return.

9
00:02:17,830 --> 00:02:30,700
Now, this is Baskette active. If you find it or develop the whole region that not you will find out the current value is greater than the value. Then I will call it left to tree ELT's with the right subtree.

10
00:02:31,120 --> 00:02:45,040
If we call this method with a tree first, we're going to call the search method with Route five and value tree for this given a tree. And we see that no is not now, nor is five.

11
00:02:45,310 --> 00:02:55,360
And the value of this node is not equal to three. And we see the value is greater than the tree. So let's go to the left subtree, not one that left subtree.

12
00:02:55,690 --> 00:03:07,000
And we see the value. Two is less than three. So let's go to the right subtree. This is the right subtree. And here we find out the value three. So it will return this, not a tree.

13
00:03:07,270 --> 00:03:16,090
So we'll return three for this function call. And this is how it works. Now, let's call this method with eight he received, five is not equal to eight.

14
00:03:16,090 --> 00:03:25,540
So let's go to the right subtree. And here we see seven is not equal to eight. So let's go to the right subtree. And here is the eight equals to eight.

15
00:03:25,540 --> 00:03:42,100
So we'll will return this node eight for dysfunction call will region that node eight. This is how the search operation works and the search operation similarly to the search operation for binary Sastry.

16
00:03:43,080 --> 00:04:01,080
We know that April three is a binary necessity where we have extra information called balance factor. So the search operation will take longer logarithmic time, complexity and logarithmic complexity since we're dividing the inventory into two halves.

17
00:04:01,080 --> 00:04:16,600
Four is recursive function call. That's what it will take because of long time complexity and the big of log in space complexity for the recursive call stack we've understood create a military method and search operation.


@@@
1
00:00:00,330 --> 00:00:12,750
Hey, you guys all come back to this video in this video. We're going to implement this insert method. This method takes a value as input and it will insert the value to that.

2
00:00:12,760 --> 00:00:26,660
I will try this method is going to be a little bit harder to understand. We have four types of rotation for inserting a value in inventory rotation. Laterite rotation.

3
00:00:26,700 --> 00:00:44,210
Right. Right. Rotation and right. Let rotation. In this video, we're going to talk about little rotation. When you are going to insert a value in April three, then this process is going to be a little bit difficult to understand for inserting involving the deviltry.

4
00:00:44,250 --> 00:00:58,980
We have poor conditions, little condition, left-to-right condition. Right, right. Condition and the right condition. In this video, we're going to talk about lipless condition, what is the condition and how little that condition works.

5
00:00:59,730 --> 00:01:16,440
Now, let's talk about that in detail. For example, if you're given this a real treat as input and we want to insert a value one and we have inserted valid one right over here, this is a binder.

6
00:01:16,440 --> 00:01:33,120
This is the correct position of one, the left of this note to be inserted. Disvalue The April three is not following the properties of every tree, and that is the properties of Vallens factor.

7
00:01:33,570 --> 00:01:47,700
All lood should have a balance factor minus one zero or plus one. But when you have inserted this value to this Aviel tree, then the balance factor of this node on is zero.

8
00:01:48,090 --> 00:01:59,220
The balance factor of this node to is zero minus minus one is on the balance factor of this node. 3S hydroplaned subtree. That is one one minus minus one.

9
00:01:59,220 --> 00:02:09,240
That is two. So this not is not following the appropriate balance factor. The balance of this number is not minus one or plus one. The balance factor is three.

10
00:02:09,840 --> 00:02:23,480
So this two node is not following the properties of a real tree. When you have inserted a value to the left of a node, then we have to handle flipflopped condition.

11
00:02:24,150 --> 00:02:37,590
Now we have to do a little rotation to make. This tree is a Aviel tree as well as a binary Sastry. In order to do that, we have to do a right rotation here.

12
00:02:37,590 --> 00:02:51,030
OK, if we do a right rotation, then the T will be represented, something like this to go off. And three goes to the right side of this node too. And the Tulba represented something like this.

13
00:02:51,180 --> 00:03:11,370
This is called Let Let It Condition. Let's take another example. For example, if you given this Aviel tree as input and you have inserted the node one right over here, and now we see that the balance factor of this node two is zero minus, minus one is one.

14
00:03:11,460 --> 00:03:29,880
The balance factor of this node for zero. The balance of this node is one minus zero. That is one the balance factor. The balance factor of this node five is two minus zero, the hydrophilic subject minus either by chapter and that is two.

15
00:03:30,330 --> 00:03:50,210
So this node is not following the properties of every tree because the balance of this note is two, not minus one zero or plus one. And we see that the balance spectrum is not five is not appropriate balance factor, because the balance that there should be minus one, plus one or the balance factor here we see is two.

16
00:03:50,520 --> 00:04:04,860
So this is the culprit node. The balance of this net five is two. So you have to do a right rotation if we do it right. Rotation. Then Tulba represented something like this and this is called split condition.

17
00:04:05,040 --> 00:04:20,400
Now let's see how this let let conditional works. This is the algorithm for inserting a value in it. Every tree here we have this helper method to insert this method takes a root and to value this is the helper method.

18
00:04:20,790 --> 00:04:33,660
This matter takes two parameter node and value. What is the root? Not initially. This is a basket. If we found Noriko's to now, then we're creating a new node and we're returning that node.

19
00:04:34,200 --> 00:04:45,090
We found the current not value is greater than the given value. We will call it let somebody else call it right subtlely. If not, we'll just return that current node.

20
00:04:45,360 --> 00:04:59,940
And this is the properties for binary search stream and this is binary search. This specific code here, we have called for a specific task. Be inserting the node to the correct position I.

21
00:05:00,020 --> 00:05:13,380
They're inserting a note to a appropriate position, they need to calculate the height of a. so the that cuts to one plus the maximum height of left and right subtree.

22
00:05:13,520 --> 00:05:27,260
And here we have this method. Height will see this method in this period to worry about that this mother takes the laptop and writes up. Then it will retain the height of left and right subtree and will get the maximum and will add to one.

23
00:05:27,620 --> 00:05:38,040
Then we have a balance factor will call this method balance factor. This method will read the balance factor of a given note and then we will check if the balance factor is greater than one.

24
00:05:38,390 --> 00:05:59,870
Then we found the value is less than that level of value. Then we have encountered Lib-Lab condition and in this video you'll see this condition. If not, if we find out the value is greater than that value, then if do have that right condition in the condition we have to call first liberated, then you have to write it.

25
00:06:00,260 --> 00:06:07,280
If the balance factor is less than minus one, then we'll take this value. The value is greater than that, right? To develop the have to do right. Right.

26
00:06:07,280 --> 00:06:17,110
Condition for right. Great condition. We have to do it if the values are less than to right. To develop the nerve to do it right. Good condition for right condition.

27
00:06:17,120 --> 00:06:29,630
You have to do first right through let's electrode and at the end we retain our node in this. We will see this left left condition. Now let's see how this condition works.

28
00:06:30,120 --> 00:06:43,430
Let's say we want to insert the node one to this level three so we can insert this, not one to this level three. So we'll apply this basic condition. Our not is not a null and this value is less than five.

29
00:06:43,440 --> 00:06:59,470
So let's go to the left. The value is less than three. So let's go to the left. The value is less than two. So let's go to the left and the left. We've encountered not so insert here this node one by this statement ten, the value is less than the node value.

30
00:07:00,260 --> 00:07:11,070
So we have created a new node with the value one by this written statement. And we have inserted that note to the left of this note to note, this is our current node.

31
00:07:11,780 --> 00:07:23,260
Now let's find out the height of this node. The height of this node is zero and the height of this site is minus one. So maximum is zero zero, plus one is one.

32
00:07:23,390 --> 00:07:34,570
So the height of this node is one. And the balance factor of this node is zero minus minus one, and there is one as well. So the balance of this node two is one.

33
00:07:35,180 --> 00:07:45,470
So we say that the balance factor is not greater than one, is not less than minus one. So we'll just return this note two to the left. So this note will be assigned to the left of this, not a three.

34
00:07:45,830 --> 00:07:59,150
The balance factor of this node three is one minus minus one. The hybrid batteries minus one. So on minus one is two. So this note is not contains the appropriate balance factor.

35
00:07:59,390 --> 00:08:12,930
So here you see that this balance factor is greater than one. This method will see in our pseudocode, can see this method in the source code. And here we see that the value is less than the node that lived at value.

36
00:08:13,130 --> 00:08:35,450
So not applicable is two and this one is less than this value two. So here we find out the left left condition and this is one level of condition in the inserted value is less than the bell on the left note or current node, the current node where we find out the inappropriate balance factor, then we have to do it right rotation.

37
00:08:36,050 --> 00:08:46,430
So it will call and write rotate method with this node here we have a right of every single node now let's call it right. Rotate with this, not a tree.

38
00:08:46,820 --> 00:08:59,330
This is also the code for a right to rotate. This method takes one parameter current node here. We have current goals for this, not three. And Nunally calls to this note to the left of our current node.

39
00:09:00,260 --> 00:09:12,770
Now current not applicable to current node. Don't let DOT right. So we have to disconnect this. We have to set it to the right. The right of this right of this new node is now.

40
00:09:12,770 --> 00:09:26,560
So we have to set this letter now then new right. Equals to cut it. So here you insert this current node and then we'll calculate the height of current and height of unit.

41
00:09:26,630 --> 00:09:44,030
Either period is one. The height of Carignan is zero. And here you see we have the height of this kind node is two. So we have calculated the height of this current node now will return this new node and this new unit will be inserted to the left of this node five.

42
00:09:44,600 --> 00:09:59,270
So the unit will be inside of the left of this five, then our balance sheet will be represented. Something like this. Since we have calculated the height of this current note that is zero by this formula.

43
00:09:59,390 --> 00:10:14,510
Height of. That is left is the ladies, not the rallies zero. We're going to find a tide of not using this tonight. The value of this kind is. All right, now we see that this is a real tree.

44
00:10:14,840 --> 00:10:24,130
This is a binary disaster as well. And this is what we can insert a value in a Aviel tree. And this process is going to be very critical to understand.

45
00:10:24,140 --> 00:10:40,730
But don't worry, we have explained every bit of information that we need to understand this problem. And this operation only takes a logarithmic time, complexity and the time complexity for right to rotate and height is constant.

46
00:10:41,360 --> 00:10:55,790
This method works in constant time and in constant space complexity. And the amount of time and space complexity for this insert method is logarithm. That is big of log of it.

47
00:10:56,840 --> 00:11:08,420
Now, let's see another example. Now, let's say we're given this ability. We have to insert the node one. So inserted this one right over here by this BSG condition.

48
00:11:08,930 --> 00:11:22,100
OK, then we have to find out the balance factor for every single node. Let's find it the height we find it the height of every single word, the height of this node to is one for this node trees two.

49
00:11:22,100 --> 00:11:31,940
And so on the balance spectrum is not only zero. The balance factor of this node is one zero minus minus one is on the balance factor of this node is the zero.

50
00:11:31,940 --> 00:11:49,340
The balance factor of this node is one minus zero. That is on the balance of this node is two minus zero. That is two. So here is the problem is not is not contains the appropriate balance factor that we see that this condition is true for this route.

51
00:11:49,340 --> 00:12:03,390
Node balance factor is greater than one and the inserted value is less than the value on the left of our current. No, your current not or you find out the inappropriate balance factor that is our current node.

52
00:12:04,100 --> 00:12:14,270
Now let's take this value. The node that led to the value, the one on the left of this node is three. So three is greater than the value we have inside it.

53
00:12:15,210 --> 00:12:27,230
So we have to be on a right rotation since this is a little condition, since the value on the left about note is greater than the inside value. So this is a left left condition.

54
00:12:27,780 --> 00:12:47,540
So let's do it right. Rotation. This is our pseudocode for right rotation. This method takes one parameter and we have to conclude and neonate. Now, let's apply this formula that me go to current let you go to count node that left it right so kind.

55
00:12:47,570 --> 00:13:05,510
No don't let equals two and not dot left. That's right. So here you insert this node for will connect to this node. So that left up correct node. Is this not for the new route dot right equals to current.

56
00:13:05,990 --> 00:13:30,530
So here on the right of this new model inside or inside the node five and on the right of five we have the node seven, then the three will be represented, something like this first three and the left two on the left one, then on the right is five.

57
00:13:31,040 --> 00:13:44,770
On the left of five we have four. And on the right of five we have already seven. We have to calculate the height of this node five and the height of this tree.

58
00:13:45,380 --> 00:14:00,050
So this is the representation of a real tree. After doing this right rotation, then our ability will be represented. Something like this, the height of current node and height of the height of this new eruption.

59
00:14:01,250 --> 00:14:13,940
So one plus makes up left and right. That is two one plus smacks of left and right. That is the one who this is where we can insert a value in a Aviel tree.

60
00:14:14,210 --> 00:14:47,750
And here we have to do this right to for this little left condition. And this is the statement for Lavallette condition and this is the if statement for that condition, when the value in such value is less than the value on the left, apower and node kind node in the first inappropriate note where we have invalid balance factor but regressing back, inserting in node, we have understood this method and this related condition.

61
00:14:48,170 --> 00:14:59,420
This operation will take over the time, complexity and logarithmic space complexity. This this two method will take constant time. Complexity, good balance factor also takes constant time and space complexity.

62
00:14:59,880 --> 00:15:13,580
And overall time complexity for this in sedimented is because of logoff in and the space complexity is because of lack of info, the recursive calls that we have understood this video explanation.


@@@
1
00:00:00,330 --> 00:00:13,020
Hey, you guys, welcome back to this video. In this video, we're going to talk about rotation on insert a node in a real tree. Then the tree can be this balance.

2
00:00:13,560 --> 00:00:24,900
To solve this issue, we have to do a rotation. We have four types of condition for rotation, landslips, condition, left-to-right condition. Right, right.

3
00:00:24,900 --> 00:00:38,090
Condition and a right left condition. Now, let's see what is left left condition, what is left, right coalition and so on. Now, first, let's talk about roleplayed condition for that condition.

4
00:00:38,340 --> 00:00:56,140
Let lymph node of the current node is causing the this balance to solve this problem, we have to do right. Rotation. You given this a tree, it will insert this not one to this real tree then with nodes creates the problem.

5
00:00:56,580 --> 00:01:08,490
So first let's find out the current node. So after inserting this node to the left up to we have to recurse back. OK, now let's calculate the balance factor.

6
00:01:08,610 --> 00:01:20,640
So zero minus minus one, the balance vector for this node one is that child is minus one. The right child is minus one. So the balance of this node is zero.

7
00:01:21,120 --> 00:01:44,340
The balance of this node to is zero minus minus one. There is one. The balance factor of this node three is one minus minus one. That is two. So this is the current node because this is the first not only find it inappropriate balance factor when we're rehearsing back, that means we are going back to our recursive function call here.

8
00:01:44,340 --> 00:01:53,880
We see that let's let node of this continent is creating the problem. This is the node creating the problem. So to solve this issue, we have to do a right rotation.

9
00:01:53,880 --> 00:02:05,370
If we do right rotation, then it will be our new head. If we do that rotation, the tree will be represented, something like this, and this tree is balanced.

10
00:02:05,370 --> 00:02:17,100
And this is a valid deviltry. This is called Lavallette condition because the node of current note is causing the problem or is causing that imbalance.

11
00:02:17,850 --> 00:02:25,230
Now, let's take another example for a little heart condition. Let's say we're giving this tree and we have inserted the node one to the left up to now.

12
00:02:25,230 --> 00:02:37,530
Let's find out the balance factor. So balance of one is zero. The balance factor of two is a zero minus minus one. That is on the balance factor of this node three is one minus zero.

13
00:02:37,950 --> 00:02:57,720
That is on the balance spectrum is not five is two minus zero, that is two. So this is the first node. What we find out in the appropriate balance factor when you're rehearsing back, that means when you are going back to our previous recursive function call, now let's find out the left and left node of this, not five.

14
00:02:57,720 --> 00:03:07,200
So left is three, the left of trees two. So this node is creating a problem. To solve this problem, we have to do it right rotation in right tradition.

15
00:03:07,200 --> 00:03:22,450
Then to our roots node it will create will be represented something like this. And this is valid every tree and this is called Leibnitz condition. We understood what is the left left condition.

16
00:03:23,010 --> 00:03:36,270
Now let's talk about left-to-right condition for electret condition. Node of current node is causing this violence in that case, first to rotation, then have to do right tradition.

17
00:03:37,920 --> 00:03:51,000
You were given this a tree and here you've inserted tree. Now let's find a balance factor balance speculatory zero balance. Spectra of this node to is minus one minus zero.

18
00:03:51,090 --> 00:04:05,040
That is minus one balance factor of this not four is one minus minus one, that is two. So this is our current node or they find it inappropriate balance factor that is not minus one zero or plus one.

19
00:04:05,850 --> 00:04:18,450
Here you see the letter for its to the right of two is the tree and here we see that this node is creating the problem. And to hear you say that this node three is creating the problem.

20
00:04:18,750 --> 00:04:33,600
So let's do a little rotation first. If we do, let's rotation in between these two node the rotation, then our Tulba represented something like this. Now we have to do here right rotation.

21
00:04:33,780 --> 00:04:45,750
If we do right rotation, then our T will be represented, something like this. And this is valid every entry and this is called Left-to-right Condition, who we have understood.

22
00:04:45,750 --> 00:04:55,770
What is the right condition for like that condition have to do first. Let rotation then. Right. Tradition. No, let's talk about right. Right. Condition for right.

23
00:04:55,770 --> 00:05:06,140
Right. Condition. Right, right. Node of current node is causing this. Balance in that ticket, we have to do a little rotation if we're given this, we'll try.

24
00:05:06,410 --> 00:05:16,550
And here we have inserted a. eight. Now let's find the balance back balance factor of eight zero. The balance factor of one is minus one, minus zero is minus one.

25
00:05:17,360 --> 00:05:32,510
The balance factor of six is zero minus minus one. There is one. The balance of this, not six is zero minus one. That is minus one. The balance factor of this, not four is zero minus two.

26
00:05:32,510 --> 00:05:45,080
That is minus two. So this is the current node. Now, who is not creating the problem? The right side of this node for is creating the problem. The right right, not the right treatment of this.

27
00:05:45,080 --> 00:06:08,600
Not four is seven, the right of forty six. Right of sixty seven. So this node is creating the problem. So we have to do here a little rotation. If we do hear a little rotation, then this node six will be our route, then this node six will be the root of rotated three.

28
00:06:08,840 --> 00:06:20,660
So if we do it then we will get this Aviel three. And this is a valid deviltry and this is called a right condition. We have understood what is the right condition.

29
00:06:20,990 --> 00:06:32,720
Now let's talk about the right condition, for the right condition, the right note of current that is causing this violence. In that case, first trip to the right rotation.

30
00:06:32,730 --> 00:06:45,170
They have to do little rotation. Even given this ability to have inserted the node sick here, have inserted this node is six. Now let's find out balance factor.

31
00:06:45,320 --> 00:06:56,390
The balance of the node is zero. The balance factor of this node seven and zero minus minus one that is on the balance of this node five is minus one.

32
00:06:56,390 --> 00:07:07,910
Minus one. That is minus two. So this is our current node. The right leg of this, not five is six. The right is seven, the left is six. So this node is creating the problem.

33
00:07:08,090 --> 00:07:23,470
First, we have to do here a right rotation. If we do right rotation, then we will get this three. Now we have to do here rotation. If we do let rotation, then we will get this tree.

34
00:07:23,480 --> 00:07:34,220
And this is valid deviltry and this is called a right left condition for right left condition. We have to do first reputation that have to do little rotation.

35
00:07:34,680 --> 00:07:56,240
We've understood what is little condition, what is Leichtfried condition and what is right. Right. And what is right left condition in the next Tiberio will insert and not to a are three and we have to do the rotation and old see all types of rotation and also we'll see all conditions.


@@@
1
00:00:00,440 --> 00:00:10,370
Hey, what's up, guys? Welcome back to this video. In this video, we're going to talk about insert operation and in this video specifically, we'll talk about laterite condition.

2
00:00:10,700 --> 00:00:19,130
Now, let's talk about laterite condition in details. For the sake of understanding, let's assume we're given this ability and we have to insert a note of value.

3
00:00:19,150 --> 00:00:33,320
Three inserted this note to this will carry this note, will goes to the right of this node to since this is a binary firstly because a filter is a binary circuitry and we have calculated the height of every single node.

4
00:00:33,530 --> 00:00:44,780
Now let's find out the balance factor, balance factor of this, not zero. The balance factor of this node three is zero. The balance factor of this node to is minus one mind zero and is minus one.

5
00:00:45,140 --> 00:00:56,330
There is no node on the lips of three. So the height of leptospira is minus one, minus one liners is minus one. Then here one minus minus one. That is two.

6
00:00:56,480 --> 00:01:07,750
So this is inappropriate node because this node is not following the properties of every tree. The balance vector is not minus one zero plus one. The balance is two.

7
00:01:08,120 --> 00:01:20,340
Here we see that inside is three, the Velone, that letterbox node, or they find it the inappropriate balance factor two, and that is less than the inserted value.

8
00:01:20,750 --> 00:01:35,910
So we have to do here let rotation first to do let rotation. So let's do a little rotation. If we do let rotation, if we do hear a little rotation, then our will be represented, something like this for right condition.

9
00:01:35,930 --> 00:01:50,760
We have to do now in right rotation. If we do right rotation, then our event will be represented, something like this. And this is the ballot. We have every single that contains appropriate balance factor.

10
00:01:51,140 --> 00:02:01,040
So this is the ability that we have to return. And this is called let the right condition for that condition. First step to do a little rotation then.

11
00:02:01,040 --> 00:02:11,600
Right rotation. Now, let's see how this actually works using pseudocode. Listen to the court and sort of got exactly the same, the pseudocode in the previous video.

12
00:02:12,740 --> 00:02:34,100
For sake of understanding, let's assume we're given this. We'll try and insert a node three so the Node three will go for the right of this node to let's find it the height of every single node and the balance vector of this node, the balance of this not three zero balance making all this noise, minus one, minus zero is minus one.

13
00:02:34,580 --> 00:02:44,030
Now, the balance of this, not four, is to because one minus minus one, that is two. Now we find out this culprit. Note this node is not contains the appropriate balance factor.

14
00:02:44,180 --> 00:03:05,370
That is zero minus one hour plus one does not contain the balance factor two. Now here we have to do that right condition first, let's call it with the left of this node for that is to let's call with this, not my reputation and returning not all assigned to the left of this node for by the segment.

15
00:03:05,930 --> 00:03:23,960
Now, let's see. This rotation is your little rotation pseudocode. Here we have current and neonate area of current node and new route. Now what we have to do, current node dot radical's to current, no dot right, dot left.

16
00:03:24,260 --> 00:03:44,770
So current node that right. Is this not the one that is now. So we have to insert to the right of node is now node then we have to say that leprechaun's to do so on the little assign the node two will return this new node and that note will be assigned to the left of this node.

17
00:03:45,170 --> 00:03:56,870
So the node three will be assigned to this node for then our tree will be represented, something like this. So we are done with this statement that leprechaun's to the project.

18
00:03:56,870 --> 00:04:06,980
Note that left. Let's call with this note that we have to do the right project. So this is our current node. So let's call with this. Not for a writer.

19
00:04:06,980 --> 00:04:19,360
Wanted it to be here, right. Wrote it for right rotation. This is our pseudocode. This is current and this is new. Kind of leprechaun's to on the left, we have to assign current one that led to that.

20
00:04:19,370 --> 00:04:35,150
Right. So on the right of this laptop current is now. So let's insert here now node and new route dot radicals to code that is for and here will return this new route.

21
00:04:35,390 --> 00:04:46,820
This new route will be assigned to the left of this node six, when you call it that leprechaun's for incitement that left with the value. Then our tree will be represented, something like this.

22
00:04:47,180 --> 00:04:59,890
And we have calculated the height of new node and continued using this formula. And then it will return this to the left of this node six. And this is the argument and will return this note to this mean for.

23
00:05:00,710 --> 00:05:12,410
And this is how we can insert a value in a inventory. This is called Labourite condition for simple deliberation, they have to do a right tradition of, if understood, left right condition.

24
00:05:12,620 --> 00:05:20,830
This solution takes a lot of time, complexity and lower the expense complexity. What we have understood is the explanation is understanding this with explanation.


@@@
1
00:00:00,660 --> 00:00:09,750
Hey, what's up, guys? Welcome back to this video. In this video, we're going to talk about inside operation, specifically in this video. We're going to talk about it right condition.

2
00:00:09,960 --> 00:00:21,210
And let's talk about what is right right condition. Let's say we're given this ability or if inserted the Node eight. So eight will goes to the right of this node seven.

3
00:00:21,900 --> 00:00:34,500
And we have calculated the height of every single node. Now let's find out the balance back to the balance of this node, 18 zero. The balance factor of this nought minus one, minus zero is minus one.

4
00:00:35,240 --> 00:00:52,080
Balance factor of this node is zero minus one, that is minus one. Then the balance factor of this node for is zero minus two. That is minus two. So this is our Calvet node.

5
00:00:52,350 --> 00:01:06,900
This node is not contains appropriate balance factor. So this is the culprit node DCG. Right. Right. Condition why. This is the right word condition. The inserted value in this binary two is eight.

6
00:01:07,500 --> 00:01:22,760
Current node is the first. Not only find it in balance factor when it recurs back. So value is six we see here. This value is great and then right valuable current node for right rate condition.

7
00:01:22,770 --> 00:01:35,110
We have to do a little rotation. If we do that rotation, then our Tulba represented something like this in the street. Every single word contains appropriate balance factor that is zero minus one or plus one.

8
00:01:35,490 --> 00:01:46,770
And here are just showing the height of every single node side of this node six is to itemise this one and so on. Now let's see how this actually works.

9
00:01:46,950 --> 00:01:57,960
And this is called little when you find out. Right? Right. Conditional to do that rotation. They say the words to the code, as we saw in the previous slide.

10
00:01:58,230 --> 00:02:07,530
Now, let's say we want to insert the eight to this Aviel three. So eight Will goes right over here to let's calculate the height we find at the height.

11
00:02:07,860 --> 00:02:18,150
So the balance factor of this Nonnatus zero balance of this note is minus one, minus one minus zero is minus one. The balance of this note is the minus one.

12
00:02:18,150 --> 00:02:30,090
That is minus one balance factor of this node is zero minus two. That is minus two. So you find it inappropriate balance factor. So it will hit this condition and minus three.

13
00:02:30,660 --> 00:02:45,540
Minus one. And here we see. Right, right. Condition that value eight is greater than the value of. Right. Not about, Carignan countered, is the not defined in the inappropriate balance factor unit rehearsing back.

14
00:02:46,020 --> 00:02:58,680
So let's do a little rotation. This is the pseudocode for liquidation. So this is our current node. This is our route now current nor the radicals to count that right of left.

15
00:02:58,890 --> 00:03:23,610
So all inset to the right of for this node five. Let's discuss this and then new route that ellipticals to current. So the left will connect to this note, then have to calculate the height of current and height of this new route node, then will return the new route node, then our three will be represented.

16
00:03:23,610 --> 00:03:36,000
Something like this. Let's calculate the height of this current node and the height of new root node. And here we see we have the ballot for every single node.

17
00:03:36,570 --> 00:03:51,990
And if we calculate the value of current note, we get max of left and right mixology right is zero and zero. So if we calculate the height max up left and right plus one, there is one mix up left and right.

18
00:03:51,990 --> 00:04:04,620
There is one plus one. And there is to know if we apply the value from this tree, we have this value. Now, if we calculate the height, then we get either current is unhide of new route is two.

19
00:04:05,010 --> 00:04:22,380
That's remained the same and at the end will return this new route node will return this new node. And here this function will return this new node by this written statement to this function called Getable Inspector Metrojet.

20
00:04:22,620 --> 00:04:33,960
And a method will work in constant time and constant espace complexity when it showing this method get the balance right. This is super simple. We have in the source code.


@@@
1
00:00:00,700 --> 00:00:10,990
Hey, yo, what's up, guys? Welcome back to this video. In this video, we're going to talk about inside operation in three, specifically in this video. We're going to talk about that last condition.

2
00:00:11,030 --> 00:00:25,390
All right. Let condition, for example, if you're given this will and and inside the Node six, we have inserted the node six to the left of this Node seven since it is a binary search as well.

3
00:00:25,750 --> 00:00:37,960
The inside it is six. The balance of this node six is zero. Balance back of this node seven is zero minus minus one. There is one. The balance of this node is minus one, minus minus one.

4
00:00:37,990 --> 00:00:53,460
There is two. So we find it inappropriate balance factor for this node, not the right of this current node. This is our current not because this is the not only find out the inappropriate balance factor when we are rehearsing back to the valley, on the right is seven.

5
00:00:53,500 --> 00:01:03,730
We see the inside. It is less than the value seven. So this is a right lit condition for us to be the right rotation. Then you have to do a little addition.

6
00:01:03,820 --> 00:01:15,640
If we do right rotation to this ability, then we get this tree the inappropriate balance factor. We find out at this Node five that we have to do a little rotation for this right light condition.

7
00:01:15,880 --> 00:01:25,930
That's to let rotate. So we get this inventory. And this is a value of what every single that contains appropriate balance factor balance of this node five is zero.

8
00:01:25,930 --> 00:01:39,790
Balance of this node is zero. Of this node six is one of the node, four is zero minus one. That is minus one. And for this node is zero. So this is a valid event.

9
00:01:40,090 --> 00:01:51,110
Now let's see how this right left coalition works in pseudocode. This is the record that we saw in the previous video. Now let's insert a node six to this, a tree.

10
00:01:51,310 --> 00:02:02,400
So six all goes to the left of seven. Now, let's find out the balance factor. The of this note, six zero balance factor of seven is one balance. Factor of five is minus one, minus one, minus two.

11
00:02:02,560 --> 00:02:16,950
It's hit this condition and here it makes this statement. So let's try to rotate with this node seven here. We have calculated the height of every single note and this number right through it.

12
00:02:16,990 --> 00:02:32,890
OK, first step right through it with the right note. This is your current. So if we do write it, this is our new node, current leprechaun's two current that left that right that is now on the left will insert.

13
00:02:34,210 --> 00:02:54,870
So on the left inset it now node the new route that. That's right. Because the current on the right or inside this node seven and will return this not the height of current and new node and then will return this new node and this unit will be at the right of this node five.

14
00:02:55,330 --> 00:03:04,130
Then our Tulba represented something like this. Let's calculate the height, the height of this node six is one height of this node seven to zero and so on.

15
00:03:04,660 --> 00:03:15,670
So we're done with this statement. Now let's do a little rotation with this node, because this is our current non-qualified it inappropriate balance factor.

16
00:03:16,180 --> 00:03:29,650
If we do, let's put it this is our rotate pseudocode. All right. This is current and this is new route current, not that radical to current node dot right.

17
00:03:29,650 --> 00:03:44,440
That left on the left of six is now. So here, inside now on the right, let's insert here now the new route that let it go through on the left or insert current that is five inside five.

18
00:03:44,590 --> 00:03:59,010
And then we'll calculate height of current and unit and we're going to return this note and this note will be attached to the left of this node for and this will be done by this statement that.

19
00:03:59,020 --> 00:04:11,530
Right. And our children represented something like this. And here we have calculated the height of six and height of five zero and one. This is how this in right condition works.

20
00:04:11,780 --> 00:04:28,660
We have understood what is it right to let condition for right condition, first step in to write it. The letter that we have understood this Avita explanation and the four conditions LePoint condition, Liveright condition.

21
00:04:28,660 --> 00:04:46,120
Right, right. Condition and right left condition. This is all about insertion operation in deviltry after inserting a node in the balance vector evaluated minus one zero or one when you're requesting back, that means we have to do no rotation.

22
00:04:46,120 --> 00:04:56,200
In that case, when you find it inappropriate balance only requesting back after inserting a node, then we have to do a rotation. We have your forward type of rotation.

23
00:04:56,470 --> 00:05:09,950
And we have talked about in this video the last. Rotation, right condition the rotation for right left condition, the time complexity of this operation is logoff in and the space complexity is logoff in as well.


@@@
1
00:00:01,450 --> 00:00:19,630
Hey, you are awesome guys. Welcome back to this video in this video. We're going to talk about the military operation. This matter takes a parameter value as input and it will delete the note of the given value from a military.

2
00:00:20,560 --> 00:00:35,320
For deleting a note from a realty, we might need to do a rotation, we might have to rotate the inventory if it a particular note, the balance factor may be changed.

3
00:00:35,560 --> 00:00:54,190
And that's up to the rotation uprooting a.. If we see the balance factor is valid, then we have to do a rotation for duetting. A. From April three, we might have full condition, lepley condition, Labourite condition, retrade condition and right condition.

4
00:00:54,760 --> 00:01:13,150
We have to rotate the avil three if we find it in appropriate balance vector for the node. If we find out appropriate balance vector for every single node after a node, then we have to do no rotation.

5
00:01:13,570 --> 00:01:34,380
We don't have to worry about rotation. OK, now let's see how to delete it. Node from a real tree and you'll see this full condition. First, let's talk about roleplayed condition for what condition the level of current not is causing this balance.

6
00:01:34,390 --> 00:01:51,880
In that case, we'll do a right rotation. Let's say we're given this Aviel tree and we want to delete this node five. It would lead it this, not five. Then we'll get this tree and the balance vector of this node one is zero.

7
00:01:51,880 --> 00:02:07,870
The balance of this node two is zero minus minus one one. The balance of this node one minus minus one, and that is two. So this is our current node, the let let node that is this not is causing the problem.

8
00:02:07,870 --> 00:02:22,850
So to do right rotation. If we do right rotation then to be our the root of the tree. So if we write rotate then we'll get this tree. And this is a valid every tree and this is called flipflopped slipped condition.

9
00:02:23,110 --> 00:02:34,210
Now let's talk about left right condition for Libbrecht condition. The treatment of current node is causing this violence, in that case up to the first rotation and right tradition.

10
00:02:34,780 --> 00:02:50,080
Let's say we're giving this Aviel tree and we want to delete this node five, delete this node five. Then our tumor represented something like this and the balance of this node three zero, the balance of this node two is minus one.

11
00:02:50,320 --> 00:03:00,940
And the balance of this, not four is one minus minus one. That is two. So this is your current node, the left or right node is three. This note is creating the problem.

12
00:03:01,120 --> 00:03:17,140
So first we hear a little rotation. If we do let rotation, then the tumor represented something like this and then we have to do right rotation. If we do right rotation, then three will be the root of rotated the tree separately, right rotation.

13
00:03:17,140 --> 00:03:30,040
Then we'll get this tree. And this is a valid Aviel tree and this is called Left-to-right Condition. We have understood what is the right condition. Now let's talk about the right right condition for right.

14
00:03:30,040 --> 00:03:43,900
Right condition. Right, right. Node of current node is causing this balance. Let's say we're giving this tree and we want to delete this node a tree. If it is not a tree, then we will get this tree.

15
00:03:44,080 --> 00:03:53,050
Now, let's find the balance factor balance between this node six is zero. The balance of this, not the balance factor of this node five is minus one, minus zero.

16
00:03:53,050 --> 00:04:04,960
That is minus one. There is no level that we have minus one for laboratory. The balance factor for this, not four, is minus one, minus one. So the balance of this not for is two.

17
00:04:05,230 --> 00:04:14,950
So this is our current, not the right right node. This is the right right note. And this note is causing the problem. So let's do here a little rotation.

18
00:04:14,950 --> 00:04:31,370
If we do rotation, then we will get this tree. And this is a valid will tree and this is right, right condition. We have understood what is the right word condition because the right treatment of current node is causing this violence.

19
00:04:31,780 --> 00:04:41,080
Now, let's talk about right left condition for right, left condition, right, left. Note of current. What is causing this violence in that case? First up, the right tradition.

20
00:04:41,080 --> 00:04:54,310
Then you have to do the tradition. Let's say we're given this ability and we want to delete this, not a tree within it is not a tree. Then we get this tree and the balance factor of seven is zero.

21
00:04:54,940 --> 00:05:08,140
The balance factor of six is zero minus minus one or one. The balance factor of this, not four, is minus one, minus one, that is minus two. So that right let node is causing the problem.

22
00:05:08,320 --> 00:05:19,420
So let's do first the right rotation. If we do the right rotation, then the two will be represented. Something like this then have to do let rotation rotation then our.

23
00:05:19,630 --> 00:05:30,430
You will be represented something like this, and we say this is a valid deviltry, the balance is not for a balance, not seven and zero. The balance of six is zero as well.

24
00:05:30,940 --> 00:05:43,360
So we can say this is a valid deviltry and this is called a right left condition here. The right, not a partner, is creating the problem. In that case, you have to do right tradition and tradition.

25
00:05:43,690 --> 00:05:59,430
As you saw, they said the first condition we have to handle for duetting and not even find out the balance factor is a valid applicability, you know, and then we have to do a rotation and there is our base case.

26
00:05:59,680 --> 00:06:13,260
Now, let's see the pseudocode decisions for the court to solve this problem. We have this matter, does it not? It takes a parameter value. Then we're saying here, really got to do it and it takes root and value.

27
00:06:14,050 --> 00:06:29,140
This is our helper method here. We're taking you've only got to now, then we're returning now, if less then developed Carnot then we're calling it. Let's agree that is greater than develop Cardno right subtree.

28
00:06:29,320 --> 00:06:43,630
If we find out a node that we have to do it, then we will apply this code. And we've already talked about how to delete a node for a binary sastry and this is exactly similar to that.

29
00:06:44,180 --> 00:06:59,370
And this is exactly same as letting a node from binaries history. If Cardno has to child, then you apply this code, if current not has, only child will apply this code.

30
00:06:59,910 --> 00:07:17,640
If the current node has only right child, then will apply. This code in the current node is lipner then will say just not to now and will retain the current node and hear this code is for every specific words and is code for every tree.

31
00:07:17,670 --> 00:07:34,800
OK, first your first of calculating the balance vector for our current node, we find that balance vector is greater than one. Then you apply this. And here we have that condition and Libbrecht condition, EBC balance is less than minus one.

32
00:07:35,150 --> 00:07:46,130
Then we might have the right road condition, all right, left condition, OK? And we're just calculating the height. And at the end, we're returning the current node.

33
00:07:46,820 --> 00:08:03,530
Here we have this helper method Mynatt. This method will find it a minimum not to give up or to give entry. And this is for right tradition. This is what Magnetation and this is for calculation of a height of it, not for that condition.

34
00:08:04,220 --> 00:08:16,970
If we apply the cord to this tree and here we want to delete this node five, then our Tulba represents something like this first only. It is not. And then it will right to rotation.

35
00:08:17,000 --> 00:08:28,100
Then we'll get this ability. This is what led to that condition. Now let's see for Labourite condition, for electret condition. If you want to delay this node, then we get this tree.

36
00:08:28,910 --> 00:08:39,380
Then here you have to do a little rotation up there, doing little rotation right over here about doing little we have to do right rotation. Then we'll get this deviltry.

37
00:08:40,100 --> 00:08:52,130
And this is called Leichtfried condition. Now let's talk about right tred condition. If we giving this a will treat, if we want to delete this node three, if we delay this not three, then we get this tree.

38
00:08:52,580 --> 00:09:17,600
And here we have to do a little rotation here, maybe apply this code. OK, then we will get this a real tree. Now let's talk about right condition. If we're given this ability, if we want to delete this node three and it will this not a tree, we get this tree and here is the right rotation using this formula first right condition, then tradition up doing right and left.

39
00:09:17,870 --> 00:09:32,180
And we get this tree and will return this tree. And this is how this full condition works. If we want to see how this works, I will encourage you to go through the pseudocode.

40
00:09:32,870 --> 00:09:46,490
I'm not going to go through line by line of code. I would encourage you to try to write it everything on a piece of paper so it will be cleared here. This method only takes a logarithmic time complexity.

41
00:09:46,820 --> 00:10:00,650
So the time and space complexity for this node is big of log in. We have understood this very explanation, epiphany. Christian understanding is the explanation.


@@@
1
00:00:00,600 --> 00:00:11,750
Hey, what's up, guys? Welcome back to this video. In this video, we're going to talk about it into a real tree. Let's see if we can implement this method to enter a military.

2
00:00:12,390 --> 00:00:22,410
This is the method to enter a military hospital, takes the parameter inside your sitting route. Now, this route pointer is points to the route of our every entry.

3
00:00:23,070 --> 00:00:33,840
If we said it's through now, then it would be disconnected from this net. And then it all points to now now means nothing. Now here we see that there is nothing else pointing to this.

4
00:00:33,840 --> 00:00:42,720
Not quite. So Dymocks collector will removed this note from computer memory. Then you see there is nothing else pointing to this, not to enter this node seven.

5
00:00:42,990 --> 00:00:51,830
So this note will be removed by garbage collector. Then we see there is nothing else pointing to this, not one to this, not three to six and to this node eight.

6
00:00:51,990 --> 00:01:02,540
So this for not will be removed by garbage collector from memory. So let's remove them. Now we see that there is nothing is pointing to this node. There is nothing is pointing to this node nine.

7
00:01:03,060 --> 00:01:15,180
So this will be removed. The garbage collector. Then we see our entry level three has been deleted from computer memory. This is how do we enter every entry method works.

8
00:01:15,750 --> 00:01:27,630
We have to set a route to knowledge. We said to now the entirety will be deleted automatically by garbage collector. So we call this method. The entity will be deleted.

9
00:01:27,670 --> 00:01:40,350
We got a mix collector and the time and space complicity for this method is because of one and because of one. So this method works in constant time and constant space complexity.


@@@
1
00:00:00,870 --> 00:00:14,180
Hey, yo, what's up, guys? Welcome back to this video. In this video, we're going to talk about trying to structure what is tri. Tried it, a structure is typically used to store and sells things in space and time efficient way.

2
00:00:14,900 --> 00:00:29,740
If you're not in, try to distract your store non-reporting character. We'll talk about that in some time to worry about that. If not, stores link of next character and every note keep track into string.

3
00:00:30,530 --> 00:00:58,510
This is an example of provided a structure we have inserted here ABC, ABCL and Ilim in here. We have inserted these three things in this tried the structure and the try is represented, something like this, every single note in it to structure Sternau repeating character here we have to repeat in character here we see we have Evvy and Evvy, but we have here and be OK.

4
00:00:58,910 --> 00:01:22,240
So we're not repeating the character and everything adds to the next character. So here A and B. So here this note is Staats, the link of this next character B and here as well, this note contains the link of this character as well and every to keep track in the string.

5
00:01:22,280 --> 00:01:42,030
So here not showing the end up string. We'll talk about in details in this section of this course. Don't worry about that. In trying to structure, we can meet for standard operation, insert the prefix inserts and then delete operation using this interpolation all insert words in our try to structure using prefix.

6
00:01:42,450 --> 00:01:59,360
Alsi if a certain prefix exist in our it try that will search for a complete word and then we will delete a word from our trying to the structure and you'll see all the operations in this section of this course.

7
00:01:59,900 --> 00:02:08,480
Now let's see the application of trying to structure. Why should anyone try. There are thousands of applications I've tried to structure in real life.

8
00:02:09,050 --> 00:02:18,740
Now we're going to talk about two common uses, spelling checker uses it, tried it, a structure. This is an example of spelling checker see BRW in here.

9
00:02:18,740 --> 00:02:30,620
This is a mistake. Using it provided a structure we can fix. This means something like this. So spelling secret uses tried to structure Google uses, try for auto search suggestions.

10
00:02:31,520 --> 00:02:54,530
We will make use more advanced techniques. But the concept remains the same curacy. We entered Google SCA, and it gives us the suggestions and they're using try to structure Google, make use more advanced features, but the core principles remains the same.

11
00:02:55,070 --> 00:03:03,260
We've understood why you should learn tried a structure and what is it? Tried it a structure. Thanks for watching this video. I'll see you in the next video.


@@@
1
00:00:01,140 --> 00:00:13,740
Hey, you guys, welcome back to this video in this video. We're going to talk about how dry data structure is represented. This try a.. This not has to attribute child.

2
00:00:13,860 --> 00:00:32,790
And in the report, this child is a Hashmat. This is the truth. And we have Hashmat. This is a Hashmat decision, Hashmat. And this is in the courts. OK, we have to Pat Hashmat and end up words for is.

3
00:00:34,140 --> 00:00:49,530
Now let's see how TREIS represented. Let's say we want to insert these three strings, ABC, ABC and L in. If we insert these three strings into a tri data structure, then our data structure will be represented.

4
00:00:49,530 --> 00:01:08,480
Something like this ABC, ABC, then l m m. And this is our tri node. We have a hash Hashmat and we have a variable in the port. Now let's see how this tried to.

5
00:01:08,480 --> 00:01:25,760
The structure is represented in computer memory. That data structure is represented, something like this. The switch our root node here we have E and ill here we're storing character and trialed here restoring character as Key and TriNet as a value.

6
00:01:26,130 --> 00:01:39,930
So we have this so that we have here this character here and this point is points to this node and here this node contains B and here we see the value for B is pointing to this node.

7
00:01:40,560 --> 00:01:56,400
And here we see we have two key S.A.G. and developes is pointing to this note and develop this pointing to this, not by this node or indicating that the word into it C and that word into it is because here we have it.

8
00:01:56,400 --> 00:02:15,540
True A. false placement. This is not the end of the word. And here we have it in and here we have two. That means it is the last character. OK, and here we have this is the last character of B word and G is the last word since we have here.

9
00:02:15,540 --> 00:02:26,400
True. And the value of this for C and the G key, we have this do not. And what we have in the prodigals to do that means we have a complete word that's in it.

10
00:02:26,400 --> 00:02:38,990
CI a.. And here we have a complete word that indeed in this is how divided a structure is represented incompetently. And this is just a representation of Troy and this is how it's represented.

11
00:02:39,150 --> 00:02:50,460
What we have understood how to write it. A structure is represented here, all important things that we learned during the multiple. We have a B, but we are studying only one.

12
00:02:50,840 --> 00:03:09,860
We have V and here we are just storing only one B, OK, so A, B, C is a word, a b, G is a word and l m N is a word. What we have understood is the explanation, even if you understand it is really explanation.


@@@
1
00:00:00,720 --> 00:00:11,380
Hey, you guys all come back to this video in this video, we're going to implement this operation, insert this method, will insert word in it, right it a structure.

2
00:00:11,400 --> 00:00:27,980
Now, let's see how this method actually works. This is source code. This method takes on parameter word inside here, we're creating it pointier current that it points to a root node and then we're iterating the given word from left to right.

3
00:00:28,760 --> 00:00:44,720
Then we're getting your current character using this formula where the chart I and then we're creating a tri node and we're getting here currently. The challenge to set up our current character does not exist in our current node.

4
00:00:45,140 --> 00:01:02,870
Then this node will be evaluated. Now, if the node imploded now, then we will insert the current character to our current node and will also insert a new TriNet key as character and neutral node as a value.

5
00:01:03,200 --> 00:01:14,850
And that will change. Current pointed to the current node and then also at the end of this fall of ruleset character in the board to true. Now let's see how this actually works.

6
00:01:15,140 --> 00:01:27,410
Don't worry about it if you're not understanding. Initially we have this root node and here we're assigning this current pointed to this route node. So current and the root pointer is pointing to this note.

7
00:01:27,410 --> 00:01:43,280
And here we have nothing by default. We have in the prodigals defaults and we have this empty Hashmat, let's say we call this method with ABC in this string ABC, our current character is a now we're going to check.

8
00:01:43,280 --> 00:01:56,750
Does the current character exist in this? Hashmat, if we see it is not exist in this. Hashmat So current child would get it in Ridgen now. So currently that child would get it.

9
00:01:56,780 --> 00:02:07,010
It will be evaluated now. So we see that in regards to null. Now, what are we going to do to create a new node and we're going to insert the character and the unit?

10
00:02:07,920 --> 00:02:21,030
Right over here, so we have inserted here. And as we're going to insert this node, then in the next iteration we have this character B and here by default, we have faults here.

11
00:02:21,030 --> 00:02:33,220
We have by default faults. And our current point at all points to this blank node. Now, our current character is B, and we see B is not exist in this current node.

12
00:02:33,510 --> 00:02:43,770
So we're going to insert here B and a new node. So let's insert here new node and B, something like this. Now, this current pointer all points to this blank node.

13
00:02:44,220 --> 00:02:57,600
Now our current character is C, which is C is not exist in our current node. So let's insurgency and in node as well, something like this. And here we have very close default.

14
00:02:57,780 --> 00:03:08,850
Now let's move on to this note. And in the next iteration of this falloff, we're out of this string boundary. So we're going to set current and up or reconstitute.

15
00:03:09,030 --> 00:03:26,450
So we're going to change this whole structural decision. We can insert a word to a try to the structure. Now, if we call this method inside with ABC, insert this in or try to structure our current node, is this not OK?

16
00:03:26,550 --> 00:03:38,090
And this is root note, as will. Now, our current character is a we see is exist in our current node, so it will do nothing. Let's move on to the next decision next.

17
00:03:38,100 --> 00:03:52,760
Not. Now let's move current to this node. We see that our current character is beebees exist in this. Not so nothing new to be done here. Let's move into this node and our current code is it is not exist in this node.

18
00:03:52,770 --> 00:04:08,690
So let's insert the and a new node as well. So we have inserted here and not as well and our current and will move our current to this node. Then in the next generation of this wall of water out of this stream, boundaries all set calendared in the Oracle structure.

19
00:04:08,700 --> 00:04:22,010
So it will change this wall through to this means that we have to work ABC and ABC. That's a complete what we have here. Two words, ABC and ABC. These two are complete words we have in this created a structure.

20
00:04:22,620 --> 00:04:36,870
Now, let's call this method with in and your current note. We see our current character will is not exist in our Rubner. So let's insert here L and as well as neonate and let's move current to this note.

21
00:04:37,410 --> 00:04:52,380
And our current character is m is not exist in our current node. So let's insert here M and as a new node, something like this, then our next character is in and let me come to this node and their current character is here.

22
00:04:52,380 --> 00:05:06,360
In here is the end is not exist in this note. So let's add here in and as a new node, something like this, let's move on to next and then in the next iteration of this wonderful part of this screen boundary.

23
00:05:06,520 --> 00:05:19,170
So let's change this fall through to by this statement. So we have inserted here this audio in and this is a competent decision, how we can insert words into the structure.

24
00:05:19,170 --> 00:05:33,090
And this is how insert operation works. We have understood insert operations. This operation will take spig of in time complexity. And this operation also takes in space complexity where it is the length of the given string.

25
00:05:33,450 --> 00:05:41,190
We have understood this really explanation. If I have an issue understanding this explanation, let us know. Thanks for watching. I'll see you in the next video.


@@@
1
00:00:01,010 --> 00:00:11,780
Hey, you guys, welcome back to this video in this video. We're going to implement this method prefigures. This method takes one parameter. This method will return.

2
00:00:11,790 --> 00:00:22,970
True, if the prefix exist in that data structure, otherwise it will return false. Now, let's see how we can implement this method prefixes for sake of understanding.

3
00:00:22,970 --> 00:00:35,420
Let's say we're given this tried structure. This is our algorithm. This method takes on parameter prefix inside here we are creating a pointer current that will point to the root.

4
00:00:35,420 --> 00:00:52,180
Not been running it for of for I from zero to the length of a given prefix inside here or getting the current character from prefix. And then we're checking if the current character exists in our current node.

5
00:00:52,490 --> 00:01:18,200
If this node evaluated null, that means the current character does not exist in our criteria structure. So it will return false. If the current character is found in a the structure, then we will move our current pointer to that node if we get to the end of the prefix and if we see this condition they were related to will just run through.

6
00:01:18,950 --> 00:01:31,760
That means our prefix is exist if this written statement get executed. Now let's see how it works. Let's say we call this method prefix with a B first.

7
00:01:31,760 --> 00:02:04,460
Our current pointer will point to this root node and our current character is A we see is it just in this node. So no, it is not evaluated now. We will move current to the node, the notice this NOROC, so it will move our current pointer to this node right over here in the next iteration with the character B, we see the character BES exist in this node, this not point at all point to this node and we see that note is not null.

8
00:02:05,520 --> 00:02:16,550
So we will move current to the Northpoint, also all of current right over here and in the next iteration we're out of steam boundaries, so we're done.

9
00:02:16,830 --> 00:02:29,610
We saw that the string, Evvy, that means the prefix Avey is just, you know, I tried it a structure. So we'll just return it to see if we call this function prefigures.

10
00:02:29,880 --> 00:02:42,090
It will simply return. True. If we call this method with Elim, let's see how it works. Initially, current pointer will point to this node and our current character is ill.

11
00:02:42,750 --> 00:02:52,920
And here this node pointer all points to this node. Since the current creator exist in this node, then we will move. Current pointed to this, not a node, pointillist points to.

12
00:02:53,290 --> 00:03:10,140
So let's move here and here. We're going to check if the current character is exist. We see and exist. So nodal point right over here and in the next generation will move current to this, not in the next iteration or out of the stream boundary.

13
00:03:10,440 --> 00:03:36,440
So we had done this in connection is never a related fault for. This is. So we'll just return true for this story and we clearly see that Ilim prefix exist in the Stryder, the structure of if understood how this method actually works, this method will take off in time, complexity and constant space complexity of have understood this very explanation.

14
00:03:36,450 --> 00:03:45,450
If we're not understanding Alali anchors here to try to write out everything on a piece of paper and try it with different examples, then you will see how it works.


@@@
1
00:00:00,730 --> 00:00:15,310
Hey, what's up, guys? Welcome back to this video in this video. We're going to implement this method sers. This method takes a word as input, this method already into if the word exist in the trial data structure.

2
00:00:16,000 --> 00:00:25,780
Otherwise it will return false letter. We can implement this method sers for the sake of understanding. Let's assume erguven destroy the structure where we have these three words.

3
00:00:26,110 --> 00:00:40,780
AVC see, eliminate the method source. We will check for a complete word. We do not check for the prefix, it will check the complete word. If the complete word is just in the trial data structure, only then it will return true.

4
00:00:40,990 --> 00:00:53,830
Otherwise it will return false. And let's say the algorithm in pseudocode. This is your algorithm versus method. This method takes on parameter word in Sunday talk declaring a pointer current to the point where it would not.

5
00:00:54,070 --> 00:01:10,960
And then we're running low for AI from zero to the length of the given word. Then we're checking if the current or is it just in our current node, then this node pointer will point to the associated TriNet for our current character.

6
00:01:11,350 --> 00:01:35,440
If not is evaluated now, then will return false. If not, then all will move. Current pointed to the pointer node when we're done with this wall of oil, check if that value in your current node, when you're done with this Frolov will check into upward of our current node you we found in the bodies to return to if in all its faults, the only defaults.

7
00:01:36,130 --> 00:01:59,620
Let's see how this method works. That's say we call this function source with V first or is and current node is this root node. And we see here the characteristic just so node pointer will point to this node, not quantity is not null, then it will move current to this node where node pointer is points to.

8
00:02:00,190 --> 00:02:17,860
Then in the next iteration, our character is B and recipes exist in this node. So node pointer will point to this node and the signal is not null. So it will move current to this node, her or node pointer it points to.

9
00:02:18,150 --> 00:02:28,060
And then in the next iteration we're done with this word. Then what will do will return the value in the port for our current node and we say that that is false.

10
00:02:28,070 --> 00:02:43,240
So we will return false for this. OK, so this word is not exist in this tri data structure because it is the prefix of what ABC search method will compare for complete word.

11
00:02:43,810 --> 00:02:55,510
That's all it's written false. Now let's call this method with ABC. Let's see how it works. Current character is a and current pointer points to this node and we see this character.

12
00:02:55,540 --> 00:03:10,900
Is it just in this node? So all assigned node pointed to this node because this node is the associated node for this category. We see that it is not now, so it will move current to this node in the next iteration.

13
00:03:11,680 --> 00:03:26,320
We are going to move node pointed to this note and we see no reason not now to all move current pointer to this node. Hundred point response to then in the next generation will move or not pointed to the node.

14
00:03:26,830 --> 00:03:39,310
We said no, it is not now. So it will move current to this node and will return the value to. We see that this order is just in this prior the structure.

15
00:03:39,520 --> 00:03:52,890
So for this order will return. True, have understood how this method actually works. Now let's see one more function call if we call with Ilim and let's see how it works and what it will return.

16
00:03:53,200 --> 00:04:05,260
Our current character is ill current one responding to this node and we feel is it just so node pointedly points to this note. This note is not now. So we will move current to this node.

17
00:04:06,290 --> 00:04:28,570
And we see the next character is exist in this not so all point to this node there is not null to all current to this node. In the next generation, our character is in in his interest in this not so we'll move and move to this not and not is not known to all of current to this note.

18
00:04:29,110 --> 00:04:46,350
And in reading, whatever value we have for the world, that is true. So for this function, we return to. This is how this method works. Have understood how this method actually works, this method takes because of in time complexity and bigger of one space complexity.

19
00:04:47,170 --> 00:04:54,220
We've understood this very explanation, if you have an issue understanding this speedy explanation latest. Thanks for watching. I'll see you in another video.


@@@
1
00:00:00,720 --> 00:00:11,880
Here you are, two guys will come back to this video in this video. We're going to implement this method until it this method takes a word as input. If the word is exist in it, right.

2
00:00:11,880 --> 00:00:29,940
It is structure, then this method will remove the word from the tree data structure. If the word is a prefix of another word, then will just change the in the word for last character from true to false.

3
00:00:30,450 --> 00:00:42,940
Let's see how we can do that. Now let's see how we can implement this method for the sake of understanding. Let's assume we're given this tried in a structure where we have three words ABC, ABC, and eliminated.

4
00:00:42,940 --> 00:01:01,110
And this is the representation of divided a structure. Or we have these three words. This is our algorithm. This delete method takes on parameter word inside here or checking if the word is H-E in know we tried it a structure by calling the source method in the search method region two.

5
00:01:01,110 --> 00:01:09,210
That means the word. Is it just you know, I tried it a structure. Then I will call this method dealing with the root word and index the first character.

6
00:01:09,540 --> 00:01:26,300
This method, this method takes three parameter. Current is your current code, then word, then the index of our current character inside here are checking if the independent of our current node is false, then will return false.

7
00:01:26,670 --> 00:01:52,580
If not, we're going to say the end of word to false and we're going to return it. True, if the site of our current node is a zero, that means if we have no element in our current node, we're setting this in word to false because the word given maybe the prefix of another word that we're setting the value of in the word of our current node to false.

8
00:01:53,130 --> 00:02:05,730
This is our base. It's OK. This is your current word. And here you are checking if the current word is it just in our current node, then this node will return to try node.

9
00:02:06,030 --> 00:02:18,060
If the node return now, then will just return false here. We're calling this function delete recursively with the current node, with the word and with our next character.

10
00:02:18,570 --> 00:02:37,590
And if we find it should delete current dot equals to two, then we will remove the character from our current node and will return to if the CitiPower current word is zero and at the end here will return false and this will be done recursively.

11
00:02:38,130 --> 00:02:50,520
This is going to be a little bit critical. Now let's see how this actually works. If we call this method delete with Ilim and in it we call this method with El-Amine.

12
00:02:50,910 --> 00:03:02,700
First it check if element is existing or try to restructure as a competent will take that using this source method and we see that this is is exist in our tried it a structure.

13
00:03:02,700 --> 00:03:18,780
So it will return. True. Then we'll call this delete method with the first character. The first character is L this year. Biscuit index is not equal to Waterland initially and the current character is ill and we see Elisi exist in our root note.

14
00:03:18,930 --> 00:03:39,450
This is your current node and we see that the current character Eliz exist in our current node. So this node will not return null. Then we're calling this function recursively again with node and the node pointer will point to this node by this statement and then we'll call with this node with the index.

15
00:03:39,450 --> 00:03:50,520
Up next character. That means the character M in the next recursive function call. This is our current node. So this is our current node for the next recursive function call.

16
00:03:51,330 --> 00:04:06,450
And it is your current character image or current character. And does the image exist in this not so node pointer will point to this node and will call recursively with this node.

17
00:04:06,840 --> 00:04:21,540
So current pointer will point to this node and our current character is in and we see in. Is it just in this not so node point, it will move to this node, so not point at all.

18
00:04:21,660 --> 00:04:34,140
Move to we see the current character in is it just in this node. So we will assign node pointed to this node. We see node is not null, so will call recursively again.

19
00:04:34,350 --> 00:04:49,320
So current and node pointer will point to the same node. Now if we call for this recursive call, the index is a tree and the length of this or this tree as well now are going to do.

20
00:04:49,350 --> 00:04:57,960
We're going to check the endpoint of this node. That is true. So it will be evaluated false. Then we're going to determine to set this through default.

21
00:04:58,890 --> 00:05:16,800
So we're going to say. Is true to false, and we're going to return to the site of this Noticiero and that Ejiro, so it will return to its current point at all points to this not and not all points to this, not for the previous recursive function.

22
00:05:16,800 --> 00:05:29,220
Call this recursive function. Call for this not all written since it's written through by this written statement, we will remove the current character that is in.

23
00:05:29,670 --> 00:05:39,840
We're going to remove this current character from this note. So we will remove it from this note and this note will be removed as well since there is no reference.

24
00:05:39,990 --> 00:05:50,490
So we have removed the key. We have removed that key. So the value will be removed as well. Then our current pointer will point to this node and not point at all.

25
00:05:50,490 --> 00:06:05,190
Point to this note, then a current pointer points to this note and not point at all. Points to this node will return to the previous recursive call. If the site of our current node is zero, that it will return true to the previous function.

26
00:06:05,190 --> 00:06:15,500
Call this value again invalided true for the previous recursive function call in this case or we're going to do we're going to remove our current criterium.

27
00:06:16,110 --> 00:06:26,370
So alderwoman, this character in from this node, so this node will be removed as well, since you have removed the key and will return to the previous recursive function.

28
00:06:26,370 --> 00:06:41,270
Call it developer current node. If the CitiPower current note is zero, we see the sidebar not Ejiro. So can point will point to this node and not will point to this node in the previous recursive function called Allegiant to using this statement.

29
00:06:41,580 --> 00:06:55,800
So this statement is still true. So what I will do, it will remove it from this node and we will move node to this NOROC from here. We're going to remove our current character ill from this note.

30
00:06:56,250 --> 00:07:05,270
So this note will be removed as well, since you are going to remove the key and then we're going to return false because the sidebar node is not zero.

31
00:07:05,640 --> 00:07:22,110
Now we're done. So we have deleted Ilim in a word from tried it a structure decision. We can delete a word, maybe call this delete method with ABC and we see that the ABC word, is it just industry restructure and ABC is a complete word.

32
00:07:22,320 --> 00:07:36,900
So we will call it the root node and with the word and with the index, with the current gater, a user base case. And we see our current characteristic just so it will move node to this node.

33
00:07:37,260 --> 00:07:53,020
And here we see no reason pointing to a Knowland. So it is not recursively. So current pointer will point to this node and not all point to this node, since node is not pointing to a will call recursively with concreter.

34
00:07:53,520 --> 00:08:04,170
Now here B is our current character. Now in the next recursive function, consider current connector. So Current will move to this node and will move to this node.

35
00:08:04,890 --> 00:08:17,250
Then we're going to call with this note recursively. We call it kind of the rule point to this note. In this term, autopsying boundaries. The side of the string is a tree and the index is three Azrael.

36
00:08:17,790 --> 00:08:32,090
So it's mass. This base case here is the index equals to waterland and we see tripto. So it will not return false. And we're going to sit this through the false and we see the side of this knowledge whole region through to this recursive function call.

37
00:08:32,580 --> 00:08:44,790
So current will point to the previous node and we see that this statement is evaluated. True. So what we will do, it will remove our current greater see current character or going to remove from this provided a structure.

38
00:08:44,980 --> 00:08:56,580
So let's see, since you have removed the key so the valot will be removed Valli's this node and count will move to this not for the previous recursive call.

39
00:08:57,210 --> 00:09:06,570
And the site is not zero of this current content, so it will reinforce false statement will be evaluated fault. So it will just return to by the statement.

40
00:09:07,200 --> 00:09:19,680
So kind is pointing to this note and responding to this node and we see that our current character is B for the previous recursive call. We have a state for each recursive function call.

41
00:09:19,680 --> 00:09:32,580
We decided we can access our current grade since it's returned false by this function. Call again are going to return false. So kind will point to this, not nodal point to this node.

42
00:09:32,850 --> 00:09:43,890
There is nothing to be done here because you receive a B is the prefix of this word ABC. So we can't remove the current character. And here we see the side of this note is not zero.

43
00:09:43,890 --> 00:09:55,830
So already false. This is again it will default for the previous recursive function. Call bitrate and false and say that our current pointer is pointing to the root note and return.

44
00:09:56,130 --> 00:10:09,950
We have deleted the word ABC, etc.. We can. A little word from try to structure direct mail that will take big in time complexity and big in space complexity with the recursion called Stack, we've understood this very explanation.


@@@
1
00:00:00,390 --> 00:00:11,970
Hey, what's up, guys? Welcome back to this video. In this video, we're going to talk about linnear search algorithm. Linus's algorithm is it was to find an element within iList.

2
00:00:12,690 --> 00:00:32,510
It sequentially check is element of the list until enmasse is found or the whole list has been searched. For example, if you were given this list of integer, this is an area that represents an element in this area.

3
00:00:32,670 --> 00:00:52,830
Let's say we want to search the element for DeBois. If we use linear search algorithm to solve this element for in this area, then we have to check the element from left to right sequentially, one by one, first to the one, then three, then eight, then seven, then nine.

4
00:00:53,130 --> 00:01:13,380
Then we'll have our desired element time. Complexity for linear search algorithm is big off end and space complexity is bigger one. So linear search algorithm works in linear time complexity and in constant space complexity.

5
00:01:13,980 --> 00:01:27,000
Now let's say we're given this array and we have a target equal to four. We have to find out the element four in this area using linear algorithm. If we apply here, linear search algorithm.

6
00:01:27,210 --> 00:01:37,260
First, we'll check the target value for with the first element we see for is not close to two. So let's go to the next. We see one is not to go to four.

7
00:01:37,560 --> 00:01:45,600
Now, let's go to the next element. Three is going to go to four. Let's go to the next element. Four is in regards to eight. Now let's go to the next element.

8
00:01:45,600 --> 00:02:02,040
So it is going to go to four. Now let's go to the next element. Four is not equal to nine. Then let's go to that next element for is equal to four. So we find out our desired element at index six.

9
00:02:02,400 --> 00:02:13,860
And this is a linear search algorithm. Works it check sequentially from left to right, one by one, first two, then one, then three, then eight and seven.

10
00:02:14,160 --> 00:02:30,150
The nine, then four. And linear search algorithm works for sorted and unsorted error. Now let's see the pseudocode for linear search algorithm. This is our pseudocode for linear search algorithm.

11
00:02:30,960 --> 00:02:42,390
This method takes two parameter array and the target element. Here we have a loop for I from zero to the length of the array here in the arrow from left to right.

12
00:02:42,840 --> 00:02:56,400
And here we're checking if the current element equals the target in all region. The index of current element. If the target element does not exist in the array, then will return minus one.

13
00:02:57,000 --> 00:03:11,100
If we're given this area and target equals to six, then if we apply this algorithm first we'll check six to two is not equal to six, then six and one on is not equal to six.

14
00:03:11,280 --> 00:03:24,930
Then three and six, three to six, then eight. Eight is going to go to six. So it is going to go to six, nine, six. Four is in regards to six. So finally we find it 666 six at the index seven.

15
00:03:25,770 --> 00:03:39,690
This is how this linear search algorithm works. This algorithm takes linear time, complexity and constant Spetz complexity. This is super simple algorithm in this algorithm.

16
00:03:39,960 --> 00:03:52,190
We have to scan the given area from left to right. We have understood this explanation, if you have any question. But if you have an issue understanding this with the explanation, let us know.


@@@
1
00:00:00,780 --> 00:00:16,430
Hey, what's up, guys? Welcome back to this video in this video. We're going to talk about Britney Dessert's algorithm. Resource is an efficient algorithm for finding an element from a sorted list of items.

2
00:00:17,080 --> 00:00:32,860
It works by repeatedly dividing in half the portion of the list that could contain the item until we have narrowed down the possible location. This is the formal definition of binary source algorithm.

3
00:00:33,400 --> 00:00:50,350
For example, if you're given this array and you have to find out an element in this area using binary source algorithm, binary search algorithm works in logarithmic time complexity and in constant space complexity.

4
00:00:50,530 --> 00:01:06,430
Binary search algorithm works in logarithmic time complexity and in constant space complexity. Now let's see how binary search algorithm works. Let's say you were given this array and your target value target equals to seven.

5
00:01:06,820 --> 00:01:17,950
First, what are you going to do? We're going to declare two pointer left and right. Left pointer will point to the first element, the right point. It will point to the last element.

6
00:01:18,160 --> 00:01:36,130
So left point to this element one and right is pointing to this element eight. Now let's calculate middle. We can calculate midle by adding the index of left and the right pointer and then we'll divide the summation of left and right pointer by two.

7
00:01:36,280 --> 00:01:52,270
So zero plus seven divided to go to a three. So four is our middle. Now what are we going to do? We're going to take the value seven with this value. If we say target is greater than four, then will move left to that next element.

8
00:01:52,480 --> 00:02:05,070
If we see target is less than middle, then all move right to the left of middle. Here we see that seven is greater than force that will move left to the next of middle.

9
00:02:05,260 --> 00:02:16,840
So left will point to this element five. Now let's calculate the middle four plus seven. Divided to support plus seven equals to level 11, divided to five.

10
00:02:16,960 --> 00:02:32,290
So six is all middle. We see seven is not equal to six and we see seven is greater than six. So let's move to the next of middle. So let's move left to the next of the middle.

11
00:02:32,290 --> 00:02:45,070
So left will point to this element seven. Now let's calculate middle seven plus six divided to six. So middle is this element seven. Now we see that middle equals the target.

12
00:02:45,310 --> 00:02:56,770
So we find it the desired element in this area. So already in the index of this element seven, there is six. And this is now one of this year's algorithm works.

13
00:02:57,460 --> 00:03:15,370
But it is our algorithm works only for sorted area. You do not work for unsorted error in this algorithm will divide our given error into two 1/2 in each step and you'll see how it works or you go through pseudocode.

14
00:03:16,000 --> 00:03:30,610
Vandalisms algorithm is similar to starting a value in binary thirsty. Let's see how. First, we're going to construct one history data structure from this sorted array.

15
00:03:31,390 --> 00:03:57,180
First four four is our root note. On the left we have two on the left up to we have one. Then on the right of two, we have three men here, the right of four is six, the left of six is five and the right of six is seven and the right of seven is eight.

16
00:03:58,350 --> 00:04:10,890
Now, let's do you want to search that target? Seven, then all we can do first and compare developed with this route, we see that target is greater than so it will go to the right.

17
00:04:11,730 --> 00:04:22,470
So it will move to the right subtree. Harry S. six is not equal to seven and six is less than seven. So let's go to the right subtree. Here is seven equals to seven.

18
00:04:23,070 --> 00:04:37,920
So will rejoin the index of this element or will reading through four binaries are straight? OK, we can dujon the index for every disaster you can read into and this is how it works.

19
00:04:38,100 --> 00:04:51,300
And this is exactly similar to a disaster. And this is exactly the reverse algorithm, exactly similar to something you value in a binary circuitry. And this is how it works.

20
00:04:51,330 --> 00:05:05,360
Let's see it. We want to search a value three in this area now. Let's see how it works here. We've constructed by necessity from this area. First, we're going to compare this with the root tree is not equal to four.

21
00:05:05,460 --> 00:05:16,350
So let's go to the left here. We see that two is not equal to three and two is less than three. So let's go to the right. And here we see two, you three.

22
00:05:16,350 --> 00:05:31,410
So it will return true for this area, will return the index. This is how the algorithm works. Understood how bad it is. Algorithm relates to. But it is Erste data structure when it starts evaluating binaries.

23
00:05:32,310 --> 00:05:43,660
Now let's see the pseudocode. This is the pseudocode. For one, it is Erste. This method takes two parameter arianda target here or declaring two pointer left and the right little point.

24
00:05:43,690 --> 00:05:58,580
The first even try to point to the last bullet. We have your right, left, right, left to right. We are calculating here middle and here we can use here we can use different formula to avoid overflow.

25
00:05:59,220 --> 00:06:17,700
Then here we have. If Hamid equals to target, if we find out the middle element to go to target an region, the index of belittlement else will compare if target is greater than the middle element that will both left pointed to the next of middle element.

26
00:06:18,060 --> 00:06:35,470
If not, we will move right pointer to the left of middle element. If the target value does not exist in the array, that will return minus one. For example, the two are given this array and try to to six here.

27
00:06:35,480 --> 00:06:48,450
We have to point out left and right liberal point of this element and point to this element. Now let's find it middle. This is our middle. We see six is not equal to four and six is greater than force.

28
00:06:48,450 --> 00:06:58,530
It will move left to this. So it will move to this element. And the middle is this element. Here you see the middle element equals to the target element.

29
00:06:58,980 --> 00:07:10,220
So we find out our desired movement in this area. And this is how this binary source algorithm works. This algorithm takes a logarithmic time complexity.

30
00:07:10,410 --> 00:07:24,630
Now let's find out the time complexity of this algorithm. Initially, the length of our areas and the marginal and that's equal to in the first iteration length holds true in divided to for second iteration.

31
00:07:24,930 --> 00:07:38,850
Linda goes to integrate, to divide, to arbitrary duration. Linda goes to the the three after iteration. Lente goes to integrate to the board k. So here we find a pattern here for consideration.

32
00:07:38,850 --> 00:07:53,040
Lenticular to is devoted to the work. We're dividing the array into two halves. It is a step so up to division length of the three will be one so we can sit in divided to the working class to one.

33
00:07:53,250 --> 00:08:07,200
So and he goes to the basket. Then if we take log here, this to log, then we get log any to log two to the power and here we get log in regards to K and then she goes to log in.

34
00:08:08,130 --> 00:08:21,720
This is to base log. So the time complexity is big of log in and that space complexity is big of one since we're using tunable left, right and middle.

35
00:08:22,350 --> 00:08:37,200
Haviv understood binary source algorithm and the time complexity of resource algorithm is an issue. Understanding this video explanation or if you have any suggestion, let us know.


@@@
1
00:00:00,510 --> 00:00:14,460
In this video, we're going to talk about Ababil search algorithm, Batbold sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they're in wrong order.

2
00:00:14,700 --> 00:00:24,830
Let's take an example to understand. Babul taught, for example, the job was that you were given. These integers are right. You have to sort this array first or what are you going to do?

3
00:00:25,140 --> 00:00:38,520
What are going to take first to adjacent? And these are the adjacent. And here you see eight is greater than two in the in the left element is greater than the right.

4
00:00:38,730 --> 00:00:53,930
We're going to swap them. We see left element is less than eight, so it will not swap. Now let's take the next pair and this is the next pair. And here we see eight is greater than five.

5
00:00:54,120 --> 00:01:11,070
So we're going to swap this tournament eight all move to this index and five will move to this index. Now, let's compare this to pairs. In these two pairs, we see that the left element is greater than the right.

6
00:01:11,190 --> 00:01:35,680
So we're going to swap them. So it is 12 eight all move here and one will move here. Now, let's compare this pair. In this spirit, we see that the lift is greater than the right, so we're going to swap them Epistrophy to move to this index, four and six will move to this index three.

7
00:01:36,180 --> 00:01:50,720
Now, we're going to compare the next year and this is the next pier. And in this pier, we see that live element is greater than the right. So we're going to move age to this index, five and three to the index four.

8
00:01:51,480 --> 00:02:06,000
So let's move three to this index four right here. You should have eight. We get this array up to the first iteration. We bubbled up the largest element to the right.

9
00:02:06,480 --> 00:02:22,910
So our right part is no solid. Now we're going to buy one of the largest ilmenite in this unsorted part in the unsorted subarea, we're going to buy one of the largest element to the right.

10
00:02:23,240 --> 00:02:34,970
So let's compare this to bear. We see two is less than five. So so not need to be done here in the next bear is this. We see that five is greater than one to let's swap them.

11
00:02:35,930 --> 00:02:49,000
One will move here and five will move here. Now let's compare this to Bear. And here we see that five is less than six. So we're not in it to be done here.

12
00:02:49,610 --> 00:03:09,320
Then the next bear is six and four and we see that six is greater than four. So we're going to swap them. So Episode four will move to this index three and and six will move to this index for up to the second part.

13
00:03:09,590 --> 00:03:24,640
We get this array and the right part is sorted and the left part is unsorted in the unsorted part are going to bubble up the largest element to the right to left, but one of the largest element in the unsorted part to the right.

14
00:03:24,890 --> 00:03:37,370
So first, we'll compare this to a pair. We see two is greater than one. So one will move here and two will move here. Now, let's compare this bear. And in this pair we see that two is less than five.

15
00:03:37,790 --> 00:03:53,630
Nothing need to be done here. Then this two pair, we see that five is greater than four, so we have to swap them. Ebisu of four will move here and five will move to this index, three after the third.

16
00:03:54,050 --> 00:04:12,260
But we see that the right part is sorted right and the left part is unsorted array. Now we're going to bubble of the largest element in the unsorted part to the end of this unsorted list will compare this to.

17
00:04:12,710 --> 00:04:24,800
And we see that they're encouraged to order in this, to see that they're encouraged to order. So nothing need to be done here. So after this pattern, we see the left parties unsorted.

18
00:04:24,800 --> 00:04:35,780
And in the unsorted part, let's bubble of the largest element to the right. Let's compare this to and we see that two is already bubbled up. This right part is sorted.

19
00:04:35,780 --> 00:04:46,790
Left part is unsorted. We see that on the left we have only one element. So nothing need to be done here. And this is the sorted area, OK? And this is how it works.

20
00:04:47,090 --> 00:05:00,850
The concept is that we will be able of the largest element to the end for our unsorted list, and this is how it works. Now let's see how we can implement this concept using pseudocode.

21
00:05:00,890 --> 00:05:13,910
This is the pseudocode for us to have this function, but we'll sort that takes the numbers around then in equals to the length of this array. This is the length and then we're running a loop from it in minus two.

22
00:05:13,910 --> 00:05:29,510
So this loop will run from the index zero to the index for. OK, we do need to compare for this element on the right of this element. We have no element and then we have this flag to optimize this algorithm in the given areas already sorted.

23
00:05:29,510 --> 00:05:51,710
Then this love will not run. OK, and then we have here this fall from for the year, from the year two and minus eight, minus two. And then we're going to compare it to the first element that wins in the left element in the left element is greater than the right will swap them using this formula that is already sorted, then this value will never be changed.

24
00:05:51,860 --> 00:06:01,200
They're doing this for all of you will find Flagel to false statement that is already sorted. We don't have to compare anymore to we can just stop. We have a break now.

25
00:06:01,250 --> 00:06:09,860
Let me show you how it works one more time. So this time we're going to have we have two and eight. Let's compare them. And eight is greater than two.

26
00:06:09,860 --> 00:06:28,160
That OK then for this year it will move here, five will move here. And then for next year we see a two move here and one will move here. Then for next comparison for this to element, it will move here and six will move here.

27
00:06:28,400 --> 00:06:38,720
And the next comparison we see that it will move here and three will move here by this algorithm. You can go through this algorithm to see how it works now after the first.

28
00:06:38,870 --> 00:06:48,890
But we see that the right word is so that the left part is unsorted. Now, let's have the largest event on the unsorted part to the to this unsorted part.

29
00:06:49,160 --> 00:07:02,840
So here are going to take this to the correct order. Then this one five will move here and one will move here. And then for this check, we see that they're in correct order for this pair.

30
00:07:02,840 --> 00:07:18,290
We see six to move here and three will move here. So now we see that this part is. The right body, sorry, the left part is unsorted. Let's bubble up the largest to the end of this unsorted part.

31
00:07:18,300 --> 00:07:38,640
So two is greater than one. So let's swap them to move here and one will move here. Then for this to we they they're encouraged to order, then these two three will move here and five will move to this index, three at this point.

32
00:07:38,670 --> 00:07:58,380
We see that the right part is sorted and the left part is already sorted. It will do all the comparisons. Then we see the error will be sorted, something like this and decision about what works and the time complexity of Babille search algorithm is bigger and square and the space complexity is bigger of one.

33
00:07:58,380 --> 00:08:12,750
That means it works in constant space complexity. When you consider space complexity, then we can you battletoads algorithm and for the best it will take off in space complexity if the area is already sorted.

34
00:08:13,080 --> 00:08:25,860
Now let me show you the time complexity. Analyse it in detail. All right. We have to calculate the time, complexity, time, complexity for this function.

35
00:08:25,880 --> 00:08:40,880
OK, here, the length it will be calculated in constant time. Complexity then is slope takes because in time complexity actually takes off in its own time, complexity and is the length of the array.

36
00:08:40,890 --> 00:09:05,590
It will start from zero two in. So it'll take off in minus one time complexity and that's equivalent to be in and here. This will takes constant time, complexity, and this all takes for the worst case because of in minus one time complexity that's equivalent to B go in and this all will takes constant space complexity to analyse this time complexity.

37
00:09:05,620 --> 00:09:14,090
We're going to take this array as an example, the length of this array six for the first iteration of this out of love. We have here the value equal to zero.

38
00:09:14,400 --> 00:09:34,440
This love will execute five times. So the execution is five four equal to one. This will execute four times in the execution for I got to do this loof but will execute three times for equals to three, will execute two times for equals to four.

39
00:09:34,950 --> 00:09:47,310
Will execute, will execute one times. And here we have the execution, here we see a pattern and the length of this area is six. So we see a pattern. Is that in minus one.

40
00:09:47,490 --> 00:10:00,350
So it means one for this arrays. Six minus one. There is five in Minnesota, four and minus three, minus three, three and so on and so forth. And at the same point all have one.

41
00:10:00,390 --> 00:10:16,920
OK, something like this at the end, the last execution will be evaluated one so we can write it this execution as equations, something like this. And if we solve this equation, then we get then we get this equation in times in minus one, divided two.

42
00:10:16,920 --> 00:10:33,240
And if we do this equation, then you get in squared minus and divided two. And the degree of this equation is one square. So the time complexity is bigger and square and the space complexity for the solution is bigger of one that it works in constant space complexity.

43
00:10:33,240 --> 00:11:09,720
Since you are not using an original split decision, how we can analyze each time complexity of algorithm. This is a babble search algorithm. This is pretty easy algorithm to implement and this is the way to find out the time, complexity of algorithm, what we have understood, the algorithm and the runtime and lay siege A. break it down this constant time and linear time complexity here for each line to make you understand every single detail, I think you have a clear understanding of time, complexity.


@@@
1
00:00:00,480 --> 00:00:21,470
Hey, what's up, guys, in this video, we're going to talk about selection, sort algorithm selection sort algorithm is an invalid comparison based algorithm in which the list is divided into two parts, the solid part at the left end and the unsorted part at the right end.

2
00:00:22,170 --> 00:00:36,240
Initially, the sorted part is empty and the unsorted part is the entire list. This is selection sort algorithm. Now let's see how selection sort algorithm works for that.

3
00:00:36,250 --> 00:00:49,980
Let's take an example. Let's suppose that we're given this area. We have to sort this array using selection sought for selection algorithm. We have two parts left port and right part.

4
00:00:50,280 --> 00:01:05,010
The left part is sorted and the right part is unsorted. First, our sorted part is empty. That means our left part is empty and the right part is your entire list.

5
00:01:05,580 --> 00:01:17,430
On the unsorted part, that means on the right part, we're going to find out the minimum element. And in this so on the right part, the minimum element is to.

6
00:01:18,950 --> 00:01:40,940
Now, what are you going to do, what are going to solve this? Valetta with nine? With the first index, OK, this is the first index, and here we are, 12, then nine will move to this index, four and two will move to this index zero.

7
00:01:41,360 --> 00:01:58,080
Now, our sordid part is this part now living part is sorted. Right. Part is unsorted. OK, in the unsorted part, let's find out the minimum element and the minimum element on the right part is five.

8
00:01:58,690 --> 00:02:11,320
Now, what are you going to do? We're going to solve this five with the first value in the unsorted part or with the first element in the unsorted part.

9
00:02:11,600 --> 00:02:30,310
So five will move to this index, one and six will move to this index three. Now, our sorted part is this part. So this part is now sorted. Now let's find out the minimum in the unsorted part.

10
00:02:30,610 --> 00:02:44,200
The minimum in the unsorted part is six. So we're going to solve this six with the first element in the unsorted part, and that is seven to let's watch them six or move to this index.

11
00:02:44,200 --> 00:02:57,940
Two and seven will move to this index three. So now our sorted part is the left part. And here on the left, part two, five six is not sorted now on the right.

12
00:02:57,940 --> 00:03:10,580
But let's find out the minimum element, and that is seven and seven in its right position. Nothing to be done here. So here now, the left part is not sorted.

13
00:03:11,080 --> 00:03:25,540
Now we're going to find out the minimum in the unsorted part and the minimum in the unsorted part is eight. So we're going to move eight to this index four and we're going to move nine to this index five.

14
00:03:26,260 --> 00:03:41,460
Now, this load part is now sorted and the right part is unsorted since we have on the right only one element. So it's already sorted. Now we see that entire area is now sorted to five, six, seven, eight, nine.

15
00:03:41,980 --> 00:03:54,000
And this is how selection sort of works. Now let's see how we can implement selection, sort using pseudocode. This is the algorithm for selection, sort for us to have function selection sorted.

16
00:03:54,010 --> 00:04:08,350
That takes an array as input, then calculating the length and then we're running a follow for ie from zero to a minus two. We have this main index equals to eight.

17
00:04:08,380 --> 00:04:31,170
OK. Initially the first index is the minimum index and then we're running this for J from our plus one to in minus one. Then we're going to check if nums is less than nums minimum indexed and we're going to change the minimum index to that, to the current index for this follow.

18
00:04:31,750 --> 00:04:45,150
And then we're just swapping the minimum element with the first element in the unsorted list. Now let me show you how it works one more time. So initially we have here nine, OK?

19
00:04:45,670 --> 00:04:57,790
And initially we have the sorted list, it empty and the minimum element in this sorted list is two. And we can find the minimum element using this area.

20
00:04:57,800 --> 00:05:11,320
OK, something like this, we are finding the minimum element using this follow and we found this minimum element here. There is two and we're going to solve this element in the first element in the unsorted list.

21
00:05:11,470 --> 00:05:24,610
So to move to this index and nine will move to this index four. So we swapped using this formula. Now our sorted list is this. So on the left we have sorted list and on the right we have entered the list.

22
00:05:24,950 --> 00:05:37,510
Now, the minimum element in the unsorted list is five. So the minimum index for the second iteration of this following is the index entry. Now we're going to swap this element in the first element in this and sorted list.

23
00:05:37,780 --> 00:05:50,380
And there is six. So five will move here and six will move here. Now, the sorted part is this two and five and the unsorted part is seven, six, nine, eight.

24
00:05:50,680 --> 00:06:05,230
Now, the minimum element in this unsorted part is six. OK, so we're going to swap six and seven. Six will move here and seven will move here. Now, the left, Sabra, is no solid on the right.

25
00:06:05,240 --> 00:06:15,790
Let's find out the minimum. The minimum is seven. It's already in the current position. So we have to do nothing here. And then here we have nine and eight.

26
00:06:15,790 --> 00:06:30,520
The minimum is eight to obtain the twelve. Eight will move to this index. Four and nine will move to this index. Eight. And then we'll move to this index five, OK?

27
00:06:30,960 --> 00:06:53,100
And we see that they're in very solid order and if we split right here and we see the left for the right part on the right one element. So that element in its current position, since you have only one element on the right, and the sooner we can solve this problem and this is the selection algorithm and this is how it works.

28
00:06:53,220 --> 00:07:06,630
Well, we have understood selection algorithms. Now let's do the time and space complexity. The time complexity for this algorithm is big and square and the space complexity for this algorithm is bigger of one.

29
00:07:06,630 --> 00:07:16,610
That means constant space complexity since are not using any additional space. Now let's see how we can find out the time complexity big up and square here.

30
00:07:16,620 --> 00:07:32,520
We break it down durations and here able to calculate the time complexity when you have the length of the given array is in. And here we have constant operations and we have some linear operation and these operational things, the government has one and that's equivalent to begin of in.

31
00:07:32,790 --> 00:07:49,710
You are iterating from Jeanetta in Minnesota and same thing here for our and this is linear time, OK? And all other operation takes constant time. Now how this works and for the the initial it it's five times.

32
00:07:49,710 --> 00:08:07,850
So execution is five four equal to one. They execute four times and so on and so forth and four equals. Before we get one here you see that five, four, three, two, one zero, something like this in one in minutes, two and three in minutes for a minus five.

33
00:08:08,010 --> 00:08:24,030
So we can write the equation something like this in minutes one plus and minus two plus and minus three when in is unknown or whatever. OK, and at some point we'll find out the execution one.

34
00:08:24,510 --> 00:08:36,340
And if we do, this formula from this one will get in times in and divided to and that's equivalent to in square one is in divided two and the degree of this equation is in square.

35
00:08:36,600 --> 00:08:45,930
So the time complexity is bigger off and square. The space complexity for the solution is bigger of one. The solution works in constant space complexity.

36
00:08:46,590 --> 00:08:59,670
So when we need the same split, then we can consider using selection's or algorithm. And this is all about this video. We have understood the time, complexity and the selection algorithm.


@@@
1
00:00:01,160 --> 00:00:22,580
Hey, yo, what's up, guys? Welcome back to this video in this video. We're going to talk about insertion sort algorithm. Insertion sort algorithm is an implicit comparison based algorithm in which the list is divided into two parts, the solid part at the left end and the unsorted part at the right end.

2
00:00:22,950 --> 00:00:42,240
Initially, the solid part is empty and the unsorted part is the enter list. For example, if you're given this unsorted array, webisode disarray using insertion initially the sordid part is empty and unsorted.

3
00:00:42,240 --> 00:00:52,260
Part is the entire list. So the left part is empty and the right part is the enter list will pick the first element from the unsorted, but in this case, four.

4
00:00:52,710 --> 00:01:07,760
And we will move this to this position. Now, the left part is sorted and the right part is unsorted. Since the insertion algorithm is an inference algorithm.

5
00:01:08,250 --> 00:01:22,830
So we will modify the given array. Now what are going to do? We're going to get this element to write the first element from the unsorted part and we'll insert it to the right position.

6
00:01:23,130 --> 00:01:35,010
Now we're going to compare two and four here. We see that four is greater than two. So we will swap them. If we solve them, two will move here and four will move here.

7
00:01:36,120 --> 00:01:52,500
Now we see that on the left up to we have no element now. We see that this left part is not sorted and the right part is unsorted, so let's pick this element five and let insert it to the right position.

8
00:01:52,650 --> 00:02:10,680
In the solid part, we see that five is greater than four. So nothing need to be done here. Now, the left is sorted, the right part is unsorted. And let's pick this element eight and let's put it in the right position to the sorted part.

9
00:02:11,010 --> 00:02:21,520
And we see that eight is greater than five. So nothing yet to be done here. Now we see that the left part is now sorted and the right part is unsorted from this.

10
00:02:21,540 --> 00:02:30,120
Right. But we're going to pick at this element six and we're going to insert it to the right position in the solid part, which is six is less than eight.

11
00:02:30,120 --> 00:02:43,200
So we will swap them. If it's of here, we get six and here we get eight. And let's compare the six and five, which is six is greater than five. So nothing need to be done here.

12
00:02:43,740 --> 00:02:56,010
So the left part is not sorted. Right part is unsorted. Let's pick this element nine. We see nine already in its correct position. Yeah. So now we see that the left part is solid, the right part is unsorted.

13
00:02:56,460 --> 00:03:07,410
Now what are you going to do? What are we going to compare this one and nine we see that one is less than nine. Will two of them be swap them. Nine will move here and one will move here.

14
00:03:07,530 --> 00:03:19,030
Now let's compare this to one and eight. We see one is less than eight. So let's watch them. If we stop them, eight will move to this index, five eight will move here and one will move here.

15
00:03:19,410 --> 00:03:30,810
Now, we're going to compare this to eliminate one and six. And we see that one is less than six. So let's stop them. If we swap them, one will move here and six will move here.

16
00:03:31,440 --> 00:03:44,540
Now, let's compare this to eliminate on and five on is less than five. So let's drop them. So one will move to this index, two and five will move to this index three.

17
00:03:44,550 --> 00:03:56,400
And again, we see that four is greater than one. Two, let's stop them. If it's twelve, one will move to this index. One four will move to this index. Two again.

18
00:03:56,400 --> 00:04:10,830
We see that one is less than two. So let's swap them. We get here two and here one. And on the left we have no element. So nothing to be done here. Now we're done.

19
00:04:11,160 --> 00:04:26,820
And now we see that this array is now sorted. Now the entire area is sorted and they switch how insertion of it will be the first element from the unsorted part and it will insert to the right position in the sorted part.

20
00:04:26,860 --> 00:04:38,740
And this is how insertion. So it works. So we have to return this array. Now, let's see the algorithm. Alright, this is the algorithm for insertion sought first to have this function insertion.

21
00:04:38,740 --> 00:04:53,800
So that takes the given numbers array. Then you're going to find out the length and then we're running a loop from there to minus one. Then we have ten variable temp all store the current element and the equal to I.

22
00:04:53,970 --> 00:05:13,570
Then we're going to check if these is greater than zero and the left element is greater than the temperament, then we'll change the current element with the liberty element when we're done with the loof will do this formula nums jagels to ten and then at the end you're going to return the numbers array.

23
00:05:13,740 --> 00:05:24,720
Now let's see how this actually works. First of understanding, let's assume we're giving this array for the first iteration of this for love. I will point to this element eight.

24
00:05:25,080 --> 00:05:36,420
They will point to this Element eight and temp will point to this Element eight. This condition inside this well off is false because there is not a greater than zero.

25
00:05:36,720 --> 00:05:53,460
There is the index of our current element. So this one will not run then the going to this element eight with this element eight. So we're done with the first iteration after the first iterations, the left for this sort of the right word is unsorted now.

26
00:05:53,460 --> 00:06:04,380
Temp is pointing to this element is six and is pointing to this element six at will. Now what are we going to do? We're going to check if is is greater than zero.

27
00:06:04,380 --> 00:06:16,500
Yes, this is greater than zero. And the left element is a greater than the temp. So what are you going to do? What are you going to replace this six with the left element and there is eight.

28
00:06:16,770 --> 00:06:32,640
The left element is eight now is pointing to this element eight and now the who I love will stop here since there is no pointing to zero. So we're going to solve with the value of temp at ten variable, we have the value six.

29
00:06:33,030 --> 00:06:51,130
So we will replace this eight with six. Now, what are you going to do now? We see that the liquid is sorted and the right part is on. Sorted. Now, our temp is pointing to this argument five, 10, because to five, and they will point to this element five.

30
00:06:51,520 --> 00:07:01,250
Now we're going to check if they're minus one. And that means this element eight is greater than five years. Eight is greater than five. So what are you going to do?

31
00:07:01,280 --> 00:07:17,990
We're going to replace five with eight. Then there is pointing to this index one. Now we're going to check them minus one. That means this element six does six greater than the temp.

32
00:07:17,990 --> 00:07:30,500
Chimpy goes to five years. It is all going to replace this element eight with six. So we're going to replace this element six with. So we're going to replace this element eight with six.

33
00:07:31,790 --> 00:07:43,080
Then this is pointing to this element at index zero. And here this one of stuff, and we're going to replace six with the value of ten variable to be close to five.

34
00:07:43,100 --> 00:07:57,050
So let's replace six with five. Now, the left part is sorted and the right part is unsorted. And our temp will points to this element for so typical two to four and zero point to this element, four as well.

35
00:07:57,470 --> 00:08:08,240
Now we're going to check the minus one. There is eight does eight is greater than the temp. We see that eight is greater than four. So we're going to replace four with eight.

36
00:08:08,510 --> 00:08:24,730
Remember it temp is storing the value of this element four. OK, now this is pointing to this index to and here we see the minus one is greater than five.

37
00:08:24,860 --> 00:08:41,370
So we're going to replace it with six. Then they will point to this element. Now we're going to check the on if the administration is greater than five, we see that the minus on its five five is greater than four and the term variable we four.

38
00:08:41,660 --> 00:08:56,920
So what are you going to do? Are you going to replace six with five? So let's replace six with five here. Now let's move to the left. And here they is pointing to this element five and Loop will stop here.

39
00:08:57,200 --> 00:09:09,170
So we're going to replace this five with the value of term variable, and that is four. So let's replace this value five with four. Now, we're done with the iterations.

40
00:09:09,680 --> 00:09:24,110
Now we have this left and right now we have this left part is sort of the right path is unsorted. Now, this is our temp and this is pointing to this element to and the typical structure to.

41
00:09:24,350 --> 00:09:39,940
Now we're going to check the minus one and tenth. So minus on is this element eight and 10 two. We see that the minus one is a greater than 10. So we're going to say we're going to move eight to this index, eight.

42
00:09:40,310 --> 00:09:55,580
Let's move it here. And now Jay is pointing to this element eight and here minus one is six. Six is greater than two. So let's replace it with six. Then there is pointing right here.

43
00:09:55,910 --> 00:10:08,240
Now is the minus one is five. Five is greater than two. So let's replace six with five. The point to this element five. And now we're going to compare the minus one that is four.

44
00:10:08,360 --> 00:10:19,700
Four is a greater than two. So let's replace this five with four. So we're going to replace five with four. And on the left, we have this element four.

45
00:10:20,060 --> 00:10:31,140
And there is pointing to this element with this world of stuff here. And now we're going to do we're going to reflect this for with two. So let's replace four with two.

46
00:10:31,430 --> 00:10:42,290
Now we're done. So after this iteration, we have this left part sorted and the right part is unsorted. Only one element. Now, let's pick this element and let's put it to the right position.

47
00:10:42,470 --> 00:11:06,110
So now 10 because two one and this is pointing to this element one initially we see one is we see the minus one eight eight is greater than temp. So we're going to replace one with eight and similarly zero point here and we're going to replace eight with the value on the left.

48
00:11:06,110 --> 00:11:16,760
And that is six. So let's replace eight with six now. Zero point here. And this is the minus one is greater than tenth. So let's replace six with five.

49
00:11:17,240 --> 00:11:36,960
Now, they will point to this element five. And here we see five is a greater than one. So let's replace five with four. Then similarly, they is in here and we're going to replace four with two and then zero point here.

50
00:11:37,400 --> 00:11:54,200
Now we're done with this one. So we're going to replace this. With one simple replace this, do it all, we get this right now, our entire area is sorted and this is how insertion sort of checks and they said your algorithm to solve this problem.

51
00:11:54,500 --> 00:12:05,160
We have understood the insertion sort. Now, let me show you the time, complexity and the space complexity. The space complexity for this problem is bigger up one.

52
00:12:05,160 --> 00:12:18,120
That means it works in constant space complexity. Since we're modifying the given area, we're not using any extra space. Now, let's see the time complexity for this problem to analyze.

53
00:12:18,630 --> 00:12:45,180
For sake of understanding. We assume this is your given array for the first sketch and this is your algorithm. And here we have to calculate the time, complexity, time, deal of in and here we break it down every single line and this followable takes off in this world of will, takes off in for the first catch and all others will takes constant time, complexity.

54
00:12:45,850 --> 00:13:01,860
And here we have breaking down the iterations for our lives and here we have the execution. If we add all the execution, then we get something like this one plus two plus plus in equals to end times in plus one divided two.

55
00:13:02,220 --> 00:13:11,710
And here we get this equation in squared plus in the added two. And the degree of the situation is N square. That means the highest term of integration is in square.

56
00:13:11,910 --> 00:13:21,040
So that time complexity is big enough and square and the space complexity is bego of one because you are not using any original speech or just modifying the given area.


@@@
1
00:00:01,020 --> 00:00:15,660
Hey, you guys all come back to this video, in this video, we're going to talk about a bucket shot algorithm. Bucket Short is a sorting algorithm that works by distributing the elements of an array into a number of buckets.

2
00:00:15,670 --> 00:00:28,610
Each bucket is then sorted individually, either using a different sorting algorithm or by recursively applying the bucket sorting algorithm. This is the formal definition of a bucket sort algorithm.

3
00:00:29,550 --> 00:00:44,100
So we're given this array. We have to return this array. This is unsorted. This is sorted and you have to sort this out using bucket. And in this video, we'll see the concept of a search algorithm and we'll see how it works.

4
00:00:44,550 --> 00:00:57,840
Bucket sort algorithms is useful only for uniformly distributed data. If the data is not uniformly distributed, then the output of buckets is defeated.

5
00:00:58,530 --> 00:01:14,390
Now let's see how bucketed algorithm works and how we can sort an array using bucket short. So first we're going to create a number of buckets. That means we're going to find out the number of buckets first by using a simple formula, by taking scale.

6
00:01:14,400 --> 00:01:33,170
Our floor of the square root of the length of that array then will iterate through his element and place it in appropriate bucket, appropriate biologicals to sail, and then 12 times the number of buckets and will divide it by the max value in the area.

7
00:01:33,720 --> 00:01:44,220
And this is where we can find the appropriate bucket. And then we will sort all the bucket and almost all the buckets and then we'll get our array is solid.

8
00:01:44,460 --> 00:01:59,240
Now let's see how it works. If you're given this array, for example, first we have to find out the number of buckets to find a number of buckets. Use this formula and he will take salesgirls, square root of lentil of misery.

9
00:01:59,460 --> 00:02:10,920
So lined up this Ariston so square root of tennis three point something. And if we take syllabary point something that will be overloaded for so we're going to construct four brackets.

10
00:02:10,920 --> 00:02:20,960
We have no bucket equals to four here. Poor bucket. Then we're going to it through is ilmenite and implicit it in the appropriate bucket. First we have 40.

11
00:02:21,570 --> 00:02:44,790
So in his pocket we'll insert 40. So bucket equals to sale value times a number of buckets we have four buckets. So 40 times for equals to one hundred sixty and one hundred sixty divided the maximum value in this one hundred to one point something that means sale of one point something is to fourteen.

12
00:02:44,790 --> 00:03:03,420
All goes to this bucket to then we can find out the appropriate bucket using this formula. Then all goes to this bucket one thirty goes to this bucket to similarly ninety which goes to this bucket for then a do goes to this bucket for the seventy.

13
00:03:03,420 --> 00:03:17,250
All goes to this bucket. Three twenty it goes to the bucket one sixty goes to the bucket. Three people goes to the bucket two and one hundred all goes to the bucket.

14
00:03:17,790 --> 00:03:30,480
For now this is your bucket. We have inserted the right element in the appropriate bucket. Now we're going to sort the bucket. If we saw the bucket or bucket will be represented.

15
00:03:30,480 --> 00:03:51,870
Something like this. OK, now our bucket is sorted. Now our goal is to merge all the buckets and in return that mastery. And if we merge the buckets, then we get this every 10, 20, 30, 40, 50 and 60, 70, 80, 90, 100.

16
00:03:52,500 --> 00:04:01,980
And this is how it works. Now, let me show you the algorithm and then also we'll see how it actually works line by line. This is our algorithm for the bucket.

17
00:04:01,980 --> 00:04:20,040
Should we use this formula number of buckets to sail the square root of the length of the given array, then maximum and the minimum value? OK, using this one, if we're going to find out the minimum value and the maximum value and then we're declaring a bucket with the site of the.

18
00:04:21,220 --> 00:04:39,480
Number of buckets we have calculated right over here, then we are creating the number of buckets we need to insert in this list and then we're inserting the right element to the appropriate bucket and then we're sorting is bucket and then we're merging the buckets using this formula.

19
00:04:40,220 --> 00:04:50,160
Here you are using quicksort and you can use any other sort likes Morisot no matter what. And let's see how this actually works. One more time for super understanding.

20
00:04:50,240 --> 00:05:05,330
Let's assume we're giving this array and we have here for bucket by doing this formula. So Martin will be evaluated three point something and say love three point something is four supermarkets now 40 for 40.

21
00:05:05,510 --> 00:05:20,380
The appropriate bucket is 40 times four, divided by one hundred one point six. The sale of one point six is to the forty. Will goes to this. So Forty Will goes to this bucket to then ten times ten.

22
00:05:20,390 --> 00:05:33,760
Forty four divided one zero point something so genuine goes to this bucket one then tarde Thada dimes for each one hundred twenty and one hundred twenty divided one hundred is one point three.

23
00:05:33,770 --> 00:05:51,740
So the sale of one point three is two. So, so Taroom goes to this bucket to the ninety four times ninety four times ninety calls to three hundred sixty three hundred sixty divided one hundred equals to three point six.

24
00:05:52,400 --> 00:06:03,830
That's evaluate the sale of three point six is four. So, so 92 goes to this bucket for and we can find out the appropriate bucket using this formula pretty easily.

25
00:06:04,580 --> 00:06:18,260
And this is the formula and it will move to this bucket for then seven to them up to this bucket. Three twenty goes to this bucket. One sixty. Who goes to this bucket.

26
00:06:18,260 --> 00:06:30,740
Three fifty goes to this bucket two and one hundred. It goes to this bucket for now. Our job is to sort the bucket besought the bucket is bucket episode is bucket.

27
00:06:30,740 --> 00:06:47,810
We get this bucket. OK, now our goal is to merge all the bucket boomers first 10, then 20, then 30, 40, 50, 60, 70, 80, 90, 100. So it is all the bucket.

28
00:06:47,810 --> 00:07:03,080
We get this array and this bucket sort of works. We have understood the concept of bucket short. If the area is not uniformly distributed, then the purpose of bucket short is defeated for the ticket.

29
00:07:03,320 --> 00:07:26,660
All the element all goes to only one bucket and that sticks for the worst, gets bigger of in scary time complexity. And that's the worst thing. And for the best case that this will takes, if the data is uniformly distributed, then that time complexity is bigger of each log in for the quicksort algorithm.

30
00:07:26,660 --> 00:07:51,660
And if we add all the fall of the time complexity and we get bigger of input as we go up in, plus we go in, plus we go in. And the overall time complexity is bigger of in log in for the quicksort or my resort algorithm or whatever algorithms you use to sort the bucket and the space complexity is bigger of in you.

31
00:07:51,670 --> 00:08:08,120
You should then no extra space is required, but you have to construct the bucket so that the space complexity should be bigger off in. If the data is not uniformly distributed that time complexity would be big of Entocort and that is not the which are bucket short.

32
00:08:08,390 --> 00:08:18,800
If the data is uniformly distributed, only then we will consider using bucket sort of. Right guys, we have understood the concept of bucket short. Thanks for watching this video.


@@@
1
00:00:01,220 --> 00:00:11,480
Hey, what's up, guys? Welcome back to this video. In this video, we're going to talk about Mars sort algorithm, this each one of the efficient sorting algorithm.

2
00:00:11,810 --> 00:00:29,390
Now let's see how much salt actually works in this video. We're going to see how much salt works. Then you'll see Line-by-line explanation. Then you'll see the runtime analyze each master divide and input into two hubs.

3
00:00:29,960 --> 00:00:41,830
Give breaking those two hubs recursively until they become simple enough to be solved, then ease of the broken pieces which are merged together. We'll see how this actually works.

4
00:00:42,170 --> 00:00:55,440
This is the formal definition of Mars sort algorithm. For example, if you're given this array using this algorithm, we have to sort this array in ascending order, something like this.

5
00:00:56,150 --> 00:01:06,540
So for this given array, we have to return this array. Now, let's see how much salt actually works for Sidcup understanding. Let's assume we're giving this array.

6
00:01:07,100 --> 00:01:16,010
Now, we're going to break it down this hour into two hops by doing a simple formula, the index of the first element, plus the index of the last element.

7
00:01:16,370 --> 00:01:30,770
So zero plus six divided three goes to three. So on the first half, we have the element from zero to three. And on the second element from from forward to the end and we'll break it down into two hops in DFS manner are in depth.

8
00:01:30,770 --> 00:01:41,720
First matter. So first, we're going to break it down into this half. So in this house, we have this four element. And again, we're going to break it down, this summary into two hubs.

9
00:01:42,020 --> 00:01:53,560
Then we get this from this summary. And then again, we're going to break it down, this summary, and then we get this only one summary and we can't break it down any more.

10
00:01:53,780 --> 00:02:05,600
Then let's go to the right on the right of the two. And now we're going to sort and merge these two sabari here. We'll use the techniques called merge two sorted array.

11
00:02:05,780 --> 00:02:20,660
And that super simple, if we merge and sort this to array two will move here and four will move here. OK, so we absorbed this Sabari and this Sabari. We get two.

12
00:02:20,660 --> 00:02:32,850
And for now, let's break it down to the second half of discovery so we get five and eight. And let's break it down further. We get five and eight. Now, what are you going to do?

13
00:02:32,870 --> 00:02:42,800
We're going to Mars and sort this two single speech if merged. And so these two single pitch, we get five and eight. Now, what are you going to do? We're going to Mars.

14
00:02:42,970 --> 00:02:58,790
These two sorted array little summary and these two array are sorted. So if we merge these two sorted array, then we get two. Then for the five it so it will merge these two sorted separately.

15
00:02:58,800 --> 00:03:09,710
Get this Southbury two, four, five it. So now we're done with the left part. Now let's go to the right part and this is the right part. And let's break it down into two hops.

16
00:03:09,800 --> 00:03:21,050
On the left we have two element. And then again, let's break it down. We have six and then we have here nine. We can't break it down six and we can't break it down nine any further.

17
00:03:21,440 --> 00:03:37,220
So now let's sort them and merge them. So if we merge and so these two separate, we get six and nine. Now let's go to the right on the right one. And now let's merge and sort these two sorted array and epitomizing.

18
00:03:37,230 --> 00:03:52,010
So these two separate, we get one six, nine, one, six and nine. Now we have solved this to separate left and right. And here we see that these two separate are in sorted order.

19
00:03:52,130 --> 00:04:10,160
They're sorted. So if we merge these two sorted array, then we will get the sorted array, something like this one, then two, then here for one, two, four, then here we should have five, then six, then eight and then nine.

20
00:04:10,430 --> 00:04:27,380
All right. So it'll be merged and sorted. Is two separate. Then we get this error and this is how merge sort of breaks. We're going to break it down. The given arranged two hubs using recursion and will break it down using depth.

21
00:04:27,380 --> 00:04:38,230
First search that's called depth, first traversal something like that. And this is how it works. Now let's see the algorithm and then we'll see how it actually works.

22
00:04:38,240 --> 00:04:50,450
Again, this is the master algorithm. First you have this function, my sort. It takes nums array left and right. If a right is greater than left, then we're going to calculate middle by this one.

23
00:04:50,480 --> 00:05:12,960
Left, plus right, minus hleb divided two. We can do it simply left plus right. Divided two and that most overflow. That's why we're using this one. They were calling this function Amersfoort with numbers, left me and my sort numbers Metellus on right recursively and they were merging and sorting the two sabari.

24
00:05:13,190 --> 00:05:26,720
OK, and this is the function to Mars and sort the two sabari. We have lift temporary. Right temporary then recopying the element from our array to let temporary and to the right temporary.

25
00:05:26,900 --> 00:05:39,460
And then at the end of September we were inserting a maximum integer just for a Marsing properties. And that's super interesting. And then you'll be able to point up unimpeded to Mars to solidary.

26
00:05:39,470 --> 00:05:49,010
And this is super interesting and super simple. Now let's see how this works and we're going to we're going to call this function master recursively something like this.

27
00:05:49,790 --> 00:06:00,620
And we can't call this function anymore. We referred to this Sabari. Now let's call this Mussert announcement plus one and. Right. And then we get four and two.

28
00:06:00,830 --> 00:06:14,500
Now, let's sort it. Using this murse function, this function will merge and sort the two. Southbury Satou will move here and four will move here. Now, let's call it with the right, but the right part is five and eight.

29
00:06:14,510 --> 00:06:33,770
The left Parlette. What is five then. Right, but right there is eight. Now we're going to merge this two part here. We already processed this to summary here and then let's process this to merge these two separate ellipticals to this summer and right equals to this temporary summary.

30
00:06:33,770 --> 00:06:46,240
And then we're adding this maximum integer just for sorting purposes, just for sorting and parsing purposes. Then we're going to merge this to insert episode and merge these two samarium.

31
00:06:46,260 --> 00:06:58,220
Then we get this and we're going to merge. And so disturbing I didn't get to four it. So here are two, then four. So you see this summary is now sorted.

32
00:06:58,220 --> 00:07:07,280
Two, four, five, eight. Now let's call it with the right part. The right path is six nine one. Let's call it the left. Left is six nine and the right is one.

33
00:07:07,490 --> 00:07:19,840
And then the left of six. Nine is six and the right is nine. Now let's sort Soran merge these two Sabari. And if we do that, then I get this summary. OK, this is already sorted.

34
00:07:20,180 --> 00:07:33,620
Now let's call it this one and only we have one. No, let's merge these two sorted array. Then we'll have one six, then nine. So now the left and the right array.

35
00:07:33,860 --> 00:07:57,590
We get these left arrays sorted in the right arrays solid and these are Sabari. Maybe merge these two sorted array. Then we get something like this. Now we see that if we Meurs these two sorted array and get to this area and we can merge this to sorted array using this function murres and this is how my search works, understood the concept.

36
00:07:58,010 --> 00:08:09,410
When you're merging these two left subframe, we're modifying the element in order given away to the main area. And you're just sick of understanding. We are.

37
00:08:09,670 --> 00:08:22,280
We're just modifying that right here. But actually we're adding that value to our menary because we're using a reference here. We're just sending the given array and here we're just directly adding to that area.

38
00:08:22,670 --> 00:08:33,140
We're not merging that to our temporary area. And that element we're going to insert to the right position to our main array. Don't be confused about that.

39
00:08:33,140 --> 00:08:41,390
Just for sake of understanding. We're just merging these two and we're just throwing it right here. We're actually adding this value to our amenorrhea.

40
00:08:41,390 --> 00:08:51,770
OK, what we have understood the merge sort algorithms, and this is how my algorithm works. Now, let me analyse the time, complexity and the space complexity.

41
00:08:51,890 --> 00:09:04,520
The space complexity for this solution is bigger ofin because we're creating a temporary array for Austudy. We're going to create our two temporary and divided two and in divided two.

42
00:09:04,790 --> 00:09:29,720
So the overall space complexity is bigger ofin. Now let me analyse that time complexity. Alright, here we break it down every single line and we have to calculate this t off in the time complexity for this in a the length of the given arrays in and this takes bigger one than this operation takes bigo of one.

43
00:09:29,990 --> 00:09:41,170
And we're just dividing this array by two hub's. It's time for this recursive call stack and then we're Marsing, the two Southbury and this function takes off in the end.

44
00:09:41,180 --> 00:09:59,660
Here you can see how we can calculate the because in the end we have just some of it super simple. So this function takes off in. So if we add all the time complexity here t of inequal too, because of one big of one then T of anybody to dissolve into the two plus in.

45
00:09:59,740 --> 00:10:14,890
Here we are doing in executions, so here it two and that's that we have here in the city of illegals to tee off in the attitude of plastic. You have anywhere to plug in and we can just skip because of one because they're constant.

46
00:10:15,780 --> 00:10:25,180
Now, let me show you how we can find the time, complexity to find its time, complexity up to date back substituting. Now, let's see how we can do that.

47
00:10:25,960 --> 00:10:41,320
OK, we are given this so we find out this equation of a nickel to dissolve in the other two plus two up and divided to plug it in. And if we add this to the opening with a two, then we get to the end to plug it in.

48
00:10:41,320 --> 00:10:55,000
And this is only one. And if we substitute in by anybody to an equation one, then we get this equation and you can calculate this by putting in equals to anybody to to this equation one.

49
00:10:55,570 --> 00:11:07,810
Now, if we substitute this equation to into equation one, then we get this equation. Do you have any close to to the departure time state of endeavoring to do the bar two plus two times in?

50
00:11:08,020 --> 00:11:20,270
Again, if we insert in divided four at the pledge into the equation one, then we get this equation. If we substitute this equation three to the equation, one that to get this equation.

51
00:11:21,040 --> 00:11:31,690
So here we find out a pattern. The pattern identified is something like this to happen equals to to to the items deep in the valley, to the right plus eight times in.

52
00:11:32,140 --> 00:11:44,650
This is the pattern we have identified. This time we're calling the Marzotto function or we're calling with the individual who we're calling the master functions.

53
00:11:44,950 --> 00:11:56,250
We're dividing that array into two halves is time. At some point we'll find out in Divided to do the icons to one so we can assume that in devoted to the bar equals to one.

54
00:11:56,560 --> 00:12:09,610
And here, if we solved this problem, we get luck to any calls to I maybe substitute I to the situation with luck two. And then we get this equation here to do the power lock to end.

55
00:12:09,640 --> 00:12:24,940
It will be loaded in and here D in divided in because this will be related in and then we have a lock to end times in here. We find out in terms of on plus lock to end times in type one.

56
00:12:24,940 --> 00:12:38,450
So it only takes constant time, complexity and this is a basket. So when you have the sides of the array or when you're calling recursively, then it takes only one execution so we can argenti up when he goes to one.

57
00:12:39,490 --> 00:13:00,940
So in times one plus log to end times in and finally we get in plus lock to in, times in. And this is the highest term in this equation. So the time complexity is because in times like to end, so we find out that the time complexity is because of in times a lock to end.

58
00:13:01,330 --> 00:13:16,520
And the space complexity is because in and this is the most thought algorithm. We have understood my algorithm in details. And also if I understood the runtime analysis, if you have any problem with previous additions, let us know.


@@@
1
00:00:00,960 --> 00:00:10,950
Hey, you guys all come back to this video in this video, we're going to talk about a quick short algorithm. This is one of the efficient sorting algorithm.

2
00:00:11,950 --> 00:00:26,880
In this video, you'll see how quick short works and all the information you need to understand. Quick, short algorithms, then all I talk about the random analyses of this algorithm quick.

3
00:00:26,950 --> 00:00:44,200
Sure. It works by selecting a pivot element from the array and it will partition at the pivot point into two hubs where the smaller element on the left and the greater element on the right it'll keep for doing this process recursively until the entire array is sorted.

4
00:00:44,920 --> 00:01:07,380
For example, if you're given this array, you have to return this sorted arraying ascending order using the concept of quicksort algorithm. The concept is that first you have to pick a pivot and we have to partition that array based on pivot all the element on the left pivot or lasdun and all the element on the right, a pivot are great.

5
00:01:07,490 --> 00:01:18,100
Then let me show you how quick should algorithm actually works. We will consider the rightmost element, the pivot element. OK, now let's see how it works.

6
00:01:18,790 --> 00:01:31,210
For sake of understanding, let's assume that we're giving this array here. We have the index number from zero to eight and first we'll pick this five spot and this new recursion called three.

7
00:01:31,780 --> 00:01:44,020
And this will solve this problem. Don't worry. First, let's see how we can solve this problem and solve this problem in depth. First matter or in DFS matter.

8
00:01:44,470 --> 00:02:02,080
Let's see how. So this is our pivot element initially and we have to insert this pivot element in the right position where we have the left element are lasdun and the right element are greater than we partition this array by considering five is the pivot.

9
00:02:02,080 --> 00:02:11,890
Then we get this array. OK, this is five, this is pivot. And on the left we have all the elements are less than we would on the right, all the elements are greater than pivot.

10
00:02:11,890 --> 00:02:24,910
And here we see we have the pivot index is for. We'll see how we can partition this array by this pivot point. Don't worry about that. Then we're going to move to the left and on the left we have from zero to three.

11
00:02:24,910 --> 00:02:43,300
And here we have the index number and we're going to choose to pivot and pivot will be our ADD index one, OK? And all stuff when we see the left is greater than right and we'll consider whenever we implement the algorithm, then we'll see how this works.

12
00:02:43,990 --> 00:02:53,950
So the two will move to this index two and we partition this loop separate into two hops. The left part is less then and the right part is greater then.

13
00:02:54,070 --> 00:03:05,140
So we have a partition this array by considering pivot as to now let's go to the left. On the left we have one at index zero will consider pivot this element on itself.

14
00:03:05,470 --> 00:03:15,360
So nothing need to be done here. Only we have only one element. And for the implementation of algorithm we will see this two basic liberties agreed upon.

15
00:03:15,370 --> 00:03:27,760
Right. And here we move to the right Leptis gridding. Right. So we'll stop and we'll see it when we implemented the algorithm. Now let's go to the right of this node.

16
00:03:27,940 --> 00:03:38,830
Let's consider this is not so. Let's go to the right of this node. And here we are, two, three. So in between two and three, let's pick three eSport. So we pick three spot.

17
00:03:39,160 --> 00:03:50,890
Then it will move to the index two. This will be represented, something like this. And then we have on the left to one. This is what our algorithmic analyses this is for our algorithms implementation.

18
00:03:50,890 --> 00:04:00,520
We'll see then how it works and break it down every single things so that you can understand it better. Then we have your three and three and we have only one element.

19
00:04:00,520 --> 00:04:14,170
So nothing need to be done. Here are the siege period and we have to do nothing here and here. We have two left and right are for the recursion call. And let's go to the right or the left of this route.

20
00:04:14,500 --> 00:04:28,240
Now, let's go to the right. And in this case, we have five and eight. And here, if we pick it, we pick eight as our pivot in between this index five and eight, then our pivot would be at seven, Rudnic seven.

21
00:04:28,240 --> 00:04:37,000
So it will be represented something like this. And if we keep doing this process, it will be something like this. Then our six pivot and here six will move here.

22
00:04:37,000 --> 00:04:46,840
Then we have only seven, seven in three and nothing to be done here, then only nine Lip-Synch Uninspired and nothing yet to be done here. And the area is solid.

23
00:04:47,260 --> 00:04:59,020
So we're partitioning the area by selecting a pivot until the entire area is sorted. We're doing this in in pledge. So this will not cost any extra memory.

24
00:04:59,080 --> 00:05:10,270
But this will works in constant and espace complexity. Now let's see how this actually works and how we can let's see how we can partition the array by selecting a pivot point.

25
00:05:10,570 --> 00:05:26,370
All right. On the right, we have our tree recursion tree and this is Pivot, initially, I will point to the out of this array. This is P, then they will point to the first element to our area.

26
00:05:26,640 --> 00:05:45,780
Now we're going to check if there is less than or equal to pivot, then we'll move I that means will increase the value of I will move to the next and also if I end Z in this case we see that five is not greater than or equal to eight.

27
00:05:45,930 --> 00:05:58,890
So it will just move to the next element. So they will move to this element. Now we're going to check if five is greater than or equal to four, we're going to move it to the next.

28
00:05:59,550 --> 00:06:12,890
Let's fly right over here. And now we're going to do we're going to swerve. And if we swap them, we get four here and we get eight here. Now, let's move to the next element.

29
00:06:12,900 --> 00:06:29,420
If we move to the next element, as they will point to this element three. And here what we're going to do, we're going to check if a pipe is greater than or equal to the where is point two and we see five is greater than three.

30
00:06:29,430 --> 00:06:46,320
So we're going to move to the next element. The next element is eight in this case. So let's move here I and let's move. Ended up we serve in the A2 move right here and G will move to the left.

31
00:06:46,320 --> 00:06:58,410
Right here. OK, now let's move to the next element and they will move right here. This is pointing to this element six. Now let's take a pie with a greater than or equal to six.

32
00:06:58,770 --> 00:07:09,480
Then we will serve. And yet we see that five is not greater than six, so not twelve. Let's move to the next. So now this is pointing to this element one.

33
00:07:09,690 --> 00:07:23,090
And in this case, we see that five is greater than one. So what we're going to do, we're going to move it to the next. We will move it right here and we're going to solve this I energy.

34
00:07:23,250 --> 00:07:44,580
So eight to move here and one will move right here. Now, let's move to the right and zero point to this element seven. And we see that five is not greater than seven to let's move to the next zero point here and here we see two is less than five.

35
00:07:44,820 --> 00:07:57,410
So five is greater than two. So we're going to do we're going to move it to the next. I'll move here, then we're going to swap two and six. Iron density will move here and six will move here.

36
00:07:57,840 --> 00:08:08,490
Now, let's move it to the next element. And next element is nine. So this point in year nine is greater than five. So now they need to be done here again.

37
00:08:08,490 --> 00:08:20,430
Let's move to the next. Now is pointing to P, and we see that P is less than three calls to Z. So what are we going to do? We're going to move it to the next.

38
00:08:20,430 --> 00:08:32,130
I will move right here and we're going to swerve I and Z, if we swap them, eight will move here and five will move here. All right. We're done with the first iteration.

39
00:08:32,400 --> 00:08:47,630
After the first iteration, we see that a partitioned this array into two halves, something like this. So after the first iteration, we get this array and we partition this array at the pivot point five.

40
00:08:48,270 --> 00:09:00,750
Now, let's solve this for the left. Sabari, let's pick this up. What this is our pivot and is pointing to out of this array boundary. Then they are pointing here.

41
00:09:01,530 --> 00:09:13,050
We see four is a greater than two. So now they need to be done here. Let's move to the next element here. The same thing. Three is greater than two. So nothing need to be done here.

42
00:09:13,080 --> 00:09:28,740
Let's move to the next. And here we see that one is less than two. So we're going to move it to the next element. I will point right over here and then we're going to swerve and the one will move here and four will move here.

43
00:09:29,460 --> 00:09:41,130
Let's move to the next element. The next element is two. So they will move here and we see we see that there is less than or equal to P, so they are equal.

44
00:09:41,130 --> 00:09:59,550
So we're going to move to the next. I will move here and we're going to swap this to Ayanda. So two will move here and three will move here. So after this iteration, we get this array and here we partitioned this array by this pivot point or two.

45
00:09:59,550 --> 00:10:10,200
So we get this array, something like this. And this issue will be doing this partitioning by selecting pivot point. And here only you have one if we select this as pivot.

46
00:10:10,870 --> 00:10:23,800
I think it to be done here, this is already in its current position and then here will take people to right here and we will partition this summary and then we'll partition this area by taking a pivot point.

47
00:10:24,040 --> 00:10:33,430
So if we take pivot as one, then we'll have this as pivot and then we'll take spot here. Then it will be swapped and this will be something like this.

48
00:10:34,180 --> 00:10:42,630
And then we'll take pivot aid, the newly partitioned. Then we will get something like this. Then we'll take Pivot right here six and it will be something like that.

49
00:10:42,630 --> 00:10:52,370
Then we have seven, then eight, nine. And this is how we can solve this problem. And this is how quicksort works. Well, we have understood the concept of quicksort algorithm.

50
00:10:52,840 --> 00:11:04,930
Now let's see the algorithm for this problem. This is the algorithm for quicksort. We're calling the Scrooged function with numbers array and start is the here start is the index of the first element.

51
00:11:04,930 --> 00:11:15,550
And is the index the last element? Then we're checking upstaters less than and then we're going to find it pivots. Then we're going to call with the list and then we're going to call it that.

52
00:11:15,550 --> 00:11:28,210
Right. That means from start to pivot, we're going to partition this array from zero to the pivot minus one, and then we're going to partition this array upon pivot plus onto the end.

53
00:11:28,480 --> 00:11:48,550
And then we have the partitions. We really got to end and I got to start minus one for year from start to end. If nums there is literally close to the pivot element, then we're going to we're going to increase I that means we're going to move it to the next and then we're going to have Ayanda and at the end Ulrichsen return I and this is how it works.

54
00:11:48,760 --> 00:12:03,670
First thing I understand let Adam or given this array and this recursion call three and we're still calling this function recursively when we find out the value Leptis than right.

55
00:12:03,670 --> 00:12:12,910
And here we see Leptis guerdon. Right. And here we have OK. And you can take a look at this recursion call three, then you will understand this problem pretty easily.

56
00:12:13,120 --> 00:12:24,910
Here we have the start and end index and here we have that pivot point for that recursive call. And here we have the start and end index. And this is the partitioned result.

57
00:12:24,910 --> 00:12:35,820
And this will be returned by this partition functions. And four is the pivot. This is how we should work. Let me show you one more time. Right. So this is our recursion call three.

58
00:12:36,280 --> 00:12:47,830
And this year, given our efforts to keep our understanding and for first four first call, we have a pivot point five and then two, then one, then three, four.

59
00:12:48,370 --> 00:12:59,350
Then here we have eight, then six, then seven, then nine. And we're done. And this is how it works. You have understood the concept of quicksort algorithm.

60
00:12:59,600 --> 00:13:11,230
This is how it works. If you're not understanding, take a look at this recursion called Stack and you can see how it works and you have explained how we can partition the array.

61
00:13:11,380 --> 00:13:23,260
Now let's see the runtime complexity for this problem. We're modifying the given array inflate, so we're not using any additional space. So the space complexity is bigger of one.

62
00:13:23,260 --> 00:13:34,390
That means it works in constant space complexity. Let's see the runtime analyze it here. To break it down is line and we have to calculate that time for the in.

63
00:13:34,390 --> 00:13:47,170
In is the length of the given array. This operation takes up one. This takes we go off in the districts t of individual to into the arena to hubs with the pivot point and here as well.

64
00:13:48,320 --> 00:14:04,130
And function partition, it takes big off in WI, you can see here and this operation takes off if we add all of them to have any calls to go up on us because of one plus the individuality and the other two.

65
00:14:04,130 --> 00:14:19,470
Plus in the United States, we go in now. Do you have any calls to do you have anybody to stop, anybody to place in here? It takes in steps are in executions to find out the partition or to partition the area.

66
00:14:20,120 --> 00:14:30,840
Now, if we do back substitutions, we can find at the time complexity. Let's see how this is your given our equation. And we get this equation by adding these two and they are the same.

67
00:14:30,860 --> 00:14:48,980
So two times D and divided, two plus in every substitute in by the two in equation one. Then we get this equation and B substitute this equation to an equation, one that we get this equation again to be substituted and by the third, then we get this equation.

68
00:14:50,000 --> 00:15:08,960
And if we substitute this equation three into one, then you get this equation and here you find it to pattern. The pattern identified is that this pattern we're calling our function quicksort recursively at some point we'll call it the element one.

69
00:15:09,440 --> 00:15:20,390
So in that times it only takes only one operation so we can consider dissolve in a divided two to depart equal to one. So in divided to the deeper I go to one.

70
00:15:21,420 --> 00:15:37,350
If you consider that and if we solve this, then we get I got to walk to end and if we replace I to this equation, then you get something like this. And if we solve the situation, we get this equation in terms of a divided one.

71
00:15:37,830 --> 00:15:48,930
And the best guess here is that Europe only goes to one when calling the functions with the element, one that will take only one operations and that will execute just four one times.

72
00:15:49,380 --> 00:16:24,120
So Dearborne goes to one and here we get the situation in plus long up to in times in an episode. This we get bigger of in times like to end. And this is what we can find out, that a random complexity for this algorithm quicksort so that our long term complexity is bigger of in log in time complexity and it will take big off in space complexity senge or not using any original speech, but for recursion called stack, it will take Spiga off in space complexity.

73
00:16:24,420 --> 00:16:32,670
Hoofy have understood the concept of QuickStart algorithm, even understanding. Let us know. Thanks for watching this video. I'll see you in the next video.


@@@
1
00:00:01,140 --> 00:00:17,080
Hey, what's up, guys? Welcome back to this video. In this video, we're going to talk about a sorting algorithm, hip sort what is he sort algorithm he thought is one of the sorting algorithms used to arrange a list of elements in order.

2
00:00:17,370 --> 00:00:46,590
He sort algorithm uses one of the three concepts called binary HIF. Binary data structure is also called his data structure. If we're given this particular array, we have to sort this array in ascending order, using sort algorithms now how we can sort a given array in ascending order, isn't he algorithm?

3
00:00:46,860 --> 00:00:57,590
Now let's talk about that. For example, let's say we were given this array first. What are we going to do? We're going to construct a binary data structure from this area.

4
00:00:57,930 --> 00:01:15,480
We're going to scan this area from left to right, and then we will construct our binary if that a structure, and then we will extract our hate node and we'll put that to the first position and then again, all extract.

5
00:01:15,600 --> 00:01:30,810
Then we will put that head to the second position and so on and all see that how we can do that. Now, let's construct our data structure first. We have this matrix.

6
00:01:31,080 --> 00:01:50,010
So six is our route and we have left. And right now by default, the next element is for what you have only one node we don't have to worry about. If you find now we have this note for let's now let's insert this note for as a change of this node six.

7
00:01:50,500 --> 00:02:04,710
Now let's do it. If I if I here we see the parent of forty six, so let's swap them since part is greater than the current node. So four will goes here and six who goes here.

8
00:02:05,430 --> 00:02:20,430
Then our next element is seven. So let's insert seven right over here. Here reconstructing meaning. OK, we're not constructing massive even understanding how we're constructing binary give don't worry about it.

9
00:02:20,640 --> 00:02:36,450
We have a complete section where we have talked about binary in details. Now let's see if we see seven in each correct position because the parent is less than the current seven is than for the next element is three.

10
00:02:36,450 --> 00:02:50,900
Let's insert three as the left side of this node six. Now let's say we see three less than parent. Parent is six, so let's swap them. So we have swapped three and six.

11
00:02:51,240 --> 00:03:04,480
Now the parent of three, four, we see four is greater than three. So let's watch them. Ebisu of Wisoff three and four, then three will move here. And for all, Maria.

12
00:03:07,400 --> 00:03:18,350
Now, the next element is one, let's insert one to the right child of this node for and we see for is less than and we see four is greater than one. So let's swap them.

13
00:03:19,520 --> 00:03:33,200
One will move here and four will move here. Then the parent of one is three. We see three is greater than one. So the two of them, three will move here and one will move here.

14
00:03:34,250 --> 00:03:48,380
Then the next element is to let's incertitude with the left child, a base node seven. Now let's clarify. Here is seven is greater than two. So let's have them two more here and seven will move here.

15
00:03:49,400 --> 00:04:06,430
Then we see the parent of two is one and one is less than two. So we have found the correct position of this node to then the next element is five. Let's insert five to the right and up to and here you see that five is greater than two.

16
00:04:06,440 --> 00:04:22,460
So nothing need to be done here. We have constructed our binary structure. Now, what are we going to do? We're going to extract the hidden it from our data structure and we're going to insert that to the first index for the first iteration of this one.

17
00:04:23,120 --> 00:04:37,420
Then in the second iterations, we're going to get the Hadnot and we're going to update the value at index on and so on. Let's and do that. So first we're going to extract this node one, extract this, not one.

18
00:04:37,430 --> 00:04:47,660
We get one. So let's update the value at index zero with one. Now, what are we going to do? We're going to get the percent first. So what is the best?

19
00:04:47,660 --> 00:04:58,190
Not the president is an order that we get by traversing a binary HIF, using level or whatever. So whichever this binary to level, already we get five.

20
00:04:58,190 --> 00:05:11,030
So five is the best. We're going to update the one with the value of the first node. So let's update this value. So let's update the value one with five and we're going to remove this node five.

21
00:05:11,570 --> 00:05:25,420
OK, we have instructed the head node after extracting the hadnot. We have to you find the binary heap. Now, what are you going to do? We're going to find out that minimum of left and right.

22
00:05:26,120 --> 00:05:40,670
So minimum of left and right child, we see two. So we're going to swap five and two since five is a greater than two. So let's swap them. Five goes here, two goes here.

23
00:05:41,090 --> 00:05:56,750
Now we see that for this node we have only one left child and we see the left side is greater than five. So nothing is to be done here. We're done now in the next generation of this for Loof, we're going to extract the hit too.

24
00:05:56,930 --> 00:06:15,790
So let's extract this too, and let's insert it to this position. So we extracting the hidden right now, what are we're going to do? We're going to find the defense node seven is the deepest node, so let's split the value to with seven and let's delete the deepest node as well and let's delete the depressed.

25
00:06:15,870 --> 00:06:33,560
And now let's find out the minimum of left and right. The the minimum is a three. So let's swap them. And we see the minimum is three. So let's swap seven and three, three moves here and seven moves here.

26
00:06:35,550 --> 00:06:49,200
OK, now let's find out the minimum of left and right child of seven, which is the minimum is four. So let's say seven and for seven goes here and four goes here.

27
00:06:50,100 --> 00:07:04,170
We're done. OK, for the next iteration of this fall off, let's extract the hit history. So we're going to update the seven with three now. We're going to update the three with the best note.

28
00:07:04,680 --> 00:07:19,210
There is seven. So let's update the value of this node three with seven and also have to remove the deepest node net we have to call a function vivify to divide the binary heap.

29
00:07:19,710 --> 00:07:36,150
Now let's find it the minimum child, and that is four Lietzau four and seven. So let's have four and seven seven moves here and foregoes here. Now, we have only one left child for this node seven, so let's swap them since six is then seven.

30
00:07:36,750 --> 00:07:55,270
Six more here and. Seven move here were done for the next generation of this forum. We're going to extract four, so let's extract more and let's update this fellow with four and we're going to get the seven in the Senate.

31
00:07:55,720 --> 00:08:16,400
So let's remove seven and let's update rudiment with seven. Now let's find out the minimum on the left and right, the minimum is five, so let's swap five and seven five goals here and seven goes here for the next iteration of this fall.

32
00:08:16,400 --> 00:08:27,550
If we're going to get the Hitner, there is five. So let's extract five and let's update this one on one with five. Let's update this rule of five with seven, the depressionary seven here.

33
00:08:28,220 --> 00:08:39,260
So let's update this node with seven and let's do a half right here and here. You see, we have only one node, the LoopNet and Lipner is less than this original.

34
00:08:39,260 --> 00:08:56,750
So let's have seven and six, seven GWAS here and six goes here for the next iteration of this wall. We're going to get the hidden under the six. So let's update to it six and let's update six here with the deepest note.

35
00:08:56,780 --> 00:09:13,870
That is seven. So. Now, we have only one note that is serving the left and right point, are you going to consider now for the next generation of this fall if we're going to get this Hadland and we're going to update five with seven.

36
00:09:15,660 --> 00:09:42,570
OK, and then we're going to remove this note. And we're done, this is how he sort algorithm works for us, we have to construct our data structure that we have to extract from the structure and then we have to update that area by extracting from a data structure, even understanding insert and extract method.

37
00:09:42,600 --> 00:09:59,280
Don't worry about that. We have a complete section in discourse. Check the section binary here. This is how he sort of works. He said algorithm will take Spiga off in log in time complexity and it's the length of the given area and it all takes constant space complexity.

38
00:10:00,060 --> 00:10:14,840
I tell the source code where we use space complexity because when you begin to construct our data structure by modifying our given area, then you can solve this problem in constant space complexity.

39
00:10:15,060 --> 00:10:28,860
But that makes this problem a lot harder. That's why we're creating it. New array to create our data structure. Don't worry about that. I tell you the source code to this video for easy implementation.

40
00:10:29,430 --> 00:10:55,440
We're not constructing or even a structure by modifying our given area. Well, we've understood this Avita explanation. This is all about he thought algorithm we're using here means if data structure you can use Max, if you use, you have to update our area from right to left and the process exactly the same way we've understood.

41
00:10:55,440 --> 00:11:05,460
What is he algorithm and how it works. I have a test. The source could check the source code. Thanks for watching this video. I'll see you in the next video.


@@@
1
00:00:01,020 --> 00:00:18,930
Hey, lots of guys will come back to this video in this video. We're going to talk about what is recursion. Recursion is a method of solving a small problem where that solution depends on solutions to the smaller instances of the same problem, the properties of recursion.

2
00:00:19,440 --> 00:00:36,890
We have three properties of recursion. SIM operation is performed multiple times with different input in every step. We try to make the problem smaller and we must need to have a base collision with tilt system going to stop the recursion.

3
00:00:37,350 --> 00:00:55,390
And these are the formal definition of recursion. Now let's take an example to understand recursion here. The properties of recursion simulation is performed multiple times with different input in every step we try to make this problem.

4
00:00:56,070 --> 00:01:11,280
And we should have a base condition. This is an awesome gift box. Inside this gift box, we might have some gift. Now let's open this box. Inside this box, we have another box.

5
00:01:12,060 --> 00:01:27,500
Let's open this box. Inside this box, we have another box. Let's open this box again. Inside this box, we see we have another box here. We see that we're doing the same task multiple times, OK?

6
00:01:27,780 --> 00:01:39,210
Here we're doing the same operation multiple times. Now, let's open this box again. We see inside this box we have another box. Now let's open this box again.

7
00:01:39,540 --> 00:01:56,460
Finally, we find it awesome gift. And this is amazing gift gold ring. So here what you understood. We understood that we're performing the same task multiple times with different inputs.

8
00:01:57,180 --> 00:02:10,510
And in each step we try to make the problem smaller. We're opening the box. We're opening the box, OK? We're doing the same task. We must need to have a base condition who is still the system, when to stop the recursion.

9
00:02:10,710 --> 00:02:27,300
So this is our base basket. So this gold ring is the basket. So we're repeating same task multiple times in every step with a different input. So we're making our problem smaller.

10
00:02:27,300 --> 00:02:41,230
In is EZchip and this is our best condition. When you find out our gold ring, we will stuff. And this is exactly similar to recursion. Now let's try to understand recursion with Coey.

11
00:02:41,590 --> 00:02:51,770
We are given a binary search and we want to search a value in this one resource. This is the algorithm to search a value in this one. It is our street.

12
00:02:52,500 --> 00:03:07,670
This method takes two parameter route and developed inside here. You've really got to know all now this is base condition. Or if you go to value, if the value of Ruggeri goes to the given value will return the root root route.

13
00:03:08,310 --> 00:03:20,520
We're checking if the value is greater than value, then we'll call it the lips of the rights of. Let's say we call this method with the root eight and with the value six.

14
00:03:21,240 --> 00:03:33,240
We preserves the value six. In this one, it is considered Rudys Records to know and it is not equal to six. And we see the value is greater than the given value.

15
00:03:33,240 --> 00:03:45,150
It is greater than six. So let's call it let's through with this subtree, we see that three is not equal to six and three is not null for the recursive call.

16
00:03:45,420 --> 00:03:57,090
Now we're going to check does that well is greater than Harlow. No. Three is not greater than six. So let's call it. Right. We disagree. We have only one node here and here is a six equal to six.

17
00:03:57,390 --> 00:04:11,760
So we will return the node six. In fact, in this code, we have our best condition. This is our best condition. If records to know the whole region, no else.

18
00:04:11,760 --> 00:04:29,400
If you did not develop, then will return the root. This is our base condition here. We saw that in every step we try to make this problem here. We are doing the same operation multiple times with different inputs.

19
00:04:29,460 --> 00:04:41,460
OK, so here we are doing the same operation with different inputs and in every step we try to make the problem smaller. So in every step we are making that problem smaller.

20
00:04:41,820 --> 00:04:52,380
First we call with the entire tree. There are three that we call with the right center and we must need to have it base condition. And this is our base condition.

21
00:04:53,440 --> 00:05:14,620
We have understood what is recursion and how it works. Recursions, internal uses is. For recursive function call now let's talk about what we should learn, recursion, recursion makes it easy to write compared to iteration with a given problem can be broken down into smaller problem.

22
00:05:15,050 --> 00:05:30,140
It is heavily used in tree graph, etc., and recursion, heavily used in techniques like divide and conquer, dynamic programming. There are many use cases of recursion in this course.

23
00:05:30,710 --> 00:05:45,560
We saw a lot of algorithms uses recursion. We have understood what is the recursion and what you should learn it if you have any. If you understanding this redistribution or if have any suggestion, let us know.


@@@
1
00:00:00,600 --> 00:00:15,320
We'll come back to this video in this video. We're going to talk about formate of Precursor, we have to guess for recursive function biscuit and recursive kit biscuit is the kit called.

2
00:00:15,330 --> 00:00:42,170
The function does not recur. That means where the function of recursive kit is the kit, the function recor support recursive function will have to kiss a biscuit and recursive katch the function of at biscuit and the function will calling the function for recursive kit lettieri undefined at the factor of five.

3
00:00:42,360 --> 00:00:55,050
How can find it. Factorial of five will call recursively something like this. Factorial for factorial three federal two factorial one. And this is our base kit for factorial one region one.

4
00:00:55,170 --> 00:01:06,660
Then we'll have two times. When he goes to do so for two, it will return to them. Three to six Morphettville three to return six. Six term four equals to twenty four.

5
00:01:06,870 --> 00:01:19,230
So four factorial four. It will return twenty four. Twenty four times five equals to one hundred twenty and that will return to factorial five. And this is the format of recursion.

6
00:01:19,420 --> 00:01:31,800
This is the biscuit and we're calling recursively federal, four federal, three federal to this are called recursive kit and this is the code to find it factorial of it.

7
00:01:31,800 --> 00:01:43,080
No, this is Biscuit and this is our recursive git in terms material and minus quite understood. What is the format of recursion. Thanks for watching this video.


@@@
1
00:00:00,600 --> 00:00:14,230
Here you are, two guys will come back to this video in this video. We're going to talk about how recursion works internally. Recursion is a process in with a function call itself directly or indirectly.

2
00:00:14,760 --> 00:00:30,060
This is the formal definition of recursion for recursion. We have to kasit base case and recursive case and we'll talk about that in this video. We're going to talk about how recursion works internally.

3
00:00:30,660 --> 00:00:40,440
Recursion uses its tech data structure for recursive function call. Now let's see how function color works. We have this main function inside this function.

4
00:00:40,470 --> 00:00:55,890
We call another function for inside this function we call another function bar and this is bar function. And inside this bar function we printed and var how it actually works in the stack first.

5
00:00:55,920 --> 00:01:16,400
This main function is to when we call this main function inside this function we have four. So before printing, I mean so it will call this function for so full get placed in that stack memory inside for we have another function bar before executing this print we have to call this bar function.

6
00:01:16,470 --> 00:01:31,110
So bar function get placed into a stack, then inside this bar function it will just print and then this bar will be popped out from the stack. Then it will move to this printed statement.

7
00:01:31,140 --> 00:01:46,710
Since we're done with this function call now it will print. And so now for this main function, the function popped out from the stack. So this function call is done, so this function has been executed.

8
00:01:47,460 --> 00:02:00,000
Now let's go to the next line. This each print so it'll print. I am me and this is your function. Call works and function uses is tech. Now let's see how recursive function works.

9
00:02:00,900 --> 00:02:09,900
Let's say we want to find out factorial of a given integer and this matter takes one parameter in inside inserting what, if any, goes to one that will region.

10
00:02:09,900 --> 00:02:21,540
One else will return in times factorial in minus one. And here we're calling this function recursively and this is based conditio and this is recursive conditio.

11
00:02:22,050 --> 00:02:34,310
Now let's see how it works. If we not know, let's see how it works. If we call factorial five, then the federal five will get placed into a stack. All right.

12
00:02:34,500 --> 00:03:02,580
And here the order of recursive function call first. We call it four five, then five times four in four times, three in three times federal, two into those federal one first five get placed into stack memory, then factorial four, then factorial three, then factual to the real one and aracy for this function, call it match that base gets so it will reject one.

13
00:03:02,820 --> 00:03:18,780
So two times only goes to two. So for this function call two it will return to So Pacula on its popped out from Stack Now let's calculate the value Veliz two times to go to six so six will be returned to this function.

14
00:03:19,530 --> 00:03:30,450
So this material will be popped out from Stack and four times it goes to twenty four and this twenty four over return to this function call factorial four.

15
00:03:31,140 --> 00:03:43,560
So this is proctored and federal for region twenty four. Twenty four times five. Close to one hundred twenty here factorial for region twenty four and five times twenty four is only twenty.

16
00:03:43,560 --> 00:03:55,520
So federal five. Region one hundred twenty. So finally the result of federal five is on the twenty. This is how this recursion works and this is what we can find.

17
00:03:55,520 --> 00:04:11,730
It factorial of a number of recursive function called works of. If understood how recursion works internally. The time complexity for this function call is big arfin and the space complexity is bigger of in as well for the recursive function called stack.


@@@
1
00:00:00,600 --> 00:00:13,100
Hey, you, what's up, guys? Welcome back to this video in this video. We're going to solve a problem. You want us to see Rich using recursion if necessary, which is a list of numbers.

2
00:00:13,620 --> 00:00:27,550
The first two number is one. Then the next number is generated by adding the previous to number one. Plus one is two. Two plus one is three two three five five plus three is eight and so on.

3
00:00:27,840 --> 00:00:44,010
Now we have to implement a method five that will take an integer and return the imp to A.C. number from people necessary. Let's see how this is the code to find out.

4
00:00:44,490 --> 00:00:59,760
And if you want to see number, this method five takes one parameter in as input inside here we're checking it in is greater than or equal to three. Then we will return by adding 15 minutes.

5
00:00:59,760 --> 00:01:14,830
One plus 15 minutes to another is already in one here. This is our base and this is our recursive gate. Now let's see how it actually works. This is going to be a little bit critical to understand Daury.

6
00:01:14,850 --> 00:01:29,730
I'll explain everything. So if we call this fifth method with five that up to find out the fit if you want to see number four. So the fifth number in this will be fine.

7
00:01:30,180 --> 00:01:43,890
So if we call five five, then it should return five. But how each region five. Now, let's find out here have region five in Manasquan. So let's go to the left for now.

8
00:01:43,890 --> 00:01:57,920
Let's go to the left again until we hit this base conditio. Let's go to the left again. And here we see in is greater than equal to three. This collision force two is not greater than equal to three.

9
00:01:58,230 --> 00:02:12,720
So it will return one. This is base gate. So we're done with this function. Call for three. Now, let's call now let's call this function 15 minutes to there is 15 minutes to one five.

10
00:02:12,720 --> 00:02:25,260
One will return one because this is base condition and will add these two on and on and on. And that to this five three. So let's return here to so we're done with this function.

11
00:02:25,260 --> 00:02:38,020
Call five minutes, one, four, five, four. Now let's go to the right. That means to this function call in minus two and that is five to this function call will hit this biscuit's.

12
00:02:38,050 --> 00:02:50,780
So it will return one, two plus one is three here. Old Britain three. So we're done with this function. Call four to five. Now let's go to this function call in Minnesota.

13
00:02:51,210 --> 00:03:05,040
So five a.m. is five ministries, three. So we have three. This function call will not eat the biscuit. Now let's call five one for this five three. Here we have two.

14
00:03:05,040 --> 00:03:16,770
So let's return here one now. Let's go to the right. That means to dysfunctional for this three here we have five one. It's all written here one. So one plus one is to here region two.

15
00:03:17,130 --> 00:03:30,440
And finally will region three plus two, that is five. And this is what we can find it in number from people. It is recursion. We have understood how to find out in three minutes.

16
00:03:30,460 --> 00:03:41,250
Number from people necessary. Now let's take another example for a better understanding. Now let's call this five function with six that we have to find out the sixth number from.

17
00:03:41,260 --> 00:03:53,070
If you want to search there is eight. So let's find out this number eight using this code now we're going to call fifteen minutes, one recursively until we hit this basket.

18
00:03:53,400 --> 00:04:07,680
So five, five, then five, four, then three, then two. So this hit the biscuit. We really don't want no, let's call this five minutes, two, four, five, three.

19
00:04:08,160 --> 00:04:22,410
So we get five one. It will return one as well. So one plus one is two. So we're done with five minutes. One, four, five, four. No, let's go to the minutes to four people and this age fifteen.

20
00:04:22,410 --> 00:04:32,520
So it will hit the space, get to it will return what. One plus two is three. So dysfunctional will return three, four, five, five. We're done with this.

21
00:04:33,000 --> 00:04:45,090
Fifteen minutes on. Let's call fifteen minutes to. So we get here five three. Now let's go to fifteen minus one and this one will hit the basket so it will return on this function.

22
00:04:45,100 --> 00:04:56,610
Will, will hit the basket since it goes to two. So it will return on. No let's call it minutes to four with three so we get five one it will return on as well.

23
00:04:56,730 --> 00:05:10,110
So one plus one is two, two plus three is five. Now, let's call in Minnesota for five, six, five, four, no, let's go to let it three again. Let's go to let's say to Sweden, region one.

24
00:05:10,350 --> 00:05:21,110
That's good, right? It will region one as well to one plus one is two. Let's go to right for free for that means to 15 minutes to get to. So it will begin on.

25
00:05:21,120 --> 00:05:35,870
So two plus one is three, two plus five is eight. So for this function call five six, all region eight. This is how this could work and this is what we can find out in severity number from people as hope.

26
00:05:35,990 --> 00:05:48,210
We have understood how recursion work. This recursion call three in this code. We are repeating the same task multiple times here. We have calculated the value four, five, three.

27
00:05:48,390 --> 00:06:16,710
Here we are calculating again here we've calculated the value for free for here we're calculating again. We can reduce the function call using dynamic programming if we apply here dynamic programming that will not have any repetition of function call and that will talk about in dynamic programming section of this course what we have understood how to find out in a few minutes, a number from a few minutes.


@@@
1
00:00:01,290 --> 00:00:16,640
Hey, yo, what's up, guys? Welcome back to this video. In this video, we're going to talk about recursion versus iteration. For recursion and iteration, let's find out first speed, efficiency and time efficiency for recursion.

2
00:00:17,500 --> 00:00:37,020
We have to call a function recursively. We have to add element on its deck and we have to remove element from a stack. And that takes some amount of spit in the memory for recursion, OK, and for iteration, it will not take any extra switch for a time efficiency.

3
00:00:37,870 --> 00:00:54,010
We have to add element on a stick and that will take sometimes I call the function recursively that takes sometimes, but for loops it takes less time than recursion for space efficiency and time efficiency.

4
00:00:54,400 --> 00:01:07,690
Iteration is the winner for is a code. That means when we have problems, the problems can be broken down into smaller sub problem. And that is called is code.

5
00:01:08,230 --> 00:01:24,170
To solve the problem. The recursion is recommended. Her division is not for is a code. Recursion is that we're now going to use recursion and point average recursion.

6
00:01:24,310 --> 00:01:39,510
Now let's talk about that. To when we can easily break down a problem into a similar problem. Then we should use recursion when you're OK with extra overhead space and time.

7
00:01:39,690 --> 00:01:56,000
OK, the space, complexity and time complexity. Then again, consider recursion when you need a quick working solution instead of efficient one that we have to use recursion now hoping to avoid recursion.

8
00:01:56,970 --> 00:02:10,230
If the response to any of the above statement is no, then we should not go with recursion. In that case, we should consider iteration that meant loops.

9
00:02:10,790 --> 00:02:24,770
So we have to use recursion when we can easily break down a problem into smaller problem and we are OK with extra overhead. And for a quick solution, we should consider recursion.

10
00:02:25,640 --> 00:02:43,580
Now let's see some practical uses of recursion stack tree sorting algorithm quicksort, my sort or soul searching, insertion, deletion, divide and conquer, dynamic programming, a graph, etc..

11
00:02:44,240 --> 00:03:01,790
There are many use cases of recursion, recursion almost mandatory for tree problems, and there are many use cases of recursion. We already saw a lot of recursive function in this course.


@@@
1
00:00:00,690 --> 00:00:16,260
Hey, you also, guys, welcome back to this video in this video, we're going to talk about what is hushing hashing is a method of indexing data. The idea behind the hashing is to allow a large amount of data to be indexed using case.

2
00:00:17,580 --> 00:00:29,790
The most popular use for hashing is the implementation of hash. Stable hashing is commonly used for password verification or for password authentication.

3
00:00:30,870 --> 00:00:47,880
Now you might think what we should learn hashing. We have a lot of different data structure. Added It is doctors will takes logarithmic time complexity for finding an element in a sorted area in link list.

4
00:00:47,930 --> 00:00:58,970
It all takes linear time complexity for a tree. It will takes longer to make time complexity. It takes a lot of the time complexity for a binary society and for every tree.

5
00:01:00,050 --> 00:01:17,480
Here we see at the end, you will takes longer to make time, complexity and link list. All takes linear time. Complexity or hashing will takes for the best cases, constant time complexity and for the worst cases it will takes linear time complexity.

6
00:01:18,650 --> 00:01:34,220
This is why we should learn hashing. Hashing all takes constant time complexity that super efficient for the best case, which we can assume on average cases, hashing will takes constant time complexity.

7
00:01:34,550 --> 00:01:47,720
So we see that constant time complexity is way more better then. Well, what are the three time complexity? For this reason, we should learn hashing. This is an array of length.

8
00:01:47,750 --> 00:02:00,200
16. We have index number from zero to 15. Let's say we want to store the string every CTF and X widget in this area and what it will do, what you will do.

9
00:02:00,200 --> 00:02:14,060
It will store this twisting in this area. And if you want to find a dusting, you'll scan the whole array to find it the string every c d f or excited so it can store the string into this array.

10
00:02:14,330 --> 00:02:33,860
The search operation will 2x linear time complexity, but using a hashing we can find the string in the array in constant time for the average cases. First thing what I'm going to do, I'm going to find it an integer value from this string.

11
00:02:34,130 --> 00:02:45,500
For that, we will call a hash function with this tree. Let's say the hash function will return six for this string and for four sting. The hash function will return.

12
00:02:45,920 --> 00:03:03,470
15. And for the string, the hash function will region 11. Now what are you going to do or going to store? If you see at Index six in this area and you're going to store this string at Index 15 and you're going to store these String X widget at Index 11.

13
00:03:03,740 --> 00:03:14,960
Now, if you want to find it the element, if you see first, what are you going to do? We're going to find out the hash value of this string. That's all we want to find out.

14
00:03:14,960 --> 00:03:25,790
If we see first what you will do, it will find it the hash value four. If you see when you call this string with hash function, then the hash function already has value.

15
00:03:26,360 --> 00:03:41,270
So we find it here. The Hizbul is six and we're going to move at index six in this area. Now we're going to look up at Index six in this area, and we're going to compare this to elements every C and here we see every C and we see are the same.

16
00:03:41,360 --> 00:03:53,920
So we'll region two because we found the element in that area. And this is called the hashing data structure. This hashing is widely used in the real world.

17
00:03:53,930 --> 00:04:04,940
The hashing function is way more complicated, but the core principle is the same here. How we're finding out this hash value. We're using a simple function.

18
00:04:05,240 --> 00:04:28,850
We're passing this string into the hash function, and we're adding all the asking value for the character in the strings. We're adding to ask you a love, plus the estimate of B plus the symbol of C, and we're going to calculating the mode for the submission of to ask you about and you'll see how we are calculating this hash value.

19
00:04:29,060 --> 00:04:37,700
We'll see a simple hash function, but in the real world, the hash function is way more complicated. In the next video, you'll see hashing terminology.

20
00:04:37,820 --> 00:04:48,860
Hash function has value collision. Now let's talk about application of hashing. Hashing provides constant time, search in search and do the operation on average.

21
00:04:49,490 --> 00:05:05,720
This is why hashing is one of the most used data structure. Example problems are distinct element counting frequencies of items, finding duplicates for solving these problems or these types of problems, or use hashing.

22
00:05:06,080 --> 00:05:26,390
Actually, it was high stimulus to solve this type of problems. The stable uses hashing data structure internally for matters digest. We use hashing. This is an application of cryptographic hash functions, password verifications for password verifications or use hashing.

23
00:05:26,690 --> 00:05:46,310
Cryptographic hash functions are very commonly used in password verification. Compiler operations uses hashing the famous Robin Curve algorithm uses. Rushing, linking file him and pats together on a PC or computer uses hashing data structure.

24
00:05:46,610 --> 00:05:58,700
No, let's see practical uses of hashing. Now let's assume this is Facebook server and this is your computer. Here are trying to logging into our Facebook account.

25
00:05:59,090 --> 00:06:10,310
Let's assume this is your Facebook account. Email This is the email, and this is the password. Now we can store this password into the server. You restore the plain password one two three four five six seven eight.

26
00:06:10,490 --> 00:06:39,590
If somehow server hacked by Hacker Ben Hacker can access our account. And if this is your information for your bank account or online account, if the server get hiked and if the pin password it was stored on the server, then the hacker can access your information and the hacker can steal a lot of lot of money and that's not secured instead of storing the plain password.

27
00:06:39,830 --> 00:06:57,740
What do you do? It will generate high Chevelle low. The highest value for this password is this hash value of him. Instead, storing displaying password all stored this high onto the server when it entered this email and password on your computer.

28
00:06:58,220 --> 00:07:10,820
The password will be converted into the hash fellow by a hash function, and you can access the account if we enter the correct password. We don't have to remember this hash values.

29
00:07:11,150 --> 00:07:25,760
We just have to remember our password, and this is secured for password authentication. We use this hashing data structure. There are a lot of hashing functions that can generate huge values in the real world.

30
00:07:25,940 --> 00:07:36,190
Hashing functions are way more complicated, but the core logic is the SIM and other popular uses of hashing is how stable has to build in a structure.

31
00:07:36,190 --> 00:07:48,080
It uses hashing data structure internally. Using a high stable, we can make our program super efficient, and there are a lot of applications of hashing to just structure.


@@@
1
00:00:01,260 --> 00:00:15,880
In this video, you're going to talk about hashing terminologies. First, let's talk about the hash function in hash function is a function that can be used to map data of arbitrary site to data a fixed site.

2
00:00:16,780 --> 00:00:28,840
The hash function will takes input from user and it generate hash values from the given token. Now let's talk about the key keys that data given by user.

3
00:00:29,770 --> 00:00:42,910
What is? It has value. The value returned by a hash functions are called Hijuelos hash code desist. Also, it's called simply hashes. What is how stable it is?

4
00:00:42,910 --> 00:00:54,640
A data structure who is implements an associated ARI obstruct due to type a structure that can map key developers. It uses a hash function to compute.

5
00:00:54,640 --> 00:01:10,690
The hash code has double digit structure in the lock. It uses hashing data structure using has table. We can store peer of data on trustable. We can access data on how stable or average in constant time.

6
00:01:10,900 --> 00:01:23,830
And that's super efficient. Now what is coalition for hashing? A coalition, of course, went to different key to a hash function produce the same output called hash value.

7
00:01:24,460 --> 00:01:42,130
If the hash function return, same value or same hash values for different inputs, then it's called collisions per collisions. The hashing data structure rule takes for the worst cases.

8
00:01:42,190 --> 00:02:04,000
Linear time complexity If there is no collision, that it will takes constant time complexity no matter what. In this section of discourse, you'll see how to reduce collisions for hashing data structure, so hash function or index key as input and written hash value.

9
00:02:04,630 --> 00:02:19,380
If hash function return SIM has value for different inputs, then collisions are right and we have to. It is a collision for the aptitude, a good hash function in the collision resolution techniques.

10
00:02:19,450 --> 00:02:31,150
VIDEO We'll talk about how to handle collisions when a hash functions a return. SIM has four different inputs in the next video or going to talk about hash function.


@@@
1
00:00:00,730 --> 00:00:10,260
Here you are, two guys all come back to this video in this video, you're going to talk about harsh Russian. This is a simple hash function, dysfunction takes two parameter.

2
00:00:11,530 --> 00:00:33,760
Is string is and an integer in here or converting the string into character area? And here isn't this variable. We're adding the ask you value for the character in the given string and here recalculating the ASCII value using this formula after calculating the asking value.

3
00:00:34,100 --> 00:00:52,870
We're returning some modulus in. This is the simple hash function. Now let's assume this is an area of Lent 610. We have here index from zero to 15 for string every C for string DFA and four String X widget.

4
00:00:52,910 --> 00:01:12,320
If you call, if you call this hash function or string ibs-c and six, then it will return six. Because with this string and constant value 16, it will return Putin and four x widget into a region you live in here.

5
00:01:12,350 --> 00:01:34,870
We call this function house function. It's return. Six. Now let's see how it's done. Six. First, we add the ASCII value for it, for B and for C. So sixty five is asking for ID, sixty six for B and 67 for C if we add all decimal yet 198 198 model of 16 equal to six.

6
00:01:35,350 --> 00:01:48,970
So for this input, this 106 for this string D, if it's fifteen, now we find out in number six. Now what are we going to do? We're going to insert this string at Index six in this area.

7
00:01:49,090 --> 00:02:02,870
So let's insert here. Now, let's call this function with D F and 16. It's 15. Here we're adding the asking value. Ask him in order six to eight. Ask him enough is six tonight and ask him an off if he's 70.

8
00:02:03,420 --> 00:02:15,730
If we had basketball, we get 207 207 more or less. 16 equates to 15. If you don't know what is asking Malone, asking value is a value behind is key on a keyboard.

9
00:02:16,120 --> 00:02:27,100
For all the characters we have, ask you below, you're going to see the ASCII table then charts in Google ASCII Table four. We have asked you a lot. Sixty five for B, we have asking about No.

10
00:02:27,370 --> 00:02:40,360
Six two six four lowercase. It will have a different ask you feel for is key on a keyboard. We have asked you value. If you want to see the list of ASCII value, just search on Google.

11
00:02:40,720 --> 00:02:51,890
Table of ASCII value many will see the list of ASCII value. This is ASCII table. Here we have ASCII value for each character. Here for ABC, for uppercase ABC.

12
00:02:51,910 --> 00:03:03,130
We see here you are six two five six two six six two seven four dd. If you see the ask you over here six two eight six three nine seventy and four x widget, we have it here.

13
00:03:03,130 --> 00:03:22,210
Ask him how long a date? Eighty nine and ninety. Now here we find out the index, an integer fifteen from this function. This is hash value. Now we're going to insert this string at Index Fifty, so let's insert here DCF now let's call with X widget.

14
00:03:22,540 --> 00:03:35,590
The value of X is eighty eight. As Kevin, what is 89 as giving up is 90. If we add old, ask him a lot. We get two six seven two six seven 16 year olds to Iran.

15
00:03:35,950 --> 00:03:51,280
We find out here has value you live in for. This is string. So let's insert rated at Index 11. Now, if you want to check, does this string diff exist or not, you know our hashing data structure.

16
00:03:51,310 --> 00:04:07,150
First, we're going to call hash function with this string the if and with the value sixteen that will find out the value fifteen, the right index moved in, all going to take those at index 15.

17
00:04:07,160 --> 00:04:24,540
We have that string the f we see here. Yes, we have D. If so, let's return it to or something like that. So we encoded the strings into this integer and we stood the string at this index.

18
00:04:24,550 --> 00:04:35,320
OK, this is the concept of hash function in the real world. Hash function is way more complicated, but here we're showing you the simple, simple example of hash function.

19
00:04:35,680 --> 00:04:49,090
The core logic is the same. This is the core logic of a hash function. This is how hashing data structure works so we can look up at data on hashing it a structure in constant time on average.

20
00:04:49,150 --> 00:04:59,110
Now let's take different inputs for testing a will for string and for a string ADC forever, so it will return to four executable written two and four.

21
00:04:59,110 --> 00:05:10,930
It is a it will return to. So for different inputs that we find it sim hash values now, or we should storyville what we should store key and how we should store it is now the problem.

22
00:05:11,010 --> 00:05:21,060
Arrays here. Let's see how we can find it to ask you, will you be call this hash function with Will and with the constant five it will return to and this is how it's returning to?

23
00:05:21,110 --> 00:05:32,400
Here we have added all to ask you to look for the character reveal and we are finding the models for 207 and five. We find her too. We're going to insert ivill at Index two.

24
00:05:32,480 --> 00:05:46,820
Now you call hash function with this string, then you find it to know where you should insert this string SDK. And also, if you call this function with ADC and five, it's prudent to know what you should insert added.

25
00:05:47,070 --> 00:05:57,240
We already have an element at Index two. This sport is occupied already, or you should insert card and Hauner should insert EDC, and this is called collision.

26
00:05:57,330 --> 00:06:07,630
They're trying to GWAS on a SIM index. This is a coalition now where you should insert this three strings for that. First, we have to understand coalitions.

27
00:06:07,920 --> 00:06:20,310
What these two strings should goods where you can place this toasting SDK and ADC in order to understand that. First, we have to understand the collision resolution techniques.

28
00:06:20,550 --> 00:06:31,910
In the next video, we'll talk about collision resolution techniques. Now let's talk about the properties of a good hash function. The properties of a good hash function, it should uniformly distribute Hijuelos.

29
00:06:31,950 --> 00:06:42,270
It should be easy to calculate. It should minimize collisions, and it should result any collisions. These are the characteristics of a good hash function.


@@@
1
00:00:00,570 --> 00:00:15,360
In the previous video, we saw that we have inserted the string at Index two, but we're not understanding how they should insert insecure and edges. This is happens because of collisions.

2
00:00:16,260 --> 00:00:27,390
Now we have two result collisions. Now let's talk about collision resolution techniques. We can solve this problem in three ways. Now let's talk about that one by one.

3
00:00:28,230 --> 00:00:38,070
Now we're going to talk about collision resolution techniques for collision resolution techniques. We can solve the collision using this direct training.

4
00:00:38,280 --> 00:00:47,700
And you can solve collision resolution using open addressing for open addressing. We have three ways linear proving, quadratic probing and double hashing.

5
00:00:48,390 --> 00:01:06,600
First, let's talk about direct training. We'll talk about linear probing, quadratic probing and double hashing. What is direct training retraining? Implement the buckets as linguist colliding elements are stored in this list.

6
00:01:07,530 --> 00:01:22,650
Here we have four string every k-ville. Here it is. And here we have an array of length. 16. Now let's talk about direct training. Now let's see how direct training works.

7
00:01:23,160 --> 00:01:34,500
Let's say we are given this string. So we call a hash function the hash function return. This has value one. We're not going to insert this string at index one instead.

8
00:01:34,560 --> 00:01:46,830
We're going to create a link list at index one. Let's create a linguist here, and let's insert this node at battling list. So here we have a now long list.

9
00:01:47,190 --> 00:01:58,980
Now we're going to insert in node and in that node, insert this string. Now let's say we created this node with address one on one. We have here this is string and in null pointer.

10
00:01:59,790 --> 00:02:16,920
Now we're going to store the referent of this link list here. So we're going to string this address so it will be represented something like this. If we find it, the hash functions return the same value one, we will add the string to the next pointer of this node.

11
00:02:17,160 --> 00:02:28,710
Now for this string it's written to. Now we're going to create and not every ill and we're going to insert that at Index two. And here we're going to store the reference that pins the address of this note.

12
00:02:28,890 --> 00:02:41,610
That is 01:58 So let's insert here 2-2-2, then it will be represented something like this. Now our next string is insecure. Now our next string is a secure its root in the house relata.

13
00:02:41,880 --> 00:02:55,650
We saw that the index two already occupied by the string every. Now what I'm going to do, I'm going to create a new node and I'm going to add the referent of this node here.

14
00:02:56,010 --> 00:03:08,130
So we're going to add this node as the mixed node of this node. So it will be represented something like this. Now for this string, we saw that it's written the highest value, too.

15
00:03:08,610 --> 00:03:19,710
We saw that indexed to already occupied by some elements. Now what are you going to do? We're going to create a new node and we're going to add this node as the next node.

16
00:03:20,250 --> 00:03:29,370
So we're going to store this reference here. So we're going to adding this node as the next of this node. So it will be represented something like this.

17
00:03:29,790 --> 00:03:42,270
And this is called direct training. Let's say you want to find out the string exec here will return to this string, eg just in our hashing just structure for what you will do.

18
00:03:42,420 --> 00:03:52,170
First, we'll call a hash function, the hash function will return to. Now we're going to look at Index two. Here we see the first element we have in this, not every.

19
00:03:52,170 --> 00:04:11,820
So that's not equal energy. Now we're going to move to the next node and that is here. Here we see psyche. So we find out this is string for the worst case, it if a collision happens, the second operation will decrease because in time complexity, that is the worst case for the best kids.

20
00:04:12,150 --> 00:04:37,320
On average, it will takes constant time complexity. If you want to find out this is string, it will return. The has one and you can look up at index one, and that is every key if you want to find this value, if you will, then if you call hash function with this string, the hash function or alluded to at index, we see that first element is if you so you'll region two.

21
00:04:37,680 --> 00:04:52,470
So on average, it will takes constant time complexity. Now let's talk about open addressing poor open addressing. We have three ways to resolve a collision linear probing, quadratic probing and double hashing.

22
00:04:52,500 --> 00:05:06,500
Now let's talk about linear probing what is open addressing in open addressing colliding elements are still. In other vacant brackets, it will not store multiple element on the same spot like direct training.

23
00:05:06,770 --> 00:05:20,660
So we're open, we can use the back packets. Now let's talk about linear probing. Linear probing is a strategy for resolving collisions by placing the new key into the closest falling empty cell.

24
00:05:21,440 --> 00:05:31,890
Let's see how it works. Now we're going to talk about linear probing. First, we have this string. Now, what are you going to do? We're going to find out the highest value by calling a hash function.

25
00:05:31,910 --> 00:05:42,500
So hash function only one at index one, we're going to insert every key. So let's insert your MBK now for this string, because the hash function, the hash function, or Luyanda has value too.

26
00:05:43,400 --> 00:05:54,260
So what are we going to do? We're going to insert this well at Index two. We see that select index is empty, so let's insert the string here. So let's insert.

27
00:05:54,440 --> 00:06:08,570
We'll add index two. Now we have the string ethic here. Here we see it be called hash function. The hash function will return to at index. We have already an element, but index to is already occupied.

28
00:06:09,290 --> 00:06:19,100
So what are you going to do? We're going to move to the next hill. I'm going to take the mix. So if the mixed fill is empty, we're going to insert Asuka in the next few.

29
00:06:19,310 --> 00:06:29,450
Here we see the cell is empty at index three. So let's insert here, Ezike. Now, let's see. We want to insert this string. We because the hash function.

30
00:06:29,960 --> 00:06:41,090
If the hash function region two, we're going to insert two at index two. But we saw that the index two already occupied by an element. Now what are we going to do?

31
00:06:41,390 --> 00:06:51,950
We're going to move to the next cell. We're going to take the next two. We see the next cell is not empty, so we're going to move to the next. And here we see an index for this cell is empty.

32
00:06:52,160 --> 00:07:04,370
So we're going to insert a digit right here. And this is called linear, proving your current cell is empty. We're going to find it the closest avec un cell, and this is called linear probing.

33
00:07:04,970 --> 00:07:16,670
Understood what is linear, probing in linear probing or going to find it the closest back to the sport. If you find it vacant spot, then we'll insert that string or that data.

34
00:07:17,150 --> 00:07:34,010
Now let's say we want to find out this string. You know what hashing you to structure if this string exists, leading to others already unfolds. First thing what you will call a hash function or the string and the hash function alluded to if the hash function will return to what do you do?

35
00:07:34,040 --> 00:07:44,970
We will move that index to in this area at index. We have this element of you now. What are you going to do? We're going to check this element editor and Erbil, and they are not equal.

36
00:07:45,410 --> 00:07:57,250
Since this is linear probing, we're going to move to that mixed cell. Mixed still is key, but this is ADC. So let's move to the next to the next cell is the cell.

37
00:07:57,260 --> 00:08:10,730
Here we have ADC. So you found it is it will return to for the or circuit. We have to traverse the entire hashing data structure and that all takes off in time.

38
00:08:10,730 --> 00:08:29,180
Complexity of it understood what is linear probing and for this is string and for this key resource distrusting that it will return true in constant time at index when we have it and at index two, we have review so we can search this twisting in constant time.

39
00:08:29,870 --> 00:08:40,590
Since we have a collision, it might fix linear time complexity and this is the worst catch hope we have understood what is linear inappropriate. Now let's talk about quadratic probing.

40
00:08:40,610 --> 00:08:55,610
What is quadratic probing? Quadratic probing operates by taking the original hash index and adding successive values of an arbitrary up an arbitrary quadratic polynomial until an open slot is found.

41
00:08:55,940 --> 00:09:13,580
This is the definition of quadratic probing. Now let's see how quadratic probing works. And so we have this first string encoded probing quadrant. It was this polynomial formula for the quantity coming or going to use this polynomial one squared, two squared, three squared, four square R2 and square.

42
00:09:13,670 --> 00:09:23,300
Now let's insert this string. Well, let's say we want to insert this string into our hashing data structure. First thing what I will do it will call a hash function, lets a hash function region one.

43
00:09:23,450 --> 00:09:33,050
So at index one, we're going to insert this string because at index one, we see empty spot. So let's insert bucket at index one. Now you want to insert this string.

44
00:09:33,050 --> 00:09:42,080
If you if you call the hash function or the string of U the hash function unladen two. Now at index two, we're going to insert this string at Index two.

45
00:09:42,110 --> 00:09:53,380
We see we have empty spot. So let's insert the Ehlert Index two. Now we want to insert this string. If we call hash function, the hash function will return to the hash function alluded to.

46
00:09:53,450 --> 00:10:04,790
We see that at Index two, we have an element already, but Index two is already occupied. Now we have to resolve coalition here because we found coalition inequality growing.

47
00:10:05,090 --> 00:10:14,920
What do you do? We will add one square to the returning wall over the hash functions when the coalition accord. So we're going to add two and one square we get here.

48
00:10:14,930 --> 00:10:30,410
Three. Now let's check at index three. We see we have an empty spot. So let's insert here is key. Now let's say we want to insert this string ADIZ. If you call hash functionality hash function, read him to add index to what we have already and eliminate.

49
00:10:30,560 --> 00:10:41,620
So we find it coalition here. Now what I'm going to do, I'm going to add one square to this region of yellow, one square plus two is three and index three.

50
00:10:41,630 --> 00:10:52,970
We see we have an element. So we're going to take the next element. So we're going to take two square from this polynomial. Now we're going to take two square and we're going to add the region, followed by the hash functions.

51
00:10:53,120 --> 00:11:02,750
So two plus two a square records to six. Now let's check at Index six. We see Add Index six. We have an empty spot, so let's insert here the string integer.

52
00:11:03,050 --> 00:11:15,230
Let's say we want to insert another string a let's do you want to insert another AEI? I call hash on the string all region two we see at index two. We have already at Element.

53
00:11:15,470 --> 00:11:23,700
So we cannot insert here two by quantity. Probably. Let's resolved this coalition. Now we're going to add one square to two. We get three at index three.

54
00:11:23,720 --> 00:11:34,790
We have an element so we cannot insert here. Now let's stick to square and let's add two score and two what we get. Six at index is we have an element so we cannot insert here as well.

55
00:11:34,880 --> 00:11:43,460
Now we're going to take this three square and we're going to add two square to this rather two. So we get either in my right index in the bin. What are we going to do?

56
00:11:43,520 --> 00:11:55,940
We're going to insert this element. So let's insert here because here we have empty sport. This is how quadratic probing works. Now let's see. We want to find out this string in our hashing, you the structure.

57
00:11:56,000 --> 00:12:05,150
And here we're using quadratic probing for coalition resolution. Now what I'm going to do, I'm going to Typekit Index to add index to what we have, if you will, is not equal to air.

58
00:12:05,180 --> 00:12:14,690
Now we're going to take the first 12 here, and we're going to add it to this to add an X three. We have a DC that's only go to air. Then we're going to take two square to score.

59
00:12:14,690 --> 00:12:27,780
Plus two equals two six at index six. We have it. Is it is. It is going to go to AA, though we're going to take the next from polynomial that is three squared, two plus two is going to go through, you know, metric at eleven.

60
00:12:27,830 --> 00:12:40,340
We see a we find it a high school reading too. This is what we can source an element in hashing to just structure when we're resolving using core rip-roaring understood quantity properly.

61
00:12:40,400 --> 00:12:53,420
Now let's talk about the last one double hashing. What is double hashing interval between probes is computed by another hash functions. So in double hashing, we use another hash functions.

62
00:12:53,600 --> 00:13:02,930
So in double hashing, we'll use PU Hash Russian to resolve the collision. Well, let's see how we can do that. Now, let's assume we want to insert the string every K.

63
00:13:03,170 --> 00:13:14,330
If you call the hash all function, then let's say you 201. If it's student one and at index one, we see empty spots. So let's insert here it became. Now we want to insert a bill.

64
00:13:14,810 --> 00:13:25,700
We call this hash one function. Then to add index two, we have to support select insert here every now. We want to insert SDK B call hash unit function.

65
00:13:25,940 --> 00:13:36,380
Let's assume it will return to. If it will return to what I'm going to do, I'm going to check out in the street. We see Index two is already occupied by an element, so we encountered collision.

66
00:13:36,410 --> 00:13:51,140
Now we're going to call secondary hash function. Let's call a secondary hash function has two. Now we're going to call another hash function with this string SC Q Let's assume this function a region for this is hash to function and this is a hash function.

67
00:13:51,380 --> 00:14:02,510
Now we're going to apply this Formula two plus items for the value of eyes one two three up to N. Initially, I got two one. So we get two plus one times pretty close to six.

68
00:14:02,690 --> 00:14:14,880
Now we're going to check at index six and indexes. We see we have an empty spot. So let's insert here. Okay, now we want to insert this string into hashing through the structure for that.

69
00:14:14,900 --> 00:14:24,920
First, we're going to find out the highest value we call this hashing function, and let's say it will return to end at indexed to what we have already and elements.

70
00:14:25,130 --> 00:14:34,040
So we encountered collision again. Now we have to resolve it for double hashing or going to call. Now we're going to call another hash function with ADC.

71
00:14:34,280 --> 00:14:46,190
Let's assume the secondary hash function returns. Four. Now here you'll apply this formula two plus one times where you go to six at index six. We see we have an element.

72
00:14:46,640 --> 00:14:58,460
So we're going to increase the value of IE from one to two. So two plus two times what he goes to 10 at indexed in. We see we have empty spot, so let's insert here it is now.

73
00:14:58,460 --> 00:15:11,250
Let's say we want. To insert this string into the hash, the structure first, we're going to call with Haitian function and let's say Region two, and we see at Index two, we have an element.

74
00:15:11,460 --> 00:15:26,750
So we encountered coalition and we're going to call it has to function. Let's assume the has to function already and for and we're going to apply here, this formula first six four, I got two one at six.

75
00:15:26,760 --> 00:15:38,820
We have an element, so let's increase the runoff. I and we get 10 and at 10, we have an element so he can insert here at 10. So let's increase the value of EI from two to three.

76
00:15:39,300 --> 00:15:50,280
Now at Index 14, we get 14 by increasing the value of EI from two to three to plus three times what he goes to 14. At Index 14, we see we have empty spot.

77
00:15:50,370 --> 00:16:04,980
So let's insert here a we have another string in that string region, two for Hasharon function. And if this has to return for four, the given string. Now what do you do?

78
00:16:04,980 --> 00:16:20,160
It will take six at index six. We have an element at index. We have an element add in exporting. We have an element. Now we'll check add index two plus four times for it goes to 18 and we see this index 18 is out of this has stable boundary.

79
00:16:20,520 --> 00:16:31,020
So what are we going to do? We're going to find it the modulus 18 modulus here. We're going to use 16. So we're going to apply here this formula 18. Maula 16.

80
00:16:31,410 --> 00:16:47,380
And this is what we can swap coalitions using double hashing. We understood that techniques of double hashing. Now, if we want to find out the string API first, what are going to do or what are going to generate the hash value add index to what we see.

81
00:16:47,400 --> 00:17:01,500
We do not have the Element III. We're going to call it this has two function and it's written for we're going to apply. This formula first will take at six in order to get 10, then we'll take at 14.

82
00:17:01,500 --> 00:17:12,840
At 14, you'll find it at unredeemed two. And this is how double hashing works. We have understood how to solve the collision using collation, using double hashing.


@@@
1
00:00:00,450 --> 00:00:09,570
Hey, you awesome, guys. Welcome back to this video in this video, we're going to talk about pros and cons of collision resolution techniques for direct tuning.

2
00:00:10,350 --> 00:00:23,010
We have no fear of adjusting has go back. We don't have to recreate the hashing to just structure, to insert new elements, but we have fear of Big Lindquist.

3
00:00:23,370 --> 00:00:38,790
It might script a big linguist that might cause this the slower time complexity for open addressing. It's easy to implement, but we have fear of adjusting has to brackets markets.

4
00:00:39,000 --> 00:00:56,800
We might have to create new hashing data structure for inserting new data, going to choose the right training and when to choose open. Addressing the input side is not been all it is we should consider open addressing.

5
00:00:56,880 --> 00:01:10,680
And if the deletion is very high, there should always go for direct training. And these are the pros and cons, and we have understood when to choose returning and horn to choose open addressing.


@@@
1
00:00:00,360 --> 00:00:23,880
Now in this video, we're going to talk about what you should do when our hashing due to structure is full. Lets him we have here this six string and let's assume for the string the hash function region, zero for the string hash fractured region, one four distinct, two for the string, three for the string hash function region four and four the string hash function region seven.

2
00:00:24,690 --> 00:00:43,320
In this hashing data structure, we have inserted this five strings every C K L and C K and it is and we see the hashing due to structure is full. We cannot insert new strings to this hashing due to structure.

3
00:00:44,100 --> 00:01:03,600
The string region seven four returning, we can find out this hashing value that might fit in this range of index from zero to four. We can use here Model S operator and a constant integer to fit the seven.

4
00:01:03,600 --> 00:01:18,360
In this wrench in the package, we have to use direct chaining and we have to steward the strings as a linguist. But for open addressing, we have to create a new hashing u the structure of sight.

5
00:01:18,570 --> 00:01:34,380
The double of this existing hashing data structure seem to create a hashing to a structure in order to insert this string for open addressing. Now let's create hashing u the structure of length 10.

6
00:01:34,530 --> 00:01:44,450
The length of this hashing due to structure is five, and the length of this hashing due to structure is 10. Now we're going to edit it through this adjunct instructor, and we're going to find out the index index.

7
00:01:44,620 --> 00:02:01,770
ABC is zero in NIC, so every year is one four eight two four six execute three four added you four. Now you want to insert this string into this data structure, then what do should do?

8
00:02:02,070 --> 00:02:14,520
We should check the index seven. And here we see we have empty spot. So here we can insert the string. So let's insert here. In here, we see that this hashing data structure is exhausted.

9
00:02:14,850 --> 00:02:27,310
We are creating unit a structure. If this structure is full at this point, then I have to create the new hashing to the structure of the Darvel of this existing uder structure.

10
00:02:27,390 --> 00:02:41,970
Here we're talking about this string. If this hashing, this structure is full and if we saw the index that is not fit in this range of index, then what I will do, we will use modulus operator and a constraint.

11
00:02:42,240 --> 00:02:56,520
Let's say, if we use your constant five and we're known as operators have been more or less five equal to two. So in that case, you two moves here. But if we do here open addressing, we cannot blitz at any position because there is no background.

12
00:02:56,520 --> 00:03:23,040
So in this case, we have to insert as the next of this element and all element should stored as a link list. So for open addressing, we might need to recreate the hashing due to structure, but for direct chaining, we might have a long linguist and that's might cause this slower accessing time and that will increase the time complexity.

13
00:03:23,250 --> 00:03:32,130
All right, guys, or we have understood this with the explanation for every question here in this edition or even understanding. Post your question in the Q&amp;A forum, I'll get to you.


@@@
1
00:00:00,420 --> 00:00:10,050
Here you have some guys who come back to this video in this video, we're going to talk about how hash map works internally. Here we declare a hash map method.

2
00:00:10,140 --> 00:00:25,020
String integer math equals two new hashgraph here in this hash map, or you want to store key appears string as key and integer as a value. So old store key value appears.

3
00:00:25,470 --> 00:00:42,900
The default side of hash is 16. Load factor equals to zero point seven five. This is a default load factor and threshold equals to build. Load factor means we can store 70 percent of the given site.

4
00:00:43,140 --> 00:00:59,250
The 75 percent of 16 is built so we can store 12 items in the hash math. The site is 16, but we can store 12 items, so the default sizes 16 and load factor is 0.75.

5
00:00:59,610 --> 00:01:20,220
Load factor 0.75 means we can load data 75 percent of 16. The 75 percent up 16 is Trump. If it raised the load factor, that means if it raised that threshold, then the sage of our hash will be doubled.

6
00:01:20,730 --> 00:01:35,220
If we insert 11 items in the Hashgraph bin, nothing going happens when you insert 12 items in the hash --. The hash mixes will be doubled because here we have a load factor 75.

7
00:01:35,490 --> 00:01:53,550
We can store 75 percent of Sixt in the 75 percent, up 16 is 12. Whenever it erased this threshold, the sage of our hash map will be doubled and the is the internal things we can't see.

8
00:01:53,970 --> 00:02:08,640
When Insert Quilt Item the sage, our hashmi will be doubled. We can specify the site and load factor to this hash map, something like this. Here we're specifying the site and load factor.

9
00:02:08,970 --> 00:02:21,390
Let's say we inserted CC 09:45 and load factor equals to one. So here we can store 100 percent of the site. So here we can. It was 100 percent off sites.

10
00:02:21,390 --> 00:02:34,290
10. So here we get in such 10 items when it raised this threshold. The sage of our hash rate will be doubled. When insert nine items, then nothing going to happen.

11
00:02:34,560 --> 00:02:47,310
When we insert tent item in the Hashgraph, the sage of the Hashgraph will be doubled for this site. Din and load factor goes to one. Well, we understood how hash map works.

12
00:02:47,550 --> 00:03:04,710
Now let's see how it store data and how it's retrieve data. Now we're going to talk about how food method and get method works in hash math. Now we're going to talk about how put and get method work in hash data structure.

13
00:03:05,040 --> 00:03:19,620
Now let's talk about that. One important thing here is that Hashgraph uses hashing data structure. Here we have an array of sites fixed in the default side of hash is 16 year old store linguist.

14
00:03:19,800 --> 00:03:43,380
This is not aria of integers. This is an array of linked list. If we declare this hashgraph, then we will create an area Blinkist off site. 16. Now, if we insert the key AVC end one, then how it will be stored in the hashgraph and how we can get this key value from the Hashgraph.

15
00:03:43,560 --> 00:04:00,870
Now, let's see. First, we're going to generate highest value for this key MVC. And then you'll calculate index of this key using a formula. Now let's see the function to generate hash code or hash value from this key AVC here.

16
00:04:00,900 --> 00:04:11,970
This is the hash grid function. This function takes on parameter string as input inside. Here we are converting the string into character array. Then we have your variable semi-custom zero.

17
00:04:12,150 --> 00:04:27,690
And here using this for all of we're adding the ask you a loop of all characters in the given strings. Here we have character Air B and C, and here we're adding the ASCII of Air B and C, and it will return to ask you to buy this hash grid function.

18
00:04:27,960 --> 00:04:44,190
This is a simple hash grid functions hash uses advanced hash grid function. But here for setting up understanding or assuming we're just returning the sum of ASCII value of all characters in a given string.

19
00:04:45,090 --> 00:04:54,150
Now what are we going to do? We're going to find it indexed using a formula. This is the formula indexed courts to hash courts, key utility and the hash code.

20
00:04:54,480 --> 00:05:07,890
And here we're using this and operator. This is a bidets operator. And here in mine, this one we're in is the length of the hash map here, any quarter to 16 16 minus one is 15.

21
00:05:08,100 --> 00:05:20,460
If we call this function with every C and one dysfunction World Region two nine four two, nine, four and 15 equals two here and operator. This is a big and operator.

22
00:05:20,460 --> 00:05:45,120
If we call this to a nine, four and 15, then we will get six for index six. Now we're going to insert this key value peers at Index six, but how we're going to insert the data at Index six, we're going to create in node the node, you'll have four parts key value hash code and next pointer.

23
00:05:45,390 --> 00:05:58,500
Let's good and note here we created a node which has value has value. Here is two nine four here the string every C and that value here at one and the next pointer is now initially ended.

24
00:05:58,500 --> 00:06:09,150
The address of this node is one one one. Let's stored the address of this not here string the reference of this node, so it will be represented something like this.

25
00:06:09,450 --> 00:06:20,800
No, let's insert this key will appear. The key is bcd and values. To be call this hash could function. It will return to nine seven. And using this formula, we'll get the index.

26
00:06:20,820 --> 00:06:34,900
Seven. Let's insert a node at Index seven. It has value 297 with the string as key and the value to end. The next pointer is now. Initially, let's insert that node at Index seven hit.

27
00:06:34,920 --> 00:06:45,960
Add this up. This note is 2.2. Let's insert this address here. This is the reference. Okay, here's the reference of this node. Then it will be represented something like this.

28
00:06:46,230 --> 00:06:59,160
So we have stored this to it appears if you see one and visited two, now let's insert this key will appear d f and add three. First, let's call this hash caught with the F.

29
00:06:59,160 --> 00:07:10,080
It will return three zero three, then index equals to fifteen. We'll get index records to begin by using this formula. Now let's insert this keyboard appears at Index 15.

30
00:07:10,320 --> 00:07:25,590
First, let's grid A.. This is the node. This is the node. Here we have has value three zero three. We have String D if this is key value three. And no, let's store the address of this note here as a reference.

31
00:07:25,830 --> 00:07:39,630
Then it will be represented something like this. Now let's insert Kiva Lapeer SC, and for first, let's calculate the hash below. The hash is two nine seven, and let's find the index here in Mexico two to seven.

32
00:07:39,900 --> 00:07:51,300
Now we're going to insert this. Keeble appears at Index seven, but here we see that at Index seven, we have already in node. So here is a collision for solving collisions.

33
00:07:51,480 --> 00:08:04,050
Highsmith uses direct chaining. Let's grid A. And let's it has the node as the next bit of this node. So let's grid A.. This is the node at this two, nine, seven and C four, and no.

34
00:08:04,080 --> 00:08:12,600
Now here we're going to store the differential this note. This is the next note of this note. So let's store here for four four, then it will be represented something like this.

35
00:08:12,750 --> 00:08:26,700
Now let's insert every C and five. Here we see this is already exist. And here's what I'm going to do. I'm going to just update develop five for this node here or going to update this one from one to five.

36
00:08:26,700 --> 00:08:35,460
How we're going to do that. First, let's find the hash code. Hash code is two nine four. Now let's go good index in Mexico two to six. Now let's go to add Index six.

37
00:08:35,610 --> 00:08:44,130
Now let's try to compare the key of this node with this key. We see they're equal. So we're going to update this value from one to five from one to five.

38
00:08:44,160 --> 00:08:53,720
So let's update the developer one to five. Now we're going to update the value of this node to six here. OK, so we're going to update this four to six how we're going to do that.

39
00:08:53,730 --> 00:09:04,610
First, we'll call this function how short it will return to nine seven. Now we're going to find it index indexes seven. Now let's go to Index seven here, Index seven, and let's compare this SC with this node.

40
00:09:04,650 --> 00:09:16,350
We're going to compare the key here. We see B, C D and here SC, the are not the same. So let's try to move to the next node. We clearly saw that we have a coalition, so we have to move to the next A..

41
00:09:16,530 --> 00:09:26,710
This is the next note. Now let's try to compare a C and this key. See, we see they are equal. So what are we going to do here? We're going to update this fellow from full to.

42
00:09:27,360 --> 00:09:37,860
Six. So that's updated as well from four to six. Then it will be represented something like this. If we call this method, put weight now and seven. What did you do for now?

43
00:09:37,980 --> 00:09:48,540
This is the best guess what hashgraph for how stable it not works, but how stable except now as key for null keytruda jun zero. So how good will return zero?

44
00:09:48,690 --> 00:09:59,390
This is the basket, and let's calculate index index will be related zero if we applied this formula now at index zero or going to store this given live here now and seven, this is the node we.

45
00:09:59,530 --> 00:10:09,220
Hello. No, here we have has your digital and here. Value seven and next pointer is not now let's do it this address here and it will be represented something like this.

46
00:10:09,460 --> 00:10:19,310
This is how this put method works. Hope you have understood how put method works in hash map. Now let's see how get method works. Maybe call this method method.

47
00:10:19,360 --> 00:10:30,610
Get with MVC 805. How it'll ruin five. First, it'll calculate hash called. The hash rate is two nine four. And now we're going to calculate index indexes six.

48
00:10:30,640 --> 00:10:42,700
Now let's go to Index six and compare this with the first Norval. Now we're going to configure the kit with the key of this first node. We see ABC and NBC are equal to or going to return the value from this node.

49
00:10:42,850 --> 00:10:52,180
So we're going to return the value from this now that is five. So it's 3.5. So it's region five. No. We call this get minted with BCT. First, we're going to calculate hash code.

50
00:10:52,210 --> 00:11:01,510
Hash code is 297. Index is seven. So let's go to add index seven. Here we're going to compare this basically with this key C. They're equal to all written two.

51
00:11:01,540 --> 00:11:13,150
If you call this method, get it. See, here we have this key. So first, let's find it. The hash good hash code is 297 indexes. Seven. Well, let's go to Index seven here with subsidy and see they're not equal.

52
00:11:13,150 --> 00:11:25,210
So let's move to the next note here we have a collision, so we see as see and here is the same. So all written this rule of six. This is no. This great method works for the average case.

53
00:11:25,210 --> 00:11:37,060
It dispute method, and this get method works in constant time complexity. If there isn't a collision, if there is a collisions, then it might takes MyGov in time complexity.

54
00:11:37,300 --> 00:11:54,610
Hope you understood how Hirshman works internally. This is how Hirshman works. Here we have this simple hash grid functions, but hashgraph uses advanced hash grid function to generate hash value, and there might use advanced techniques to find the index from the Haynesville.

55
00:11:54,700 --> 00:12:07,030
This is the internal things of Kashmir functions. This is Joe Hashomer works, and we see that Hashgraph uses hashing to just structure first or converting the key into a hash value from the hash below.

56
00:12:07,180 --> 00:12:17,470
Where calculating index. OK, so here we clearly see that Hashem Abedi destructor uses hashing did a structure. Well, we've understood this explanation.


@@@
1
00:00:00,580 --> 00:00:21,510
Hey, what's up, guys? Welcome back to this video in this video. We're going to talk about what is dynamic programming. Dynamic programming is a technique for solving a complex problem by breaking it down into a collection of simple problem solving of this problem just once and storing their solution if next time there's a problem.

2
00:00:21,520 --> 00:00:36,780
Of course, instead of computing, its solution simply looks of the previously computed solution. And this is the concept of dynamic programming. For example, if you're given this expression, one plus two plus three plus four plus five goes to 15.

3
00:00:37,450 --> 00:01:00,010
So you have computed this expression on plus two plus three plus four plus very close to 15. If you are given this expression on plus two plus three plus four plus five plus six, then here we don't have to compute this expression one plus two plus three plus four plus five because we have computed this expression previously.

4
00:01:00,190 --> 00:01:16,380
So will use the previously computed solution and will add that to six or six plus fifteen is twenty one. So we reduced our competition and this is the concept of dynamic programming.

5
00:01:16,570 --> 00:01:36,580
We used the previously computed solution instead of computing, and this is the concept of dynamic programming. We use the previously computed result to save our times so we don't have to compute that dynamic.

6
00:01:36,580 --> 00:01:52,360
Programming has two properties. One is called overlapping s problem and optimal substructure. If we find out for a problem, these two properties are overlapping s problem or optimal substructure, then we can apply dynamic programming for.

7
00:01:52,930 --> 00:02:09,450
The problem. We have two approaches top down approach and bottom up approach. In the next video, we'll talk about top down approach and bottom up approach in details in this video, let's talk about overlapping the problem and optimal substructure.

8
00:02:10,030 --> 00:02:24,970
First, let's see the definition of overlapping the problem. Then we'll see. What does this mean? Actually, one of the main characteristics is to split the problem into such problem, as similar as a divide and conquer approach.

9
00:02:25,390 --> 00:02:41,980
The overlapping sub problem is found in that problem are bigger problems here. The same smaller problem. However, unlike divide and conquer, there are many problems in which our love cannot be treated distinctly or independently.

10
00:02:42,700 --> 00:02:57,760
Let's say we want to find it empty. When I say no, this is the pseudocode to find it. If you want to say no from if you were necessary, it is function takes on parameter in inside your checking.

11
00:02:57,760 --> 00:03:10,480
If it is greater than or equal to three, then we're calling this function fifteen minutes one plus and minus two. For Baskette, we're returning one. This is Recursive Catch and this is Baskette.

12
00:03:11,560 --> 00:03:23,470
Now let's draw a recursive call tree. This is the recursive call tree. When it's finding out the value here, we're going to explain what is overlapping SG&amp;A problem here.

13
00:03:23,470 --> 00:03:41,320
We call this function five six. Then we're making this problem smaller and smaller. And here we can't break this problem into smaller problem. After five, two, three, one up to solving this problem, we're going to return the value to this five three.

14
00:03:41,410 --> 00:03:55,450
So it will return one and it will return one. So here will return to one. Plus one is two. So we have solved this problem five three. And here we see that we have five three again and here we have five three again.

15
00:03:55,630 --> 00:04:08,050
So we see that we have here repetition or overlapping. Then you have two. It will return one, then four people all return two plus one is three. So we solved this problem before.

16
00:04:08,290 --> 00:04:19,810
And here we see that we have again five, four. So we have overlapping SG&amp;A problem. This is our problem are overlapped and this is called overlapping s problem.

17
00:04:19,810 --> 00:04:30,940
When you find it overlapping s problem, we can apply dynamic programming here. We call this function 086 here. We called this function with that number six.

18
00:04:31,090 --> 00:04:44,530
If we call this number with one million, then you'll have plenty of repetition of function. Call here we see we have two repetition of this function. Call it three.

19
00:04:44,740 --> 00:04:59,830
And here we see the same problem overlapped here. Fifty overlapped instead calling this function again and computing what we can do. We can just store the result when we solve this, our problems.

20
00:05:00,170 --> 00:05:13,670
In an area that you can use that data to to make a court efficient and we can we can reduce reputation or function call. And here we see five, three, 50 50 that function call are overlapped.

21
00:05:13,670 --> 00:05:23,630
And this is called overlapping s problem. This is a problem overlapped here. Five, four, five, four overlapped. And this is called overlapping s problem.

22
00:05:23,750 --> 00:05:35,540
When you find out about the S problem, we can apply dynamic programming to make code efficient. Now let's talk about overlapping substructure first. Let's see the definition then.

23
00:05:35,540 --> 00:05:56,250
Also, what does this mean about having some structure in place that the optimal solution can be obtained from the optimal solution of it? S problem? So optimal substructure is simply an optimal selection among all the possible sub structures that can help to select the best structure of the same kind to exist.

24
00:05:56,270 --> 00:06:06,860
Again, let's say we want to find out in a few minutes a number from previous Syrett. This is the code and this is the recursive function called Here we are breaking this problem into smaller problem.

25
00:06:07,250 --> 00:06:20,150
So we break this problem into smaller problem you receive up to and you're receiving one. We cannot break this problem anymore. Now, if we solve this problem efficiently, that means optimally.

26
00:06:20,360 --> 00:06:32,440
Now, here, I want to ask you a question. If I sold that sub problem efficiently or optimally, can I solved the problem from the solution to the problem?

27
00:06:32,510 --> 00:06:51,110
What is your answer? I think it will say, yes, we can. So here we have optimal substructure. If we. So that's our problem. Optimally, if we can support our given problem by solving it's our problem optimally, then we can say the problem has optimal substructure.

28
00:06:51,550 --> 00:07:02,300
So here we have on and on. So here we have two and we want it will return on intelligent one. So it will return to then here it will return on, then it will return three.

29
00:07:02,570 --> 00:07:13,480
Then this five year we have three. So this three will return to because on the left and on the right will have on and here two plus three is five on the right here episode.

30
00:07:13,480 --> 00:07:27,170
Did we get here. Three to three plus five is eight. So we can solve this problem by solving the problem. If we can solve it's our problem efficiently, we can solve this problem.

31
00:07:27,170 --> 00:07:42,050
So this problem has optimal top structure and this is called optimal top structure. We have understood what is optimal type structure when you have overlapping problem or optimal structure for the problem, then again can apply dynamic programming.

32
00:07:42,320 --> 00:07:58,400
In this section of this course, we're going to be solving this seven dynamic programming problem if necessary. Longest increasing subsequent house. Rober mean Pathum, longest common, subsequent zero upset problem and a regular expression macing.

33
00:07:58,490 --> 00:08:08,780
We're going to solve this if you a serious problem using top down and bottom up approach and the rest of the problem will be solving using a bottom up approach in the next video.


@@@
1
00:00:00,870 --> 00:00:09,250
Hey, what's up, guys? Welcome back to this video. In this video, we're going to talk about a top down approach. What is top down approach? First, let's take an example.

2
00:00:09,600 --> 00:00:22,800
This is our footprint as a syringe. The first two numbers start with one. Then the next number is generated by adding the previous to number one. Plus one is two two plus on his three, three plus two is five five, six eight.

3
00:00:23,040 --> 00:00:35,840
Eight plus five is 13 13, bus eight is 21 and so on. This is our code and this is the recursive function call. Now you might ask what is top down approach.

4
00:00:36,390 --> 00:00:53,040
Now you might ask what is top down approach in top down approach, the algorithm start from top value and bottom is stiff to get our top value. So what does this mean to find out the value of this function?

5
00:00:53,040 --> 00:01:06,120
Call will break this problem into smaller problem until we cannot break the smaller problem anymore. So we're breaking this problem here. Five, four, three, two.

6
00:01:06,270 --> 00:01:14,990
And we cannot break this problem anymore and we cannot break this problem anymore. So we will solve this problem first. So it will return or it will return one.

7
00:01:15,210 --> 00:01:27,030
And then this problem will return to. So we're going to have to bottom and then we're going f and this is called top down approach here for you to a little one.

8
00:01:27,300 --> 00:01:42,610
Then it will return for all this. It will return to in four five irreligion five. Then for this subtree be then it will return at three, three plus five is eight.

9
00:01:43,200 --> 00:01:56,320
So first we sold the smaller problem. We are going top to bottom to get our top value. And this is called a top down approach, or we have understood what is a top down approach.

10
00:01:56,760 --> 00:02:07,320
This is a divide and conquer algorithm where just dividing the problem into smaller problem or not optimizing this problem. And here we are just showing you that top down approach.

11
00:02:07,650 --> 00:02:25,590
So now let's optimize this problem. Using dynamic programming to solve this problem is in dynamic programming, we have to create a dynamic programming table if we're given a number six that we have to find out the sixth Fibonacci number from previous Estridge.

12
00:02:26,220 --> 00:02:42,690
We have to create a dynamic programming table of LENTE six plus one. So seven here we have indexed from zero to six. This is our code. This is the dynamic programming table of Lente in plus one here.

13
00:02:42,840 --> 00:02:57,780
Checking if if the current value is not equal to zero, then we will return the value for our current number from dynamic programming table. When we create an integer error in the programming language, the array is filled with zero.

14
00:02:57,780 --> 00:03:14,010
By default, the default value is zero that you were checking if N is not equal to zero. And here our recursive catch, if any, is greater than or equal to three, then we'll call it five minus one minus two.

15
00:03:14,160 --> 00:03:32,990
And this is your biscuit. The basket is four one and two for one. It will return one and for two it will return. One will not use this first three. So OK, we can assume, we are told that we have year one we have here one will have it here.

16
00:03:33,030 --> 00:03:47,400
In fact, virtually we can assume that we have here one. And at the end we'll have our answer to the last. So now let's see how we can find out the value for five six.

17
00:03:48,090 --> 00:03:57,120
So here we are breaking this problem into smaller problem. So this is the problem. And here we cannot break this problem anymore. This feature will hit the basket.

18
00:03:57,120 --> 00:04:13,560
It will return one. And if you want, it will return one. So here will return one plus one. That is true for this three, when it will return to for this function call, we will insert at third index the value to right over here.

19
00:04:13,830 --> 00:04:26,340
So let's insert here too. We have your overlapping s problem will not repeat this overlapping problem. Animal will reduce the function call using this dynamic programming table and let's see how.

20
00:04:26,700 --> 00:04:38,720
And here we have two. This is base case. This will hit on base condition. So two plus one is a three. So for this function, call for here at index for all.

21
00:04:38,730 --> 00:04:51,000
Insert the value three. Let's insert here three now four five five. What it will return on the left we have three on the right on it. Call with this function here we see that we need it with three.

22
00:04:51,240 --> 00:05:23,020
It will stick at the current. So current is three set. Currently we have two Wilmont recompute it's. Not recompute, we don't have to go to all the function call right over here, OK, so all just return from dynamic programming table just to OK, if what we have here, too, and we see that we don't have to recompute 53 again, we're just returning the value from a dynamic programming table.

23
00:05:23,270 --> 00:05:33,950
This one function called get reduced. OK, so two plus three is five. So two plus three is five. And let's insert here five for this number five at index five.

24
00:05:33,980 --> 00:05:43,390
OK, then for this function, call five six. On the left we have five, five, four, five, five. We have the value five. Now let's go to the right. On the right.

25
00:05:43,600 --> 00:05:56,320
We have to recompute this part, OK, to get the value of it for we have to first compute five three. Then if you two then if you want then you again pure at index four.

26
00:05:56,320 --> 00:06:08,620
We already stored the value three and that we solved here. OK, so we solved just once and then we're just reusing here. We don't have to recompute this function.

27
00:06:08,620 --> 00:06:22,000
Call will directly return from our dynamic programming table. That is three. So we have here three, so three plus five is eight. Let's return eight to this function call and let's insert here eight.

28
00:06:23,020 --> 00:06:43,090
We're done. We'll just regenerate. And you see that we don't have to compute this function. Call if we have here use number instead. Six, if we were given a number one thousand, two thousand or even bigger number like one million, then will have a lot of function reputation.

29
00:06:43,420 --> 00:06:58,270
We have to call one functions a lot of times that will reduce the efficiency of our code and that will treat trivially OK. If we do not use that dynamic programming table, then the solution will take exponential.

30
00:06:58,450 --> 00:07:12,600
That means to do the power in. But using dynamic programming, this problem takes because in time complexity and because of in space complexity. But if we do not apply here dynamic programming, the solution decrease.

31
00:07:12,640 --> 00:07:24,580
We got to rudeboy. We're in. That's the worst thing ever. So we can reduce this exponential time complexity into a linear time complexity using dynamic programming.

32
00:07:24,730 --> 00:07:38,380
And here we have our answer at this scale of indexing will just return this evaluate. If we have a used number, we can apply this concept to reduce the time complexity from exponential to linear.

33
00:07:38,650 --> 00:07:50,650
This is a dynamic programming came into the picture. We're just storing our computed result. Then we will not compute the result again. And this is the advantage of dynamic programming.

34
00:07:50,650 --> 00:08:03,550
This is called top down approach, where we have understood what is top down approach and what is the properties of dynamic programming. In the next video, we're going to talk about a bottom up approach here in the next video.


@@@
1
00:00:00,730 --> 00:00:12,340
Hey, yo, what's up, guys? Welcome back to this video in this video. We're going to talk about a bottom up approach. Let's take an example. This is our code to find out in a few minutes.

2
00:00:12,370 --> 00:00:30,310
No, in the previous video, we talked about top down approach and what is a bottom up approach. If you look at this algorithm, it actually start from lower values, then got a tough I want to find out the sixth Fibonacci number.

3
00:00:30,490 --> 00:00:44,020
Then what I'm going to do, I'm going to calculate first number, then second number, then third all the way to UFF, sixth number. These techniques actually called bottom up techniques.

4
00:00:44,470 --> 00:00:56,050
So we'll start from lower values then will go up. Now let's see how it actually works. This is our dynamic programming table and here output one equals to one.

5
00:00:56,230 --> 00:01:05,500
At first we're going to insert one at second, so we're going to insert one, then we'll start iterating from this cell. And at this, what are you going to do?

6
00:01:05,530 --> 00:01:17,820
We're going to add the previous to sell the value, add three to one plus one is two to find it the value of this. So let's add the value on the previous two two plus on history three here.

7
00:01:17,830 --> 00:01:29,200
What we're doing, we're starting from lower value one one, then we're going off, OK, and then here two plus three to five, then five plus three goes to eight.

8
00:01:30,070 --> 00:01:42,160
And this is super easy. And this is called a bottom up approach. We're starting from lower value and then we're going to the upper value. And this is called bottom of approach.

9
00:01:42,190 --> 00:01:53,100
We're starting from bottom and then we're going F and this is called bottom up approach or we have understood what is a bottom up approach. And here we have code for bottom up approach.

10
00:01:53,620 --> 00:02:19,930
OK, we have understood what is bottom up approach and the solution will take Spiga of interim complexity and it also takes off in space complexity. Now, I hope you have understood what is a top down approach and what is a bottom up approach of dynamic programming for Fibonacci series problem for normal kids, it takes exponential time, complexity for top down.

11
00:02:19,930 --> 00:02:35,300
It takes off in space and time, complexity for deep bottom of approach. It takes big off in space and time complexity for normal kids. It was taking exponential time, complexity, and that's the worst thing ever.

12
00:02:35,620 --> 00:02:46,450
Now why don't you top down and bottom off now? Let's compare them for ease of algorithm. Top down approach is easy to come up with solution and for bottom up approach.

13
00:02:46,630 --> 00:03:07,390
It's not so easy to come up with a solution for time. See, top down is slow and whatever is fast for space efficiency. Top down approach use stack internally for recursion called stack and for whatever approach we use we will use loof so there is no stack is used for what approach we have to use.

14
00:03:07,570 --> 00:03:23,800
Dynamic programming table for most casette. So for space agency bottom of approach is the winner we can say and hold huge top down and bottom off. When you need a quick solution, then we should consider top down and only need an efficient solution.

15
00:03:23,800 --> 00:03:35,100
Then we should search bottom up approach. We have understood everything about top down and bottom up approach. If you're not understanding what is top down and bottom up approach, let us know.


@@@
1
00:00:00,450 --> 00:00:27,600
Hey, yo, what's up, guys? Welcome back to this video in this video. We're going to solve a Korean trivia question, longest increasing, subsequent. Given an integer Eminem's region, the length of the longest strictly increasing subsequence is subsequent is a Cequent that can be derived from an array by deleting some or no elements without changing the order of the remaining elements.

2
00:00:27,630 --> 00:00:43,140
For example, three six to seven is a subsequent of the array zero three one six to seven. Here we see we deleted the zero. Then one. Then any of that two.

3
00:00:43,820 --> 00:00:59,870
OK, and we get this subsequent and we have the other OK, when you were talking about Subsequence, we're looking for a sequence that can be contiguous and also that can be non-contiguous.

4
00:01:00,050 --> 00:01:23,250
What is contiguous? Contiguous means first, then the nine, then to and here ten, nine, two is contiguous. If we say five seven. Eighteen, and that is not a contributor, and this is called a noncontiguous, so is subsequence can be contiguous and it also can be noncontiguous.

5
00:01:24,090 --> 00:01:37,110
Now, let's take some example. For example, if you were given this area as input, then you have to return the land of the longest strictly increasing subsequence in this area.

6
00:01:37,140 --> 00:01:54,000
We have to strictly encasing subsequent two five seven, one hundred and two, five, seven and 18. So we have to return the length of any of the longest increasing subsequence.

7
00:01:54,840 --> 00:02:11,340
So for this given area, we have to return four because the longest strictly encasing subsequent in this area is this true area. So we have to return the length of this area and there is four for what given that have to return for.

8
00:02:12,060 --> 00:02:30,500
If we are given this area's input, then I have to find out the length of the longest strictly increasing subsequence, the longest strictly encasing. Subsequent is this zero one, two, three separate and the length of this subsequent.

9
00:02:30,510 --> 00:02:42,540
And this is the longest strictly increasing subsequent. And the length of this subsequent is four. So for this given input, we have to return for now how we can approach this problem.

10
00:02:42,570 --> 00:02:53,370
Now let's talk about how we can solve this problem for the sake of understanding. Let's assume we're given this area. We can solve this problem in two to devour in time complexity.

11
00:02:53,580 --> 00:03:03,450
And that's the worst solution. And we not talk about that in this video. We're going to solve this problem in quantity, time, complexity, using dynamic programming.

12
00:03:03,630 --> 00:03:16,640
We'll use your intermediate results to solve this problem. Now let's create a dynamic programming table. This is our dynamic programming table. Initially, we'll fill out that first cell with one.

13
00:03:16,650 --> 00:03:29,690
Why is that? When you consider when you consider this is our area of land on here, we have only one element. So we can assume that we have that longest strictly including subsequent of land one.

14
00:03:30,000 --> 00:03:42,800
That's why we're inserting here at one and we're going to use two pointer I energy. I will initially points to the second element and will point to the first element and we'll have Emacs a variable.

15
00:03:43,080 --> 00:03:53,910
Now we're going to check this to value what I and your point of response to now we're going to check. Does the value add to the pointer is less than the Valot Appointer know.

16
00:03:54,090 --> 00:04:06,270
So let's move to the next and just point right here when Joel point right here would start, because Z is pointing to that same element. Now, in that case, what are you going to do?

17
00:04:06,540 --> 00:04:23,130
We're going to insert max splotch on to the corresponding seal of DB programming table where I pointed it points to. So let's insert here Mike plus one and that is one and let's move it to the next and there will all its points to the first.

18
00:04:23,130 --> 00:04:35,250
So when you move to that next. Now let's do the comparison. Dustin is less than two. No, so let's move to the next element. Does nine is less than two.

19
00:04:35,580 --> 00:04:48,060
No. So let's move to the next element. Is the end all points for the same elements, the old stuff. Now we're going to insert to this. So Max plus one and there is one.

20
00:04:48,060 --> 00:04:58,830
So let's insert here one. Now, let's move to the next element and the two the first element. Now, let's do the comparison. Does two is less than five.

21
00:04:58,860 --> 00:05:22,200
No. So let's move to the next. Does nine is less than five. No. So let's move that to the next. Now we see two is less than five. When you found the value at the pointer is less than the value of a pointer, then we're going to get the value from a dynamic programming table where the pointer is pointing to the corresponding cell and we're going to get the maximum.

22
00:05:22,410 --> 00:05:34,020
So Max of Max and the value add the corresponding already up until this points to the max of zero and one is one. So we're going to chance this zero to one.

23
00:05:34,200 --> 00:05:50,310
So Mexico two one. Then let's move to the next and the end is pointing to the same cell. So we're going to see the old stuff here and we're going to insert Max plus on to this cell where I appointers maps, too.

24
00:05:50,640 --> 00:06:02,700
So let's insert here, too, and also have to set our max to zero. Now, let's move to the next element and to the first element. Now, let's do a comparison.

25
00:06:02,700 --> 00:06:12,060
Does ten is less than three not so. Let's move to the next. Does nine is less than three. No. So let's move to the next. Now we see two is less than three.

26
00:06:12,180 --> 00:06:27,810
Now, what are we going to. We're going to update the value of Maximiliano, so we're going to find out the max maximum of Max. So Max is zero and the value add is pointed to the corresponding cell to our dynamic programming table.

27
00:06:27,810 --> 00:06:39,670
And there is one. So Max of zero and one is one. So let's update this value of Max to one. Now let's move to the next. Does five is less than three? No.

28
00:06:39,690 --> 00:06:51,630
So let's move to the next. And now we see the end is pointing to the same cell. So let's insert to the cell max plus one. There is two and they have to raise it max to zero.

29
00:06:51,960 --> 00:07:03,120
Now let's move on to the next. And that's the first element. Now let's do the comparison. Does 10 is less than seven. No. So let's move to the next element.

30
00:07:03,750 --> 00:07:14,010
Does nine is less than seven not. So let's move to the next element. That's two is less than seven. Yes, it is. Now, what we're going to do, we're going to update the value of max variable.

31
00:07:14,370 --> 00:07:25,260
Now what we're going to do, we're going to update the value of max variable. So maximum of Max, Max is zero and the value at our corresponding position to the enemy programming table.

32
00:07:25,470 --> 00:07:36,900
WidePoint responding is one, so max zero and one is one. So let's change this value to one. Now let's move to the next. That's five is less than seven.

33
00:07:36,910 --> 00:07:51,730
Yes, it is. So what are going to do? We're going to update the value of max variable. So maximum of Max Max is one and the value at the corresponding position to a dynamic programming table where the pointer is points to and there is two.

34
00:07:51,990 --> 00:08:04,590
So Max of one and two is two. So let's update this one to two. Now let's move to the next element, and that is three. The three is less than seven. Yes, it is.

35
00:08:04,830 --> 00:08:18,480
Now, what are you going to do? We're going to develop max variable. So maximum of Max and the value of the pointer in a dynamic programming table. So Max, is to add the value at this position to a dynamic programming table is two.

36
00:08:18,690 --> 00:08:29,790
So max up two and two is two. So this value of this variable, Max, is unchanged. Now, let's move to the next element. And here is, is it and I's point to the same element.

37
00:08:29,790 --> 00:08:40,250
So it will do nothing here. And we're going to insert here the value of max plus one to two, plus one is three. So let's insert here three and let's reset max variable to zero.

38
00:08:40,590 --> 00:08:57,070
Now let's move to the next and the two, the first element. Now, let's do a comparison. Does ten is less than one hundred. Yes, it is. Now we're going to update the max variable to a maximum of Max and the value in a dynamic programming table.

39
00:08:57,300 --> 00:09:08,880
The point of this points to one. So maximum of zero and one is one. So let's insert here one. Now, let's move to the next element. There is nine. Does nine is less than one hundred one.

40
00:09:08,880 --> 00:09:20,910
Yes, it is. So let's update the value of our max variable. A maximum of max there is one and this one. So maximum of one and one is one. So this value is unchanged.

41
00:09:21,390 --> 00:09:32,760
Let's move to the next element again. We see two is less than one hundred one. So let's update the max variable. So maximum of Max and this one. So Max up on and on is one.

42
00:09:33,780 --> 00:09:50,900
This one is still unchanged. Now let's move to the next element. Five is less than one hundred one and let's develop max variable. So maximum of max and the value here we have to show maximum of one and two is two.

43
00:09:51,000 --> 00:10:00,660
So let's update this one to two and let's move to the next element. There is three. Three is less than one hundred one. So let's update the max variable.

44
00:10:01,140 --> 00:10:17,940
So maximum of Max and this value two, because the pointer is maps to this two. So maximum of two and two is two. So this is unchanged. Now let's move to the next element, and that is seven.

45
00:10:17,940 --> 00:10:29,150
Seven is less than one hundred one. So let's update develop max variable. So maximum of Max and the value here we have three, so maximum of two and three is three.

46
00:10:29,160 --> 00:10:40,820
So let's update this value two to three. Now let's move to the next. And now we see the end is pointing to the same element. So we're going to insert max plus one to this.

47
00:10:40,840 --> 00:10:53,190
So I pointed his maps, too. So let's insert here Max plus one. There is three plus one four. And let's set this relative zero. Now, let's move to the next element.

48
00:10:53,370 --> 00:11:08,690
And that's the first element. Now, let's do the comparison is less than 18, so let's update the value of Maxo, maximum of zero and one is one. So let's update this value to one.

49
00:11:08,950 --> 00:11:24,040
Then let's move to the next nine is less than 18 to let Abda develop maximum level. So maximum of max and one is one. So this value is unchanged. Let's move to the next two is less than 18.

50
00:11:24,160 --> 00:11:35,460
So let's update max variable to a maximum of Max. And this one, that is one. So this value is still unchanged. So let's move to the next element. Five is less than 18.

51
00:11:35,650 --> 00:11:47,110
So maximum of max and the value here to the maximum of one and two is two. So let's update this value one to two. Now, let's move on to the next element here.

52
00:11:47,110 --> 00:12:00,220
We say three is less than 18. So let's update develop max variable. So maximum of max and the value to a maximum of two and two is two. So this value two is unchanged.

53
00:12:00,400 --> 00:12:10,990
Now, let's move to the next element. Now we see seven is less than 18. So let's actually develop max variable maximum of max and three. So maximum of two and three is three.

54
00:12:11,020 --> 00:12:23,530
So let's after this two to three. Now, let's move to the next element. That is 101. 101 is greater than 18. 101 is not less than 18. So let's move it to the next.

55
00:12:24,460 --> 00:12:36,130
And in this case, this points to the same element where I pointed this response to. So we'll start off here and we're going to insert here three plus one and there is four in the next iteration.

56
00:12:36,130 --> 00:12:49,500
I will point to the out of every boundary. So we're done. This is what we can solve, this problem. This is the intuition to solve this problem. This is a dynamic programming problem that we're using our intermediate result to solve this problem.

57
00:12:50,430 --> 00:13:12,190
OK, we understood the intrusion. This solution only takes bigger off and square time complexity and bigger off in square space complexity to constrict our dynamic programming table answer to this question is the maximum value we have in this area.

58
00:13:12,570 --> 00:13:22,680
We can scan this dynamic programming area for the maximum value and the maximum value we see for we have that wolfer and we can get any of them. We have a double four.

59
00:13:22,690 --> 00:13:44,190
That means we have to strictly increasing subsequence. That means we have to longest strictly increasing subsequence. We can scan this dynamic programming table using for all of or we can keep track or maximum element using a variable and that we'll see in our pseudocode and unknot scan.

60
00:13:44,190 --> 00:13:56,340
This dynamic programming table for our maximum value will keep track our maximum value during generating the dynamic programming table. Now let's see the pseudocode this year, Sudhakar.

61
00:13:56,340 --> 00:14:10,860
To solve this problem. We have this function length of longest increasing subsequent L AI is this function takes one parameter inside your checking, if not applicable to the given arrays empty then will return zero.

62
00:14:11,370 --> 00:14:29,130
Then we're constructing the dummy programming table and we're inserting at the first position one we were inserting, one we have talked about in the previous slide, and then we have our entry codes to one initially because initially we have one element that brings the first element.

63
00:14:29,550 --> 00:14:40,620
The first element is a long list, increasing subsequence. We can consider that. And that's what we're inserting it at the first one and then running a love for ie from zero to like minus one.

64
00:14:40,860 --> 00:15:02,590
And we have your max variable and therefore J from zero to eight minus one. If NOM's eye is greater than Nomsa, we will find it a maximum maximum Gault's to a maximum of answer and that value were disappointed response to from dynamic programming table.

65
00:15:02,810 --> 00:15:15,400
And then we're inserting after the fall of Max bludge one and we're tracking our maximum value using this answer variable. We don't have to scan our array to find out the maximum value.

66
00:15:15,920 --> 00:15:28,730
And at the end of returning our answer, this code will take us back up and square time complexity for the old circuit and it will take off in space complexity to construct the dynamic programming table.

67
00:15:28,880 --> 00:15:37,700
And we have here our array and we have our dynamic programming array. We have constructed the dynamic programming table. We don't want to waste your time.

68
00:15:37,880 --> 00:15:47,560
I'm going to leave you the resource for you, and I would suggest you to construct this dynamic programming table, use the concept we used in the previous slide.

69
00:15:47,810 --> 00:15:59,860
All right, guys, this is my solution to this problem. We have understood this voodoo explanation. If you have any question, if you have any suggestion or if you have an issue understanding this voodoo explanation, let us know.


@@@
1
00:00:00,810 --> 00:00:16,020
Hey, guys, welcome back to this video in this video. We're going to solve a dynamic programming problem. How is robber you're a professional robber planning to rob houses along the street is how has a certain amount of money.

2
00:00:16,320 --> 00:00:32,910
The only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses are broken into on the same night.

3
00:00:33,570 --> 00:00:45,320
In this problem, you are given an integer. Every numbers representing the amount of money of is out, reaching the maximum amount of money you can rob tonight without alerting the Polish.

4
00:00:45,600 --> 00:01:03,860
For example, if you're giving this away in this area we have five elements is elements indicates one out. And in that particular house we have some amount of money and we have to roof in the house it without alerting the police.

5
00:01:04,080 --> 00:01:16,460
That means we cannot rob adjacent houses and we have to retain the maximum amount of money. If we remove at this house, then we cannot arrive to this house.

6
00:01:17,040 --> 00:01:42,410
So if we run at this house two, then nine, then one, if we run at this house seven. Then again at three. And here we see that if we add to that at 9:00 and then at one, the maximum that we can get, it will improve at 7:00, then the value we will get, that means the money will get eaten.

7
00:01:43,030 --> 00:01:54,980
So here we have to return trilled without robbing at the adjacent houses. We can make twelve dollars if we consider it, we consider the given number as a dollar.

8
00:01:55,510 --> 00:02:09,760
So we are given this area. We have to return 12. Let's take another example. For example, if you given this area as input, then what is the maximum amount you can receive from this array?

9
00:02:10,150 --> 00:02:26,950
So first all at seven, then will run at 30, then will roll at four. Here we see that we're robbing at thirty, then we're not robbing at the adjacent houses that OK, here we see that we can run at this house to instict.

10
00:02:26,950 --> 00:02:43,540
Robbing it to where. Robbing it for Epirus at two. Then we'll have less money. That's what we're keeping this HOUGE The maximum money can rough. Forty one for this given area seven plus thirty plus four records to forty one.

11
00:02:43,820 --> 00:02:57,130
So if we're given this right we have to return forty one. Now let's take another example. For example, if you're given this array as input, what is the maximum money can receive without Ruby in the adjacent houses.

12
00:02:57,310 --> 00:03:10,090
First will run at 20, then all will revert, sudden they will run at 40 to the maximum money can draw from this array is 73, 40 plus 13 plus 20 calls to 73.

13
00:03:10,300 --> 00:03:23,290
So if we're given this array, we have to return seventy three first unlove at this house where we have money 20 then all robard here will get the money starting then will Robert here will get the money.

14
00:03:23,290 --> 00:03:32,890
Forty. So we will return seventy three for this given area. Now how we can solve this problem. We're going to solve this problem using dynamic programming.

15
00:03:33,100 --> 00:03:46,150
We know that for dynamic programming problem we can use top down approach or we can use a bottom up approach. In this video we're going to see how to solve this problem for a bottom up approach.

16
00:03:46,390 --> 00:03:56,380
We're not going to talk about a top down approach. We can establish an approach as well. Now, let's see if we can solve this problem using a bottom up approach for sake of understanding.

17
00:03:56,380 --> 00:04:05,410
Let's say you were given this array in this problem. We're going to put a bottom up approach to solve this problem. First, let's create a dynamic programming table.

18
00:04:05,750 --> 00:04:20,410
This is the dynamic programming table. We know that in bottom up approach will not break our problem into the smallest problem. Instead, we'll start solving the smallest problem that will go off.

19
00:04:20,800 --> 00:04:33,640
Let's see how we can solve this problem at first. So maximum money, we can drop D'Arista for the second. So we have to try it by Robin at this. Houge and by not arriving at this Houge.

20
00:04:33,640 --> 00:04:43,710
If we stop at this house, the maximum money again can seven. If we do not run at this house, the maximum money we can resolve to, we will just copy from that.

21
00:04:43,720 --> 00:04:54,670
Let's go to the maximum of seven and two is seven, so it will insert here seven. Now we have solved this problem for this part. Now let's populate the valley for this.

22
00:04:54,670 --> 00:05:13,300
So here we have nine. Our first choice is if we run at this house nine, the maximum money we can remove nine plus two, we'll skip that one. So because we cannot run at adjacent Howard, so we'll just skip this out and will add will add two to nine.

23
00:05:13,480 --> 00:05:25,270
So eleven nine plus two is eleven. And if we do not run at this, how would that maximum we can drop seven. So maximum of eleven and seven is eleven. So let's insert here eleven.

24
00:05:25,420 --> 00:05:37,000
At this point we have solved the problem for this sabari. Now let's populate the valley for this. So if we look at this house three, the maximum value we can improve at this house.

25
00:05:37,000 --> 00:05:57,660
Three, if we run at this Houge, the maximum money we can draw three plus seven, that is ten. If we do not run at this house the maximum value, if we do not run at this house, three, if we do not if we do not approve at this house at three, the maximum we can prove that is even coffee from the left cell.

26
00:05:57,750 --> 00:06:09,240
So maximum of ten and eleven is eleven. So let's insert here eleven. We have already solved this problem for the left portion so we don't have to worry about the value on the left.

27
00:06:09,260 --> 00:06:20,500
So now at this point, we have solved this problem for discovery. At this point, we have solved this problem for this discovery. Now let's populate the value for this cell.

28
00:06:20,500 --> 00:06:36,030
You we at this house, the maximum money we can drop one plus even that is trilled. At this house, the maximum money we can eliminate will be from the Clipsal, so maximum of 11 and 12 is 12.

29
00:06:36,300 --> 00:06:48,000
So let's insert here strip and this is the answer. So if we're giving this array, we have to return to help. This is how we can solve this problem for better understanding.

30
00:06:48,240 --> 00:07:01,140
Let's take another example. Let's say we're giving this area and our dynamic programming table at first still the maximum money we can, roughly six for second.

31
00:07:01,150 --> 00:07:13,590
So the maximum money we can give, the maximum of first sale and the maximum of second. So and that is seven. So let's insert here Suban now let's popular the value for this.

32
00:07:13,590 --> 00:07:30,660
So we have solved this problem for the Leape summary. Now let's populate the value for this cell for this. So we have to try it. We at this how would the maximum value we can Roaf one plus six by squibbing on how much?

33
00:07:30,660 --> 00:07:45,600
Because we cannot because we cannot remove at adjacent Houge. So one plus six is seven. And if we do not arrive at this, how would the maximum moneychanger of seven will come in from the left.

34
00:07:45,780 --> 00:08:01,110
So max of seven and seventy seven. So let's insert here seven. So we have solved this problem for this. Let Soury first or solving the smaller problem then we're going f now let's populate the funnel for this cell.

35
00:08:01,500 --> 00:08:18,920
By looking at this, how would the maximum money we can generate thirty plus seven thirty seven by not robbing at this houge the maximum money we can of seven, so a maximum of seven and thirty seven is thirty seven.

36
00:08:19,050 --> 00:08:38,760
So let's insert here thirty seven. So we have solved this problem for this robbery at this point, that maximum money we can rob thirty seven. So we already understood, we understood that if we consider this is our sabari the maximum we can drop's six.

37
00:08:38,760 --> 00:08:48,780
If we consider this is our sabari, the maximum money we can draw of seven, if we consider this is our sovereignty, the maximum money we can draw of seven.

38
00:08:48,990 --> 00:09:06,330
And if we consider this siege our sabari, that maximum money control thirty seven. Now let's populate the value for this cell. If we love at this outdate the maximum money we can receive eight plus seven, that is 15.

39
00:09:06,840 --> 00:09:17,600
If we do not arrive at this Houge, the maximum money can draw thirty seven. So max of thirty seven and fifteen is thirty seven. So let's insert here seven.

40
00:09:18,360 --> 00:09:35,400
So at this far we find out the maximum money we can receive. Thirty seven. Now let's populate the value for this cell it would have at this house to the maximum money we can resolve to plus thirty seven.

41
00:09:35,610 --> 00:09:56,600
There is thirty nine here. We're skipping the one Houge because we cannot rob at adjacent Houge. So 39, if we do not roll at this house, the maximum money we can rule 37 is a maximum of 37 and 39 is 39.

42
00:09:56,600 --> 00:10:09,580
So let's insert here thirty nine. Now, let's populate the valley for this cell. Every room at this house for the maximum money we can roll for plus 37.

43
00:10:09,590 --> 00:10:22,120
That is forty one. If we do not roll at this house the maximum money we can roll 39. So maximum of forty one and thirty nine is forty one. So all in thirty or forty one.

44
00:10:22,640 --> 00:10:34,850
So if we're given this area we have to return forty one. This solution will take big off in time complexity because we are traversing the given area once from left to right.

45
00:10:35,660 --> 00:10:48,020
And it will also take as we go up in space, complexity because we are constructing the dynamic programming table of land. Now let's take another example for even more better understanding.

46
00:10:48,590 --> 00:11:00,320
Let's say we're given this array. Let's create dynamic programming table. This is our DB table at first. So let's insert 20, because here we have only one choice.

47
00:11:00,620 --> 00:11:14,360
If we remove at this hour the maximum, you can remove twenty nine for this. So if we roll at this house the maximum money we can roll five. If we do not provide this house the maximum money we can drive 20.

48
00:11:14,690 --> 00:11:29,620
So maximum opportunity and five is 20. So let's insert here 20. So we have solved this problem for this summary now for this house. If we run at this house, the maximum money we can receive.

49
00:11:30,020 --> 00:11:41,560
Twenty plus one there is twenty one. If we do not buy this house one, the maximum money we can drop 20. So maximum of twenty one and two and is 21. So let's insert here twenty one.

50
00:11:42,440 --> 00:11:55,160
So we have solved this problem for this summary for this will improve at this house, targeting the maximum money we can receive Tartine plus twenty, that is thirty three.

51
00:11:55,670 --> 00:12:07,150
If we do not run at this house then the maximum money you can drop. Twenty one is a maximum of thirty three and twenty one is thirty three. We have solved this problem for this every.

52
00:12:08,200 --> 00:12:24,680
Now let's look for D.L.. Every room at this house is the maximum we can roll for six plus twenty one twenty seven, if we do not arrive at this house, the maximum money we can rough thirty three.

53
00:12:24,890 --> 00:12:41,480
So a maximum of 27 and 33 is 33. So let's insert here thirty three. Now, let's populate the valley for this cell. If we roll at this house, the maximum money can you live in plus territory that is forty four.

54
00:12:41,960 --> 00:12:58,720
If we do not arrive at this house the maximum money you can draw territory, a maximum of 33 and 44 is forty. Now this is our final sale here to have our answer at this house, the maximum money we can draw.

55
00:12:59,210 --> 00:13:11,750
Forty plus thirty three. That is seventy three. If we do not run this out, the maximum money we can run forty for a maximum of seventy three and forty four is seventy three.

56
00:13:12,350 --> 00:13:33,130
And here we see that we roll at this house 20 at this house starting and at this house 40. So 40 plus 13 plus 20 equals 273, and he refined it 73 and this is what we can solve this problem of, we understood how broad of solution works.

57
00:13:33,160 --> 00:13:41,670
This is bottom up approach. We're solving the smallest problem first and then we're going out. Now, let's see how we can solve this problem using pseudocode.

58
00:13:42,160 --> 00:13:55,540
This is the pseudocode to solve this problem. This is the function it takes to give an input. If you checking if numskulls to now or if the length of the human error is zero, then all returning zero.

59
00:13:55,930 --> 00:14:08,800
The Leontes one then will have only one element and retaining that element. If the length of the human error is two, then we're returning the maximum of two.

60
00:14:09,430 --> 00:14:20,230
If not, we're creating dynamic programming table, then inserting at the first so the first value and at the second. So the maximum of first and second.

61
00:14:20,230 --> 00:14:35,170
So then we're running Aluf four iframe two to the length of the error minus one. That means we're starting from an extra all the way to the end. Then we're populating the value for dynamic programming table maximum of here.

62
00:14:35,170 --> 00:14:51,750
We have the condition improve at current Namsan plus minus two. We're adding the current element and then we're skipping one element on the left. If we are not robbing at the current hold, then we're covering the value from the left at the end.

63
00:14:51,760 --> 00:15:17,610
We'll have our answer at the last cell in our dynamic programming table. Now let's see how that's all. Given this array and this is our dynamic programming table first or inserting two, then the maximum of first and second and there is seven then for this cell here or applying this formula nums plus minus two, nine plus two, that is 11 and just seven.

64
00:15:18,190 --> 00:15:34,050
So the maximum of 11 and seven is eleven here. What we're doing here, we're considering if we improve at this house then we're adding nine plus by skipping the one element on the left two.

65
00:15:34,150 --> 00:15:45,780
So no strings 11. If we roll at this house that many can drop, even if we do not know where this is coming from the left. And this is what we're doing here then for this.

66
00:15:45,780 --> 00:15:59,770
So three plus 17 and that is Ilorin, maximum of 10 and 11 is 11 then for this. So if will decide which one plus eleven that is twelve. And here we have 11.

67
00:15:59,950 --> 00:16:15,640
So here in such trilled and this is our answer. This is how we can solve this problem. This is a board of dynamic programming problem we can solve. This problem is top down approach, but for now we're solving this problem, using a bottom up approach.

68
00:16:15,760 --> 00:16:28,450
And this is how we approach work. The solution takes because in time, complexity is the length of the given array and it also takes off in space complexity to construct the dynamic programming table.

69
00:16:28,840 --> 00:16:37,900
We have understood this wider explanation. If you have an issue understanding this video explanation, let us know. Thanks for watching. I'll see you in the next video.


@@@
1
00:00:01,390 --> 00:00:12,730
Hey, yo, what's up, guys? Welcome back to this video. In this video, we're going to solve a dynamic programming problem, minimum patzer, giving it in by any metrics filled with negative numbers.

2
00:00:13,000 --> 00:00:26,440
Find a path from top left to bottom right who is minimizing the sum of all numbers along its path? Not that you can only move either down or right at any point in time.

3
00:00:26,980 --> 00:00:48,510
Now, let's see some example. For example, you were given this matrix, you were given this matrix. You have to start from this top left cell and you have to visit the bottom right so so that it minimize the number of sums along its path.

4
00:00:49,150 --> 00:01:02,980
We can go right or bottom from any cell. OK, from the cell can go right and the bottom from the cell you can go bottom are right from the cell. We can go right our bottom.

5
00:01:03,310 --> 00:01:18,610
So we have two directions we can go right or we can go Boerum and we have to find out a path from top to bottom. Right says that the numbers along its path has a minimum some.

6
00:01:19,660 --> 00:01:32,840
So what does this mean if we visit this one, something like this first one, then for them to then one one plus one plus four plus two, eight plus or nine?

7
00:01:33,130 --> 00:01:50,950
So in this part, the summation of the numbers along its part is nine. In this matrix, the minimized Pathum is this part one plus three plus one four plus one five plus one six.

8
00:01:51,280 --> 00:02:07,410
And this is the part where we have the minimum patzer. So if we're given this matrix, we have to return six. Now, let's take another example. For example, if you're given this matrix, you have to start from this flipped.

9
00:02:07,810 --> 00:02:24,040
So then you have to visit the bottom, right. So now we have to find out a pet from this top to bottom. Right. So that the sum of numbers along its path is minimum.

10
00:02:24,880 --> 00:02:41,160
So what is the minimum path? We can go from one to three, then two, then two, then three, then one, then two. Or you can go from one to three to five to four to five to one to two.

11
00:02:41,470 --> 00:02:58,330
But you have to find out the minimum pattern. So which is the minimum Pathum for this matrix? So what is the minimum pet? So what is the pet that has minimum Pathum for this matrix?

12
00:02:58,600 --> 00:03:16,120
That minimum Pathum is this pet for this matrix, the minimum Pathum. Let's find out the fat. Here we have this pet one three one, two, three, one, then two and the pet some is 13.

13
00:03:16,720 --> 00:03:29,060
One plus three plus one is five plus two seven. Prostratin plus one. Eleven plus 230. So for this given matrix we have to return the minimum Pathum 13.

14
00:03:29,350 --> 00:03:41,320
Now how we can solve this problem. This is a dynamic programming problem. We can solve this problem using top down approach or bottom up approach. In this video, I'm going to solve this problem.

15
00:03:41,560 --> 00:03:54,310
Using a bottom up approach first will solve the smallest problem, then will go off first. Sort of a smaller problem then will slowly get into the bigger problem.

16
00:03:54,850 --> 00:04:06,370
Now let's see how we can solve this problem first by understanding let's assume we're giving this matrix. And first, what are you going to do? We're going to create a dynamic programming table first thing.

17
00:04:06,390 --> 00:04:19,560
What are you going to do? We're going to find out the pattern for the first rule. Then for the first column, let's find it out for the cell. We'll just copy the value from this cell.

18
00:04:19,630 --> 00:04:33,610
So let's insert unit one then. Here we're going to add one plus three. There is four then for this one plus four. OK, that is five. So for the cell, the value is five.

19
00:04:34,150 --> 00:04:47,230
Now let's find out the pattern for first column. So one plus one is two. Two plus four is six. Here we can do this is to fall off and that's super simple.

20
00:04:47,650 --> 00:05:05,200
And you'll see that how we can do this when we go through our pseudocode. Now, we'll start iterating from this. We'll start iterating from this. So all the way to the end, that means from this cell to this cell, we'll start from this cell and will end up with this cell.

21
00:05:05,650 --> 00:05:15,640
And here will have our answer. This is our current cell. Now, what are you going to do? We're going to find it. The minimum value on the tough and on the left is the minimum of twelve.

22
00:05:15,640 --> 00:05:26,760
And let is. To hear right, so on the top three or four on the left, you have to take the minimum is two, two plus five is seven. So let's insert here seven now for this.

23
00:05:26,980 --> 00:05:39,280
We have developed one to the minimum of late and twelve is five, five plus only six. Let's insert your six then here up to the minimum of seven and sixty six.

24
00:05:39,280 --> 00:05:54,390
Six plus two is eight in the minimum of six and eight is six. Six plus one is seven. This is our answer. If we are given this matrix to region seven and this is what we can solve this problem for better understanding.

25
00:05:54,400 --> 00:06:04,630
Let's take another example. Let's say we are given this matrix. We have to find out the minimum path from this cell to this cell. And this is our dynamic programming table.

26
00:06:04,720 --> 00:06:18,130
First, let's find out the pattern for the first through and for the first column. So for this cell, one for this three plus one is for for the cell. Four plus five is nine for the cell.

27
00:06:18,400 --> 00:06:31,280
Nine plus one is ten. Now for first column one plus three is for four plus one is five, then five plus four is nine. We can do this using to follow four faster and for first column.

28
00:06:31,450 --> 00:06:41,040
Now we're going to start iterating this matrix from this cell all the way to the end of this matrix will stuff right here and here. It will have our answer.

29
00:06:41,410 --> 00:06:53,590
This is our current element. Now let's find out the minimum on the top and on the left. Minimum of four and four is four, four plus three six. The minimum of nine and six is six.

30
00:06:53,590 --> 00:07:12,810
And the current element is four support plus six is our current element is five. The minimum of twelve and left is ten. Ten plus five is fifteen. Now here you are said you have to visit this cell, the last cell of two from the top left.

31
00:07:12,820 --> 00:07:25,280
So the minimum Pathum is 15. Now, this is our current element. The minimum of Tufte and left is five five plus three seven. The minimum of twelve and left is seven.

32
00:07:25,630 --> 00:07:37,810
And here we have current three. So seven plus three is 10. The minimum of 12 and left is ten and current is one. So one plus ten is eleven. And this is our current element.

33
00:07:38,440 --> 00:07:49,690
The minimum of twelve and left is seven. Seven plus three is ten. Then this is your current element. The minimum of and left is still ten plus five is fifteen.

34
00:07:50,020 --> 00:08:02,830
Then our final cell here will have our answer. Minimum of twelve and left is eleven and the current element is two. So eleven plus two is starting and this is our answer.

35
00:08:02,860 --> 00:08:14,410
So if are given this matrix we have to return tarde. The solution will take Spiga of erm in time complexity. It means the number of rule and in is the number of column for the given matrix.

36
00:08:14,770 --> 00:08:28,450
And the solution also takes bigger space complexity for the dynamic programming table. We can solve this problem invalid. Then it will takes constant space complexity and will add the code for a solution.

37
00:08:28,720 --> 00:08:39,610
But for exploration will use dynamic programming table the auxillary matrix. Now let's see how we can solve this problem using pseudocode. This is also the court to solve this problem.

38
00:08:39,820 --> 00:08:56,920
This is function Min Pathum. This function takes the given matrix as input. Then we're calculating the height and weight. Then we're creating dynamic programming table and at the first self that means to the top level we're just copying the value from matrix top.

39
00:08:57,100 --> 00:09:12,190
So then we're filling out the first column using this formula and then we're filling out the first row. Then we start iterating from one to the height and here we have zero from one to the weight.

40
00:09:12,670 --> 00:09:26,710
And then here we are applying this formula minimum of twelve and lips and the current and at the end will have our answer to the right most of the dynamic programming table or in the Matrix.

41
00:09:26,710 --> 00:09:35,260
If we are in pledge, let's say we're giving this matrix and here we're going to create a dynamic programming table. This is our dynamic programming table.

42
00:09:35,470 --> 00:09:50,160
So first we're going to coffee, the first Avello, then we're going to populate the first column using this formula. So here we're starting from on, so on plus three is four, four plus one is five.

43
00:09:50,730 --> 00:10:10,060
Five plus four is nine. And for the first row, three plus one is four, then five plus four is nine, the nine plus one is 10. So the Maxo, foreign forces for four plus three six using this formula.

44
00:10:11,100 --> 00:10:25,110
Then for. Six plus Foreston, then 10, plus five is 15, then five plus three seven, then seven plus three, the minimum of 10 and seventy seven. So seven plus three is ten.

45
00:10:25,560 --> 00:10:42,720
Then minimum of 10 and 15 is 20 and plus one is 11. Then a minimum of nine and seven is seven, seven plus three. Estin now minimum of Tenente in Estin Suchin plus five is fifteen, the minimum of eleven and fifteen is eleven even plus two is thirteen.

46
00:10:43,470 --> 00:10:58,800
So for this given matrix will return this 13 by this written statement. So for this given matrix we have to redeem 13 and the solution takes bigger of it in time.

47
00:10:58,800 --> 00:11:07,460
Complexity, horniness, the number and it is the number of column. And it also takes because of human space complexity for this dynamic programming table.

48
00:11:07,620 --> 00:11:23,670
Or we can solve this problem inflated by modifying this array, by modifying the matrix itself, and then it takes constant space complexity. All right, guys, this is the bottom of approach of dynamic programming for min some problem.

49
00:11:24,070 --> 00:11:32,550
We have understood this video explanation. If you have an issue understanding this with explanation, let us know. Thanks for watching. I'll see you in the next video.


@@@
1
00:00:00,570 --> 00:00:13,860
Welcome to The Cording interview question longest common subsequent. Here's the problem statement you're given to things text and it takes to return the length of their longest common.

2
00:00:13,860 --> 00:00:26,800
Subsequent and subsequent string is a new string generated from the original string, with some characters deleted without changing the relative order of the remaining characters.

3
00:00:27,210 --> 00:00:37,830
All right. A common subsequent of two string is a subsequent that is common to both strengths. The input string consists of lowercase English characters only.

4
00:00:38,160 --> 00:00:53,310
If there is no common subsequent, then we have to return zero. All right. And this is our overall problem statement. Now let's see some examples. If you're given this to string here we see these two things here.

5
00:00:53,310 --> 00:01:08,730
The character, a thenet here, the character B, then nature, the character C, all right. So the longest common subsequent for this to string is AVC. And the length of the longest common subsequent is three.

6
00:01:09,420 --> 00:01:23,250
When you see the word subsequent, then it could be any secrets of the character. It don't have to be contiguous, but it may be contiguous. Here we see it contiguous right now.

7
00:01:23,250 --> 00:01:35,970
Let's see some more examples. If you're given these two strings, then we see this twisting, ensure the character is. Then I see it here, the character D and then we see it here.

8
00:01:35,970 --> 00:01:50,850
The character is in this case, we see the longest common subsequent is three a DH and here Eighty-eight. So we see here this is not a contiguous. If we have this truthtelling, then I see this two things.

9
00:01:51,120 --> 00:02:06,330
The character A then it's here, this character B then it's here, the character E then it's here, the character F. So the longest common subsequent for this thing is a b e f.

10
00:02:06,540 --> 00:02:18,000
So the length of the longest common subsequent is for now. Let's see how we can find longest common subsequent to solve this problem. We're going to use a dynamic programming.

11
00:02:18,330 --> 00:02:30,900
All right. Now let me work through the intuition to this problem here. We have a pseudocode. First, I'm going to declare a function longest common subsequent that takes two things.

12
00:02:31,080 --> 00:02:46,170
One and string two for testing by adjusting only goes to A, B, C, D, E, F and strings to equals to a, C, BFG. OK, then we're going to convert this two string into a character array.

13
00:02:46,990 --> 00:03:11,470
OK, then we're going to construct a dynamic programming table. All right, this is our dynamic programming table, then we're going to initialized a variable rate gyro and this variable will hold our answer, then we have it to live and this loop will start iterating from this box and it will stuff when it raised at this box.

14
00:03:11,710 --> 00:03:24,760
Then we have this condition. If we see two character match, then we're going to copy the value from diagonal. If not, then we're going to get the max from Tof or from left.

15
00:03:25,000 --> 00:03:36,340
And then if we found a value at current index is greater than the answer, then we're going to change the answer to that value at the end. We're going to return the answer.

16
00:03:36,520 --> 00:03:47,200
OK, now let's fill out this dynamic programming table and we're going to fill out this dynamic programming table in bottom up approach. All right. So we have your AMNESTYING and MDT.

17
00:03:47,380 --> 00:03:57,730
So an empty string is a match, but the end of the longest common subsequent four. I'm just thinking amnestying is zero. Then we have your character in the longest common.

18
00:03:57,730 --> 00:04:13,930
Subsequent four character and indistinct Ejiro, now the longest common subsequent for V and Indistinct is then we have AVC and enlisting the longest common subsequent of ABC and then longest common subsequent four.

19
00:04:13,930 --> 00:04:45,790
ABCDE is also for the Starbucks on this row. OK, now let's fill out the value for this column. All right. So here you have interesting and a so the length of longest common subsequent four interesting and is and four interesting and asked for amnestying and HCB Jaroff for interesting and acbl Ejiro and interesting and a CBF Dero and also for interesting and ACBL 50 is zero.

20
00:04:45,910 --> 00:05:01,880
OK, we fill that role and Juillet column. Now let's populate the Vello for the rest of the Vox's. Now we see here E and A and that is match. So this condition will run so diagonal each one and that is one.

21
00:05:01,900 --> 00:05:18,700
So here it should be one. Then we see we have A and B and that is not a match. So then we're going to copy the max from top or left. So in this case, the max of zero and one is one that we see A and C is not a match.

22
00:05:18,880 --> 00:05:33,610
So Max Obdulio and one is one that we see and this is not a match smacks of zero and one is one and zero for this two. All right. Now we see here and C is not a match.

23
00:05:33,850 --> 00:05:47,340
So max up this top or the left is one, then B and C is not a match. So max up one and one is on. All right, then I, C, C and C, that is match. So the diagonal value plus one.

24
00:05:47,350 --> 00:06:00,920
So one plus one is two that we see. DMC is not a match in that cage. We're going to get the max for top and left. So top one and left to the max up. One and two is two.

25
00:06:00,940 --> 00:06:11,770
So here it should be two also C and is not a match. Some accept one and two is to then here we see if and C not a match. So, so max up one and two is two.

26
00:06:11,800 --> 00:06:25,330
All right then. And B so we see and B is not a match. So Max up top or left and there is one then we see B and B is a match. So diagonal value plus once we have one plus one to two then C and B is not a match.

27
00:06:25,390 --> 00:06:36,700
So max of two and two is two, then I, C, D and B is not a match. So Max of two and two is two we see. And B is not a match to max of two and two is two, then you have F and B.

28
00:06:36,700 --> 00:06:47,770
So this is not a match Max of two and two is two. All right then here we have E and so this is not a match. So Max upon energy is one then ECB and E is not a match.

29
00:06:47,950 --> 00:06:58,360
So max up two and one is two, then C and it is not a match. Max of twenty two is two. We see D and E is not a match to max of two and two is to all right.

30
00:06:58,600 --> 00:07:18,370
At this position we see and match. So a diagonal value plus one and that is three then if and is not a match. Some accept two and three is three. Now we see it and if it's not a match to max up on and the euro is one, then I see B and if it's not a match, so max of twenty one is to the C and it is not a match.

31
00:07:18,370 --> 00:07:32,160
Max of twenty two is two. OK, in this case we see we have D and if so this is not met so Max of twenty two is two then we see E and if is not a match Max of three and two is three then if and if is a match.

32
00:07:32,170 --> 00:07:46,120
So diagonal each one so four here then we have it. And this is not a match to max up on integer is one then we see beyond is not a match to max of two and one is two, then you C and D is not a match.

33
00:07:46,120 --> 00:08:02,170
Max up two and two is two. All right. So we see the end is a match. So diagonal latch on to two. Then we see and this is not a Mad Max of two and three is three then if and is not a match to max up four and three is four, are it?

34
00:08:02,170 --> 00:08:16,230
And this is our answer. OK, we can have your insta dissenter this court so that you'll return disvalue. OK, so if you use this return here, then you can just remove this statement and this answer variable.

35
00:08:16,270 --> 00:08:29,880
Don't worry, you can use any of them. So we found the answer. That is for now how we can find the longest common. Subsequent we found here the length we can get the longest common substring from this dynamic programming table.

36
00:08:29,890 --> 00:08:40,050
First we see here, this four is coming from the top. When you see it well, it is coming from the top. That means this is not the part of our longest common substring.

37
00:08:40,090 --> 00:09:00,370
All right, then. Here we see this for it's coming from this tree when we get a value from diagonal, the string contained in our subsequence. Alright, then we see this tree is also coming from this diagonal because this e and this is so in this case, the E also in our subsequence.

38
00:09:00,370 --> 00:09:13,230
OK, then we see this two is not coming from the diagonal. It could be from left or from top. So let's go to left. All right, then we see this too is clearly coming from the top or from left.

39
00:09:13,420 --> 00:09:25,510
So, yeah, let's go to that. All right. And here we see this, too, is coming from the diagonal because the character B and B are the same. So here diagonal, when you have diagonal, then will include that crater.

40
00:09:25,510 --> 00:09:39,030
And there is. All right. And here we see this image coming from the top. Right. And then we see this. It's coming from the diagonal diagonal going to get a that's how we can get the longest common subsequent SBF.

41
00:09:39,040 --> 00:09:50,340
All right. We see here we have different stretch so we can go to any of the directions. OK, at this place, we have the character end. If instead going to the left, if we go to a top, let's see what's happened.

42
00:09:50,350 --> 00:10:00,500
So if we go top right here, we see this tourist coming from the left. So this, too, is coming from the diagonal because this character, C.A.C. at the same.

43
00:10:00,520 --> 00:10:12,580
So this will be in our answer. So let's add your see. OK, so we see this character one, and that is coming from the left. All right. And we see this one is coming from the diagonal.

44
00:10:12,580 --> 00:10:24,520
So it will be in your answer. So in this case, we get the longest common subsequent FCF. So we see in the student we might have different longest come on substring, but the length of the longest one substring is four.

45
00:10:24,520 --> 00:10:36,040
And we might have here couple of longest common substring we went for. OK, so that's how we can solve this problem. This is the intuition to this problem and that's how we can solve this problem.

46
00:10:36,040 --> 00:10:46,960
Using dynamic programming in bottom up approach. OK, this solution will textbook go up element time, complexity or image, the linear the first thing and it is the end of the second string.

47
00:10:46,960 --> 00:10:57,700
It also takes space, complexity, big up, aiming to construct this dynamic programming table or image the of the first thing and is the into of the second string of this concept was clear.

48
00:10:57,970 --> 00:11:06,970
If you have any question, if you have any doubt previous addition, let me know. Thanks for watching this video. I will see you in the next video. Telvin take care.


@@@
1
00:00:00,910 --> 00:00:14,260
Welcome to this video. In this video, we're going to solve a recording interview question, do you know Navteq problem? Here's the problem statement. You're given weight and values up in items.

2
00:00:14,590 --> 00:00:41,680
Put these items in an up check up capacity w to get the maximum total value in the knapsack. All right. If you're given these four items with weight and values and total seven, now we have to pick item from this set size that some of their value is maximum and some of their weight is equal to or less than the total rate.

3
00:00:42,100 --> 00:01:03,100
Now, how we can solve this problem to solve this problem, we're going to use dynamic programming. OK, before that, what does this to one means? Do you want means either you pick the item or you don't pick the item, but you can split the item, determine you don't pick the item.

4
00:01:03,250 --> 00:01:19,780
One minute you pick the item. All right. Now, let me give you the inside intuition to this problem. OK, here we have our pseudocode. First, I'm going to declare a function now that takes valid and total weight as input.

5
00:01:20,110 --> 00:01:33,130
All right. For testing part, what we have this to array for well, and for it. And we're giving total weight equal to seven. All right, then we're going to construct a dynamic programming table.

6
00:01:33,370 --> 00:01:45,730
All right. This is our dynamic programming table here. We have well, then you have weight and here we have zero to seven weight. And this is the size of an object.

7
00:01:46,030 --> 00:02:01,810
We can store seven weight in an object. So we have here from zero to seven and here we have index. Then we have these two loops, this loophole iterate through from the starting box until it reached at this box.

8
00:02:02,230 --> 00:02:13,200
All right, then we have this condition. If I got to do that or decor's to gyro, then we're going to insert just zero. So first it was we love this row, OK?

9
00:02:13,480 --> 00:02:26,920
And in this will have the value zero, because if we have the total weight in Navteq is zero, then if we have zero weight and values, then we can insert your right.

10
00:02:27,040 --> 00:02:39,790
If we have one total weight, then we can have zero value here because we have here you know it or it will feel that then we have elusive if the current total weight.

11
00:02:40,210 --> 00:02:52,800
Let's consider this and this three. OK, when if we left this box we see here, this condition is true because this weight is less than or equal to the total weight in this case.

12
00:02:53,140 --> 00:03:10,660
OK, then we have had to try it. The first tried it. What we can do best by selecting this weight. And the second choice is that what we can do best, we are selecting this three so that what we're doing here, then if not, we're going to copy the value from the top.

13
00:03:10,810 --> 00:03:25,240
At the end, we're going to return whatever value we have at this position. All right. Now let's see how we can feel this dynamic programming table. We're going to use a bottom up approach to fill up this dynamic programming table.

14
00:03:25,450 --> 00:03:39,340
All right. First we have here it and here also have direct and Villagra. So the value for all the box set for this, Junod wrote, will be Dero. OK, so four is iteration of this.

15
00:03:39,340 --> 00:03:50,740
I it will if you love this column. Right. For the sake of understanding I'm going to fill up right now. So here also will have zero. If we have to deal with Obdulio then if we have item zero.

16
00:03:50,740 --> 00:04:04,140
So we have here OK here we have the Saijo panoptic way to do so then we can't put any more items here. So the value will be zero here. All right. Now here we see one end one.

17
00:04:04,390 --> 00:04:17,440
So this condition is met, so we have to try it. The first choice is that so what I can do best with selecting which one. Right? So one plus here one is the value for this great one.

18
00:04:17,440 --> 00:04:32,190
Plus by subtracting this one from the total weight, we are left with zero. So we have here for top at total Girot we have Yadu so one Platero. OK, the second choice we have here, we don't selecting which one.

19
00:04:32,380 --> 00:04:46,930
So we did selecting which we have here, zero on the top. So match up one end is one. So here we will have one. OK then we have a two and one two. Don't wait is two and this with each one.

20
00:04:47,140 --> 00:04:58,960
OK, here also we have to change what we can do best here by selecting this one value. We have one and now let's subtract this weight from this total weight.

21
00:04:59,140 --> 00:05:11,860
So we are left with one. So at one point we have had one, Platero is one, and if we do not select that one, then we can do best is zero. So Max zero and one is one.

22
00:05:12,190 --> 00:05:30,100
OK, so we have a three and one who can do best by selecting the right one, and that is one plus by subtracting this out from this or that is two. So here we have zero zero plus one and then we go to selecting this one, we can do best zero.

23
00:05:30,310 --> 00:05:45,130
So match one is one. OK, here we have four and one. So this condition is met here according to best by selecting this one and that is one plus by subtracting this word from the military three.

24
00:05:45,430 --> 00:05:58,420
So for three, we have you. So one is one and we are selecting this what we have here do so max up one and there is one. OK, then we have five and one.

25
00:05:58,720 --> 00:06:12,910
All right. So this condition again match then what I can do by selecting this already one to one plus five minutes is four. So here we have one plus zero and the best we can do is selecting this one that is zero.

26
00:06:13,210 --> 00:06:25,960
So match up on and you is one. OK. Similarly, the value for these two boxes will be one. OK, here we have one and three. So the total it is less than this weight.

27
00:06:26,620 --> 00:06:37,300
If we have the total weight of ownership is one, then we can't store their three weight. Right. So this condition is false. Then we're going to copy it from the top.

28
00:06:37,540 --> 00:06:50,320
OK, then it will be on from here. All right. Then we see two and three. So again, we're going to copy the value from the top. All right. Now we see three and three is equal to this condition is true.

29
00:06:50,620 --> 00:07:01,380
Then what we can do best by selecting the with three, that is we have value for three is for OK now by subtracting this weight from the total weight relate to it didn't weight.

30
00:07:01,570 --> 00:07:15,010
So do you know what we have here. So support plus zero. And what I can do best with are selecting this eight three and there is one so metaphor and one is four and this is how it works.

31
00:07:15,220 --> 00:07:31,450
OK, let's insert here for now we see four is greater than this weight. So here we have to try it by selecting this all three we can do best for bludge then relate to it here one weight because for minute three is one.

32
00:07:31,570 --> 00:07:45,040
So here we have one support plus one and that is five and we are selecting this eight. Best we can do. That is one. So max of four plus one is five, so max of five and one is five.

33
00:07:45,400 --> 00:07:56,650
Then we have here five and three. So by selecting this with three best, we can do the value here we have four and by subtracting this eight from the total that is two.

34
00:07:56,860 --> 00:08:09,790
So for two we have one. Then we get selecting this three. Best we can do. That is one. So Max of five and one is one. And this is how it works. So let's insert here five.

35
00:08:10,360 --> 00:08:24,270
OK, now is six and three to total. It is greater than this weight. So this condition is true in this case. We have to try it first by selecting this three best we can do for Blatche.

36
00:08:24,550 --> 00:08:35,320
Six minus three, there is three or four. We have one. And by not selecting this three, we have one. So maximum five and one is five. All right, then we have your seven and three.

37
00:08:35,320 --> 00:08:44,710
So this condition is again true. Then we have had to try it working the best by selecting this already. Three that is four and three minus seven is four.

38
00:08:44,730 --> 00:08:56,530
So here for four we have one plus one is five. Best we can do with selecting this with three and that is one. So match up five and one is five. OK, now we see we have four and one.

39
00:08:56,530 --> 00:09:08,400
So this will run this health condition. So it will copy this fellow from here to here. All right. Then also it'll copy this one to here and also to copy this well from here to here.

40
00:09:08,440 --> 00:09:23,500
OK, so now we see four and four. That is match. So what is the best we can do by selecting this for that is five and we're led to it by subtracting this four from this four Ejiro so four that we have here to do so five plus zero.

41
00:09:23,680 --> 00:09:32,890
And what the best we can do with that. Selecting this right. Four and that is also five. So of five and five. That is five and this is how it works. All right.

42
00:09:32,890 --> 00:09:46,480
So it's insert here five. OK, now we see five and four. This condition is true. So what is the best we can do by selecting this? There is five and then by subtracting this one from this five, we're left with one two.

43
00:09:46,480 --> 00:09:57,880
There is one here. Add here one without selecting this. What we can do that is five. So Max of six and five or six. Let's insert here six then we have four, six and four.

44
00:09:58,000 --> 00:10:12,850
All right. So in this case. It by selecting this award for best we can do, is that five plus, then subtract this one from the six related to so support that we have won so far, I plus only six and here we have five.

45
00:10:12,880 --> 00:10:28,960
We are selecting this with best we can do is five. So max of six and five is six, seven and four. So this condition is true. Then you have to try it first rate by selecting this with best we can do five plus subtract this four from seven, that is three.

46
00:10:29,110 --> 00:10:41,070
So developed we have four three we have your four so five plus four is nine and we are selecting the best we can do. That is five smacks of nine and five is nine to let insert your name.

47
00:10:41,080 --> 00:10:52,270
OK, now for this box we see this total. It is less than this weight. So this condition will run. So it will copy the valve from the top. And here it also true, this eighth condition.

48
00:10:52,480 --> 00:11:03,370
So let's insert here one and it will also copy this valve from here that is four. And also it will copy this Rella five here. OK, now we have five and five.

49
00:11:03,370 --> 00:11:15,400
So this condition is true now. Happy to do it by selecting this five best we can do seven plus five minus five. That is so we have your autogyro seven plus zero.

50
00:11:15,760 --> 00:11:28,610
We did. Selecting this best you can do that is six. So max of six and seven is seven. Then we have your total at six and eight five. So by selecting this at best we can do seven plus let's subtract this five from six.

51
00:11:28,610 --> 00:11:37,900
So we have one. So seven plus one is eight and best we can do it without selecting this. We had five, that is six max of eight and six is eight. Right now.

52
00:11:37,930 --> 00:11:52,810
We are at this final position here. We will have our answer. OK, now let's calculate it. We have your seven and five. So this condition is true here. We have again to choose it first straight is that we selecting this at five best we can do seven plus.

53
00:11:52,900 --> 00:12:04,980
Now let's subtract this fight from seven. That is true. So we have one four two total it. OK, so we have here seven plus one that is eight and we are selecting this with five.

54
00:12:04,990 --> 00:12:20,530
Best we can do that is nine. So maximum eight and nine is nine. OK, so here our answer should be this nine and it will return nine. OK, so that's how we can solve this problem now, how we can find the actual items with that.

55
00:12:20,530 --> 00:12:32,770
We get this answer right now. Let's find out. First we see this nine is coming from the top. When we see Avello coming from top, that means the item is not included in our answer list.

56
00:12:32,890 --> 00:12:46,120
Now we see this nine is not coming from the top. So this it will be in our answer list. So here, wait, and five is value. OK, now by subtracting this four from the seven, we get three.

57
00:12:46,270 --> 00:13:00,880
Right. So for Aparo, one, two, three and this is four. And we see this is not coming from the top. So this is included in our answer list. So eight, three and four, we clearly see that this four is not coming from the top.

58
00:13:00,880 --> 00:13:15,320
OK, now, by separating the story from the total weight, we get zero. So for the euro, at this rate, we have zero. Right. So for this one, we have no items selected because here we have to deal with zero.

59
00:13:15,430 --> 00:13:28,240
So at the end we get these two items with four and five and three and develop four. And we see that the sum of their value is maximum when we have total weight.

60
00:13:28,240 --> 00:13:48,310
Observing the solution all takes up time, complexity or because the length of the value array and any calls to max weight. It also takes space complexity to construct this dynamic programming table because to learn of the value array and any to exit, this concept was clear.

61
00:13:48,340 --> 00:13:57,370
If you have any question, if you have any doubt, hyperboles addition, let me know. Thanks for watching this video. I will see you in the next video. Telvin take care.


@@@
1
00:00:00,900 --> 00:00:16,350
In this video, I'm going to talk about a comedy interview, caution, a regular expression, Marsing. Here is the problem statement. Given an input, string it and the pattern p implement a regular expression.

2
00:00:16,350 --> 00:00:46,400
Mouthing would support dot and asterisk here. Dot means. Message, any single character asterisk means Masset zero or more of the preceding character, that means masses or more character that you have before asterisk the macing should be cover the entire input string, not partial string is can be empty and contained.

3
00:00:46,430 --> 00:00:59,780
Only Lorqess character aged PKP empty and contains only Lorqess character to jet and characters like Dort or Asterisk. Now let's look at some examples.

4
00:01:00,620 --> 00:01:12,710
We already saw this right. Dortmund's message and a single character asterisk means as a due or more of the character that we have before pattern here.

5
00:01:12,710 --> 00:01:33,800
We have on the left side parathion and on the right side string and four pattern in its message. Only the string A and it doesn't match A, A, B or A and four it should be it Masset ACB, A, B, B, AXP.

6
00:01:33,860 --> 00:02:08,450
But it doesn't match. It'd be a, b, y, b. How does this match work here. It means any single character we have in between A and B so we can have any single character in between A and B here we have see in between A and B here we have been beaten and B and here we have X in between A and B, so this three string I set the pattern now for this pattern.

7
00:02:08,590 --> 00:02:29,000
Asterisk B, it might be a b a b a it b but it doesn't match a, r, b or HDB. How does this work, asterisk means message or more of the preceding character.

8
00:02:29,860 --> 00:02:41,980
We have the preceding character here is right in saying that here Messaggero or more of this character. So here we have B, so here you see it appears different times.

9
00:02:42,010 --> 00:03:01,620
So it's true. Then we have A, B and B appears or more. Here we see it appears once. So it's true. And for districts it appears it. So it's also to and for the string it appears four times.

10
00:03:01,720 --> 00:03:20,480
So also true, but four distinct. This pattern doesn't match. Then we have your dot asterisk, dot asterisk match. All tsking Right. Every string here we have A, B, B, B, B, DCG, whatever.

11
00:03:20,830 --> 00:03:35,010
We have to match everything now to see how does this work. We know that DOT means any single K to write and asterisk mean zero or more of the preceding character.

12
00:03:35,020 --> 00:04:01,060
Here we have predicator dot so dot means any single character and dot can be different times or more times. Here we have dot asterisk and for this event and to be a we have to dot because it can be zero times or more times whenever we see asterisk after dark.

13
00:04:01,240 --> 00:04:20,320
Now, this does not match the first and these dot match this B, so it Emet B, so here these first dot match B and the second dot match A and dot mint and a single character.

14
00:04:20,620 --> 00:04:45,930
All right. And we take here six dot for this string meby ddc and the first thought might be second dot, might be tad dot match this the fourth dot math this these people dot match this C and six dot math this year.

15
00:04:46,120 --> 00:05:13,780
So it's a match. Right. Frankly speaking dot after that everything. And here's how it works. Right. And here see asterisk. Asterisk be it match c.b because second appears are more times they can appear due to time times here c c appears once and it appears during times.

16
00:05:14,140 --> 00:05:46,900
And to be here we have at the end. So it's a match B for the string C and it appears at times and here C, A, B, C and it appears once and for this string CIPA straight up straight and we must need to have B at the end and it's match but it's not match because we should have at the end to be A, B, B, so it's not a match.

17
00:05:47,620 --> 00:06:05,360
We should have at the end B and here we have A right. But this is not a match because you have your B, C, X Ebbie here. It missed the C at the end. We have B but in between C and we have X and A.

18
00:06:05,650 --> 00:06:26,820
So this is a Anne-Mette and for the last eight asterisk B dot asterisk y here we have B or it's Emet Y here in the strings it appears genotypes and B appears once and dot asterisk means there times or more times to abduct.

19
00:06:26,980 --> 00:06:40,030
So in this case zero times dot that means nothing. So be it's met a b why here. It appears once then we have B didn't have way and asterisk as you know dot asterisk.

20
00:06:40,300 --> 00:06:59,440
It can match everything or nothing. Then we have it the way it appears to have. Then we have it way here. We have it. This is unmet because we must need to have B and or at the end and also it B and also this it for the match.

21
00:07:00,030 --> 00:07:16,360
All right. Now, I think you understood how this match works. All right. Now, right. Function is underscored match that takes a string and a pattern as input and this function should return.

22
00:07:16,360 --> 00:07:28,420
True. Or if the pattern matches the strings, then this function should return true. If the pattern does not match the strings, then it should return false.

23
00:07:29,080 --> 00:07:53,050
These function calls should return true because pattern masset the strings. So it should return to this function. Calls should return to auto because this pattern message the string and for this function calls we should pattern fault because this pattern does not match the strings.

24
00:07:53,290 --> 00:08:07,000
All right. Now I'm going to solve this problem using dynamic programming. Here's how my solution might look like. First I'm going to declare a function is underscore, match the text, a string and the pattern.

25
00:08:07,420 --> 00:08:27,460
Then we're going to construct a dynamic programming table. And here we have is Daudt Land plus one and peatland plus one. If we consider idot as to this could be a pattern and x y be it string, then the binary programming table, it will look like this.

26
00:08:27,730 --> 00:08:44,190
OK, this is our table t now here we have empty string and here we have empty sitting right. Empty pattern and industry is a match. So we will put your T t through by default when you created.

27
00:08:44,430 --> 00:09:00,930
This to the area, we have value for all the box faults and all represent if as a fault. OK, and here we have t genealogy records to to record everything and everything is a match.

28
00:09:01,240 --> 00:09:18,840
Then we're going to take it and interesting. So and everything is not met. So here put F then idot and empty string and idot and mystery is not a match.

29
00:09:18,990 --> 00:09:35,200
So here we'll also insert EBP, then we're going to run a loop and the loop we used only for this type of pattern. We have this for, if only for the patterns that can be met with empty string.

30
00:09:35,760 --> 00:09:47,760
So when we encountered Asterisk, we'll check that in this falloff here for I from want to t the door to lend. And this is the length of the column, right.

31
00:09:48,180 --> 00:10:06,840
One, two, three, four, five and five. So it will run from one to four if I may not. One equals two asterisk for first iterations. It points to error rate and is not asterisk and for second iteration it would points to dot.

32
00:10:06,990 --> 00:10:20,150
So dot is not an asterisk, then it will point to three and here three minus one equals to two. So you don't want to. And here we see asterisk right then.

33
00:10:20,160 --> 00:10:42,760
This condition is true here. T I t so this is it. This is the rule and I quote the two in the circuit. So zero, one, two, three. And here it will copy whatever we have in here and that is if and zero T minus two one.

34
00:10:43,200 --> 00:10:58,540
So here this is Ruggiero and T minus two one zero one. So that is it. So it will copy F over here and then it does not asterisk B and interesting. And that is not a match.

35
00:10:58,800 --> 00:11:26,680
So here will have if OK. And for this column we will have if right here, if here, if this all unfolds because in the pattern and it will not match. So this is false empty pattern and it will not match in the pattern and it will not match in the pattern and X, Y, B will not match.

36
00:11:26,850 --> 00:11:43,680
So all the faults now that populate value for the rest of the box. OK, here we're going to run Aluf for I want to t that minus one and this is the end of the road.

37
00:11:43,830 --> 00:12:01,190
Right. One, two, three, four. And here we have left one, two, three, four, five, minus one for this. Followill will run from one to four. Then we have another Frolov for I want to want to t minus one.

38
00:12:01,620 --> 00:12:21,110
And this is the length of our columns and that is also five and five minutes on four. So this loop also will run from one to four. OK, and this to will iterate through until we get to this box.

39
00:12:21,600 --> 00:12:42,030
Now let's see how we can calculate now let's see how we can calculate the value for the rest of the boxes. First I equals to one and equals to one. OK, so here we have happy one minus one equals to zero and at zero we don't have Daudt.

40
00:12:42,360 --> 00:12:57,570
So this is false then p Geminid to end and one minus on zero. So it points to it. And here it's, I mean each one I go to one. Right, so it's zero and it is a match.

41
00:12:57,570 --> 00:13:12,660
Right. So if we have a match between eight and then we have like this E and A right. And this is a pattern and this is just string. So we see we have a match here and so we can just remove both of them.

42
00:13:12,810 --> 00:13:24,360
Then we'll have empty string. Right. Then we'll copy what we have interesting versus empty string. And here we have T and we are going to just copy the street right over here.

43
00:13:24,540 --> 00:13:37,320
Alright. And this is the exact formula to copy this value from here to here. Then we have it right. And for the next iteration developed, there will be two and you put your mind at one and this each one.

44
00:13:37,320 --> 00:13:55,970
Right. And direct one. And that is equal to do it. So this condition is true then. It all goes to this line, T.J., So on to this one, and you don't want to hear and hear the value we will have if right and here the value will have if.

45
00:13:56,270 --> 00:14:10,990
Now, let me clarify this, how this actually works. OK, it and right. And this does not match with it. So we can just remove this dot. And this is then we have E and industry.

46
00:14:11,240 --> 00:14:26,030
So ANTM testing for everything we have here. If so, we just copied this right over here. OK, for the next iteration, the value of two to three and this is not match and this is not a match.

47
00:14:26,060 --> 00:14:38,480
OK, so then it goes to this Eltis part. Here we have B minus one and that is T minus one is two and there is equal to asterisk. So this condition is true.

48
00:14:39,020 --> 00:14:50,600
This condition is true here. How we can calculate the value for this here. We can get the value, whatever value we have right over here t and we can just copy that here.

49
00:14:50,990 --> 00:15:04,940
And this is the exact formula to copy the value from here. And lets me clarify how this actually works. We have here a dot asterisk and we have here a no without an asterisk.

50
00:15:05,000 --> 00:15:18,600
OK, so here if this dot an asterisk and may have dual occurrence so we can just remove it, then whatever value we have for entry here for entry we have t so we can copy it from here to here.

51
00:15:18,620 --> 00:15:31,400
All right. If we have the minus two equals to dot. OK, so here we're minus two and here we have three minus three codes to one. Right. One for Peaden, one we have dot.

52
00:15:31,400 --> 00:15:47,540
Right. And this condition is true. Since this condition is true then this court will write, this will be overridden right here we have so t either whatever we have we have T and then we have LTI minus one.

53
00:15:47,540 --> 00:16:00,980
So it will go off and it will just copy whatever value we have here. So t true or false and that is equivalent to true. So here we have two right now for the next iteration.

54
00:16:01,310 --> 00:16:17,860
The value will be four. Right. For Jagels to four this equals and this is what. So it will directly insert here false. Now for the next iteration of this file of the value of I will be two, then it will point to this row.

55
00:16:17,930 --> 00:16:36,890
OK, and then whenever we have difficult to one. OK, so then here we see it and x and this is not a match. If this is not a match then we will have here directly false and here directly if and this part will run for that.

56
00:16:36,890 --> 00:16:50,780
We have this value f here and then for the next iteration of J we have Dorte and X. So here this is a match and T I know that. Calculate the value for this box.

57
00:16:51,020 --> 00:17:05,560
OK, so here iminent oil so it will go off. So it will go off and demand that one and it goes to two. So it should be one zero one. Whatever value we have here, we have it.

58
00:17:05,810 --> 00:17:24,530
Now let me clarify how this actually works. We have pattern and dot, right. And we have string E and X and here Dot and X match. Right. So we can just remove this because don't make any single character and we have your end.

59
00:17:25,220 --> 00:17:38,330
So for end it we have t so we can copy whatever value we have in this box. So we have your key. So we copied Hirte. All right. And for the next iteration J we have here asterisk.

60
00:17:38,330 --> 00:17:52,190
Right. And Asterisk and X here it comes to this line here. Whenever we have this condition set then you do the it will stay on the same line and it will go back to minus three.

61
00:17:52,190 --> 00:18:05,230
So one zero one. So it will copy whatever value we have at this position. F So if now see this, this condition is true, we have germaneness two that means to you minus to one.

62
00:18:05,270 --> 00:18:26,610
Do you know what it costs to do what we have here dort then this condition will run. Right. So we have already here fault, it will go off and then we have t I minus one so it go off and do Jaycox to three one, two, three and then false or two equals two.

63
00:18:26,740 --> 00:18:38,540
True. So here this value should be true. Now for the next iteration of G then we have V and X and this is not a match. So here we should have faults. All right.

64
00:18:38,660 --> 00:18:54,930
So for the next iteration of I, it, it points to this and. Just one little point right here, so here we see into it, that is not a match. So here we have if then for the next iteration of do we have to do it here?

65
00:18:54,930 --> 00:19:08,890
Right here. But then we need to copy whatever value we have. So let's calculate that at minus one. So this is three minus two. So it's go up then minus one.

66
00:19:09,140 --> 00:19:23,300
So to manage on one and here zero one one of the 12 that we have here, it just copied over here how this actually works. Now let me clarify it. We have your insert and explain so it can match.

67
00:19:23,310 --> 00:19:34,030
Why don't get a match so we can remove it and then we need to match it and X and four and X we have your. If so, we can just copy that right over here.

68
00:19:34,040 --> 00:19:47,030
And for the next iteration of J, we have your asterisk right. And asterisk and then we have to go back here. We have four. Right. So it will copy. Just felt right over here, minus two.

69
00:19:47,480 --> 00:20:12,840
And that is P one. And that is Dot. This is Dot. Then we're going to go off and get the value. Whatever value we have here, we have yet to see here. The value should be T because if our if our t, false or true is equal to true for the next iteration of git, we have value for and it will point here and B and why is not a match.

70
00:20:12,860 --> 00:20:27,990
So here we should have if then for next iteration of AI and the next iteration, the value of is for an X points to this Lastra. So here this is points to this box and here A and B is not a match.

71
00:20:28,010 --> 00:20:41,450
So here we can have directly F then we have your dot and B so this is a match. So let's go to AF here and here. We have to just copy the. Then you have your asterisk.

72
00:20:41,450 --> 00:20:59,710
Right. If we have your asterisk then we are going to go back here and here we have if to just copy it over here. Since the value of the minus two is equal to DOT, since this is equal to DOT, then it's going to copy the value.

73
00:20:59,730 --> 00:21:14,350
Whatever we have in the top here t so it'll copy t right over here. Now let me clarify that how this actually works. So we have your dot asterisk and here we have X, Y, B, so here dot asterisk.

74
00:21:14,660 --> 00:21:28,430
So it match with B so we can just remove B as the part of it, then we have X, Y and dot asterisk. So for added asterisk and for X, Y we have developed.

75
00:21:28,430 --> 00:21:39,780
So we can just copy that right over here. How simple is that then for the next iteration, heavier B and B equal. So this part will run so it will just copy whatever value we have here.

76
00:21:39,800 --> 00:21:52,700
So here we should have T and at the end we're going to return is dot land and that is four and that is four. So four and four. So this value since you have two here, seem to have to here.

77
00:21:52,970 --> 00:22:11,720
That meant this pattern matches with the strings and this solution takes speed, complexity bigger of in M or is the length of string and a middle and a pattern to construct this dynamic programming table and the time complexity for the solution.

78
00:22:11,720 --> 00:22:23,060
It's bigger of in Imahara in is the length of the string and M is the length of the pattern hardcase. I think you have a clear understanding on this problem.

79
00:22:23,300 --> 00:22:34,620
Regular expression, macing. If you have any doubt, if you have any questions, let me know. I'll be glad to help you like this video. If you want to get more video like this, make sure you subscribe to the channel.


@@@
1
00:00:00,520 --> 00:00:27,030
Hey, you got some guys. Welcome back to this video. In this video or going to talk about it, graph a data structure. What is graph data structure? Graph is a nonlinear digital doctor consisting of nerds and is the nerds are sometimes referred to partisans and the ISS are lines that connect any two nerds in that graph.

2
00:00:28,530 --> 00:01:02,330
We can see a Graph G is an ordered peer opposite V of viruses and a set of aces. This is an example of graph data structure we have here five versus the Vargas's is called nodes, so we can say we have five nodes in this graph data structure and we have here seven is this are called versus what is.

3
00:01:02,330 --> 00:01:25,130
This is also called nodes. And this line in between two viruses is called aces. So here we have seven. Is this one two three four five six seven. So in this graph data structure, we have five vertices and seven aces.

4
00:01:26,460 --> 00:01:50,640
So the SATA versus V1, v2, v3, v4, V5, and so is this V1, B2 video v3 video v4, v2, v5, v3, v4, v4, V5 and wi fi V1. So we have year seven is this graph is undirected graph.

5
00:01:50,960 --> 00:02:04,230
We'll see what is undirected graph in the graph terminology section of this video, we will see what is undirected graph, what is directed graph and a lot more in the next video.

6
00:02:04,830 --> 00:02:20,460
This is an example of gravity to structure. We have here five nodes. The nodes are called Vargas's and we have seven aces. Now, let's see some real life application that uses a graph or two to structure.

7
00:02:21,680 --> 00:02:36,500
Social network uses a graph data structure. Facebook is a popular social media. Facebook uses gravity to structure Twitter, linking Instagram, etc. uses a graph data structure.

8
00:02:37,070 --> 00:02:57,830
Now we're going to talk about the Facebook metrics. Let's hear this guy. Mr We use Facebook. This guy has a friend, Mr. B. So Mr. B is a friend of Mr and Mr is a friend of Mr B.

9
00:02:59,220 --> 00:03:17,250
Here we have Mr If this guy is the friend of Mr. So he can say, Mr F is the friend of Mr and Mr is their friend. OK, Mr F, this guy, Mr If is the friend a friend of Mr B?

10
00:03:17,610 --> 00:03:31,470
Because Mr B is a friend of Mr. Mr F is their friend up, Mr. So he can say Mr B is that friends of friends of Mr F? Let's say we have here another guy, Mr C.

11
00:03:32,130 --> 00:03:46,290
This guy is a friend of Mr. Also, this guy is a friend of Mr B, but this guy, Mr C, is not friend of this guy. Mr F, let's say we have here this guy, Mr M.

12
00:03:46,710 --> 00:04:07,620
Mr E is a friend of Mr C. So here we can say Mr E is a friend of a friend of Mr M. Also Mr is a friend of friends of Mr B, Mr and Mr. It is not the direct friend here.

13
00:04:07,620 --> 00:04:20,500
We have this guy. Mr I, Mr I is a friend of Mr C here Mr E is the friend of Mr F. Here we have this guy. Mr Is. Let's say this guy is the friend of Mr.

14
00:04:20,530 --> 00:04:38,450
I. This guy, Mr. Diem, this guy is the friend of Mr. If Mr. Different of Mr.. Mr. G. Also friend of Mr. E. Mr. E, also friend of Mr. D. Here, Mr. eight, is a friend of Mr. G.

15
00:04:38,840 --> 00:04:51,950
This is an example of small social network. Facebook uses advanced concept, but the core principle is the same. All the social networks uses graph data structure.

16
00:04:52,250 --> 00:05:16,550
Let's say this guy, Mr. B posted on Facebook or something and the publicity is public, then all the people on the Facebook can sort the post. If the post that posted by Mr. B with publicity, friends and friends of friends, then these two guys and the friends are friends.

17
00:05:16,910 --> 00:05:28,190
So this guy, this guy and this guy again saw the post that posted by this guy, Mr. B. This is a simple example of gravity to structure the Facebook Network.

18
00:05:28,200 --> 00:05:39,720
Something like this here. This guy is connected to this guy. This guy is connected to this guy. This guy is connected to this guy. This guy is this guy is connected to this guy and so on and so forth.

19
00:05:40,160 --> 00:05:56,690
This is an example of Facebook networks here. One more example. Now, Facebook networks work something like this. The gravity to structure a little bit advanced than other data structures like a real interest is tax cuz trees.

20
00:05:57,050 --> 00:06:09,140
This is the one uses of graph data structure. Google Map uses gravity to structure in Google Maps, so you can find out the shortest path between two cities.

21
00:06:09,530 --> 00:06:21,640
Let's see a simple math. Let's, Adam. This is a symbol grabbed it, a structure we have here, some serious, it's easy to see and so on. City is connected to CDC.

22
00:06:21,670 --> 00:06:37,540
Here we have a pep. Here we have from city it. We can visit this city from this city. We cannot visit this city ever directly for that. First, we have to visit this city, been city f Oregon.

23
00:06:37,540 --> 00:06:53,470
Visit this city, then this city f and so on. Know how we can find it. The shortest path in between this two city, city and city are in order to find it the shortest gap in between these two cities.

24
00:06:54,160 --> 00:07:09,080
We can apply some graph algorithms to find it the shortest path between two cities. Well, you see how to find it shortest path in between two cities in this section of discourse.

25
00:07:09,590 --> 00:07:21,640
We'll talk about in details we could. This is a simple, graphic representation. This is an example of simple math. Google Maps uses gravity to structure.

26
00:07:21,850 --> 00:07:47,350
Google Math might uses some advanced techniques strategy, but the core principle is the same. They're using graph data structure in different ways. So this are the two uses of gravity to structure social networks uses gravity structure Google Maps uses grabbed it as structures, and there are a lot of applications of gravity to structures.

27
00:07:47,860 --> 00:08:01,030
Now, let's see some applications of gravity to structure. Google Maps use this graph data structure. Social media like Facebook, Lincoln, Twitter, Instagram, etc. uses gravity to structure.

28
00:08:01,030 --> 00:08:15,420
Operating system uses this rigid structures, recommendation engines, part optimization algorithms and more scientific computations. We use graph internal structure in this section of discourse.

29
00:08:15,440 --> 00:08:32,980
We'll talk about a lot of graphs, algorithms and how to find the shortest path in between two cities. And there are some popular algorithms grouped. There were some techniques, gravity intuitions, and a lot of content goes on in this section.


@@@
1
00:00:01,110 --> 00:00:14,950
Here you are, two guys. Welcome back to this video in this video, we're going to talk about graphic terminologies. Viruses. First, let's talk about what is this, what is this?

2
00:00:15,130 --> 00:00:34,750
Are the nodes of the graph? If you're given this graph in this graph, we see we have seven viruses. That means seven nodes we have, nor do V1, v2, V3, v4 v, five V6 and V7.

3
00:00:34,960 --> 00:00:49,750
So we have here seven vertices. This are vertices, OK? So viruses are nodes of graph. Now let's talk about is this is this are the lines between any two viruses.

4
00:00:50,290 --> 00:01:01,900
So in this graph, this is an edge. This is an aid. This is an edge. This is an edge. This is an edge. This is an edge. This is you on edge. This is an edge.

5
00:01:02,410 --> 00:01:18,940
And this is just an edge. So in this graph and data structure, we have total one two three four five six seven eight nine 10. So in this graph we have to do 10 is is this are the lines between any two viruses?

6
00:01:19,240 --> 00:01:32,680
We saw that. Hurry up to what is this? And this is a line and this line is called is. Now let's talk about annotated graph it graph. Not having a weight associated with any is.

7
00:01:32,680 --> 00:01:45,850
This is called unweighted graph. In this graph, we have some vertices and we have some is-is, but we saw that there is no way it is associated with any is this.

8
00:01:46,240 --> 00:02:02,080
So this graph is an unweighted graph. So this graph is unweighted graph. Now let's talk about oited graph it graph. Having it with associated with is a ACS is called weighted graph.

9
00:02:02,590 --> 00:02:18,280
This is an example of weighted graph. In this graph we have wit associated with is ages. So this graph is a weighted graph. So this graph is a weighted graph.

10
00:02:18,580 --> 00:02:35,800
We saw that in this this the weight one is associated here, one is associated and so on. So we see that this is a weighted graph. We saw that in this graph, we saw that one is associated with this is one is associated with this.

11
00:02:35,800 --> 00:02:52,390
It's two is associated with this is and so on. So we can say this is a weighted graph. Now let's talk about undirected graph. It is this graph where there is this don't have any direction associated with them.

12
00:02:52,810 --> 00:03:08,620
This is an example of an directed graph. We saw that in this graph, there is no direction associated with any uses. So this is an underrated graph. Now let's talk about directed graph.

13
00:03:09,250 --> 00:03:23,290
It is a graph. What is this? Have direction associated with them? This is an example of directed graph. Also, we can say this edge a weighted graph because it is associated.

14
00:03:24,010 --> 00:03:39,100
So we can see this is a weighted directed graph here. We see we have direction with this is here. We have a direction that we this is and we saw that we have direction associated with s ss.

15
00:03:39,430 --> 00:03:53,950
So we can say this is a directed graph. Now let's talk about unweighted, undirected graph. It is a graph where the ISS don't have any direction and don't have any weight associated with them.

16
00:03:54,340 --> 00:04:13,030
This is an example of unweighted, underrated graph because because in this graph we saw that there is no weight is associated with any excess. So this is an animated graph and there is no direction associated with is ISS.

17
00:04:13,150 --> 00:04:26,410
So this is not a directed graph. So this is an undirected graph. So you can see this graph is unweighted and directed graph. Now let's talk about oited and directed graph.

18
00:04:27,130 --> 00:04:44,770
It is a graph. The this don't have any direction but have a weight associated with them. In this graph, we see that there is no direction is associated with these edges, but it is associated with is ISS.

19
00:04:44,770 --> 00:04:59,890
So we can see this. It's a weighted, undirected graph. Now let's talk about unweighted directed graph. It is a graph where the ISS don't have any direction and don't have any wood associated with them.

20
00:05:00,220 --> 00:05:16,060
This is an example of unweighted directed graph. We have direction, but we don't have any weights associated with is iss we. So we have direction associated with is ages.

21
00:05:16,060 --> 00:05:33,280
So this is a. Directed graph, but unweighted, so you can say this is a unweighted, directed graph. Now let's talk about oited, directed graph. It is a graph where the edges don't have any direction but have a weight associated with them.

22
00:05:33,580 --> 00:05:48,220
This is an example of weighted directed graph in this in this graph. We saw that is in this contest a direction. This is this has a duration associated with them in this graph.

23
00:05:48,250 --> 00:06:03,880
We saw that is is this has a direction and a weight. So we can say this is it weighted directed graph. Now let's talk about cyclic graph. A cyclic graph is a graph having at least one live.

24
00:06:04,270 --> 00:06:29,820
A cyclic graph is a graph having at least one live. This is an example of cyclic growth in this graph. We see that we have a loop here. We can grow from this virus to disrupt its V2, from this vortex V6 from these waters as B7, from this virus, V7 to this Vargas's V1.

25
00:06:30,870 --> 00:06:43,170
So if we start from these vortices, we can visit this pharmacist. So if we start from this of artists, we can visit this of artists, so we find it a little here.

26
00:06:43,800 --> 00:07:05,520
So this is a cyclic graph. If we find it at least all live in a graph, then against it, that's a cyclical graph here. Another move we can start from this not view until we do from v2 to V3, from V3 to v4 v five V6 v seven V1.

27
00:07:06,000 --> 00:07:26,610
Also from here we can move to this node V5 from P5 to V6, from P6 to recevant to V1. So we have you three loops, so this is a cyclic graph. Now let's talk about a slightly graph, and a cyclic graph is a graph having no loop in it.

28
00:07:27,150 --> 00:07:40,200
This is an example of a cyclic graph here. If we start from this viruses, we cannot visit these viruses. If we start from these viruses, we cannot visit this viruses and so on.

29
00:07:40,560 --> 00:07:55,470
We have no loops in this graph, so we can say this is a cyclic graph. Well, let's talk about an interesting graph data structure. Tree three is a special case of a directed acyclic graph.

30
00:07:55,950 --> 00:08:08,160
This is a tree. We all know that this is a tree. This tree is a graph. We have this note five from this not we can move to this note from this node. We can visit this node.

31
00:08:08,430 --> 00:08:20,430
We cannot go to the trough. We can go only to the bottom, to left or to the right. And here is oil. From five we can visit seven. From seven we can visit one from seven.

32
00:08:20,440 --> 00:08:40,290
We can visit six. So we see that in this data structure, there is no love. We cannot revisit a note. So again said This is a directed acyclic graph. Here we have a direction because we can move only to the bottom of him.

33
00:08:40,500 --> 00:08:54,420
We cannot move to the trough. We can move only to the bottom. So you can say this is a directed acyclic graph. This isn't ROI. All types of tree is a cyclic graph.

34
00:08:54,900 --> 00:09:07,730
This is a why all types of a tree is a special type of gravity to structure, and there is a directed acyclic graph. Hope you have understood graphic terminologies.

35
00:09:08,340 --> 00:09:24,840
This are the common terminologies that we have talked about in this video. Hope have understood all the time analogies. If you have an issue understanding any of them, I would request you to post your question in the Q&amp;A forum.


@@@
1
00:00:00,630 --> 00:00:13,550
Here you are, two guys, or come back to this video in this video or going to talk about types of graph. This is the picture, a representation of graph data structures.

2
00:00:14,030 --> 00:00:35,670
First, we have categorized Graph. Into two categories directed and it directed and undirected graphs is also categorized into two categories waited and waited and waited grabs.

3
00:00:35,880 --> 00:01:01,410
We categorised into two parts positive and negative. Now let's see all of them. In general, we have this six types of groups and we did undirected graph unweighted, directed graph positive, ordered and directed graph positive, oited, directed graph negative, avoided and directed graph and negative or did directed graph.

4
00:01:01,830 --> 00:01:22,560
Now let's see all of them one by one. This is unweighted directed graph because there is no wit associated with the ISS. We have direction with all ISS, so this is a directed graph and there is no weight with ISS.

5
00:01:22,740 --> 00:01:44,030
So this is unweighted graph. So again, so this is a unweighted directed graph. This is an example of unweighted, undirected graph. We see that there is no weight associated with the ISS and there is no direction associated with the ISS.

6
00:01:44,240 --> 00:01:57,080
So this is a unweighted, undirected graph. This is a positive, weighted, undirected graph. First, this graph is weighted. We have weight associated with the ISS.

7
00:01:57,200 --> 00:02:11,330
So this is a weighted graph and we see all the weights having value positive. So this is a positive weighted graph, and we see that there is no direction associated with the ISS.

8
00:02:11,330 --> 00:02:27,260
So this is a undirected graph. So we can say this is a positive oriented, undirected graph. This is positive or did directed graph. We have weight associated with all the ISS and weight are positive.

9
00:02:27,350 --> 00:02:38,360
So this is a positive ordered graph and we see that with all ISS, we have direction. So this is a directed graph, so you can see this is a positive, weighted directed graph.

10
00:02:39,050 --> 00:02:51,650
This is a negative or did undirected graph. First, we see there is no reduction associated with the ISS, so this is a undirected graph and we see we have weight with all the ISS.

11
00:02:52,010 --> 00:03:03,260
So this is a weighted graphs, but we see that we have negative points in this graph. So this is a negative did undirected graph if we saw at least one negative.

12
00:03:03,260 --> 00:03:16,850
But then again, see, this is a negative weighted graph since there is no direction, so we can say this is a negative weighted, undirected graph. This is negative weighted, directed graph.

13
00:03:17,000 --> 00:03:34,340
We see we have at least one wit that is negative. So this is negative weighted graph and we see direction associated with the ISS. So this is a directed graph, so we can see this is a negative weighted directed graph.

14
00:03:34,610 --> 00:03:50,480
This are the types of graphs in general who have understood this for types of groups. This is the peak similar representation, so we saw all types of grabs in general hopefully have understood this explanation.

15
00:03:50,840 --> 00:04:02,510
In the next couple of a video, we're going to talk about how to implement gravity to structure, and you'll see graph representation techniques. See you in the next video.


@@@
1
00:00:00,930 --> 00:00:13,470
Hey, you guys. Welcome back to this video in this video, we're going to talk about graphic representation. Graph representation is a technique to store graph into the computer memory.

2
00:00:14,670 --> 00:00:27,030
There are many different ways to store graph into the computer memory. But in this course, we're going to talk about two popular graph representation.

3
00:00:28,430 --> 00:00:48,080
One is called Ad Jacinta Metrics, and the other one is called Ad Jacinta List. Now, let's talk about adjacency matrix. This is an example of adjacency matrix, this matrix group is this graph.

4
00:00:49,170 --> 00:01:08,710
In this graph, we have five verdicts and seven aces. We are representing this graph in data structure using this adjacency matrix. This is a logical representation of this.

5
00:01:09,040 --> 00:01:24,420
I Jacinta metrics. We are representing this. Grafted his structure using this matrix, this is called add just into Matrix. We'll see how it actually works in this video.

6
00:01:24,480 --> 00:01:40,970
We're just showing you this graph is representing. We decide this into Matrix four adjacency list. This graph will be represented something like this when a U.S.

7
00:01:41,360 --> 00:02:21,430
I just don't see list. This is just a logical representation of this ad to the list. We'll see how it actually works. We'll talk about every bit of information that you need to understand that graphic representation and you go through line by line of code in the next video, we're going to represent unweighted, undirected graph using adjacency matrix and weighted did undirected graph using adjacency matrix.

8
00:02:22,700 --> 00:02:35,030
Then you'll see the graph representation for Addison to list. First up, let's talk about the graph representation for adjacency matrix, then all talk about for at Jacinta list.


@@@
1
00:00:00,610 --> 00:00:09,540
Hey, you got some guys. Welcome back to this video. In this video, we're going to talk about who interviews with representation in this section of discourse.

2
00:00:09,580 --> 00:00:26,270
We saw how to represent different types of groups with representation you should choose, in which case it. Now let's talk about that. If the graph is a dense graph, then we should use add to center metrics.

3
00:00:28,050 --> 00:00:48,750
Here we have the definition for dense growth dense graph is the graph in which the number of aces is close to the maximum number of aces. That means the number of aces we have in a complete graph in a complete graph will have all ages maximum number of aces.

4
00:00:49,800 --> 00:01:04,410
And if the graph is a sparse graph, then we should use adjacency list. Here we have the definition for Spurs to graph a graph with only a few edges. Is it first graph?

5
00:01:05,820 --> 00:01:21,660
This is an example of AD to send him metrics, and this is an example of adjacency list. First thing, what do you have to do? First, we have to check the number of aces in a given graph.

6
00:01:22,140 --> 00:01:41,920
If we saw the number of this is close to the maximum number of cases that can have in the given graph that you consider adjacency matrix. We're using here metrics, if we have fewer number of cases, then we will perform few operation here.

7
00:01:42,040 --> 00:01:57,980
The most of the cell will be unused. That's right. In that case, we have to use +2% Jacinta list and the site of adjacency matrix is fixed. So the number of pages is close to the maximum number of isthis we will use.

8
00:01:58,000 --> 00:02:15,160
Add to sense the matrix if we saw in the given gov with few that we will use +210 to list and that's space efficient. We'll have a lot of unused cell in this add just inside matrix if we dividend experts graph using Add Jacinta metrics.

9
00:02:15,280 --> 00:02:28,360
You would have a giant Spertzel graph using adjacency matrix. You'll have a lot of unused cell in this matrix. And that's not space efficient. That's all we have to consider, adds essentialist.

10
00:02:28,660 --> 00:02:41,650
And if we have number of is, this is close to the maximum number of ISS, then we should not use just list. We should use adjacency matrix for these types of graph.

11
00:02:41,890 --> 00:02:54,910
We can consider adjacency matrix. And for these types of graphs, we should use adjacency list to represent the graph. For Composite Graph, we should consider adjacency matrix.

12
00:02:55,360 --> 00:03:06,530
What is the composite graph? If we have the number of ISS in the given graph is maximum, then the graph is called composite graph. Is this graph a complete graph?

13
00:03:06,580 --> 00:03:19,900
No, this graph is not a composite graph. In complete graph, you'll have in times in minus one divided do viruses. But in this graph we see that we have seven vertices.

14
00:03:20,710 --> 00:03:32,320
Here we are. Five is is so five times four equal to 2020, devoted to those two 10. And here we have seven. Is this but we should have the number of ISS in times in minus one.

15
00:03:32,320 --> 00:03:44,620
The other two. Here we see that this vitesses is connected to this three viruses but incomplete graph. Any vertices is connected to all the vortices in the given graph here.

16
00:03:44,680 --> 00:03:56,770
Zero is connected to two. Two is connected to two four and this one is connected to four. If we have this connection or this type of ACS, we can see this is a composite graph.

17
00:03:56,980 --> 00:04:12,700
Here we have two built in ISS and that follows this formula in times in minus one 2.2. So we can say this is a complete graph for compute graph. We should consider adjacency matrix ologist hope we have understood when to use with representation.


@@@
1
00:00:00,570 --> 00:00:18,410
Hey, what's up, guys? Welcome back to this video in this video, we're going to talk about graphic representation using ad Jacinta metrics. In this video, we're going to see the representation for unrated, undirected graph and for weighted and directed graph.

2
00:00:18,750 --> 00:00:30,110
First, let's talk about unweighted, undirected graph, then we'll talk about weighted and directed graph. Now we're going to talk about unweighted, undirected graph.

3
00:00:31,070 --> 00:00:52,280
Now we have to represent this and directed unweighted graph using adjacency matrix we have here. 2.5 is zero one two three four. So we will create a matrix with five rows and with five columns.

4
00:00:52,640 --> 00:01:11,260
Here we have five rows and we have here five columns. Now let's see how we can represent this graph using this add to Cincy matrix. First, we have here this so this show is empty.

5
00:01:12,530 --> 00:01:28,580
In this matrix, you know, it's true by one and. False by zero. So we will store in this ad, Jacinta Jacinta Matrix zero or one. The default value are zero.

6
00:01:28,820 --> 00:01:42,560
Initially, this matrix is filled with zero here for this first sale for zero and zero. We see we have here zero and we do not have any look here. So here you have zero.

7
00:01:42,950 --> 00:02:02,390
We have here no fluff from zero to zero. So here old store zero, there is no edge for this note. Zero two zero. Also, you can see this is a versus the default value at zero for understanding or inserting zero when you're inserting zero, it means that the value is already zero.

8
00:02:02,510 --> 00:02:19,040
We're just doing it just for sake of understanding no for zero and one in between zero and one. We see we have an eight. So here you'll insert one. One means we have an ID in between.

9
00:02:19,040 --> 00:02:30,380
These two parties is zero and one that's inserted here. One one indicates we have and is in between these two phases zero and one. So here we have zero and one.

10
00:02:30,500 --> 00:02:42,920
Since this is undirected graph, we will insert here one as well. We have an edge from one to zero alter from zero to one. That's right, we have inserted here one and here on as well.

11
00:02:43,340 --> 00:02:56,660
One end is zero now for zero and two for zero and two. We see there is no is in between zero and two. So let's insert here zero now in between zero and three.

12
00:02:57,080 --> 00:03:08,000
We see in between zero and three, we have an edge. So let's insert here one here. It means that we have an eight from zero to three and also from 3.0.

13
00:03:08,300 --> 00:03:21,770
And this is why we will insert here one here. It means that we have an edge from three to zero now four, two and four, four zero and four in between these two vertices.

14
00:03:22,370 --> 00:03:36,380
We see we have an eight. So let's insert here one here we have is from zero to four and we have the is from four to zero. So we'll insert here one as well because this is an underrated graph.

15
00:03:36,740 --> 00:03:49,940
Now for one, and do we have here one for one and one? There is no loop from this node to this note here. Sometimes I'm saying nodes and sometimes I'm saying, What is this?

16
00:03:50,540 --> 00:04:02,930
Don't be confused about that vertices aren't the nodes are DCIM. So here you inserted your own because we do not have any edge in between this not one end this node one.

17
00:04:03,290 --> 00:04:11,330
No, for one and two we see for one and two, we have an eight. So let's insert here one here we can go from one to two and also you can go from two to one.

18
00:04:11,330 --> 00:04:24,920
So let's insert here one as well. Now, for one and three, we see four nodes, one and three. We have an ease. So let's insert here one, we can go from one to three and you can go from two to one.

19
00:04:25,250 --> 00:04:33,770
So let's insert here one as well. We can grow from this, not three to this, not one. We'll take a go from this node one to three now four, one and four.

20
00:04:34,070 --> 00:04:45,770
We see we do not have any is in region one and four. So let's insert here zero now four, two and zero. We see there is No. Eight. So here you insert the zero.

21
00:04:46,100 --> 00:05:01,720
We have here one, four, two and one because we can move from two to one now for two and two. There is no love in this node. We cannot go from this. Not to this, not to because we do not have here and love.

22
00:05:02,120 --> 00:05:15,590
So let's insertions zero now two and three. We have an s. Let's insert one. We can go from two to three and also can go from two to two. So for three to two here you'll insert one now for two to four.

23
00:05:15,740 --> 00:05:29,860
You cannot go from two to four. We do not have any is. So let's insert here zero. Here we have three values already for three. This note three and three you do not have an ID, so let's insert here zero, then four, three and four.

24
00:05:29,870 --> 00:05:43,280
We have an is. Let's insert here. One, we can go from three to four and four to three. So let's insert here one. Now for this. So for foreign one, you do not have any is let's insert zero.

25
00:05:43,550 --> 00:05:56,720
No, for the Northeast four and two, we do not have any is. So let's insert here zero. Finally, four and four, there is no loss in this nodes. We cannot move from this node to this note.

26
00:05:56,720 --> 00:06:10,280
There is no it in between this node and this node itself. So we're going to insert here zero. We have constructed this at the center matrix. This is the representation of this graph data structure.

27
00:06:10,730 --> 00:06:29,550
This is just a logical representation, and this matrix will be stored in our computer memory. It's storing this data structure or something like this or storing this matrix and this matrix is represented logically, something like this, and this is the graph data structure.

28
00:06:29,970 --> 00:06:41,490
Well, we have understood how to represent unweighted, undirected graph using adjacency matrix. Here we're storing one. One indicates we have and is embedding two nodes.

29
00:06:41,880 --> 00:06:59,850
Zero indicates we do not have an edge in between two nodes hiring string one. If the graph is it, we did graph, then we'll store the weight. The associated with the current is and you'll see that in this video.

30
00:07:00,090 --> 00:07:12,750
Now let's see the algorithm. This is the algorithm for unweighted, undirected graph. We have the class graph inside here. We have the decision. Matrix is history matrix.

31
00:07:13,020 --> 00:07:28,170
And here you have a variable vertices. Then here you have the constructor. It strikes the vertices as input. And inside here we're inserting the vertices to this variable vertices and we're creating to the matrix with vertices.

32
00:07:28,170 --> 00:07:43,560
And what is the number of rows and out of columns? Then here we have this function. Add is entire integer and inserting here one for either inserting one and four or inserting one because we have to direction.

33
00:07:43,710 --> 00:08:01,230
We can go from node here to not be and also from Node B2 Node E. This is why we're inserting one and one. Is it one entity, one that we have here? This function remove is this function will remove the IS indeed in any two nodes.

34
00:08:01,710 --> 00:08:14,130
I decodes to zero and is equal to zero. And here we have this function to string function will return. The graph as a string here were protesting builder.

35
00:08:14,130 --> 00:08:27,420
Then here ordering running a loop for AI from zero to Horace's minus one. Then here we're inserting AI, the current index, plus the semicolon just for printing stuff in here or running this low for G.

36
00:08:27,750 --> 00:08:45,090
I just into Matrix, I here are printing. If they go to one or inserting one R there is or inserting zero and at the end or inserting a line break and at the end or returning the string, we're converting the string builder into string end or returning the string.

37
00:08:45,660 --> 00:08:58,380
No, let's see how it actually works. You would instantiate the graph with Vertices five. It means that we're creating and I just see Matrix with Rule five and Column five.

38
00:08:58,710 --> 00:09:10,020
This is the adjacency matrix. We do a five and column five. And here we are, representing the graffiti destruction. This is just a logical representation of the adolescenti metrics.

39
00:09:10,710 --> 00:09:25,450
Now, if we call graph added with zero one, it will connect these two nodes, or we can see the party will have one here. And we can move from zero to one end from one to zero.

40
00:09:26,380 --> 00:09:46,090
So we will insert here one two zero here one year inserting one icicle to one and zero two to one for the direction we can go from zero to one. And from what did you know if we call this method, add AIDS with zero four, then here we are connecting these viruses with these viruses.

41
00:09:46,090 --> 00:10:01,390
Four. And here you insert one. So here we have an it. What we can go from zero to four and from Portage, you know, so here will insert one as well. Using this formula here, it's pretty simple right now.

42
00:10:01,400 --> 00:10:15,470
Let's call this method again with zero three. It would call, then it will connect this note with this note. And here in this at the center matrix, what do you do?

43
00:10:16,160 --> 00:10:29,240
We will insert here one zero three and four three zero. We can go from two Juno. So here will insert one as well. So this is the representation of this adjacency matrix.

44
00:10:29,810 --> 00:10:43,040
This is our Gravity two structure. Now let's call add age method one two. Here we have one and two. So here it will have one, and we will connect this node with this node.

45
00:10:43,640 --> 00:10:56,030
We can grow from one to two and from two to one. So from two to one, here we'll insert one. Now let's call this add edge with one three. If you call it one three, we'll institute one.

46
00:10:56,300 --> 00:11:07,190
It means that we have eight is in between these two node one and three. Here we see we can move from one to three, from one to three and from three to one.

47
00:11:07,550 --> 00:11:20,630
So here you insert one. Now let's call this add edge with two three. Here it will say this eight. So we can go from two to three. From two to three. And from three to two.

48
00:11:21,200 --> 00:11:34,280
Let's call this method add is it three or four? So it will connect this to Node three four. So from this, not three, we can move to this node for that's inserted at one.

49
00:11:34,700 --> 00:11:48,260
Also, you can move from four to three. So from four to three and all the empty cell are filled with zero because the default value is zero. We filled the default value with zero.

50
00:11:48,700 --> 00:12:00,000
Now we call this method to a string. Then it will return. This string by this written statement is we got to string. Here we see that this is this graph.

51
00:12:00,020 --> 00:12:11,270
OK. This is the representation of this graph. You just structure well understood how to represent unweighted, undirected graph using adjacency matrix.

52
00:12:11,570 --> 00:12:20,510
We have implemented unweighted and directed graph, and we have explained it with line by line of code. Now let's talk about weighted underrated graph.

53
00:12:21,080 --> 00:12:34,760
This is a weighted graph. This graph is weighted, and we see there is no duration associated with any ISS. So this is an directed graph, so you can see this.

54
00:12:34,760 --> 00:12:45,020
Is it weighted and directed graph? Now, let's see how he can represent this graph using adjacency matrix. Let's adam this which our adjacency matrix we have here.

55
00:12:45,020 --> 00:12:57,440
Five Is this. So we created this as this in two matrix with five rows and with five columns. Now for this. Nor did you know there is no luf in this note.

56
00:12:57,770 --> 00:13:14,270
There is no love from this, not zero to this node zero. So here insert the zero, then four, zero and one. We have a is here and here almost 2.1 in this time because this is a weighted graph will store that word in.

57
00:13:14,270 --> 00:13:27,500
This is so let's store here the weight and the weight. Here we see two. So let's insert here. Two, we can go from zero to one and from one to zero. So here also will insert the which two.

58
00:13:27,500 --> 00:13:39,540
We can move from one to zero now for zero and two. There is no connection, so let's instituted zero. There is no yet. OK. Then from zero to three, we see we have an eight.

59
00:13:39,560 --> 00:13:52,340
So let's insert the weight in this is that would in this is five. Let's insert here. Five. We can move from three to zero as well. So here let's insert five now from zero to four.

60
00:13:52,700 --> 00:14:04,260
We can move from zero to four. And here it is. Three. Let's insert the word three here. And also, we can move from Portwood Euro know. So let's insert here three now from one to one.

61
00:14:04,280 --> 00:14:17,720
There is no love in this note. We cannot move from one to one. So all in central zero now from one to two, we see we have an edge with weight four for let's insert here.

62
00:14:17,720 --> 00:14:30,530
Four. We can move from two to one. So let's inset here for as well. Now, for one and three, we have an eight with weight three. So let's insert here three from three two one.

63
00:14:31,310 --> 00:14:40,820
We can move from three to one. So let's insert here three as well. Now, from one to four, we do not have any weight, so there is no weight associated.

64
00:14:40,820 --> 00:14:53,760
So we're going to insert zero. And from two to zero, from 2.0, there is no is. So we're going to insert here zero. The default value is zero now from two to three.

65
00:14:53,940 --> 00:15:03,750
We have your value already from two to one now from two to two. We do not have any aid from this, not two to two. So we're going to insert here zero now from two to three.

66
00:15:03,780 --> 00:15:14,610
We have an eight eight for let's insert here four. We can move from two to two as well. So here we're going to insert four now from two to four, from two to four.

67
00:15:14,760 --> 00:15:27,090
We have no aids. So let's insert here zero now from three to three. We do not have any love from this. Not treated this node three. So let's insert here zero now from three to four.

68
00:15:27,240 --> 00:15:43,530
We have an eight tool that insert here too. We can move from four to three. So let's insert here to the H2 now from four to one. We have no is. Let's insert your journal now from four to two.

69
00:15:43,920 --> 00:16:01,260
We do not have any is. So let's insert here zero now from four to four. We have no age from 44. So let's in-situ zero. If we have a loop something like this, only then it will retain the weight of this edge since we have no love here.

70
00:16:01,830 --> 00:16:13,680
So in such your journal? So we have constructed the adjacency matrix for this or did undirected graph and this is the representation of disordered undirected graph using adjacency matrix.

71
00:16:14,250 --> 00:16:23,970
Now let's see the algorithm. This is the algorithm for weighted, undirected graph. We have class. Here we have. Add this into matrix and we have here.

72
00:16:23,970 --> 00:16:41,670
What is this variable? Here we have constructor graph. It takes the vertices as input and university Novartis to this variable and recruiting at descending metrics with a number of various rows and number of various columns.

73
00:16:42,090 --> 00:17:00,570
And here we are adding is using this function. Add is it takes three parameter Isaiah and it and we're setting the weight to the current ISS. We can move from A to B and from B to E, and that's why we're setting identical to it.

74
00:17:00,570 --> 00:17:10,560
And there you go. Let's do it. And here we're removing the IS by setting to zero. And here we're just returning the string representation upward graph.

75
00:17:11,070 --> 00:17:24,180
We have your string builder in here. We're running the form for IE from zero to what is minus one insert here or appending the index, plus the colon. And here we're running a loop to this current row.

76
00:17:24,630 --> 00:17:41,800
Here are checking if there's no results to zero, then we are appending Android zero absent here or appending New Line and here or returning the. String, we're converting Dustin Builder into string and we're retaining the string, this is the string representation.

77
00:17:41,980 --> 00:17:52,170
This function will return the string representation of our gravity to structure here. Instantiating this object go to new graph with five five is the verses.

78
00:17:52,180 --> 00:18:06,370
So we're going to create adjacency matrix with five rows and five columns. And here, let's draw five notes. If you call this method with zero one two two is that went from zero to one.

79
00:18:06,670 --> 00:18:18,860
We have a edge, and here we're going to insert two here from zero to one, from zero to one here. We're going to insert two. And also we have direction from one to zero.

80
00:18:18,970 --> 00:18:32,440
Since this is underrated. So we're going to insert here two as well. If you call this function again, zero for three will have connection from zero to four with with three.

81
00:18:32,830 --> 00:18:46,120
So here, from zero to four, we're going to insert here three and from four to zero, we'll have the word three. Now let's call this method with zero three five from zero to three.

82
00:18:46,660 --> 00:18:58,150
Here the word is five. The word is five. So from zero to three, the oId is five. So let's insert here five. And we have the direction from three to zero.

83
00:18:58,330 --> 00:19:13,540
So here you'll have five. Maybe call this function with one, two and four here in between these two note one and two. What we haven't is it four? So let's insert this eight here one and two right here.

84
00:19:13,540 --> 00:19:25,360
So wait for here. You can move from two to one. So here we're going to insert four as well. If you call this method again, one three three from one to three.

85
00:19:25,390 --> 00:19:38,560
Here we have an is it with three? Let's insert three right over here. One, three three. And we have direction from two to one, from three to one. Here, let's insert here.

86
00:19:38,570 --> 00:19:55,390
Three. Now, let's call this method with two three four. So from two to three, we have an is with wait for. Let's insert food here. Two, two, three four.

87
00:19:55,870 --> 00:20:09,660
We have direction from two to two, from three to two. So here we're going to insert four. Let's call this function right. Three, four two. Now we have an easy here with wit.

88
00:20:09,670 --> 00:20:29,170
Two. So let's insert the wit. Four, four, two three. Here. The way it is to end from three to four, from three to four is to. Now we're done. And the empty cell or the back end, so will the field with zero.

89
00:20:29,560 --> 00:20:48,160
The default value is zero. We see that we utilize money cells in this matrix. If there are more ISS in-between nodes, if this graph is a complete graph, then you'll have more used cell in this matrix.

90
00:20:48,760 --> 00:21:07,810
If we saw the number of ISS in the graph close to that maximum ISS, we will use this adjacency matrix address you'll use at essentialist. And this is the and this is the representation of oited, undirected graph here.

91
00:21:07,810 --> 00:21:22,000
Let's field the veteran cell with zero. All right, we filled the vacuum cell with zero in computer memory all store. This adjacency matrix and this matrix will treat as a graph a data structure.

92
00:21:22,510 --> 00:21:45,100
This matrix would represent logical, logically something like this in real life. Instead, zero one two three four we will use seeding them or passing them, or we will store the detailed information of a city or or a person now for understanding of gravity the structure.

93
00:21:45,340 --> 00:21:56,890
We're trying to understand the core principle of gravity to structure. That's what we're using here, pseudonym or passing them, or do guilt about city or details about person.

94
00:21:57,040 --> 00:22:08,830
We're just using some integer as a vertices or nodes of understood how to represent anointed undirected graph and ordered undirected graph using adjacency matrix.

95
00:22:09,320 --> 00:22:25,360
Now, if you call this method to string this method, you'll written this string. This is the text representation a our gravity to structure. Hope you've understood how to represent graph using adjacency matrix.

96
00:22:25,780 --> 00:22:40,120
In the next video, we'll see unrated directed graph representation, and we did a directed graph representation using AdSense, a matrix that will see Graph if his intuition using AdSense list suing the next video.


@@@
1
00:00:00,660 --> 00:00:14,850
Hey, you also, guys, welcome back to this video. In this video, we're going to see the representation of graphic using ads as intimate tricks, unrated directed graph and oited directed graph.

2
00:00:15,090 --> 00:00:27,270
First, let's talk about unweighted, directed graph. Now we're going to talk about the representation of unweighted directed graph, let's Adam. This is our graph.

3
00:00:27,810 --> 00:00:44,220
In this graph, we have 2.5 VAR assists or nodes and we have seven aces and we say that direction is associated with ice ages. So this is a directed graph.

4
00:00:44,430 --> 00:00:56,880
There is no word associated with aces. So this is an weighted graph. Now let's see. Hogan represented this graph using adjacency metrics we have here five vertices.

5
00:00:57,360 --> 00:01:12,930
So we created a matrix with five zeros and with five columns, I did so zero zero. We're going to insert zero. We have no love here. There is no edge from this node zero to this node zero.

6
00:01:13,290 --> 00:01:25,770
That's why we inserted here zero. Now four zero one, we see in between zero one, we have an eight. This is goes from zero to one. So here we're going to insert one.

7
00:01:26,270 --> 00:01:39,720
One means we have an eight from zero to one here. We cannot go from one to zero because we don't have a direction from one to zero. That sorry, we cannot go from one to zero.

8
00:01:40,050 --> 00:01:54,180
Now four, zero and two. We see there is no edge. So let's insert here. Zero now four zero three. We have an eight and it goes from this node zero from zero to three.

9
00:01:54,510 --> 00:02:04,920
So here we're going to insert one. We don't have a direction from three to zero now four zero two four from zero to four. We have a direction, so let's insert here one.

10
00:02:05,310 --> 00:02:18,060
We cannot go from four to zero. We have a direction from this node. Zero two four Now for one zero, we cannot move from one to zero. So let's insert here zero now from one to one.

11
00:02:18,750 --> 00:02:31,760
We do not have enough in this node from this node one to this node one. So we're going to insert here zero now from one to two. We have a duration. Let's insert here at one now from under three.

12
00:02:31,770 --> 00:02:44,040
We have a duration. Let's insert here one now from one to four. We do not have any is. So let's insert here zero now from two to zero. We do not have any yet.

13
00:02:44,070 --> 00:02:58,040
So let's insert here zero now from two to one. We do not have any. We have an eight, but this is this goes from one to two. It cannot go from two to one.

14
00:02:58,050 --> 00:03:08,490
So we're going to insert here zero. This is a directed graph, not undirected graph. Now, from two to two, we're going to insert here zero now from two to three.

15
00:03:08,520 --> 00:03:21,120
We have an H. And this is goes from two to three. So let's insert here one from two to four. We don't have an ace from two to four. So let's insert here zero now from three to zero.

16
00:03:21,150 --> 00:03:32,640
We have an h, but the direction goes from zero to three. We cannot go from three to zero. So let's introduce zero now from three to one. We have an edge, but we have direction from one to three.

17
00:03:32,970 --> 00:03:43,680
Let's instituted zero. It cannot go from three to one. Now, from Typekit to what we see, we have an h, but the direction goes from two to three. We cannot go from three to two.

18
00:03:43,920 --> 00:03:56,190
So let's insecure zero now from three to three. We do not have any love here, so we're going to insert here zero now from three to four. We see we have an edge and the direction from three to four.

19
00:03:56,430 --> 00:04:07,410
That's insert here one now from four to zero. We have an edge, but the direction goes from zero to four. So let's insitute zero now from four to one. We don't have an edge.

20
00:04:07,410 --> 00:04:20,200
Let's insert zero now four four two two. We do not have an edge now from four to two. We see there is no is for this node for +2. So let's instituted zero now from four to three.

21
00:04:20,220 --> 00:04:31,200
We have an edge, but the direction goes from three to four. So let's insert here zero now from this, not forward to this, not four. We do not have an edge, so let's inserted zero.

22
00:04:31,420 --> 00:04:44,790
We're done. We have constructed our adjacency matrix for this unweighted directed graph. And this is how this unweighted directed graph represented using at the centre metrics.

23
00:04:45,090 --> 00:04:55,860
This is how this unweighted directed graph represented using our two since The Matrix. Now let's see the algorithm. This is the algorithm for unweighted, a directed graph representation.

24
00:04:56,040 --> 00:05:08,010
We have this class graph inside here. We have add this into Matrix 2D matrix to the area. Here we have variable Vargas's. This is a constructor. It takes one parameter of artists.

25
00:05:08,030 --> 00:05:18,960
And the interesting part is just to this what? This is variable. And we are creating matrix of integer type with number of advantages, columns and with number of.

26
00:05:19,400 --> 00:05:40,180
Versus Rose, we have here, dysfunction ad age added this market extra parameter, and then here we have this function room of it. Dysfunction ticks AMG inside dysfunction or just sitting idly to one hit or just sitting icy cold stone because this is a directed graph here at the cinematics, Isaac said.

27
00:05:40,190 --> 00:05:54,650
You know, we're just deleting the aces in reading two notes by this method of ACE. Here we have this project to stream first or declaring steam building were running your love for AI from zero to Hardesty's minus one.

28
00:05:54,660 --> 00:06:08,180
You're appending AI plus this column, and we're iterating the current row and or appending one or zero. And here we're inserting new line, and we're just returning the string representation of the graph.

29
00:06:08,450 --> 00:06:24,990
Let's say we instantiate off the graph class. That means we created an object of this graph with five artists. So we're going to create I just into Matrix with five columns and five rows.

30
00:06:25,010 --> 00:06:36,050
Let's assume this is the logical representation of this adjacency matrix. If you call this method, add is eight zero one. Then here from zero one, we're going to insert one.

31
00:06:36,380 --> 00:06:53,240
So from zero to one, we have an edge. So let's add here and eight, the default value for this matrix are zero. The empty cell means we have default value zero if we call this method with zero four here instead of one.

32
00:06:53,390 --> 00:07:06,200
So let's add here, and it's from zero to four. Now, Graph and edge zero three will add an AIDS from zero to three. So let's insert here one. So we have an eight from zero to three.

33
00:07:06,500 --> 00:07:17,540
Maybe we call this method with one two here in such one, we'll have an AIDS from one to two here. You could call this method with added one three. We're going to insert here one.

34
00:07:17,870 --> 00:07:33,860
We'll have an excellent one two three if you call this method with two three. We'll have here. One will happen. Is from this to do this three. If we call this method with three or four, we're going to insert here one and we'll have an ace from three to four.

35
00:07:34,520 --> 00:07:48,170
And if we call this method to string this method, it will return this string. This is the representation of our graph in this matrix for the back end cell or for the empty cell, we will have zero.

36
00:07:48,320 --> 00:08:03,530
So let's filled the vacant Sellwood zero. So we filled the rack, and so it is zero. This is the representation of this graph. This matrix of is stored in our computer memory, and this is the logical representation of this adjacency matrix.

37
00:08:04,040 --> 00:08:16,220
Hope we have understood the representation of unweighted directed graph. Now let's talk about did directed graph in this graph. We saw that width and duration is associated with ice ages.

38
00:08:16,460 --> 00:08:25,070
So this is a weighted directed graph. Now let's see how we can represent this graph using adjacency matrix four zero zero. We're going to insert zero.

39
00:08:25,220 --> 00:08:41,630
There is no edge from this node draw to this node zero if we have a loop here. Only then we will insert non-zero value from zero to one. We have an eight and the would is to sort of insert here to run it in sort of here one, we're just inserting it two now from zero to two.

40
00:08:41,720 --> 00:08:53,300
We do not have an ID, so let's such zero now from zero to three. We have an eight with five. So let's insert here five now from zero to four. We have an eight wait.

41
00:08:53,300 --> 00:09:03,790
Three. So let's insert here three now from one to zero. We have an eight, but we cannot move from this. Not one to this node zero. So let's insert here zero now from one to one.

42
00:09:03,800 --> 00:09:13,200
We do not have any loop for this, not from one to one. So let's insert here zero now from one to two. We have an edge we wait for. We have direction from one to two.

43
00:09:13,250 --> 00:09:22,160
So let's insert here for now from one to three. We have an edge with three and we have direction from one to three. So let's insert here three now from one to four.

44
00:09:22,580 --> 00:09:35,040
We do not have an eight, so let's institute a zero now from 2.0. We do not have an edge, so let's insecure zero now from two to one. We have an eight, but we cannot move from two to one.

45
00:09:35,060 --> 00:09:46,130
So let's insert your zero because this is a directed graph direction here. Something like this. Then we should insert here four. But here we do not have a direction from two to one, from two to two.

46
00:09:46,340 --> 00:09:57,890
We do not have any love from two to two. So let's insert here zero now from two to three, we have an h with direction two to three and wait for it. So let's insert here for now from two to four.

47
00:09:58,040 --> 00:10:07,940
We do not have an ID, so let's insert here zero now from three to zero. We have an h, but we cannot move from two to zero. So let's insert here zero now from three to one.

48
00:10:08,060 --> 00:10:15,320
We have an ID, but we can't move from three to one. So let's institute zero now from three to two. We have an edge, but we cannot move from three to two.

49
00:10:15,500 --> 00:10:28,220
So let's insert here zero now from two to three. We don't have any. Look for this, not three. So let's institute zero. Now, from three to four, we have an age with the duration from digital now from three to four.

50
00:10:28,240 --> 00:10:38,710
We have an age here with age two and we have direction from three to four. So let's instantiate the urge to now from 4.0 we have is, but the duration is from zero to four.

51
00:10:39,010 --> 00:10:49,970
We cannot move from four to zero now from four to one. We do not have an age that's insecure zero from 42. We do not have an age, so let's insecure zero from four to three.

52
00:10:49,970 --> 00:11:03,580
You have an age, but the direction from two to four. Let's just hear now from four to four. We do not have any love in this note. If we have a love from four to four on literary, insert here the wit associated with this age.

53
00:11:03,850 --> 00:11:14,530
But you do not have any love here, so let's institute zero. We're done. We have solved this problem. Now let's see the algorithm. This is the algorithm for weighted directed graph.

54
00:11:14,740 --> 00:11:24,220
We have these metrics. Then we have these juarez's variable here. Constructor here are recruiting as a central metrics, and we're setting the averages in into this where this is variable.

55
00:11:24,610 --> 00:11:35,650
Here we have this method at is it sticks to parameter idiot wit, idea and wit. Here we are inserting the weight at it and Z Index. Here we're removing the is.

56
00:11:35,830 --> 00:11:47,200
We're setting to zero and here by this function, to a string or returning the text representation of the graph. Let's say we instantiate this class with five.

57
00:11:47,290 --> 00:12:02,950
So we'll create a matrix with Rule five and column five. This is the matrix, and this is a graph representation of this matrix. Now we call this method added it will add at index zero, one at zero and one here to the but two.

58
00:12:03,100 --> 00:12:19,350
So here we will have an eight from zero to one with which two if you call this method with zero four three zero four three. So here you insert three will have an ace from zero to four with duration from zero to four with weight three.

59
00:12:19,510 --> 00:12:28,810
If we call this method with zero three five, here you'll insert five from zero to three. We'll have an eight with the duration from zero to three with.

60
00:12:29,290 --> 00:12:40,600
Five. If you call this method at eight with one two four from one to two, you'll have with four. So you'll have an h from one to two here with Weight four.

61
00:12:41,200 --> 00:12:54,160
If we call this method with one three three from one to three here you'll have word three here will have an eight point one two with weight three. Maybe call this method with two three four two three.

62
00:12:54,490 --> 00:13:04,450
So here you'll have four and you'll have an H from two to three with weight for you. We call this method again with three four two from three to four.

63
00:13:04,480 --> 00:13:15,880
Here we're going to insert the two that's insert here, too. So from three to two, it will have an ease with which two here we have reconcile. The default value is zero, so let's field the back end.

64
00:13:15,880 --> 00:13:32,680
So it's zero. In this matrix, we saw that we have total 4.5 equals to 2.5 cells, but we're just utilizing seven. So. So for this type of grabs, adjacency list is the best choice.

65
00:13:33,010 --> 00:13:45,400
In the next video, we'll talk about adjacency list. Now, if we call this method to string it all written the text representation of this graph, this is the text representation of this graph.

66
00:13:45,640 --> 00:14:07,420
This is what we're going to represent and implement. Wicked directed graph over understood how to represent graph using adjacency matrix. This matrix should be stored in your computer memory, and this is just the logical representation of this matrix who understood this a video explanations of any question, if were an issue.

67
00:14:07,420 --> 00:14:17,110
Understanding this with the explanation out, Howley encourages you to post your issue on the Q&amp;A forum. Thanks for watching this video. I'll see you in the next video.


@@@
1
00:00:00,610 --> 00:00:14,980
Hey, you also, guys, welcome back to this video in this video, you're going to talk about graphic representation using Ad Jacintha list in this video or going to see the representation of unweighted, undirected graph and unweighted directed graph.

2
00:00:15,760 --> 00:00:27,250
Now let's see how we can represent unweighted, undirected graph and unweighted directed graph using adjacency list. First, let's talk about unweighted, undirected graph.

3
00:00:27,580 --> 00:00:40,000
Then you'll talk about unweighted directed graph. Now, let's talk about unweighted, undirected graph. The siege. An example of unweighted, undirected graph.

4
00:00:41,410 --> 00:00:58,390
In this graph, we see that we have five viruses and we have 2.7 is this we don't have direction and weight associated with any cases. So this is a unweighted, undirected graph.

5
00:00:58,960 --> 00:01:14,350
Now how we can represent this graphic using I just list. First, what are we going to do? We're going to create an array of Lindquist. We're going to create an array of side five because we have here five viruses.

6
00:01:15,380 --> 00:01:32,120
Decision, Ari, this Ari will store Lindquist in between the stewardesses zero and one. We have an eight. So let's create it, not with that one. And we're going to connect it to this index zero.

7
00:01:33,140 --> 00:01:45,500
Then it will be represented something like this. Here we see we have direction from zero to one and from wanted zero. And we're going to add a note of value zero from this index.

8
00:01:45,500 --> 00:01:58,580
One something like this. So we have two viruses here. From zero to one and one to zero. Now here is we have two, 246, zero and four. Here we have an ace.

9
00:01:58,940 --> 00:02:12,620
Now we're going to create A. Note with this rule of four, and we're going to add that as the next node of this node. So let's add here four. So we have to edge from zero to one and from zero to four.

10
00:02:13,250 --> 00:02:24,890
Since this is undirected, we'll have duration from four to zero. So let's add here another note with value zero, something like this. Now, from zero to three, we see we have an edge.

11
00:02:25,190 --> 00:02:38,240
So let's add here another node revelatory. We have direction from 2.0 as well, so let's add here in note, we developed zero something like this now from one to two, we see.

12
00:02:38,300 --> 00:02:52,550
We have an edge. So let's add in, not at index one here. We want to add in node with the value two as the next of this node, because we have it not here.

13
00:02:52,640 --> 00:03:03,240
So let's add in order here, too, since this is undirected, you'll have direction from two to one. So let's add here another one from this what is this one to this?

14
00:03:03,260 --> 00:03:17,960
What it is? Three. We have an eight. So let's add in order. Three right here. And not one right here, we can go from three to one, and we can go from one to three now from two to three.

15
00:03:17,980 --> 00:03:33,850
We see we have an edge. We do not have any direction. We can go from two to three and two to two. So let's add here in Node three and right here INORDERTO order so you can go from two to three and are going to go from two to two.

16
00:03:34,570 --> 00:03:44,680
Finally, we have these two viruses and here we have an eight. Here we see if we can go from three to four. So let's add here in Node four, we're going to go from four to three.

17
00:03:44,860 --> 00:03:57,220
So let's add another node. We develop three here. We see that we can go from three to four and we can go from four to three. And this is the representation of this gravity structure is adjacency list incompetent.

18
00:03:57,220 --> 00:04:09,460
Mean what will store this adjacency list? This is a logical representation of this adjacency list. Now let's see the algorithm. This is the algorithm for annotated, undirected graph.

19
00:04:09,820 --> 00:04:33,520
We have Vargas's and we have here an array of linguist. The linguist, author, integer. This is the adjacency list. Here we have constructor. It's two x Vargas's as input and we're sitting here what it is to this rebel and we are creating linguist and we're inserting linguist to this area using this follow from index zero two versus minus one.

20
00:04:33,700 --> 00:04:42,940
And here we have the method, and it's this method takes two parameter source and destinations, and here we're inserting that note add two current index.

21
00:04:43,300 --> 00:04:56,710
And here we have print graph method. This method all print the graph. Now let's see how it actually works. Let's say we instantiate this class graph with value five here.

22
00:04:56,710 --> 00:05:08,260
Five minutes. We have five artists, so let's quit here and Eric with five elements. And here you'll store link list. This is not an integer array. This is a linked list error.

23
00:05:08,650 --> 00:05:22,270
And this is the logical representation. Now, if we if we call this method, add is zero one, we'll create a node with the value one. And in such here and it will create a node with value zero and insert here.

24
00:05:22,480 --> 00:05:39,040
It means that every direction from zero to one and from one digital. So let's add, is here in between these two artists. Zero and one. Now, if we call the method, add is zero and four will add four here and we'll add zero right here.

25
00:05:39,070 --> 00:05:50,770
It means that we can go from zero to four and we can go from four to Juneau. So let's add an is here. If we call this method with zero and three will add three right over here and we'll add zero right over here.

26
00:05:51,310 --> 00:06:08,170
It means that we can go from zero to three and we can go from two to zero. So let's add an h in Britain, it's too hard. This is zero and three. Maybe call this method with one and two will create a node with value to insert here, and it will create a node with one.

27
00:06:08,170 --> 00:06:20,050
And in such here. So we can go from one to two and two to one. So let's add an ID in reading this to what it is on end to something like this if you call this method with one and three.

28
00:06:20,530 --> 00:06:29,290
Now let's create a note with three. And let's insert here, and let's go to one and let's insert here so we can go from one to three and from three to one.

29
00:06:29,530 --> 00:06:43,120
So let's add an edge here now from two to three, because now we call this method with two and three. That's grid and node with value three. And let's insert here and let's create a node with valid two, and let's insert here.

30
00:06:43,150 --> 00:06:52,210
OK. So you can go from two to three and we're going to go from two to two. So let's add an is in reading this to have artists. Now we call this method with three and four.

31
00:06:52,520 --> 00:07:01,960
Let's grid in. We develop four, and let's add it here and let's quit and not we three. And let's add it here so we can grow from three to four and I'm going to go from four to three.

32
00:07:01,970 --> 00:07:18,940
Let's add an is in between these two artists. So let's add an ingredient is too hard. Is this for entry? Now we call this method print graph. This method will print that graph due to structure this adjacency list, and this is the output of this print graph function.

33
00:07:19,510 --> 00:07:34,300
So every call this method, it will print. This output will well understood how to represent annotated, undirected graph using adjacency list. Now let's talk about how to represent unweighted directed graph.

34
00:07:34,720 --> 00:07:46,330
This is an example of unweighted directed graph we have no associated with. Is this but the direction is associated with East Asia, so this is a directed, moderated graph.

35
00:07:46,900 --> 00:07:59,290
So this is a annointed directed graph. Let's see. How did it begin to this graph? We have here five artists, so we're going to create an RF link list of sites five because we have here five vertices.

36
00:07:59,860 --> 00:08:14,000
Here we have index from zero to four now from zero to one, we have an h. The region goes from zero to one. So let's create a node. One and let's add here, it means that we can go from this not zero to not one.

37
00:08:14,390 --> 00:08:26,410
We can't go from one to zero, so we won't adhere to the note with zero now from zero and four. We can go from zero to four. So let's add here for we can go from zero to three, so let's adhere it.

38
00:08:26,420 --> 00:08:36,880
Not with value three. Now, from one to two, we can go from one to two. So let's add here a note we developed you now from one to three, we can go from one to three.

39
00:08:36,890 --> 00:08:46,160
So let's add a note here. We developed three now from two to three. We see it. We can go from two to three. So let's add here a nerd with value. Three.

40
00:08:46,670 --> 00:08:57,770
Now here we have this is we can go from two to four and also you can go from four to three. So here first, we're going to create a note with Value four, and let's insert that note right here.

41
00:08:58,190 --> 00:09:05,720
And let's create another note that we developed three and let's insert right here. It means that we can go from three to four and we can go from four to three.

42
00:09:06,740 --> 00:09:16,430
This is the representation of this annotated, directed graph. We have understood how to Virginia and we did directed graph using AdSense list. Now let's see the algorithm.

43
00:09:16,910 --> 00:09:30,030
This is the algorithm for annotated directed graph, and this algorithm is similar to unrated, underrated graph. Here we have one line instead two lines in the previous algorithms we saw.

44
00:09:30,050 --> 00:09:44,470
We have you entered the line at the since list destination dot at source here right below of this line. Since this is a directed graph that we have here this online now, let's see how it works.

45
00:09:44,480 --> 00:09:56,870
Let's say we instantiate this graph plus with five five is the vertices, so we're going to create an area of linguist of size five. And this is the representation.

46
00:09:56,870 --> 00:10:09,140
This is the logical representation of this idea, since at least now we call this method with zero one. We're going to add an order here. If we call this method, add is zero one, we're going to add a node here with value one.

47
00:10:09,680 --> 00:10:23,660
So here we have a direction from zero to one. Let's add here an h from zero to one. Now, if we call this method with zero four, we're going to add here in order we develop four and we have a direction from zero to four, and here we have an s with duration.

48
00:10:24,900 --> 00:10:34,250
Now, if you call this method with zero three, we're going to adhere to a node revelatory and let's add an eight from zero to three something like this.

49
00:10:34,880 --> 00:10:46,100
Maybe call this method with one two. Now we're going to add a note here. We can go from one to two. So let's add a node here, and let's add an edge that goes from one to two.

50
00:10:46,610 --> 00:10:56,440
Now, let's call this method add edge with one three. Let's add here a node three. So we have an excellent one to three, let's add here an edge with reaction one to three.

51
00:10:57,610 --> 00:11:10,210
If you call this method with two and three, then we're going to add an edge from two to three here. And let's add a note here we developed three. If you call this not great at, it's three or four.

52
00:11:10,270 --> 00:11:22,180
And with add is what three will add a note. Here we develop four and we'll add a note hit with zealotry so we can go from three to four and from four to three.

53
00:11:22,300 --> 00:11:35,710
So you'll have direction from four to three and also from two to four. This is the representation of this animated directed graph, and this is how we can represent and implement energy directed graph.

54
00:11:36,400 --> 00:11:53,200
If you call this method print graph, this method will print this output. This is the representation of our adjacency list. This a. is a list of is stored in our computer memory, and this adjacency list represent a graph.

55
00:11:53,590 --> 00:12:03,670
This is a logical representation of this adjacency list. Hope we have understood how did a brilliant, annotated and directed and annotated directed graph.


@@@
1
00:00:00,720 --> 00:00:15,540
Hey, you what's up, guys? Welcome back to this video in this video, we're going to talk about how to represent a graph using just list in this video or going to represent the graph widget directed graph and weighted underrated graph.

2
00:00:15,720 --> 00:00:24,390
Now let's talk about how to represent weighted directed graph. Then we'll talk about ordered and directed graph. Now we're going to talk about how did a budget or did undirected graph this?

3
00:00:24,390 --> 00:00:34,470
It's an example of oited, underrated graph. In this graph, we have 2.5 roboticists and seven ages. We see what is associated with Ethan every single ages.

4
00:00:34,560 --> 00:00:42,680
So this is a weighted graph, but there is no reduction is associated with. Is this so this is an underrated graph? Now let's see. How did envision this graph?

5
00:00:42,690 --> 00:00:54,180
First, let's create an array of linguist here. We have index from zero to four. First, we have this two. It is zero and one now in between this what it is we have and is with which to now.

6
00:00:54,180 --> 00:01:05,640
What are we going to do? We're going to create in node. The node will have three attributes. Now we're going to create and node. The node will have three attributes destination weight and the mixed pointer.

7
00:01:05,700 --> 00:01:16,410
That's great and not here with value one and weight two. And let's insert that right here. It means that we can go from this node zero to one node means what is this?

8
00:01:16,500 --> 00:01:25,170
So we can go from this. What is this to this? What is this? And here we have which two in reading this? What is this? We do not have any direction so we can go from one digital.

9
00:01:25,410 --> 00:01:40,350
So let's insert here and there, not with value zero and which two in between these two vertices we have and is it three? So let's insert here node four and three and here nor did zero and which three?

10
00:01:40,500 --> 00:01:50,160
Now in between these two nodes, here's sometimes I'm saying nodes and sometimes I'm saying vertices. Don't be confused. Vortexes and nodes are the same thing here.

11
00:01:50,190 --> 00:02:00,090
Zero and a tree in redoing this. Do what it is we have. And is it five? Let's grid and not with three. And we do it five. And let's institute right here.

12
00:02:00,210 --> 00:02:09,090
So we can go from zero to three and we can go from three to zero. So let's hear another note here. We have one zero and it is five now from one to two.

13
00:02:09,160 --> 00:02:20,110
Here we have an is with four. So let's insert. So let's insert node to right here and not the one right here with it for now for this two. What is this?

14
00:02:20,130 --> 00:02:31,020
We have an is way two three. So let's insert a node right here. Three three threes that roboticists and trees that wait. And let's insert here the node 1.3.

15
00:02:31,230 --> 00:02:43,980
Now we have these two artists two and a three. So let's insert here Node three with word for and here node to do it for as well. We can go from two to three and we can go from two to two.

16
00:02:44,010 --> 00:02:56,550
And here we have it for now, from three to four and four to three. So let's insitute node for two and here nodes three two. To this, it's the representation of this graph data structure structure.

17
00:02:56,550 --> 00:03:04,980
This is just a logical representation and this adjacency list OB is stored in computer memory. Now let's see the algorithm. This is the algorithm for this.

18
00:03:05,160 --> 00:03:16,890
We did undirected graph we have here plot node. This node has three attributes value, weight and a mixed pointer. And here we have vitesses and here we have area Blinkist.

19
00:03:16,920 --> 00:03:24,810
This is adjacent to the list. And here we have the constructor it takes on property vertices. Here are sitting partisans to this variable. What is this?

20
00:03:25,020 --> 00:03:36,630
And we are creating here link list and or inserting the link list into the AdSense list. Here we have add, is method. This method takes to promote your source destination and wit.

21
00:03:36,960 --> 00:03:50,910
And here are inserting the data into our AdSense list, and this sprint method will print our graph data structure. Instantiate this class with five will create an array of length.

22
00:03:50,910 --> 00:04:03,530
Five. This and it will store the I just since the list. This is an area of linked list and this is the logical representation of grab data structure. If you call this method, add it to zero one two.

23
00:04:03,540 --> 00:04:17,590
Yet there is it when is the destination and zero is the source. So here we're going to add a node with value one, and we wait to see if this is underrated here and also by this two line.

24
00:04:17,610 --> 00:04:31,200
OK. Here we see that we can go from zero to one and from one to zero. So let's add an eight year wait to maybe call this method. We did a four and three will add a node here and here with with three.

25
00:04:31,350 --> 00:04:45,540
So let's add here an edge with wait for. So let's add here and edge with three. If you call this method zero three five here, let's add an edge. And let's add two note here and here.

26
00:04:45,930 --> 00:04:56,580
So let's add an edge here with weight. Five. Maybe you call this method one two four. Here we'll have an edge with four, so we can move from one to two.

27
00:04:56,610 --> 00:05:05,310
Let's add here in Node, and let's add here. In not we can go from one to two and from two to one with four. So you can go from one to two and from two to one.

28
00:05:05,610 --> 00:05:20,160
And we have worked for. So let's adhere and wait for maybe call this method with one three three and let's create A. And let's add here this two nodes and let's add here an edge with three.

29
00:05:20,400 --> 00:05:30,290
If you call this adage with two or three or four, let's add A. We develop three. And here, let's add in note we developed two. And here we have with four.

30
00:05:30,300 --> 00:05:45,870
So let's add here and age word for maybe call this method again with three four two, we'll add in Node four here and in Node three here with two. So let's add here an age old tool, and this is how it works.

31
00:05:46,440 --> 00:06:02,730
Hope you've understood the representation of weighted underrated graph. Now, if we call this method print graph, this method will print the additions list and this is the output of every understood how to represent or did undirected graph.

32
00:06:03,300 --> 00:06:13,200
Now let's talk about what did directed graph using AdSense a list. Now we're going to talk about why did undirected compromise intuition using AdSense a list?

33
00:06:14,300 --> 00:06:31,460
So this is our graph here. And wind associated with these ages. And here we have AdSense. A list of lent for this is AdSense list. Now here in between these two nodes, we have an edge with which to let's insert a note here.

34
00:06:31,940 --> 00:06:41,900
We developed one and which two now from zero to four. Here we have an edge with it. Three. So let's add here and not do it with three and develop four.

35
00:06:42,560 --> 00:06:55,880
Now here we have an edge with weight five. Let's add here in note, we do it five and develop three now from one to two. Here we see we have an edge weight for Let's create A. We develop two.

36
00:06:55,880 --> 00:07:12,860
And let's add it here. Here we have it for now from these harnesses to this. What is this? We have an h weight three. So let's add here A. We develop three and with three now from two to three, we have an eight year wait for.

37
00:07:13,040 --> 00:07:25,250
Let's add here in node with four and fellow three. Now, from here to here, we see we have direction from three to four and four two three and we have here with two.

38
00:07:25,670 --> 00:07:36,770
So let's add here to note. Three to four and four to three we have here which two. And this is the representation of this graph did a structure using AdSense a list.

39
00:07:37,070 --> 00:07:45,800
Now let's see the algorithm. This is the algorithm for oited directed graph representation. Here we have little difference. Here we have only one line of code.

40
00:07:46,100 --> 00:08:00,140
But in the previous algorithm for avoided underrated graph, we saw here another line. But here we have online because a directed graph. Let's instantiate this class graph with value.

41
00:08:00,140 --> 00:08:11,480
Five. So let's create an Arab linguist. And this is the representation of graph. If we call this method ad age, which is you don't want to hear you add in node.

42
00:08:11,720 --> 00:08:24,980
And here, let's add an edge. If you call, this method will add a node here, and let's add an edge here or three. If you call this method with zero three five, you add in order here.

43
00:08:25,340 --> 00:08:39,860
And let's add an edge here with five. If you call this method, one two four will add in nodes here. And let's add an eight year old for if you call this method with one three three here will add an edge.

44
00:08:40,070 --> 00:08:54,140
And let's add here a node with three and value three. Let's add here and each with 0.3. Now from two to three. Now if you call, if you call this method with two three four, here you add an edge.

45
00:08:54,140 --> 00:09:04,070
And let's add here in node. If you call this method with three or four, two will add in order here. And if you call this method 42 will add in node here.

46
00:09:04,730 --> 00:09:14,370
Here we see that we can go from three to four and from four to three. So you'll have here direction from three to four and from four to three. Something like this with with two.

47
00:09:14,990 --> 00:09:31,430
And this is the representation, and this is how this algorithm works. If you call this method print graph, this method will print the AdSense to list, and this is the output hope you understood how to represent oited directed graph and weighted underrated graph using AdSense list.


@@@
1
00:00:00,660 --> 00:00:12,860
Hey, you lots of guys who come back to this video in this video, we're going to talk about what is grab pterosaur gravity, which so refers to the process of visiting its verdicts in a graph.

2
00:00:13,740 --> 00:00:31,950
You're given this graph as input. First, if to choose a source node and from the source not, you have to visit all the vertex in this graph. And this process is called graph traversal in graph terrorism techniques to visit all the vertex in a graph.

3
00:00:32,730 --> 00:00:44,190
Now let's talk about the graph. There were some techniques for terrorists in the graph. We have two popular method Bet Soldiers and Depth Foster's Office and DFS.

4
00:00:45,000 --> 00:01:05,090
Now let's talk about Brett Forrester's What is Brett Forster's? Beerfest is an algorithm for Java seeing gravity to structure. It starts at some arbitrary note of a graph and explores the neighborhoods for that first year decision algorithms for terrorists and grabbed at a structure.

5
00:01:05,110 --> 00:01:18,370
It starts at some arbitrary note of a graph and explores as far as possible. Along is age before backtracking. This is the definition of literature, and this is the definition of depth first search.

6
00:01:18,670 --> 00:01:31,150
Now let's see how bit versus and the first search works. For that, we're going to take a couple of examples to understand that. First, let's take this example.

7
00:01:31,240 --> 00:01:41,960
Let's say we're giving this graph. We have to visit all the vertex in this graph to the structure. We have to tick any one vertex. We can start from any vertex.

8
00:01:41,980 --> 00:01:59,220
Let's start from this vertex zero. Now here, I'm going to see first first verse, so let's see the beef is Traverso. First, we have to pick a vortex. We can pick any verdicts as sort of verdicts here.

9
00:01:59,240 --> 00:02:10,070
I'm going to pick these verdicts zero. So let's bring develop these verdicts zero. Now what I'm going to do, I'm going to explore all the adjacent verdicts first.

10
00:02:10,910 --> 00:02:29,450
Now here, I'm going to explore all the adjacent verdicts adjacent of this verdict zero, one, three and four. We can fix this adjacent verdicts in any order we can pick in four three one order or we can seek one, three or four, or we can seek one for three or four one three.

11
00:02:30,260 --> 00:02:45,140
We can pick any order, but it's defense on the implementation of gravity to structure and the implementation of B his algorithm. If we choose your one for the rest, we have to follow a pattern.

12
00:02:45,620 --> 00:03:01,100
Now I'm going to choose one. Let's choose here one. So let's print here one. Now I'm going to choose four and I'm going to choose three. So I pick three adjacent verdicts in this order one four three.

13
00:03:01,760 --> 00:03:14,960
Since we have these verdicts one as the first verdicts. So we have to explore all the end up one. I just end up on a zero, three and two. We see we already explored zero and three.

14
00:03:15,740 --> 00:03:26,900
So let's pick this Vertex two. So we'll pick this vertex. So let's print two. Now we see that we explored all the verdicts in this graph to the structure.

15
00:03:27,110 --> 00:03:45,310
So we're done this each one valid Beerfest ever set up this data structure if we choose this node one as we choose here, this vertex one as source node here, I'm sometimes saying vertex and sometimes saying nought node and Vertex are the same team here.

16
00:03:45,320 --> 00:03:58,040
We're going to print one first since we picked one as the source vertex. Now what I'm going to do, I'm going to pick is zero. This verdict is zero, then two, then three.

17
00:03:58,490 --> 00:04:09,700
So we explored zero, three and two. Now let's visit all the adjacent argentino, the adjacent opportunities one, three and four. Here we see we have already visited one and three.

18
00:04:09,710 --> 00:04:25,820
So let's so let's pick this verdict. So let's bring here for this is another valid basis for this graph. Now, if we take four as our source node, now what I'm going to do, I'm going to think first this.

19
00:04:26,120 --> 00:04:38,420
I just think Vertex, then three, you can explore a decent vertex in any order, but it depends on the implementation of gravity structure and the implementation of this algorithm.

20
00:04:38,720 --> 00:04:48,440
We picked here zero as first vertex. So let's explore all the adjacent zero. We see I just zero, three or four already visited. So let's print here one.

21
00:04:48,830 --> 00:05:01,070
Now let's explore all the adjacent of three. The AI doesn't have three is one zero four and two. We see two is unvisited, so let's explore two and we printed here two.

22
00:05:01,280 --> 00:05:12,500
This is another valid be a first. So in this granular structure, we might have numerous valid etc. So these three traversal is valid to be a fist hour.

23
00:05:12,980 --> 00:05:26,870
Now let's see defense tower. So first, we have to pick a node as a source node. Let's pick this node. So first, let's sprint zero. Now, first thing what I'm going to do, I'm going to find it adjacent nodes and you want adjacent A..

24
00:05:27,110 --> 00:05:38,270
We can go here or we can go here and we can go here. It's different. On the implementation of grab. The structure and DFS algorithm will not visit all the adjacent verdicts.

25
00:05:38,570 --> 00:05:49,310
Instead, we will go to any one vertex. Now I'm going to move to this Vertex three. Now I'm going to explore this Vertex three. Then I'm going to explore this Vertex four.

26
00:05:49,610 --> 00:05:59,390
We see that we have two Vertex Direct three and there visited. So let's backtrack here at three. Now here we backtrack. From here we can go to one or we can go to two.

27
00:05:59,630 --> 00:06:09,500
But here I'm going to move to two, and from two we can move to one because three is visited. So let's move to one, and we printed here one, and we're done.

28
00:06:09,560 --> 00:06:27,410
This is a valid defense driver. So now let's pick one as source vertex from one. Let's move to three from three to four from four to zero. And here we see what you do is you have three adjacent, but all are visited.

29
00:06:27,620 --> 00:06:38,000
So let's backtrack here. Here we see all are visited with zero antibodies needed now here for three. We see one due to poor visited, but this is unvisited.

30
00:06:38,180 --> 00:06:55,120
So let's explore this vertex. So we're done. Whichever's all the vertex in this. Grabbed a structure. Now let's speak for as our source verdict's. Now what I'm going to do, I'm going to explode three, then I'm going to explore two, then I'm going to explore one.

31
00:06:55,510 --> 00:07:13,840
Then I'm going to explain zero. We can move it in and direction. And this is called the first ever. So for BP Stomatal, which I was told, I just sent Vortex first for Bnfice, all the adjacent vortex, but for the office we're trying to move to in any one directions.

32
00:07:14,110 --> 00:07:24,340
If we find out no way to go, then all backtrack. And this is called Jefferson algorithm. Now let's take another example for a better understanding here.

33
00:07:24,400 --> 00:07:37,690
This is a tree. Tree is a valid graph data structure. First, let's see Beerfest. The prefixes first was zero, then one two, then this level three four five six.

34
00:07:38,170 --> 00:07:53,790
This is a valid first ever so we can go in this direction here. First zero, then two one, then six five four three. These two are valid and stellar, so but this first one is common before stellar.

35
00:07:53,800 --> 00:08:04,840
So now let's see a difference two hours and four difference two hours. So first we move to the left here, then we move to the left here and here on the left, we have now on the right.

36
00:08:04,840 --> 00:08:17,050
You have not, so it will backtrack. Let's go here. And here we see four is unvisited. Let's go to four. So here there is no way to visit. So first visited zero, then one, then three, then four.

37
00:08:17,530 --> 00:08:30,820
So here let's backtrack. Here we have no adjacent of one. So let's go back to here. Let's go to this inorderto. Now, let's move here. This is the adjacent on the left of five is not on the right is no.

38
00:08:31,420 --> 00:08:43,000
So let's bring five. And let's back to here and we see here. Six Unvisited. So let's visit six. So this is a different story. So now let's see another different star cell here.

39
00:08:43,360 --> 00:08:58,120
First, you move to this node two instead here. OK, so let's move here. So first zero, then two, then six, then no, not to explore here. So let's backtrack here and let's move here.

40
00:08:58,660 --> 00:09:08,470
So there is no node to explore here. Let's back to backtrack here. Here we see one is unvisited, so let's visit one. Now let's pick this one. We're picking from the right.

41
00:09:08,980 --> 00:09:20,690
This is the pattern of our algorithms, because first we choose to instead. One. So let's explore four, then three. This is also a valid defense star. We're so open.

42
00:09:20,800 --> 00:09:37,360
Understood both offense and defense to our so for a gravity structure. Now, let's take another example for this graph. If we pick zero as marked X week zero as source of X, our of Vertex now just adjustment of zero is one entry.

43
00:09:37,360 --> 00:09:47,320
We can pick any of them. Let's be here at one. Now let's finish at three since we picked one first. So let's explore and descend upon the descent. Up one is two and four.

44
00:09:47,320 --> 00:09:58,960
You can pick four or two. So let's pick here two, then four. So we explored two and four. Now here, let's explore the descent of three at decent up three seven.

45
00:09:59,440 --> 00:10:14,320
Let's print seven. Then the descent up to a descent up two is six and five. Let's speak first. Five. So we explored five, then six. Now let's visit the descent of four.

46
00:10:14,440 --> 00:10:26,180
We see at the center for one and eight one is already visited. So let's print here. Eight now for seven, we see four seven just in the three and eight already visited the four five four five.

47
00:10:26,200 --> 00:10:41,890
We see at this is nine and two nine is unvisited, so let's print nine for six. We see I just sent two and nine already visited four eight. The adjustment of eight nine four seven already visited the nine four nine.

48
00:10:42,220 --> 00:11:00,250
I just sent five six eight there visited. So we're done. This is a valid BNFICE in the first hour, so first to explored all the adjacent vertex. Here we pick one as source of our X.

49
00:11:00,700 --> 00:11:12,760
Then we'll pick this adjacent here. Zero. Then I'm going to pick two, then I'm going to pick four. This is the order since we pick zero as the first vertex.

50
00:11:12,970 --> 00:11:26,710
So let's explore the adjacent vertex of zero here. Three. Let's explore three. Now four two four two. A decent five and six. First, let's explore five, then six.

51
00:11:27,250 --> 00:11:39,460
Now four four four four. Adjacent is eight. So let's visit eight, then four three at decent is seven and zero zero is already visited. So let's print seven now four.

52
00:11:39,460 --> 00:11:58,450
Five adjacent is three and four. Five decent is two six. Nine to six already visited, so let's visit nine, so let's bring here at nine for six. The adjacent already visited the adjacent of eight, already visited four, seven and nine adjacent already visited.

53
00:11:58,630 --> 00:12:07,120
So we get this traversal. This is a first ever, so this is a valid previouscarousel. Now let's see the first ever sold for a difference to our celebrity peak.

54
00:12:07,840 --> 00:12:19,870
Zero answers verdicts will go in any direction or Kim if we have no way to go and then will backtrack. Hurry up. Zero now the eye doesn't offer zero, one and three.

55
00:12:20,050 --> 00:12:33,430
Now let's go in this direction. First three, then seven, then I'm going to move to eight, then nine, then six from nine. We can explore five, but we're exploring here six.

56
00:12:33,730 --> 00:12:44,590
Now we're more Explorer two from two. Again, we're up to five where I can move to one. From here, I'm going to move to five and we see we have two adjacent and they're already visited.

57
00:12:44,620 --> 00:12:56,110
So let's backtrack. Here we see we have three adjacent to adjacent already visited. So let's visit this adjacent. Now here we see we have three adjacent four is not already visited, so let's visit.

58
00:12:56,110 --> 00:13:10,210
For now, let's backtrack to one. There is no unvisited then. Two There is no unvisited been to five. We see there is not an visited from one out backtrack to five from five let's beta two two.

59
00:13:10,210 --> 00:13:21,670
There is no unvisited from two to six. There is no unvisited here. Nine No one visited four eight nor unvisited for seven and visited and for three. There is no unvisited and four zero.

60
00:13:21,670 --> 00:13:33,820
There is not an visited. So we have explored this gravity distractor and this is called Dfenseurs. We're trying to explore in any one directions. Well, know where to go.

61
00:13:34,120 --> 00:13:46,510
If we find it no nodes to explore, then backtrack. And this is called DFS Carousel. Now we pick this vertex one as source vertex. We have a three adjacent vertex.

62
00:13:46,510 --> 00:13:57,340
We can move in any direction. We have three adjacent vertex. We can explore any one vertex. So let's explore this vertex four from four. Let's explore eight from eight.

63
00:13:57,550 --> 00:14:08,440
We can go to nine. Or you can go to seven. So let's explore here. Nine. From nine, let's explore. Six from six. Let's explore two. From two. Let's explore five.

64
00:14:08,800 --> 00:14:19,720
Now we see there is no unvisited adjacent. Let's move here. Here are backtracking. Then let's backtrack here. Then let's backtrack at nine. Let's backtrack at eight.

65
00:14:20,020 --> 00:14:29,340
Now for eight, we see we have had three adjacent add ons and visited two. Let's visit seven for seven. We have two adjacent. One is unrelated. Let's visit three for three.

66
00:14:29,460 --> 00:14:38,170
We have one at Jacintha zero and visited, so let's visit zero. There is no unvisited adjacent zero, so let's backtrack. There is no and visited a decent of three.

67
00:14:38,170 --> 00:14:47,170
Let's backtrack. There is no. I'm visited at a set of seven, so let's backtrack. Let's backtrack here and let's backtrack here. So we backtracked at our source node.

68
00:14:47,200 --> 00:14:58,710
So we're done whatever is the enter grabbed at a structure and this is called and this is called. This is called different. So hope you understood what is difference there and what is B of a star?

69
00:14:58,720 --> 00:15:09,070
So now let's take one more example. Now let's take another example for a better understanding and it clear your doubt on Beavis and DFS that we all take here.

70
00:15:09,430 --> 00:15:22,540
2.6 examples. Now, let's see. Example number four. Here we have this graph data structure. This is a graph due to structure. Now let's see BFS. Let's zero as source Vertex zero assaults Smart X.

71
00:15:22,810 --> 00:15:36,190
From here, we have to explore all the adjacent forest. The adjacent R0 is three for one. Let's explore one, then three, then four. So we explored one, three and four.

72
00:15:36,820 --> 00:15:50,920
Now for one, let's explore all the adjacent adjacent is six, five and two. First, let's explore two, then five, then six and we see there is no vertex and visited.

73
00:15:51,040 --> 00:16:05,020
So this is a valid to be officers. Maybe fig one as our source vertex. What do you will do? We'll pick zero, then two. So we have at descent of one zero two six five.

74
00:16:05,170 --> 00:16:15,250
So zero two. Then we'll visit five, then six. So zero two five six. Now let's visit. The adjacent zero zero is three four and you can speak in any order.

75
00:16:15,280 --> 00:16:28,840
Three four four three. But it's different on the implementation of grab the structure and the algorithms. Here let's pick three. Been four. So this is a valid obvious traversal.

76
00:16:29,290 --> 00:16:41,350
Let's see some more of his tower. So we pick five sorts of artists. Then we'll visit one. Then if we pick five as Vertex, we will visit one. Then zero, then two.

77
00:16:41,440 --> 00:16:53,920
Do you know, maybe pick? As sort of vortex that will have this kind of power, so this is called preposterous, and let's see the traversal rage out of him.

78
00:16:54,160 --> 00:17:12,070
I'm not going to go through is Estefania. Vigilant will be increased. So I'm going to just showing you this pad. This is a valid be a fist aerosol five one, then six, then two, then zero, then three, then four.

79
00:17:13,150 --> 00:17:26,450
OK, now let's see defense traversal for this graph. Let's pick your source vertex. So first, what I will do, I'll move to four. So there is no way to go here.

80
00:17:26,470 --> 00:17:41,980
We see there is no unvisited Vertex four, just not four. So let's backtrack at zero twos and visited. Let's visit three. Now, let's backtrack here. There is no and visited Vertex connected to this vertex.

81
00:17:42,250 --> 00:17:56,800
So let's backtrack here. We have this vertex. Let's print one. Now let's go to here to this node six, then to this node five been two. This is a valid defense tower, so let's see.

82
00:17:57,860 --> 00:18:16,330
If we pick one as source not, then this is the difference terrorism. This is a valid defense terror. If we pick five as source of RDX bin, this is the valid defense to ours and I'm not going to go through establish.

83
00:18:16,340 --> 00:18:30,710
So by picking different vantages at source, not if I do, then the vigilant will be increased. Now let's see how we can traverse this grabbed at a structure using beef, isn't it?

84
00:18:31,430 --> 00:18:42,170
Now let's see how we can describe it to structure it using Beavis and office algorithms. First, let's see Beavis, and let's take let's take zero as source verdicts.

85
00:18:42,620 --> 00:18:54,170
Now we have zero from zero, we can move to one and three. So first one, then three. For one, we have three adjacent. First, let's explore. First, let's explore.

86
00:18:54,170 --> 00:19:06,820
Two been for now for three. There is no unvisited verdicts now for two. We have two. Unvisited. So let's be here first. Eight. The nine now four four four four.

87
00:19:06,830 --> 00:19:21,430
We have three unvisited verdicts here. OK, so let's speak first. Five, then six, then seven. So we explored five, six and seven for eight. There is no unvisited verdicts.

88
00:19:21,440 --> 00:19:32,300
Is connected to this products. Eight now four. Nine. There is no unvisited vortex here now. Four five. There is one unresolved verdict the distance. So let's bring it in for six.

89
00:19:32,300 --> 00:19:40,730
There is no unvisited verdicts. For seven, there is no unvisited verdicts. And 14, there is no unvisited verdicts. So we're done. This is a valid office tower.

90
00:19:40,730 --> 00:19:53,330
So if we hear this Node three as source verdicts, then what is the original appeal we have established? So I'm going to showing you the result. I'm not going through here.

91
00:19:53,360 --> 00:20:06,890
I'm not going to go through by taking different verdicts as a result. So let's see that we've established a three zero two one eight nine four five, six, seven and 10.

92
00:20:07,370 --> 00:20:27,440
This is a valid business reversal. Now let's take another vertex as source node five then that we've established soon is four six seven four six seven, then 10, then one, then zero two three eight nine.

93
00:20:27,980 --> 00:20:38,610
Now let's see Defense Star. So for described it to structure, let's take zero as the source vertex first. What I'm going to do, I'm going to move to this node three.

94
00:20:38,930 --> 00:20:56,810
So we explored this Node three. This is the adjacent. Also, one is adjacent. We can move to one as well. But here I'm moving to three. You can choose any direction, but it's different on the implementation of gravity structure and the implementation of Divis algorithm that I'm going to explore to.

95
00:20:57,290 --> 00:21:10,130
I'm not kidding here. The adjacent, I'm trying to go in one direction. If we see there is no vertex to visit, we'll backtrack. From here, I'm going to visit nine from nine.

96
00:21:10,130 --> 00:21:20,830
There is no vertex. There is no decent vertex four nine. There is no unvisited adjacent vertices, so let's backtrack from to. This is unvisited and this is unvisited here.

97
00:21:20,840 --> 00:21:29,360
I'm going to explore it. Now, let's backtrack again. Here we have one here. Unvisited, let's visit one for one. We have only one direction. Let's go to four.

98
00:21:29,660 --> 00:21:46,930
Let's explore four here for four, we can move to three direction to five to six or seven. Here I'm going to explore seven first four seven. We see we have two and visited vitesses five and six here and want to explore six four six.

99
00:21:46,940 --> 00:21:59,090
We have one unvisited that is five four, five one unvisited, 10 and 14. We see there is no unvisited. Let's backtrack here, then let's back to here. Then let's backtrack here.

100
00:21:59,420 --> 00:22:15,920
Then let's backtrack here. Then let's backtrack here. Then here, then here. Then add this part of this to then at three, then at zero. This is the difference to our when exploring all the adjacent vertices.

101
00:22:16,100 --> 00:22:29,890
We're trying to move two in one direction and if we find it, there is no and visited at decent matrix all back. If we pick a different vertices source node, then let's see what's going to happen here.

102
00:22:29,960 --> 00:22:45,460
Different vertex. Let's pick this vertex assortment, then this will be invalid device tower. So you will feek five as sort of the vertex. Then this would be the valid Davis Tower two.

103
00:22:45,500 --> 00:22:54,680
I would highly encourage you to try to go through this gravity to structure to find it these two traversal. Now let's take one more examples for better understanding.

104
00:22:55,070 --> 00:23:04,440
Now let's see the first ever sell for this. Richard Graf, let's pick zero +source verdicts, it would be zero as source smart. I just end up zero is two.

105
00:23:04,590 --> 00:23:17,820
We cannot move to one. We have a prediction here. The adjacent Abjure is two and three, so we can expect two or three. First, let's explore zero, then two, then three now for two.

106
00:23:17,940 --> 00:23:30,660
We have Vargas's already explored for three. We have two vertices one and four. Here, let's explore one. And then let's explore four. And we see we have explored all the vertices.

107
00:23:30,660 --> 00:23:43,140
We're done here. You see that this is a valid posterior. So now let's pick different viruses and let's see that between stellar. So we pick one as source vertex the biggest ever.

108
00:23:43,140 --> 00:24:04,290
So zero, then two, then three, then four. This is best ever. So if we pick to as source Vertex, then that be Mr. Marsalis three one four zero perfect three as sort of artists, then the best ever.

109
00:24:04,290 --> 00:24:20,820
So each one to four zero perfect here for as short as Vertex will visit one zero two three. Here we see that we have five different Beavis Towers. Well, let's talk about defense terror.

110
00:24:20,820 --> 00:24:31,800
So now let's pick zero, asserts Vertex from here again, expert to R3. Let's explore here three. From three we can explore two or four. Let's explore four.

111
00:24:32,190 --> 00:24:46,920
Then let's explore one. There is no need to visit. So let's backtrack. Let's backtrack universities and visit it. So let's visit. We're done. This is a relative historical figure.

112
00:24:46,920 --> 00:25:01,490
Different nodes. And let's see the difference. Terrorism here. I'm not going to go through different pet by taking different vertex as source vertex. If we take one as source vertex, then this is a different story.

113
00:25:01,500 --> 00:25:14,550
So if we take it to our source vertex, this is a valid device traversal. It would take three as source vertex. This is a valid device traversal we take for a source vertex, and this is a valid activist, ever.

114
00:25:14,550 --> 00:25:27,330
So now we come to the end of this video we have explained Dave is going to be his algorithms in very detailed hope. You have understood what is Barry's algorithm, what is its algorithm and how this works?


@@@
1
00:00:00,390 --> 00:00:09,240
Who you what's up, guys? Welcome back to this video in this video or going to talk about graphic terrorism techniques. Brett, a source. So let's talk about beef is algorithm.

2
00:00:10,740 --> 00:00:22,080
The is an algorithm for Jefferson graffiti to structure. It starts at some arbitrary note of a graph and explores the neighborhoods. Let's see how this algorithm works.

3
00:00:22,560 --> 00:00:35,490
You take this graph as an example. Now let's see how it works. This is our algorithms. This algorithm takes sort of art as input. Here we have an array of Boolean.

4
00:00:35,980 --> 00:00:55,380
Then we have your you didn't structure for solving this problem. We use Cube did a structure. And here we are, marking the source of art as true. And then we're adding the source vortex into the Q and here checking if the size of Q is not zero, then we're pulling the first item.

5
00:00:56,010 --> 00:01:16,410
That means the item from front and the note printing. The first item here is. And then here we have iterator. How this works, you'll see. And we're getting the list from our grab the structure from index it and we're exploring all the connected vantages to the vertices is.

6
00:01:16,680 --> 00:01:27,090
And here we're exploring all the kind of advantages that can exist. That's connected to this source of art. And let's see how this actually works. Let's assume this is our grabbed at a structure.

7
00:01:27,300 --> 00:01:40,800
And this is that graph data structures, and we're presenting this graph using adjacency list. This is adjacent to the list at this adjacency list will be stored in computer memory, and this is just a logical representation.

8
00:01:41,160 --> 00:01:50,970
Here we have queued at a structure we have front and back and we have an array of lint five because we have unified vertices from zero to four. Now let's see how it works.

9
00:01:51,270 --> 00:02:03,180
Now I'm going to take zero as the source vertex. So here visited is equal to two. Here you're inserting two at index zero. Let's insert here two differential.

10
00:02:03,390 --> 00:02:15,180
Now we're adding this source vertex, you know, recue to distractor. So we added this value here. Now we're going to take this key to the structure. Well, the side of Q is not equal.

11
00:02:15,180 --> 00:02:25,830
Cejudo, we're pulling the first item from point. And the first item is zero here. Let's pull it. If we pull, it will be removed from here. So we pulled zero.

12
00:02:26,160 --> 00:02:35,400
Now we're going to print it zero. So let's print zero here. Now we have a iterator here from IS index or going to find out the list. Here we have this list.

13
00:02:35,400 --> 00:02:45,300
One four two three. Let's explore. Now here, let's explore all the edges into what is this of zero one four three. First, we'll explore one, then four, then three.

14
00:02:45,600 --> 00:03:06,630
Let's see how. So in the next iteration of this? Well, if we have the value one here, OK? So here I'm going to insert one and I'm going to in such two year as visited an insert the the node value here, that means we visited that node will pull from the front of Q and will print.

15
00:03:06,990 --> 00:03:25,920
The next is four. So let's insert here four. And here let's add two at index four. So it means that we visited one and we visited four and we have the addition to zero is one, four and three.

16
00:03:26,130 --> 00:03:36,410
So now let's add here three. And here we have visited this three. So let's make it true. So we visited. Here we see that zero one two three four. So we're done.

17
00:03:36,420 --> 00:03:52,200
We received at the end. So using this whole look, we will added this three value one four three and here will mark the series visited. So here I'm going to pull you from here and let's let's printed on him.

18
00:03:52,470 --> 00:04:05,610
We have iterator at index one. The descent up one is three vertices. The addition of one is zero, two and three, and we seeded zero. And three already visited.

19
00:04:05,970 --> 00:04:21,210
So here what I'm going to do, I'm going to insert this note too right here and we're going to insert here too. So it marks two is visited. Now we're done after this one will have here.

20
00:04:21,480 --> 00:04:36,780
True. And here this value. Now let's pull this one before, and let's bring it here at index four will not add anything in. This will not add anything in the queue and you'll modify this visited area because all the artists already visited.

21
00:04:36,780 --> 00:04:49,710
We see that. So here, let's pick this value. Three. Let's bring here. Vertex three. We have forward connect. It's an all are visited, so this condition will be evaluated all of its faults.

22
00:04:50,100 --> 00:05:00,870
Then next note is two. So let's bring here. Two. Now we see that queue is empty. So we're done. And this is a valid device terror. So. So we find it this tower.

23
00:05:00,870 --> 00:05:22,290
So zero one four three two. This is how this algorithm works. The time complexity of this algorithm is of V plus e where vs the number of viruses and is the number of phases and the space complexity is often V or V is the number of vertices for this key to the structure and for this area.

24
00:05:22,740 --> 00:05:32,100
Hope you understood this? View this algorithm. Thanks for watching this video. I will see you in the next video. In the next video, we're going to talk about Divis algorithm.


@@@
1
00:00:00,600 --> 00:00:08,730
Hey, you what's up, guys? Welcome back to this video in this video, we're going to talk about depth first source algorithms. What is David's algorithm?

2
00:00:09,120 --> 00:00:21,180
This is an algorithm for purchasing graph data structure. It starts at so I wanted a note of a graph and experts as far as possible. Elon is age before backtracking.

3
00:00:22,310 --> 00:00:40,550
Let's see how this algorithm works with pseudocode. And we'll take this graph as an example. This is the algorithm for this depth versus this function takes one parameter the source vortex as input we have here visited already marked visited parties.

4
00:00:40,550 --> 00:00:50,570
This here have staggered a stock for this algorithm or use standard a structure for Beerfest use Q to the structure. Here first, we push the source through a stack and enriching.

5
00:00:50,570 --> 00:01:01,850
If stacking is not empty, we are picking the top element and we are removing the top element here, checking if current vertex is not visited. We are printing the vertex and when marking it as visited.

6
00:01:01,850 --> 00:01:13,490
And then here we have the list at index is and here we're running aloof. Well, we have adjacent vertex. We'll check if that Vertex is not visited. Add that onto the stack.

7
00:01:13,520 --> 00:01:25,700
Let's see how it works. Let's assume this is our given graph and this is the representation of this graph. This is an area this is visited around. This array will keep track the visited vertices and this is our strategy to structure.

8
00:01:26,000 --> 00:01:38,450
First, we inserted the source vertex. Let's take zero as sort of vertex, so let's insert here zero. Now, let's pick this zero from this stack. Since Stack is not empty and let's remove it and we're going to check, does this?

9
00:01:38,450 --> 00:01:49,350
Vertex is visited, adding this we have to follow the default value is what took him. So let's market as two and let's print. Let's print here. The value zero here escalates to zero.

10
00:01:49,400 --> 00:01:56,930
Now we have this, it is a list and here we're getting this list. One four three. Now what are you going to do? We're going to check. Does one is rooted?

11
00:01:56,930 --> 00:02:07,010
Not. So let's add here does. Four is really did not. Let's add here does three is related. No, let's add here now what I'm going to do. I'm going to prove this three.

12
00:02:07,490 --> 00:02:25,670
Let's proof and let's store it in this horrible s. Now we see three is not visited, so let's print three and let's market index three. As to now at Index three, we see that we have zero one two four and here we see zero is visited.

13
00:02:25,790 --> 00:02:34,940
So you're going to push one. Let's push here. One one is already on our stack. Don't worry about that. Then let's push here to the left push here. Four.

14
00:02:35,060 --> 00:02:43,370
Don't worry, we have had duplicates government on this stack. Don't worry about that. Now what I'm going to do now, I'm going to peek at the top and pop.

15
00:02:43,490 --> 00:02:52,760
So let's pick four and let's pop for four is not visited. Let's market as two, and let's print it at index four. We have zero and three zero is already visited.

16
00:02:52,760 --> 00:03:03,260
3'S already visited, so nothing need to be added on the stack using this. While you know, let's move to and let's add to this as we see two is not visited, so let's print two.

17
00:03:03,530 --> 00:03:15,530
And let's add here through at index two, we have one three. We see one is not visited. So let's add here one and we have three threes visited, so will not push three onto the stack.

18
00:03:15,530 --> 00:03:26,180
In the next iteration, I'm going to pick one and I'm going to profit. OK, and let's do it in this variable s and we see one is not visited. Let's insert here two and let's bring here one.

19
00:03:26,330 --> 00:03:38,120
And we're done once we see the connected notice zero, three and two and they're visited, so nothing need to be done here. Let's pop one here, OK, for only we have one here.

20
00:03:38,420 --> 00:03:47,720
We see it's already visited, so it will not print. And here it is, right here, right here. We see that this will always be the default and again, four four again for one.

21
00:03:48,050 --> 00:04:16,310
So we're done. We get this list. And this is the first hour of this graph due to structure well understood how defense algorithm works, understanding how they increase it, to go through an example and try to work with by picking different vertex as sort of R X, this algorithm only takes bigger V plus e time complexity and bigger v space complexity for this visited area and also for this is tech.

22
00:04:16,550 --> 00:04:27,160
So we don't expect a V. It might take me off to V, but that's equivalent to bigger V and here it will 2x bigger if we plus item complexity Harvey's the number of viruses.

23
00:04:27,190 --> 00:04:35,270
That means number of nodes is the number of edges in the hope you understood this algorithm. Thanks for watching this video. I'll see you in the next video.


@@@
1
00:00:00,450 --> 00:00:11,930
Hey, you what's up, guys? Welcome back to this video in this video, we're going to talk about topological sort algorithm. Many real world situations can be modeled as a graph directed.

2
00:00:11,940 --> 00:00:28,020
Is this where some events must occur before others, for example, was predicted? Let's say you were a student at the university. You want to take a Class B, then you have to take a Class E.

3
00:00:28,110 --> 00:00:42,870
Here is the credit we can solve this type of problems using trouble. Logical thought poor program in just one program will be executed if all the defendants program is executed.

4
00:00:43,650 --> 00:01:01,950
Program divinities uses strong, logical thought. If a program has some dependencies, then the defendant is must be executed to execute that program. Program Defendant uses topological cert even scheduling for even scheduling.

5
00:01:02,730 --> 00:01:15,900
We can use a logical thought in order to happen. One event some event must occur before others if one event is different on other event that we can't use.

6
00:01:16,440 --> 00:01:28,980
Trouble is encountered for this type of problems. Support You are a student at university and you want to take class eight. Then you must take classes.

7
00:01:29,280 --> 00:01:44,970
And if, as PD graduates, this is a gravity to structure here. Let's assume it is the Class B, the class is a class and so on. Here, let's assume we want to take this class eight.

8
00:01:44,970 --> 00:02:05,130
If we want to take this class eight, then we have to take class. If D and E in order to take this class, do you have to take this Class E in order to take this Class E, we have to take this Class D and B in order to take this Class B, we have to take this Class E here in order to take this class.

9
00:02:05,140 --> 00:02:16,580
If we have to take this Class C and D in order to take this class, you have to take this Class eight. So here we see that we have defendants, here we see that we have Peter greediest.

10
00:02:17,330 --> 00:02:34,530
So before we take this class, we have to take the pre-recorded classes. This is an example of topological third party program. Building a program cannot be built unless its defendants are forced to build.

11
00:02:35,400 --> 00:02:49,650
Let's say here we want to build this program h. In order to build this program, we have to build the different INSISTE program of eight. The defendant is of E's is EDF dependencies of if is DC.

12
00:02:49,980 --> 00:03:05,080
Dependencies of E is BD dependencies is Abdi's dependencies are b's and dependencies of see is a. So in order to. Build this program. We have to build all the different centers first.

13
00:03:05,680 --> 00:03:24,400
This is an example of logic sorts topological sort works only for directed acyclic graph. The word DSG directed acyclic graph. If the graph has its cycle in it, then topological sort will not work.

14
00:03:24,910 --> 00:03:38,870
Now let's see. The formal definition of logical thought it was a logical sorting is isn't ordering of the nodes in a directed acyclic graph where is directed is from nought to not be not.

15
00:03:38,890 --> 00:04:01,300
It appears before nor to be in the ordering. This is a formal definition of topological thought. Let's say we are given this graph in this graph, we see that we have a cycle in it from this node to we can move to this node four from four to six from six to three from six to two.

16
00:04:01,540 --> 00:04:22,600
So we find here is aloof. This is not a cyclic graph. This is a cyclic graph. So topological sort can be applied to this graph. Political double article sort of works only for a cyclic directed let's so it works only for directed acyclic graph.

17
00:04:23,560 --> 00:04:36,970
If you're given this graph here, we can aptly publish Got Cert. Here we have no cycle. Now let's see how topological sort actually works. For that, I'm going to take some examples for examples.

18
00:04:38,440 --> 00:04:57,730
If you're given this graph, then we have to find the topological said from this graph. First, we have to understand how this graph are built. This graph are built by adding, Is this here we have the add is method on him.

19
00:04:58,030 --> 00:05:13,480
You know, we're just showing you how this graph is built and it's five two five two two, then five two zero four two zero, then four two one, then two two three and then three to one.

20
00:05:14,470 --> 00:05:33,150
Now let's assume we have here five classic. Let's assume we have here five closet zero is a Klotz, one is a clutch. Two is a. And so on. Here we have Juno one two three as a class, OK.

21
00:05:34,210 --> 00:05:51,040
Four. Take up understanding. We're assuming during the class one of the Class three, the clutch and so on. So here we have total six classes here. We have to take one clutch before another clutch as a prerequisite.

22
00:05:51,640 --> 00:06:03,040
Here we have five two. It means that in order to take the class two, we have to take the class five. Here we have a list in order to enroll this class.

23
00:06:03,530 --> 00:06:19,140
Do we have to enroll this class five first? Only then we can enroll this class two in order to enroll this class zero First Class five only going to get to enroll the Class zero for enrolling this class, you know, faster to enroll for here.

24
00:06:19,150 --> 00:06:29,620
In order to enroll this one, I have to handle the Class four in order to enroll this class in the Class two first in order to handle this class one two in the Class three first.

25
00:06:30,400 --> 00:06:43,720
So here we have some predicates and here by graph, we see that in order to take this class, we have no prerequisites, OK? So we can take this class without any pre-recorded here.

26
00:06:43,750 --> 00:06:52,350
Also, we have this class four. We have no prerequisites. In order to take this class, we have two pretty rigid five and four. So in order to take this class, you don't.

27
00:06:52,360 --> 00:07:02,200
We have to take the Class five and the Class four in order to take this class to have to take this class five in order to take this class to produce Class two in order to take this class.

28
00:07:02,200 --> 00:07:13,090
Wanted to take this class three and four? Now we have to find out a topological order of this gravity to structure. This is a directed Insightly graph.

29
00:07:13,120 --> 00:07:24,260
We have no cycle in this graph, so we can apply here. Topological Cert The first particles in topological sorting is always a vertex with no incoming is.

30
00:07:24,970 --> 00:07:36,160
Here we see four five. We have no incoming is this and four four. We have no incoming is this. So five can be the first vertex in the topological order.

31
00:07:36,760 --> 00:07:47,800
Also, four can be the first two particles in the topological order. This is a valid logical order five four two three one zero and four five two three one zero.

32
00:07:48,100 --> 00:08:02,700
This two are valid topological ordering. Now let's see how this topological ordering works. First, we have five, then we have four. Here we see four five.

33
00:08:02,730 --> 00:08:17,700
We have no predicted four four. We have no prerequisites, so we can have four and five here in any order because they don't have any. It's that we have here two for two.

34
00:08:17,910 --> 00:08:38,730
We see it. We are pretty good yet. Five. In order to take this class, we have to take the class five first. Then we have your tree in order to take this class first us to the class two, then one in order to take this class one order to the class four and three and four and three appears on the left.

35
00:08:38,760 --> 00:08:52,470
That means four and three appears before one. Now for zero, we see what you do. We have two Peter Gadget's five and four. And we see here five and four appears before zero.

36
00:08:53,010 --> 00:09:05,850
So this is a valid topological order. Now let's see this topological order. First, we have four. And then we have five seniors, we have no Beluga jets, four or five and four.

37
00:09:05,870 --> 00:09:17,930
Are we going to have we can have four and five in any order. So here we just fast forward and fight. It's different on the implementation of data structures and implementation of the algorithm.

38
00:09:18,530 --> 00:09:30,560
Now we have here too, in order to take this class too. We have to take the class five five appears on the LIPPED, then four three. We have bigger debts too.

39
00:09:30,980 --> 00:09:43,430
We see two on the left, that one for one, we have to pretty good this four and three. So four and three appears on the left, so four and three appears before one.

40
00:09:43,820 --> 00:10:00,320
Then what do do? We have two pretty good debts and we see four and five appears before, you know. So this is a valid political order. Hope you've understood what is the top political order in the next three to see how to find a topological auditing of a directed acyclic graph?

41
00:10:00,800 --> 00:10:19,690
Now, let's take another example. For example, if you are given this graph and here we have to do five, is this let's assume we have here four classes zero, one, two or three, and we have here some conditions in order to take class on Abdoul first take the classes zero.

42
00:10:20,090 --> 00:10:32,060
In order to take that last year, we have to take the class zero in order to take the class one up to do that last two first, in order to take the class one of two, we have to take the Class three first in ordering the class to have to take the Class three first.

43
00:10:32,450 --> 00:10:45,830
This is it. This is a directed Insightly graph. The valid topological ordering of this graph is this two topological ordering. OK, now let's see how this works.

44
00:10:46,220 --> 00:11:02,360
First, we have zero for you. We have no prerequisites. And for three, we have no predicate it. So it can have zero and three in any order. We can take first zero or you can take first three, but it's different on the implementation of your digits, structures and the algorithms.

45
00:11:02,600 --> 00:11:14,630
First, we have your genome. Then we have three. Now we have yet to hear you say that you could. It's up to is zero and three. And on the left up to we have zero entry, so zero entry appears before two.

46
00:11:15,020 --> 00:11:25,820
Now we have here one. Here we see the prerequisites of one is zero two three and zero three two appears on the left of one. So zero three two appears before one.

47
00:11:25,910 --> 00:11:36,800
So this is a valid topological ordering. Now let's see how this ordering works. First, we have three and zero for three and we have no prerequisites. We can take the class in any order.

48
00:11:36,870 --> 00:11:48,370
Three. Due to order two three zero two three, then zero, then we have you two. Here we see two has two prerequisites and three different three appears to be for two, then one for one.

49
00:11:48,380 --> 00:11:59,960
We have three Brigitte's and we see that three zero two appears to be four one. So this is a valid topological ordering. Understood. What are the top of logical sort in the next video?


@@@
1
00:00:00,390 --> 00:00:09,870
Hey, you what's up, guys? Welcome back to this video in this video, we're going to talk about how to find it topological ordering of a directed acyclic graph.

2
00:00:10,320 --> 00:00:21,690
First, let's see the algorithm, then we'll see how this algorithm works. This is the algorithm for topological sort. This algorithm works in DFS fashion.

3
00:00:22,140 --> 00:00:36,570
First, we'll explore as depth as possible. We know how DFIs works. We have talked about DFS in detail in this section of discourse. Now, let's review this algorithm first, then we'll see how this actually works.

4
00:00:36,840 --> 00:00:50,280
First, we have this function topological sort. This function takes no parameter inside. Here, we're creating a stack in the stack. We will have the topological ordering that we have here decipherable.

5
00:00:50,520 --> 00:01:06,000
Then we have here this array of to our fault in this area. We will keep track visited vertices. Then here we have this love. This love will run from zero to from zero to the vitesses minus one i Lisbon vertices.

6
00:01:06,570 --> 00:01:34,290
Here we have this if statement. If visited icons defaults that we will call this top sort ideal in this utility function. We're calling with the current Vertex zero with the visited array and we just check this function will construct the stack we need done with this, fall-off will have the topological order in our stack will probably run from the top of our stack and it will print this ID, but you do function.

7
00:01:34,650 --> 00:01:47,040
This function takes three parameter the current vertex, the visited array and and a stack. Here we're marking the current vertex as visited, visited V called stood structure.

8
00:01:47,580 --> 00:01:59,290
Then we have your desirable integer current that we have here. This iterator here will have all the adjacent vertices for our current vertex. Here we have this who I live in this Israel.

9
00:01:59,400 --> 00:02:13,920
We will check if we have mixed. That means if we have adjacent bit, we will check if it is not visited. The new call this top sort you udu recursively with the adjacent node.

10
00:02:14,340 --> 00:02:30,180
When you will find it, the defense node will insert the current Vertex two. This is tech. This works in DFS manner. First, all move as far as it can. OK, now let's see how this algorithm works.

11
00:02:30,760 --> 00:02:40,920
Let's you were given this graph to the structure. This is represented using adjacent to list something like this zero connected to one. Zero guided to two.

12
00:02:41,430 --> 00:02:51,780
We can move from zero to one from zero to two, then from one. We cannot move anywhere. Then we have year two. From two, we can move to one. Then we have three from three.

13
00:02:51,780 --> 00:03:02,490
We're going to move to one. From three, we can move two two. So this is the logical representation of this adjacency list for solving this problem using DFS.

14
00:03:02,850 --> 00:03:16,560
We will use standard a structure for defense problem we all adjust. It is stack and this is the array to keep track of the visited vertices. Let's add we have this full classes here.

15
00:03:16,640 --> 00:03:30,300
We're assuming here the vertices as classic and we have some prerequisites in order to take the class or in order to enable the class one in class zero first and so on.

16
00:03:31,200 --> 00:03:44,410
Now let's see how to find it. The couple logical ordering from this given graph. This is a this is a directed acyclic graph. We have, you know, cycle and we have direction associated with is ACIS.

17
00:03:44,910 --> 00:03:57,020
First, you'll take the node zero. Here we have this wall of IndiaGlitz to zero. We'll have the first node zero. So we see this not is not visited at index zero.

18
00:03:57,030 --> 00:04:06,870
We have fault initially. This area is filled with what's here. We're not showing you the false value. By default, we have your false. So at index zero, we have faults.

19
00:04:07,140 --> 00:04:18,330
So we'll call this top sort. You deal with the current Vertex zero with the visited area and we did stack. The stack is empty initially. Now let's see how this algorithm works.

20
00:04:18,840 --> 00:04:30,600
First, what I'm going to do. I'm going to move in any one direction. We get them up to two and we can move to one because two and one is the adjacent of this node digital.

21
00:04:31,050 --> 00:04:44,400
But you cannot move in any direction. It's different on your algorithms and it's different on the implementation of your grabbed a distractor here. For this algorithm and for this implementation, I will move to it one.

22
00:04:44,610 --> 00:04:56,760
So from zero, I moved to one from one. We see it. We cannot move to any nodes. So here first, let's backtrack. We we have visited zero. So let's inside your true.

23
00:04:57,270 --> 00:05:11,560
OK. We have visited zero. Now this is our. Current node, we see it from this, not we cannot go anywhere. We're stuck here. So we find it here. Deepest node because here are doing that first tower.

24
00:05:12,160 --> 00:05:23,890
Now here what I'm going to do. I'm going to insert this node into this stack here. What does this means? It means that we have no had to send for one.

25
00:05:24,250 --> 00:05:37,090
And here we see for this node one, we have no adjacent and here we're calling recursively. OK, we're calling recursively. So for one, we have no adjacent.

26
00:05:37,720 --> 00:05:49,330
It means that this node is not puka, it's off any other nodes. So what I'm going to do, I'm going to insert this note into the stack. Now let's backtrack here.

27
00:05:50,080 --> 00:06:04,480
We see we're at zero. Now here, OK, we backtrack here. So we moved to the previous recursive function call when you call it this vertex zero. Now we see that we have it way to move.

28
00:06:04,720 --> 00:06:16,030
So we're going to move to this node here to two. So we moved to this node two. Here we have this toolkit adjacent of juries two. So we moved here now for two.

29
00:06:16,060 --> 00:06:28,930
We have one and we see one is already visited when he visited one. We have to mark this in this with two. Now we're going to backtrack and from here it will move to this node to here.

30
00:06:28,930 --> 00:06:40,390
Adjacent is to objeto now for two. We see that we have a different one. So for me it, we can move to one, but one is already visited. So we cannot move to one.

31
00:06:40,930 --> 00:06:56,970
Now here what I'm going to do. I'm going to mark this two as visited because we have visited two now. There is nowhere to go from this node to. So let's insert this node to this stack here.

32
00:06:56,980 --> 00:07:09,460
It means that we have it adjacent nodes of this node to here. It means we can move to that node here so we can move from two to one. But one is already visited.

33
00:07:09,680 --> 00:07:23,830
So we have visited this node two and we have marked and we have marked this in. This is very true. So from here, we can't move to any direction. So let's backtrack.

34
00:07:24,100 --> 00:07:35,440
Now this is our current. Now here's what I'm going to do. I'm going to process this node. OK, this already visited. So let's process this note, and let's insert here zero in the stack.

35
00:07:35,450 --> 00:07:45,730
We have one two Arduino here in the bottom of this stack, we have one. What does this mean? It means that one is not a pure prerequisite for any other nodes.

36
00:07:46,420 --> 00:07:58,600
And in order to take this clutch, we have to take the class we have on the top of this stack. OK. Here two means in order to take this class, we have to take the class we have on the top of the stack.

37
00:07:58,810 --> 00:08:06,160
You know, not to take this class, you don't. We have to take the class, whatever class we have on the top of the stack, Dilnot, we have no class on the top.

38
00:08:06,790 --> 00:08:18,850
Now we have did digital. Now we're going to move to the next vertices. The next of is is one. First, we have traversed the graph by taking zero as the source of.

39
00:08:19,870 --> 00:08:30,820
We have terrorist. That graph for Vertex zero is India officers. Now let's take the next of our next one. We see when he's already visited. Now let's move to the next.

40
00:08:30,850 --> 00:08:39,710
But it's two twins already visited. Now let's take the next vertex that is three three is not visited. OK, so let's call this you do the function here.

41
00:08:39,730 --> 00:08:51,520
We call this udu function and insert here two. Now for three, we see we have one. One is already visited. We have to do already visited. First, we'll move to this direction.

42
00:08:51,530 --> 00:09:00,850
We see when is visited. So let's backtrack. Let's move to this direction. Two is already visited. So let's process this node. Let's insert this not to the stack.

43
00:09:01,120 --> 00:09:12,850
So we inserted here three. So we have to visit the gravity to structure for the next iteration I to four and vertices it equal to four. So for less than four, we're not at fault.

44
00:09:12,860 --> 00:09:25,810
So this so this follow up will stop and we have you this while you're using this a while will pop the top 11 from stack and reprint. So first off, three, let's print three, then let's swap zero.

45
00:09:25,810 --> 00:09:38,170
Let's print zero. Now let's pop for two. Let's print two. Let's pop one. Let's print here one. So we'll remove here. But that will remove the element from the stack.

46
00:09:38,560 --> 00:09:52,420
So we get this topological ordering. So this is a valid topological ordering. In order to take the class one, we have to take the clutch three, two and zero.

47
00:09:52,450 --> 00:10:06,790
Here we see that in order to take that last one up to do that zero, two and three in order to take the class to everything that was. Three and zero. In order to do that, you know, we have no video credits in order to do that last year, we have no tickets.

48
00:10:06,970 --> 00:10:18,890
So this is a valid topological order. This is how geopolitical sorting works. Well, we've understood this algorithms in a very high level. Now let's take another example for better understanding.

49
00:10:19,330 --> 00:10:30,640
Let's see what a given this grab a that this is a direct Insightly graph and this is the representation of this gravity structure. Let's use this tech and a Boolean area to solve this problem.

50
00:10:30,940 --> 00:10:43,270
So first, let's start from the index zero. From Index zero, we cannot move to any directions from zero. We cannot move to any vertex. So let's marks zero with two.

51
00:10:43,810 --> 00:10:58,360
So let mark zero withdrew from the smart x zero. We cannot explore any vertex. We have no relation from this vertex to other vertex. So let's insert your true and let's process this note zero because we cannot move to any vertex.

52
00:10:59,080 --> 00:11:16,680
Now let's take the next vertex one here, OK? One we see. For one, we cannot move to any verdicts. So let's market as true, and let's insert here one from this vortex one, we cannot move to any verdicts, so we processed it.

53
00:11:17,250 --> 00:11:29,100
Now let's move to two. Using this portable came from two. We can move to three. OK. So let's mark two as visited. Now let's mark three as visited. Here are true.

54
00:11:29,490 --> 00:11:45,750
Now we see from three, we can go to one, but one is already visited. So let's insert three onto the stack. Now, let's backtrack here. We have two. Now here we see there is no way to go from two because three is already visited.

55
00:11:45,930 --> 00:11:57,900
So let's insert here. Two. Now, let's move to the next two verdicts. The next vertex is three. Here we see from three, we can move to one. But one is already visited for three.

56
00:11:57,920 --> 00:12:08,130
We see that tree's already visited. Let's move to the next vertex that is four from four. We see that we can move to zero and we can move to one. First, let's move to zero.

57
00:12:08,430 --> 00:12:18,690
Move to zero. And we already visited. So let's backtrack from here. We see that one is already visited. From here, we see that we have one. One is already visited.

58
00:12:18,720 --> 00:12:31,140
So let's process this. Not four. We have visited this node. So let's make it as true. We have to market as tool when envisages node for the first time, let's insert four to the stack.

59
00:12:31,470 --> 00:12:42,870
So we're done. Now let's move to the next vertex. That is. Five. OK. Here we see from five, we can move to two a.m. up to zero heuristics already visited and two is already visited.

60
00:12:43,290 --> 00:12:57,910
Let's mark five as true here when a visit for the first time. So from five, we cannot move to zero and we cannot move to two because. 012 already visited, so let's insert five here on this stick.

61
00:12:58,840 --> 00:13:13,450
Now we're done. Now what are we going to do? We're going to pop the element from that top up stack. First five. Let's out in for let's pop out then to let's pop out two, then three.

62
00:13:14,390 --> 00:13:31,840
Let's pop out three, then one one, let's pop out one from here and and finally zero. So let's pin here zero. So we get this topological ordering. We have your six closet and we have your conditions in order to take the class two.

63
00:13:32,210 --> 00:13:42,770
You have to do the class five and four in order to do that, less than zero. We see we have five on the left in order to class. You don't have to do that last for four on the laptop, up zero.

64
00:13:43,580 --> 00:13:59,750
In order to take class zero to do that last four as well in order to get class one up to take the Class four in order to take the class to do the class two, we have two on the left and take the class one of the class to even the left of him.

65
00:14:00,020 --> 00:14:23,060
So we see this is a valid topological ordering of this directed acyclic graph. Just Dr. Hope have understood how topological sort of works that time. Complexity for this illusion is bigger off policy e and the space complexity is bigger f v or V the number of vertices and is the number of is this in the given directed acyclic graph?

66
00:14:23,540 --> 00:14:42,500
So the time complexity is bigger a V plus e and less space complexity is bigger f v. We have understood this explanation. Even understanding 'Owhali encourages you to try to draw everything on a piece of paper who understood how topological sort of works in a very high level, even any question of any doubt.


@@@
1
00:00:00,540 --> 00:00:26,910
Hey, you what's up, guys? Welcome back to this video in this video, we're going to talk about single source, shortest path problem. So what is the single source, shortest path problem, single source, shortest path problem is about finding a path between a given vortex called source to all other participants in a graph shows that total distance between them.

2
00:00:27,830 --> 00:00:39,590
That means source and destination is minimum. So we're giving a source of Ortex. We have to find it the minimum distance for all other word is just from source of RDX.

3
00:00:40,520 --> 00:00:57,650
This is called a single source shortest path problem. Let's say you were given this grafitti distractor here. We have some weight. We see this graph is a weighted, undirected graph which is associated with ease acis.

4
00:00:57,740 --> 00:01:08,660
So this is a weighted, undirected graph, let's assume is the source vertex from this vertex, if we have defined the minimum distance to all other vertex.

5
00:01:09,260 --> 00:01:24,290
So from year to year, the minimum distance is zero came from it. We have no pep. So we have here zero now from E2EE. We see the minimum distance is this one.

6
00:01:24,830 --> 00:01:41,600
If we go in this direction for us. Six then took if we b and we see the cost here, six plus two is eight. So here the minimum distance is one. So from this vertex eight, we can raise this vertex e in cost one.

7
00:01:41,840 --> 00:01:54,590
Now from this vertex eight to this Vertex B, we see that distance is six. We move from A to B. If we move first here to E, then from E to be it, we see one plus two that is three.

8
00:01:55,040 --> 00:02:06,680
And it will move in this direction first one, then one, then two. And that is for one plus one plus we go two to four. So here we see we can raise this vertex from this source of particles in this path.

9
00:02:06,920 --> 00:02:18,740
And the cost in this part is three. Now let's find it the minimum distance to visit this vertex from this vertex a, we clearly see that the minimum distance to raise this vertex is one plus one.

10
00:02:19,160 --> 00:02:32,750
So this is the direction. So here we'll have the distance, the minimum distance. To now, let's find the the minimum distance to this vertex, and that is one plus one plus five and there is seven.

11
00:02:32,930 --> 00:02:43,580
So here we can raise this bar to see from here. So if we want to visit this bar to see from this vertex, the cost is seven one plus one is two two plus five is seven.

12
00:02:44,240 --> 00:02:56,540
OK. This is called single source shortest path problem. We can solve this single source shortest path problem using this extra algorithm and using Billman forward algorithm.

13
00:02:56,900 --> 00:03:11,300
But here, this extra algorithm doesn't work for negative cycle. If we have a negative cycle in the given graph been, this algorithm will not work. So what is a negative cycle?

14
00:03:11,900 --> 00:03:25,730
Here we see this is a undirected graph. So in this graph, we have cycle if we have minus seven in stage two, if it is minus seven and if we add it in this cycle, we get zero.

15
00:03:25,970 --> 00:03:41,300
So we do not have here a negative cycle, the condition for having a negative cycle in aloof. We should have the summation of which is less than zero. But here we see we have elu in this loop.

16
00:03:41,300 --> 00:03:55,040
We see seven minus seven plus one plus two and there is minus four. So we see the word in this cycle is minus four. That is negative. So this is a negative cycle.

17
00:03:55,280 --> 00:04:06,110
The another condition for negative cycle is that we had to it pat to visit that negative cycle from the source apart x. The source of our here is from here.

18
00:04:06,350 --> 00:04:16,610
We can't visit this cycle. OK, so this is a negative cycle in this graph. So for negative cycle, this extra algorithm unit works for a negative cycle.

19
00:04:16,910 --> 00:04:29,330
Billman forward algorithm works in the next video. We'll see how this extra algorithm works, then in the next video or see how Billman forward algorithm works, suing the next video.


@@@
1
00:00:00,390 --> 00:00:14,800
Before move to these extra algorithm, first, let's talk about white VFS, and if this does not work for single source shortest path, the problem here is this is before a single source shortlist.

2
00:00:14,970 --> 00:00:32,100
But first, let's talk about why if this does not work for single source shortest path problem, we know that because explores a given graph only read way, but there can only just be a better route, which is not a breath away.

3
00:00:33,270 --> 00:00:43,350
This is the way business works. This is how Beerfest our solar works. Let's add him arguing this gravity to structure. This is kind of true to the structure.

4
00:00:43,470 --> 00:00:55,440
We know that tree is a special types of gravity to structure in this gravity. Just talk to Adam. Or given this vertex is, you know, we have to find out the shortest path.

5
00:00:55,740 --> 00:01:08,220
We have to find it the shortest path from this vertex zero to all other vertex, if we do here. B, if this first all drivers this level, then this level here we see that the distance between this not zero and one is ten.

6
00:01:08,760 --> 00:01:28,410
And here we move to this level. We see that the distance between from this vertex to this vertex three is 10 plus 30. That is 40. But we see that the minimum distance from this vertex to the smart X three is ten plus five plus six.

7
00:01:28,680 --> 00:01:47,010
That is not 40. There is 21. So we see that here. We find it a wrong answer for the problem. Single source, shortest pet. So we can enter through here because it would do Beavis, then we will get a wrong answer.

8
00:01:47,730 --> 00:02:00,160
Now let's talk about why defense doesn't work for single source shortest path problem. We know that defense has the tendency to go as far as possible from source hands.

9
00:02:00,240 --> 00:02:14,670
It can never find shortest pet. Let's see why. Let's assume you're given this grabbed a distractor, and let's assume this. It's our source vertex. OK, so let's find out the distance from this vertex to this vertex.

10
00:02:15,810 --> 00:02:29,840
If, OK, so what is the minimum distance from this verdict? It was worth except for that if we do hear defense, then first we will explore B, then C, then backtrack D, then then f.

11
00:02:30,080 --> 00:02:42,290
Here we see that if we do the first hour or so from this vortex to this vortex, if we see that this is not the minimum distance, we clearly see that the minimum distance is this of him.

12
00:02:43,280 --> 00:02:57,800
But we get this Pat, and we find it here. Wrong answer. And this is why defense doesn't work for a single source shortest path problem who understood why we focus on defense does not work for single source.


@@@
1
00:00:00,990 --> 00:00:16,070
Hey, you lots of guys, welcome back to this video in this, we are going to talk about these extra algorithm. Let's, Adam, we're giving this graphic data structure, and the source of vortex is this vertex zero.

2
00:00:17,060 --> 00:00:32,990
Now we have to find her the minimum distance from this source of Vertex to all vertex in this graph. So let's see how to find it's the minimum distance from this vertex zero to all other vertex in this graph.

3
00:00:34,010 --> 00:00:50,660
Let's see how this extra algorithm works. First, what it does it assume that to visit any vertex, the cost is infinity. So let's assume to visit this vertex one is what the cost is infinity.

4
00:00:51,830 --> 00:01:09,540
So the initial cost is infinity. So let's add here Infinity, Infinity and infinity. Here is the source vertex. So from this body zero to this vertex zero, visit this vertex zero from these particles zero.

5
00:01:09,560 --> 00:01:21,290
The minimum cost is zero because we have you know what associated. We have no love in this vertex. OK, so the cost here is zero and zero is less than infinity.

6
00:01:21,440 --> 00:01:37,010
So let's replace infinity with zero. Now what are we going to do? We're going to find out the vertex with minimum cost. OK. So here we see that we have these products and this vertex has minimum cost.

7
00:01:37,250 --> 00:01:50,180
Now what I'm going to do, I'm going to find out the minimum distance from this vertex to this vertex one, the minimum distance, Oregon's the minimum cost.

8
00:01:50,840 --> 00:02:02,130
Let's addameer distance, OK? The minimum distance from this vertex to this one is 0.6. That is six, and this is six is less than infinity. So let's give this infinity width.

9
00:02:02,150 --> 00:02:18,170
Six. Now let's explore the next adjacent. We have process this adjacent. Now let's explore this adjacent. Now for this vertex, we see that the wood in between these two particles is at one.

10
00:02:18,350 --> 00:02:31,340
The cost to visit this smart x is zero plus one. So let's update this value infinity with one because one is less than infinity. So the minimum distance here is one.

11
00:02:31,580 --> 00:02:47,780
So from this vertex zero, the minimum distance to this vertex four is one. So we press this Vertex zero will not visit this verdict. Zero. Anyway, we have processed this vertex.

12
00:02:48,620 --> 00:03:03,620
Now let's find out the minimum distance for the vertex. OK. So we see that the minimum distance here is for this vertex. Look at this one here, the minimum distance one here we have six.

13
00:03:03,620 --> 00:03:21,740
Here we have infinity and here we have infinity. So this is that vertex, where we have the minimum cost or the minimum distance from source vertex. Now what I'm going to do, I'm going to update the value for the AdSense.

14
00:03:21,980 --> 00:03:37,850
If be, consider this is you. And let's adjust this view, OK? So let's find out the minimum cost here if we move in this direction. So we see that one plus two equals two three three is less than six.

15
00:03:38,000 --> 00:03:55,760
So let's update six with three. Now for this ad doesn't now is this now? Is this vertex? Here we see that minimum cost or the minimum distance to visit this vertex is one plus one that is two two is less than eight.

16
00:03:55,940 --> 00:04:10,190
So let's update this well with two. So we have processed this vertex. Now let's find it the minimum vertex. OK. So here we see four is already visited and zero is already visited.

17
00:04:10,670 --> 00:04:24,140
Now let's find it the minimum distance here. We see the minimum distance we have for this VORTEX2. Here we see that the minimum distance we have for the Vertex three, there is two from this vertex.

18
00:04:24,950 --> 00:04:38,960
Let's try to find it the minimum distance for this vertex. If we consider this is you and this is V, then from you two v, the minimum cost is here. We have already three, but the cost from this product to these vertex is two plus two.

19
00:04:38,960 --> 00:04:51,480
It is four. Four is not less than three. So Ueland update this regulatory no, that's above the minimum distance for these particles, and that is two plus five, seven and seven is less than infinity.

20
00:04:51,560 --> 00:05:07,020
So let's admit this vertex with seven. So we have processed this vertex now. Let's find out the minimum. Here we see the minimum is three. The minimum distance for this verdicts is three.

21
00:05:07,380 --> 00:05:16,950
Now from these verdicts, we have only one at decent and visited verdicts and we have heard you two, four three. And there I dissent, but they're visited.

22
00:05:17,220 --> 00:05:26,490
Now what I'm going to do, I'm going to find out the distance from these verdicts to these verdicts. OK, you have three. I was eight, but here we have seven.

23
00:05:26,640 --> 00:05:38,420
So we're not updating this well to seven with eight because it is not less than seven. So this verdict is visited. Now let's find out the minimum verdicts, what unvisited we see.

24
00:05:38,430 --> 00:05:50,550
This is the verdicts in this verdicts. We see the minimum distance is seven. But here we have no and visited adjacent. So nothing to be done here. We're done.

25
00:05:50,880 --> 00:06:00,990
There is no unvisited. I dissent for this party to. So will you not think here? We're done. We find it the minimum distance from this, nor the zero to all other nodes.

26
00:06:01,350 --> 00:06:09,600
This is that the extra algorithm. This is how this algorithm or so from zero to this node one, the minimum distance is three from zero to four million.

27
00:06:09,600 --> 00:06:20,430
Based on this, one from zero to three minimum distances to from zero two to the minimum distance is seven. Understood. How does its algorithm works? Now let's see.

28
00:06:20,430 --> 00:06:33,000
That is extra algorithm. This is the this extra algorithm. This function takes so smart as input. Here we are visited. Ari here will keep track. The visited viruses here have distant in this area.

29
00:06:33,030 --> 00:06:46,260
We'll keep track the minimum distance. Then you are running a loop here from index zero two vertex minus one. And here we're inserting the maximum value and adding meaning that this well is infinity.

30
00:06:46,410 --> 00:07:03,000
Here we're assigning the maximum value we can store in 32 bit and the maximum value we can string entitled to. We're considering infinity that we are inserting a source of particles zero because from Vertex, from source vertex to source Vertex, there's no distance.

31
00:07:03,080 --> 00:07:16,860
OK, the minimum restraint is zero. Now we have you this move. We're running this loop from I and Islas. Then what is I split here? We have you got to find a minimum distance, find the minimum distance in the graph.

32
00:07:17,040 --> 00:07:30,960
If we find it minimum distant, all set that as true because that vertex will be the particles and the particles will not revisit anyway. Here we have this form of individuals vehicles.

33
00:07:31,090 --> 00:07:44,910
You know, Villazon, what is this? And here we're checking if the add just into Vertex is not visited. And if we have it connections, if that is adjacent, Hilbert checking using this connection here, I just Reddick's.

34
00:07:44,940 --> 00:07:57,570
You already got two zero. If you have value, go to zero. That means the vertex is not the adjacent of the Vertex you. Here we have this core. OK, this is for relaxation condition, OK?

35
00:07:57,840 --> 00:08:11,190
Here we're adding distance. You end and the weight added in between these two vertices you envy and you're checking if it's less than that distant at, we're updating that distant at a V.

36
00:08:11,580 --> 00:08:25,830
And then here we're just printing the event from this distance area. OK at index zero will have the distance from zero to zero at index on all our distance from zero to one, and the distance will store in the distance.

37
00:08:26,280 --> 00:08:37,260
And there's a minimum distance. So let's review this function. Find mean distance in this function, we call a distance and visited, and we are assuming this integral to integer dot max value.

38
00:08:37,470 --> 00:08:51,840
And then we're assuming min distance vertex equal to minus one. This variable will have a value alleges. OK, so we can have year minus one. We don't have to worry about the index outbound that we have here this frolov for angles to zero.

39
00:08:51,890 --> 00:09:00,240
I lived in Vertex and here checking if the current vertex is not visited, then we'll check this condition. It was a distant isolate, the mean distance.

40
00:09:00,360 --> 00:09:14,060
We will update this well and then the mean distance of Vertex. OK, here. This function all region, the vertex. We have the minimum distance where you are returning that because we will not revisit the particles anymore.

41
00:09:14,200 --> 00:09:27,450
Let's assume we're given this graph data structure in order to solve this problem. Used to array visited and distance of limp vertices representing this gravity structure using this adjacency matrix.

42
00:09:27,810 --> 00:09:41,400
Now let's see how this algorithm works. In this distance, Ari will fill with infinity value. Add you mean maximum value we can store entitled two bits adds infinity.

43
00:09:41,730 --> 00:09:55,290
So let's insert here. Infinity here infinity. So let's insert infinity here as well. Here here. Infinity, Infinity Infinity. So Index two algorithm first.

44
00:09:55,410 --> 00:10:11,590
What it does it assume that to visit any vertex in. The graph from source of that cost is are the minimum distance is infinity. Now we're going to set the source vortex to zero because the distance between this vertex zero two, this vertex zero is zero.

45
00:10:11,590 --> 00:10:25,690
So let's update this well with zero, let's change this value to zero. Now we'll run this falloff. Here you'll find it the minimum distance. The minimum distance here do so in Britain will return here, the mean distance of art.

46
00:10:25,840 --> 00:10:35,320
So in this graph, we see that the mean distance of our X is zero. So Illusion zero and all in such a true by this statement. OK, now we have this loop here.

47
00:10:35,590 --> 00:10:46,900
Now let's find it all at the center of this vertex at this in this war and one which in the adjacent four zero, we're taking the adjacent vertex here using this formula.

48
00:10:46,910 --> 00:11:01,960
If we see it is a matrix, you know, equal to zero. It means that the vertex you and we are adjacent. So from this vertex zero to this vertex on, we can rise in cost six.

49
00:11:02,230 --> 00:11:12,970
I see a bit here, OK, if we visit in this direction and will check this condition your distance you plus at the center matrix, you've lived in this tent.

50
00:11:13,690 --> 00:11:25,930
This is the condition for relaxation. So let's update this value with six, because this condition is to zero. Six is less than infinity. Zero plus six is less than infinity.

51
00:11:26,200 --> 00:11:41,410
Here at this informatics is that within in between you and Vertex, you is zero and vs one. So let's update this well with six. So here at Index, Abdi developed it six now from zero to four.

52
00:11:41,890 --> 00:11:52,540
Hyrule Check from zero to two zero zero two two. We have value zero, so we have no edge from zero to three. We have no. It's from zero to four. We have an ID and we see that it's adjacent.

53
00:11:52,870 --> 00:12:03,400
So here we're going to add one and two zero one two zero one one is less than infinity. So let's update the value at index four with one. We're done. We have processed this node.

54
00:12:03,850 --> 00:12:14,860
Now let's move to the next iteration of this loop, and let's find out the mean distance of Vertex for the unvisited vertex and visited Vertex 142. Here you have the mean descends.

55
00:12:14,860 --> 00:12:26,890
Vertex is four. So this function will be done four and four for the adjacent is we see here zero one and three zero one and three zero is already visited.

56
00:12:27,220 --> 00:12:41,770
So we will not revisit zero here, finding out the mean distance of X because because we only find it the minimum distance. So here we see four scenes rooted in this vertex four will insert at index for two.

57
00:12:41,890 --> 00:12:51,640
Now here one plus two is three. Three is less than six. So we're going to orbit here six with three now from four to three. We see one and one that is two one plus one is due to is less than infinity.

58
00:12:51,790 --> 00:13:07,900
So let's abit at index three value two. So here two and here two, now we see that four and zero is visited. The unvisited is one, two and three. Now let's find out the minimum in this unvisited part for the next iteration.

59
00:13:08,320 --> 00:13:28,820
The minimum vertex, the minimum distance vertex is three. Here we have two here to have three and infinity. So two is the minimum. So the Vertex three is that middle distance vertex we're hearing here mean descending particles because we want to find it the minimum distance you can find at the minimum distance from minimum distant.

60
00:13:28,840 --> 00:13:37,750
We'll try to find it the minimum distance to other vertex, so we'll have a minimum distance. This is the concept of this extra algorithm. We'll revisit this anyway.

61
00:13:37,900 --> 00:13:51,580
If we have negative cycles, then we might find it incorrect answer. So from three to one, we see two plus two is four. Four is not less than three. So we need on this verdict.

62
00:13:52,060 --> 00:14:03,850
It will market as visited now here from 3.2 to plus five seven. So it is less than infinity. So let's RBD with seven and up to this, well, infinity with seven as well.

63
00:14:04,180 --> 00:14:17,800
So I visited all the adjacent vertex here for is already visited. Now let's find it the minimum distance of our X for and visited and visited Vertex one and two, and we have the minimum distance vertex is detracts from this body.

64
00:14:17,800 --> 00:14:25,780
This vertex, the minimum distant is five plus three. That is eight eight is not less than seven to oolleot. Abdou Diallo will mark this one as visited.

65
00:14:26,440 --> 00:14:39,790
This is because this is a mean distance vertex, so let's market as visited. Now let's find out the minimum distance vertex we have here only one vertex.

66
00:14:40,220 --> 00:14:54,970
We're left with only one vertex. So this is the mean distance Vertex will run to at in the to all mark as to. So here it's visited and we see there is no and visited a decent up to.

67
00:14:55,240 --> 00:15:13,530
So we're done for to. We see that the adjacent is one end here. Three. And they're already visited. So we're done. This is the disaster algorithms. This is all this extra algorithm works the minimum distance with this verdict zero to this verdict zero zero The minimum distance of these one zero to one is three.

68
00:15:13,860 --> 00:15:25,440
The minimum distance of this vertex zero to four is one from zero to three is two from zero to two is seven. This is know this extra algorithm works. This algorithm works one negative cycle.

69
00:15:25,860 --> 00:15:42,900
The time complexity for this algorithm is bigger if we square where with that number of vertices in the given graph data structure and it all takes because of the space complexity for the distance and visited.

70
00:15:43,710 --> 00:15:59,090
It would actually be up to the time complexity, and that's equivalent to big off V because we ignore that constant part for time complexity analysis. Here is the number of vertices in the given graphic data structure.

71
00:15:59,330 --> 00:16:07,620
Hope you have understood this extra algorithm. Thanks for watching this video In the next video, we'll talk about a Billman Ford algorithm suing the next video.


@@@
1
00:00:01,050 --> 00:00:11,220
Here you are, two guys. Welcome back to this video in this video, we're going to talk about why this extra algorithm will not work for negative cycle.

2
00:00:12,540 --> 00:00:29,460
If a given graph contains a negative cycle, then this extra algorithm will not run. It will return incorrect results. Now first, let's see how the extra algorithm works for this graph.

3
00:00:29,490 --> 00:00:44,860
Let's assume this zero is our source vertex. In the previous video, we talked about these extra algorithms in detailed in this video. We're going to talk about why this extra algorithm doesn't work for a negative cycle.

4
00:00:45,690 --> 00:01:01,110
For the first, let's take this example in this graph, we have no negative cycle. First, let's solve this. Initially, the minimum distance to visit any vertex is infinite from source vertex.

5
00:01:01,620 --> 00:01:17,630
So infinite, infinite, infinite and infinite. This is your source vertex. The distance from this vertex zero to this vertex zero zero. So let's abed Israel zero.

6
00:01:18,030 --> 00:01:31,530
Now we see the adjacent of zero is one. And this vertex two. So let's find out the distance, the minimum distance to visit this vertex and there is zero plus five zero plus five is five.

7
00:01:31,530 --> 00:01:43,930
Five is less than infinity. So let's Abd Infinity with five now from zero to two again. He received the distance zero plus for there is Lisbon Infinity.

8
00:01:44,010 --> 00:01:58,440
So let's update Israel with four. So we have processed this node zero. Now let's find out the minimum distance vertex. The minimum distance vertex is this vertex.

9
00:01:58,740 --> 00:02:13,350
So from here, we see we can visit this vertex with minimum cost for +6. That is stent and is greater than five settlement update. And we can go to this direction and this direction.

10
00:02:13,800 --> 00:02:29,440
So we're done. We have processed this vertex two. Now let's find it. The mean distance of Vertex, the mean distance vertex is one. We can visit this vertex three from this vertex one and the minimum this trend is five plus three eight.

11
00:02:29,460 --> 00:02:46,230
So let's update this infinity with eight. So. So we have processed this node one. Now the mean distance vertex is this vertex. Because this is unvisited, the mean distant vertex is three excluding the visited vertex.

12
00:02:46,530 --> 00:02:57,000
And we see from here we can move only to this direction. But here we see this vertex already being processed. But here we see these vertex already been processed will do nothing here.

13
00:02:57,150 --> 00:03:07,590
So we find the minimum distance here. The minimum distance to visit this vertex is five. To visit this vertex is to visit this. Vertex is four to visit this.

14
00:03:07,590 --> 00:03:22,320
Vertex is eight. This is how this extra algorithm works. Now let's see if we have a negative cycle. Here we see we have a negative cycle. The sum of the weight of this cycle is negative.

15
00:03:22,380 --> 00:03:37,760
OK, minus six plus three plus two equals two minus one. So we find it here a negative cycle. If we have negative cycle in a given graph, then single source shortest path problem will not work now.

16
00:03:37,770 --> 00:03:49,050
Well, let's see why this extra will not work for this graph. This graph contains negative cycle. Initially, the minimum cost to visit any vertex is infinity.

17
00:03:49,560 --> 00:04:00,690
This is our source vertex. OK. Let's assume zero is our source vertex. So let's update this one with zero, because from this verdict zero to this verdict zero, the distance is zero.

18
00:04:01,230 --> 00:04:15,810
Now at the center, here we have this node one and this note two. Sometimes we're seeing Vertex sometimes or a single node and Vertex are dissecting the minimum distance to visit this vertex, where plus zero.

19
00:04:16,230 --> 00:04:28,920
So five here the minimum distance to visit this vertex four zero four. So we have processed this vertex. Now the Mideastern, the vertex is these verdicts from this vertex.

20
00:04:28,920 --> 00:04:41,100
You can visit this vertex with minimum cost for minus six that is minus two monasteries, less than five. So let's update this value with minus two so we can reach this vertex.

21
00:04:41,100 --> 00:04:50,190
One of the source vertex zero with minimum distance minus two. So we have processed this node two. We cannot move to this direction and to this direction.

22
00:04:50,190 --> 00:05:02,400
We're going to move only in this direction. Now let's find out the mean distance of Vertex went and visited Vertex. We have yet to unvisited vertex, and the minimum distance vertex is this vertex one.

23
00:05:02,760 --> 00:05:13,630
From this vertex, we can raise this Vertex three in the minimum distance minus two plus three. That is one. So let's admit this infinity one because. Because it is greater than one.

24
00:05:14,080 --> 00:05:26,710
So we have processed this not now for this node. We see that from this node. We see that we cannot visit this in order to because this node is already visited.

25
00:05:26,980 --> 00:05:41,230
But we see that two plus one is three will have the minimum distance for this part. OK. But here we see that we have four and the minimum distance should be two plus one.

26
00:05:41,230 --> 00:05:59,020
That is three. But we have here four since this is visited. So we cannot find it the actual distance here. OK. So you find it. The minimum distance from zero to one is minus two from zero to three one and from zero to two is four.

27
00:05:59,560 --> 00:06:10,840
It will move in this cycle multiple times. We see the value will be a chance to develop will be decreased. The value will be decreased. And here we find the answer.

28
00:06:11,350 --> 00:06:22,590
Three. The minimum distance from zero to this vertex is three. And already this vertex is visited. So here we find out a negative cycle. You can find it a negative cycle.

29
00:06:22,870 --> 00:06:36,670
The extra algorithm Ueland works, actually, when you find it in negative cycle, the single source shortest path problem woodland walks in the ticket. We will print or region.

30
00:06:36,970 --> 00:06:53,380
No. Or we can print to the council. The graph contains an English cycle, so you cannot find it the shortest map. But this extra algorithm does not have that mechanism to detect a negative cycle in a given graph.

31
00:06:53,890 --> 00:07:05,740
For that, we have to learn a new algorithm that is called Billman flawed algorithm and will be talking about Billman field algorithm in the next video suing the next video.


@@@
1
00:00:00,570 --> 00:00:15,330
Here you are some quite welcome back to this video in this video, we're going to talk about relaxation. Let's talk about as relaxation. Let's say you were given this graph in this graph, we have total five ages.

2
00:00:16,440 --> 00:00:30,780
We relax all of the ages once. Let's see, how is it relaxation works? And this is the condition for is relaxation distance you plus the weight of current age.

3
00:00:31,260 --> 00:00:43,590
If the distance plus or current is less than a distance of V, then we will change the minimum distance for node by adding the distance of you, plus the weight.

4
00:00:44,220 --> 00:01:00,420
Let's see. How is relaxation works now? We're going to work through these groups using these extra algorithms. Initially, the minimum distance to visit any Vertex producers vertex is infinity.

5
00:01:00,930 --> 00:01:13,650
Let's assume zero is our source vertex. Now, the minimum distance to visit this vertex from this vertex is zero. Let's just this relative gyro now from this vertex zero two.

6
00:01:13,650 --> 00:01:27,570
This vertex on the minimum distant is your plus five. That is five. Let's update this infinity with five. Now we see that we applied this formula here, so this is our current edge.

7
00:01:27,990 --> 00:01:43,470
We have applied this formula to these eight. So this age is now relaxed. This is called is relaxation. Now this is is relaxing. We will not visit this ages anymore, OK?

8
00:01:43,830 --> 00:01:56,100
This is called Israel exertion. Now let's move to this relation to the blast furnace for Let's Update Israel. For now, we applied here this formula. So this is now like things.

9
00:01:56,100 --> 00:02:10,460
OK, now this is relaxed. This is called is relaxation. Now the minimum is this Vertex two here. The minimum distance is for to visit from this vertex to this Vertex star, the four plus one is five and this is five.

10
00:02:10,470 --> 00:02:20,580
So nothing needs to be done here. We cannot go to this direction and we cannot go to this direction because this is, is no relaxing, will not revisit the relax eases.

11
00:02:21,180 --> 00:02:32,820
Now here this is, is no relaxing. OK, we're taking this condition. This condition is all loaded fault here now we can said this is is not relaxed here.

12
00:02:32,820 --> 00:02:43,890
Minimum Vertex is one to visit this vertex three from one that we knew. This trend is five plus 3's eight. So let's update this well with eight. Now we can say this is not relaxed.

13
00:02:44,130 --> 00:02:55,800
Now I'm treated to the minimum distance is eight plus two the distance, but we see that this vertex has already visited, so we cannot move from this vertex to this vertex.

14
00:02:56,130 --> 00:03:10,740
So finally, we can say this is is not relaxing. This is called is it relaxation? So we relaxed all the edges once this is called is relaxation. We have understood what is is relaxation.

15
00:03:10,980 --> 00:03:25,650
Let's take another example. Let's see you were given this graph. Let's apply here this extra algorithm to find out the shortest path. So initially, the cost or the minimum distance to visit any vertex from source vertex is infinity.

16
00:03:25,950 --> 00:03:33,810
Let's assume this is sort of vertex. So here let's after this well, with zero from zero two zero, the distance is zero now from zero to one powerplants.

17
00:03:33,810 --> 00:03:43,860
Zero is five less abilities, well with five. So we applied this formula. So this is is no relaxing now. From one to two, Darwinian distance is five plus one.

18
00:03:43,860 --> 00:03:54,210
That is six. Let's apply here. Let's do this one with six. Now this is is it relaxing or is it this eight animal now from one two three five plus three seven?

19
00:03:54,210 --> 00:04:06,660
Let's double this is with seven. OK, this is is no relaxing now. The minimum is six this eight. So from six to from, this is two. This is we can visit in cost nine.

20
00:04:06,660 --> 00:04:16,020
OK, let's update this well with nine. So this is not relaxing. We will not revisit this eight anymore. Now the minimum is seven here. So from seven again, visit this note.

21
00:04:16,260 --> 00:04:26,070
Seven plus one is eight, but it is close then, so this is relaxed. Finally, we have this vertex and there is no way to go from this vertex. We're done.


@@@
1
00:00:00,480 --> 00:00:09,110
Here you got some guys welcome back to this video in this video, you're going to talk about Billman Ford algorithm in the previous video, we talked about the extra algorithm in details.

2
00:00:10,410 --> 00:00:25,650
We know that it is extra me or it works for negative words, and this extra cannot detect negative cycles. We know for negative cycle, single source, shortest path problem will not work.

3
00:00:26,400 --> 00:00:36,030
Now let's talk about Billman for algorithms. In this video and details, let's add you were given this graph and we see that in this graph we have 2.5 pages and four vertices.

4
00:00:37,110 --> 00:00:47,040
Four billion four algorithms will relax all the edges. If you want to school in times, are that vertices for this graph vehicle to four four minus one exhausted three.

5
00:00:47,040 --> 00:00:57,810
So it will relax all it just three times. For this extra algorithm, we relaxed all the edges once. First, let's that is extra algorithm. These extra algorithm will fail on this graph.

6
00:00:58,050 --> 00:01:11,590
Let's see how. So here you have distance, infinity, infinity, infinity and infinity initially. Let's assume this is your source vertex. So let's RBD Israel with zero now zero plus or equal to one.

7
00:01:11,610 --> 00:01:21,300
Let's update this plot with one, because when is less than infinity? So relax this age zero two four zero two zero plus one is one. One is less than infinity.

8
00:01:21,300 --> 00:01:35,550
Lets Ari develop with one. Then here we will takes the minimum vertex. Let's add some here you lots of guys all come back to this video in this video, we're going to let Adam argue in this graph.

9
00:01:35,670 --> 00:01:47,630
In this graph, we saw that we have total five edges and poor vertices for this extra algorithm will relax all the edges once, but for billion, Ford will relax old ages.

10
00:01:47,880 --> 00:01:58,500
If you want us one times or vs the number of viruses in a given graph. In this graph, we have to roll for what it is so it will relax all the ages three times.

11
00:01:58,920 --> 00:02:13,020
First, let's see how these extra feel on this graph. OK? So here let's insert Infinity, Infinity and infinity. Here we'll have zero zero plus one equals to one.

12
00:02:13,020 --> 00:02:26,580
Let's observe this infinity with one zero zero zero. So let's address this with zero. Now here we see that we process this node and this is and this is is no relaxing now.

13
00:02:26,580 --> 00:02:39,300
The minimum here. Zero one zero. So zero plus two equals two to let up the developed with two, and there is no way to go to this direction. So this is is not relaxing.

14
00:02:39,300 --> 00:02:48,570
The minimum of one and two is one. So this vertex one from one to two, the minimum distance one plus one is still bodheri zero. There is not a greater than two.

15
00:02:48,700 --> 00:03:02,280
So abdicates, we're done. This vertex is not relaxing now. From this vertex to this vertex one, we see two minus three to minus one. But here we found one for the extra algorithm.

16
00:03:02,700 --> 00:03:13,950
We cannot move to that visited Vertex. OK, from the unrelated vertex, we see that this extra algorithm is not working for this graph. Here we see that we'll have the minimum distance from the source.

17
00:03:14,310 --> 00:03:31,620
Vertex is minus one, but here we have one. So we see that we clearly see that these extra feel on this graph. Let's see how brilliant works. What this graph for women forward will adam to visit any vertex from source vertex.

18
00:03:31,620 --> 00:03:45,660
The initial distance is infinity. This is your source, vertex. Let's average this well, it is zero for source. Vertex will be developed with you because from source to source, there is no distance now from zero to one one zero plus one is one.

19
00:03:45,660 --> 00:03:58,500
One is less than infinity. Let's average one now from zero to two zero zero zero. So let's RB this with zero now from one to two one two two one plus one is two.

20
00:03:59,190 --> 00:04:13,560
Two is not less than zero so uninhabited. Here we see that we relax this age, this age and this age. Here, this ID, this age and this age. Now, from two to three two year plus two, go to two.

21
00:04:13,560 --> 00:04:24,400
Let's average this infinity because two is latent infinity. Now, from two to one to minus three goes to minus one. So let's average this well with minus one so relaxed all the edges.

22
00:04:24,720 --> 00:04:38,230
But let's count the. Well, hero. One. Now let's relax all day just again, because if you relax all day, just three times now from zero to one zero plus one is one, one is not less than minus one.

23
00:04:38,740 --> 00:04:58,720
So will not change it. Zero two two zero zero zero is not less than zero. Then from one to two minus one plus one is zero zero is not less than zero. Even from two to three plus three go to two will not change it from two to one to minus three points to minus one to almost abit.

24
00:04:59,170 --> 00:05:12,910
So relax all it. Just let's relax all day just again. OK, so we relaxed all day, just two times. Now let's relax. This one is one. So we're launching zero, then four minus one plus one.

25
00:05:13,150 --> 00:05:24,760
Hurry up zero unattended from two to three. Two from three to one is minus one, so it is not tense. So we have relaxed all the edges three times. So we're done now.

26
00:05:24,760 --> 00:05:37,210
We see that we find the shortest fat from storage, the verdicts to all other verdicts. OK. This is called Billman four algorithms. This is how we can solve single source showed us that problem.

27
00:05:37,210 --> 00:05:48,160
Isn't Billman for algorithms. If we take here any node here, let's assume you start from three. We can first relax this age. This age, this is. This is Antawn.

28
00:05:48,460 --> 00:06:01,530
OK, we can do back and forth. We can go further. We can go backward if we move backward. Let's see how this look likes him. Now, let's assume this is sort of vortex infinity infinity infinity.

29
00:06:01,570 --> 00:06:16,300
OK, let's assume all start relaxing from this side. T1 Infinity minus three Go to infinity because if you subtract three from infinity, and that's also infinity because it's a huge number, so nothing changes here.

30
00:06:16,720 --> 00:06:30,460
Now from two three. So this is not relaxing from two three. We see we see Infinity Plus two is also infinity, so it will not change it then from one to to infinity plus one.

31
00:06:30,490 --> 00:06:42,970
That's also infinity, so it will not change it then zero two zero plus one is one. So let's average this value with one now from zero to two zero. So let's update this well, so we relaxed all of it just once.

32
00:06:43,540 --> 00:06:54,990
Now let's relax them again. Three, two one. So you don't want Chin's infinity minus three goes to infinity. Two to three plus two go store two. Let's do this with two now from one to two.

33
00:06:55,180 --> 00:07:12,820
One plus one is to hurry up zero. So we're not since zero to one. It's OK you two two two zero zero. So not change it here. You two, here you two one one plus zero is one you have on unattended zero plus zero zero unattended.

34
00:07:13,060 --> 00:07:24,330
So relaxed, although it just twice. One plus one is two. Now, let's relax them again. Three two, one is minus one. OK, two minus three go to minus one.

35
00:07:24,680 --> 00:07:37,460
Now from two to three, we see here too. So let's send it from one to two minus one one zero and zero and attended zero two one well-attended G2. You know, unintended.

36
00:07:37,470 --> 00:07:50,360
OK, so we're done relaxed all older ages three times. We can. We can relax all it just in any order. OK, here we can relax all day, just in any order.

37
00:07:50,510 --> 00:08:06,140
But if you follow a certain order, then you have to follow that order for the rest because we have to relax all the is this b minus one times? This is called the Billman for a great this is Joe win for algorithm works so we can relax this ages in any order.

38
00:08:06,320 --> 00:08:21,630
It's different on the implementation of your graph data structure. We can take first this, then this, then this, then this one than this one. But you have to follow the pattern or the order for the rest because you have to relax.

39
00:08:21,650 --> 00:08:32,510
We want to score in terms of the number of advantages of you. Understand this Billman for algorithm. Now let's talk about how big of an algorithm to detect a negative cycle and how it handles negative cycle.


@@@
1
00:00:00,990 --> 00:00:09,120
Here you are, some guys. Welcome back to this video in this video, you're going to talk about a Billman Ford algorithm, let's assume or given this gravity to structure.

2
00:00:09,450 --> 00:00:33,660
Here we have 2.5 inches. This are the ages zero one zero two one two, two three and three one. In this extra algorithm, we relaxed all the edges just once, but for billion, four algorithms will relaxed all the edges b minus one times where v is that number of advantages in the given graph?

3
00:00:34,680 --> 00:00:45,900
In this graph, the number of artists is four, so four minus what do you call it, two to three? So you'll relax all the edges three times. Let's see how it works.

4
00:00:46,020 --> 00:00:59,460
First, let's talk about the D68 algorithm for better understanding. So initially, we have infinity for all the versus the initial minimum distance to visit all the vertices from sort of the parties.

5
00:00:59,470 --> 00:01:10,890
This is from source. Vertex is infinity. Now this is your sort of verdict. So OK, we're going to assume this is there were stories vertex. So the distance from sort Vertex two series vertex is zero.

6
00:01:11,280 --> 00:01:22,350
From this verdict to this vertex, the distance zero plus one that it's one. So we have really liked this edge now. From zero to two, the minimum distances zero plus two, that is two.

7
00:01:22,530 --> 00:01:39,210
So let's average this value with two. So this is is not relaxing. We'll not revisit this eight anymore. We're trying to we're trying to move to the adjacent vertices of him from this vertices.

8
00:01:39,300 --> 00:01:55,440
We have minimum distance. That's what we will not revisit this vertex. Now this too, is just relaxing. Now the minimum is here at one from one to two, the minimum distance, one plus one that is still here, up to another native done here.

9
00:01:56,280 --> 00:02:09,520
One two three. We can't move from one to three because we have direction from three to one. So here. We're done. This is isn't a relaxing walk him now for two to three.

10
00:02:09,550 --> 00:02:22,210
Here we see this is the minimum distance of our two plus three votes to five. That's up to develop with five. Now this is is no relaxing, OK now five minus four equal to one.

11
00:02:22,540 --> 00:02:37,240
And here we have the value one. Here we see that these extra algorithm works, but sometimes these extra algorithm will not works. Now let's talk about that Billman four algorithm, OK?

12
00:02:38,200 --> 00:02:56,800
Now let's talk about that Billman four algorithm. Initially, we're going to mark all the vertex as infinity. OK. So here we're going to add you invent to visit all the vertex from source vertex initially infinity.

13
00:02:57,040 --> 00:03:08,650
We're just in-market as infinity. Now, let's assume zero is our source vertex. In Billman four algorithm, you'll relax all the edges p minus one times Piglet's to four from Venezuela's three.

14
00:03:08,800 --> 00:03:23,440
So it will relax all the it just three times first. Zero one. OK, so the distance from source of artists to this vertex zero zero because this is our says Vertex from zero to one is one.

15
00:03:23,560 --> 00:03:35,210
So let's Abdel this one because infinity is greater than one. So would you like this eight zero one now zero two g plus two is two two is less than infinity.

16
00:03:35,230 --> 00:03:47,200
Let's update this and read it with two. So we relaxed this h now one and two. Here I see one and one is two. And here we have valid two. So we do like this h.

17
00:03:47,590 --> 00:03:58,820
Then two three two plus two is five. Five is the less than infinity. So let's update this infinity with five. So this is not relaxed now from three to one.

18
00:03:59,020 --> 00:04:12,730
Five minus four equal to one. So here we have the value one. Now we see that we relaxed all the edges once. Let's count it. We realized once. Let's relax them again.

19
00:04:12,910 --> 00:04:24,550
Now, zero one zero plus one is one. So another need to be done here because one is not less than one zero two two. So would you like this one two one two is two.

20
00:04:24,580 --> 00:04:39,850
That's OK. Then two or three here we have two plus three is five. Then three one four two one five minus four equal to here one. OK. That's OK. So we relaxed quite all the edges twice.

21
00:04:40,090 --> 00:04:50,440
Now let's relax them. Now let's relax them again. Now, let's relax this age zero one plus one is one. Then let's roll like this eight two zero two zero plus two is two.

22
00:04:50,860 --> 00:05:04,780
Then this eight in one two on plus one is two. Then two three year five year three one three one here. Five minus four. That is one. So we're done with relaxed all the edges.

23
00:05:05,170 --> 00:05:20,920
Would you like to order? Is this B minus one times? He recently relaxed, although it is three times. So we're done. Now we see that we have the shortest path from this vertex, the source of particles to all other parties.

24
00:05:20,920 --> 00:05:35,010
The shortest path here is one the shortest. What here is two. Here is two plus threes five two plus three minus four equal to one. So the shortest path from this vertex four to this vertex is one.

25
00:05:35,350 --> 00:05:46,900
Have you understood how Billman four algorithm works for better understanding? Let's take another example Let's add or given this graph of the structure here, we see that we have a negative cycle.

26
00:05:47,080 --> 00:06:02,130
Let's see how it handles going off cycle and how it to detect negative cycle if if the graph contains any grief cycle. So let's mark all the vertex as infinity the minimum distance to visit any vertex.

27
00:06:02,140 --> 00:06:17,320
One sort of vertex is infinity initially. Let's change this relative zero, because this is our source vertex. Now, from the source to this vertex, let's run like this one is one that's been developed with one now zero plus two equals two two.

28
00:06:17,530 --> 00:06:30,330
That's after this. Well, with two. Well, guess what? We you this two edges now one two from one and from one to two plus one is two. So relaxed this eight, then two three two plus three is five.

29
00:06:30,340 --> 00:06:40,780
Let's update this value because five is less than infinity, then let's like this. It's three one here. Five minus 60 goes to minus one. So let's run like this eight.

30
00:06:40,780 --> 00:06:53,860
So we get him minus one. So we relaxed all the edges once. Let's count it now, let's relax them again. Now zero one plus one is one. One is not less than minus one.

31
00:06:54,070 --> 00:07:07,070
Would you like this h then zero two zero plus two is two. That's OK, then one minus one is one minus. One is zero, so let's develop with zero because there is less than two.

32
00:07:07,460 --> 00:07:17,330
Then here two three plus trees, three, let's upgrade this one with three. Then three minus six equal to minus three. Let's either develop with minus three.

33
00:07:17,810 --> 00:07:34,010
So we relaxed all the edges twice. Now let's relax them again. Let's be like this eight zero plus one is one that is not less than minus three zero plus two equals two to two is not less than zero minus three plus one is minus two.

34
00:07:34,010 --> 00:07:49,160
Minus two is not minus two is less than zero ministers late in the year. Let's update zero. It's minus two, then minus two three. Here's one let's argue this value with one, because one is less than three now one and minus six is minus five.

35
00:07:49,180 --> 00:08:03,090
Let's update value it minus five. So we relaxed all the edges three times, and here we have the verdicts for the four. Bartok's here. OK, so we have relaxed all the edges.

36
00:08:03,650 --> 00:08:17,140
B minus one times. He had three jumps and we relaxed all the it just three times. So we're done. Now how to detect negative cycle. Here we sit. We have a negative cycle in order to predict negative cycle.

37
00:08:17,350 --> 00:08:33,340
We're going to run in love. We're going to check if you plus the weight is, let's assume this is you and this is a V. If we saw zero plus one is less than minus five, then what I will do, I'll just print.

38
00:08:33,670 --> 00:08:43,990
The graph contains negative cycle. Why is that? Here we have the minimum distance. So from here to here, the minimum cost is zero plus one. That is one.

39
00:08:44,260 --> 00:09:01,030
OK. And here we all have the value less than or equal to this value. OK? Here we will have the minimum distance, less dense or equal to d'Israel if we saw this value is greater than this value one.

40
00:09:01,810 --> 00:09:11,770
That means we have a negative cycle. Here we see that zero plus one is one. One is not less than minus five. Now let's play this formula here as well.

41
00:09:12,160 --> 00:09:25,990
Zero plus two zero plus two is not less than minus two. It's OK. It's completely fine. No, minus five one equals two minus four. We see minus four is less than minus two.

42
00:09:26,260 --> 00:09:40,000
Here we should have volue here. We should have a value that is equal to or less than minus four. But here we have minus two ministries greater than minus four.

43
00:09:40,480 --> 00:09:55,450
So we can see this gap contains a negative cycle. If this graph does not contain a negative cycle, then we'll have here value at most minus four or less than minus four.

44
00:09:55,480 --> 00:10:13,570
OK. Since we're routing here, because here we have a negative cycle. So the value decreasing. OK. So you we move here to here by one route, then this value will be decreased to minus four since we have calculated the value already.

45
00:10:13,750 --> 00:10:25,540
So again, see here this graph contains a negative cycle because because minus five plus one equals two minus four minus four is not greater than or equal to minus two.

46
00:10:25,720 --> 00:10:38,710
Here will have the maximum value minus four. So this graph contains a negative cycle. So all printed this graph quantity and negative cycle for negative cycle will not have an answer for the old parachutist problem.

47
00:10:39,110 --> 00:10:51,010
Also, we know for the single source shortest path problem. Hope you understood Billman flawed algorithms. Now let's see the pseudocode. This is the pseudocode to solve this problem.

48
00:10:51,520 --> 00:11:01,520
We have this function. It sticks to promote your graph and source. Here are calculating vertices and edges here are calling a distance arrow for the versus.

49
00:11:01,520 --> 00:11:19,000
Subtract the minimum distance from source to all other vertex. And here we're inserting the infinity here. Or as you mean the maximum value constraint to it, as infinity were inserting zero to the source of particles because the minimum distance from source to source vertex is zero.

50
00:11:19,600 --> 00:11:32,320
Now we're running aloof here. We're running this out of love for b minus one times because we have to relax for B minus one times. And inside here we're running this loop from zero to the is minus one.

51
00:11:32,590 --> 00:11:48,760
Here we are getting source destination and weight and registering it. We're starting at U.V. and W here we're checking if Sense U is not equal to integer that Macksville end the distance implies is less than distance within or updating the value.

52
00:11:48,760 --> 00:12:09,670
OK? And here we are detecting the negative cycle u v w and here are two. If this trend is not to go to Maxwell and if we saw distance u plus distance W is, let us then distance a v, then we can simply say the graph corners negative cycle and just return from the function.

53
00:12:10,060 --> 00:12:21,340
We'll have no answer in that case. Otherwise, it will print the distance r. It will have the answer, you know, distance ari. And this is the function to print the distance, OK, from service vertex to all other vertex.

54
00:12:22,060 --> 00:12:32,500
Assume this is your distance and this is your given graph. And here we have vertices. Now let's relax all the vertices few minutes on time here to be with us when we go to three.

55
00:12:32,920 --> 00:12:45,880
Initially we have Infinity, Infinity, Infinity and Infinity. The minimum distance to visit all vertex on sort of vertex is. Affinity here as well, let's insert infinity.

56
00:12:46,810 --> 00:13:00,950
The length of this distance array must be for. OK. The length of the distance R is for all, not have the seal here. We'll have index from zero to three because we have yet to rule for viruses.

57
00:13:02,000 --> 00:13:12,500
Now let's update the first distance here. Let's this distance with you. And it's just a representation here. We're just showing you. That's about this zero.

58
00:13:12,560 --> 00:13:25,970
OK, now from zero to one, one plus zero is one that is less than infinity. So let's update this with one. Let's update this mix one with one. Now from zero to two.

59
00:13:26,630 --> 00:13:38,210
So would you like steer zero one from zero to two plus zero is two. Two is less than infinity, so let's average Israel with two. And here as well, let's average Israel with two.

60
00:13:38,270 --> 00:13:48,710
So it relates to this agent now from one to two, from one to two, one plus one is two. So your one plus one is two. Two is not less than two. So not Anita Dunn here.

61
00:13:48,710 --> 00:14:01,160
This is relaxed now. Two or three from two to three. Two plus three is five. Let's admit this. With five we got because five is like the infinity. Let's update this with five as well.

62
00:14:02,140 --> 00:14:17,620
Now, from two to one, this easy is not relaxed to the one minus one. Let's use your minus one. And we see at index one at index one will have a minus one here.

63
00:14:17,630 --> 00:14:28,330
Let's argue this will lead minus one. So we relaxed all the adjust ones. So let's keep track the value here. OK, so relaxed once. Now let's relax them again.

64
00:14:28,900 --> 00:14:41,000
Zorbalas crystal dribblers. One is. One, but one is not less, and miners are not Anita Dunn here, Julius twist to do is not less than two need to be done here now one and two minus one one is zero.

65
00:14:41,180 --> 00:14:52,190
That's Aboriginal with zero now two or three jobless trees. Three. Let's update this well with three now three one two minus six is minus three. Let's average as well with minus two.

66
00:14:52,370 --> 00:15:07,040
Here we have to also update the value here. Here first, we have no changes. Words you don't want, Angela. Do we have twins? Zero. Let's update this. Well, with zero now from zero to three, we see that from zero to three, we have developed three.

67
00:15:07,310 --> 00:15:20,030
So we averaged d'Israel with three and two from three to one minus three. Let's average Isabelle with minus three. We're showing you here later, so relaxed old age is one plus one.

68
00:15:20,060 --> 00:15:34,790
That means right now, let's relax them again. Zero one one one is not less than minus three zero two two is not less than zero minus T one minus two minus two is less than zero.

69
00:15:35,060 --> 00:15:48,150
So let's averages Israel with minus two here at Index two. I read Israel minus two. Now, from two to three minus two plus three one, let's do this well with one.

70
00:15:50,440 --> 00:16:09,530
So here will I be here with one? Never true to one. Let. Either the 12 minus two with minus five, because one minus six is minus five is minus five. Here here will update as well with minus five.

71
00:16:10,010 --> 00:16:22,510
So we're done. We relaxed all the air just three times. That means view minus one times. So we're done here. Now what I'm going to do, I'm going to check if the graph contains initiative cycle.

72
00:16:22,520 --> 00:16:36,470
We're going to use this formula here to really move to these elections. Well, this is you and this is why and what do you got to one with plus minus five equal to minus four here, minus two ministers greater than minus four?

73
00:16:36,500 --> 00:16:45,920
So this graph contains a native cycle because here we can have maximum minus for what we see here, minus two. This is already calculated, so we don't have to worry about that.

74
00:16:46,040 --> 00:16:54,740
So you can see here this graph contains A. Cycle. So we're done. This is called Billman for algorithms. Well, we understood how to solve this problem.

75
00:16:55,040 --> 00:17:05,150
When it has a negative cycle will have no answer here. We just print contains a negative cycle and you'll read in the graph do not contains negative cycle.

76
00:17:05,410 --> 00:17:15,200
We'll have in this distance, Ari and we will print this distance. Ari using this print functions here, OK, simple print function. This is called Billman for algorithms.

77
00:17:15,210 --> 00:17:27,910
This algorithm will takes time complexity. BS and I would have what it is, is the number of edges. OK. And it all takes off the space complexity. Hope you understood Billman for algorithms.

78
00:17:28,150 --> 00:17:35,350
If you have any questions, I mean, a good understanding has been around for algorithms. Let us and thanks for watching this video. I'll see you in the next video.


@@@
1
00:00:00,750 --> 00:00:15,510
Hey, what's up, guys? Welcome back to this video in this video, we're going to talk about all pair shortest pat problem. The all peer shortest pat problem is the determination of the shortest drive distances between every pair of forces in a given graph.

2
00:00:16,530 --> 00:00:30,960
This is called all pure shortest pat problem. Let's Adam Ohuruogu described this structure in describe this structure. We have defined it the minimum distance from this vortex to all other viruses first to poor quality that this is our source vortex.

3
00:00:30,970 --> 00:00:40,260
Then we have to consider this is our source products from this vertex, the minimum distance to all other viruses. The nifty concept. This is our source vertex, and this is our source vertex.

4
00:00:40,290 --> 00:00:58,910
OK. So if we're given this gravity structure, you Billy Adam zero versus Vertex initially, then we can move from zero to zero and there is no pad. OK, then from zero to one, we have paid zero one.

5
00:00:58,920 --> 00:01:14,100
This is the shortest path. Then from zero to two zero two, then from year to three, this trip zero two one or zero one three, if we consider one, is our source vertex, then we can.

6
00:01:14,910 --> 00:01:25,730
We can't move from one to zero because from one to three, there is no direction. That's what we have here. This in a now from one to one, there is no loop here.

7
00:01:25,740 --> 00:01:39,240
There is no sealed glove, so we have no direction here. So we have no shortest path here now from only to shortest. Path one three two nine four three from one to three.

8
00:01:39,600 --> 00:01:55,010
The shortest path is on the three. If we wanted it to is our stories vortex from 2.0, there is no path from two to one, the paths to one respect having the minimum distance to the two, there is no surplus to the three.

9
00:01:55,020 --> 00:02:10,820
We have dispatched two, one and three. If you consider. Three daughters verdicts one three, two zero. There is no there is no connections or there is no ages from one to from three to one.

10
00:02:11,000 --> 00:02:25,490
This is the part who is having the minimum distance then home to the two. This is the path from three to three. The shortest path doesn't exist, so we're just representing that using this product.

11
00:02:26,420 --> 00:02:38,060
So if we're giving this graph, we have to find it the shortest distance from every vertices to all other vertices. OK? This is the all pitch, shortest path problem.

12
00:02:38,170 --> 00:02:51,260
Hope you understood this problem? Now let's see how we can solve this problem. In the next video, we'll talk about how to solve this problem using this extra algorithm and using Billman for algorithm suing the next video.


@@@
1
00:00:00,090 --> 00:00:10,420
In this video, you're going to talk about how this soap. All shortest pat problem using this extra algorithm, we have talked about this algorithm in a lot of details.

2
00:00:10,440 --> 00:00:19,800
In this video, you're going to overview the way to solve all insurance fraud problem using this extra algorithm. Let's see what have you in this graph.

3
00:00:20,040 --> 00:00:34,350
First, all, consider it the source of our from zero. We have to find it the shortest path to all other vertices. Here we have the source vertex and from source vertex to all other vertices.

4
00:00:34,350 --> 00:00:43,170
OK? From source, did you know their shortest path is the minimum? So the minimum distance is zero from zero to one? The shortest part is, you know, one.

5
00:00:43,470 --> 00:00:54,510
The minimum distance is five from zero to two. This is the shortest, but the minimum distance is four and from zero to three, this is the shortest. The minimum distance is eight.

6
00:00:54,970 --> 00:01:09,510
If we apply here, the extra algorithm that will find it this shortest pat from this source vertex, then if we consider one is our source, vertex then will get the shortest but listed here.

7
00:01:09,600 --> 00:01:21,880
OK, then if you consider this is our source, Vertex then will have the shortest path listed here. Then if we consider trees are a super smart extent, we'll get this shortest pat.

8
00:01:21,900 --> 00:01:31,290
OK, you robotics and from products to all other vertices. OK, the distance from this vertex to all other artists. And here we have path and the shortest distance.

9
00:01:32,550 --> 00:01:45,780
This extra algorithm will take here bigger off in queue time complexity. We'll add the source code to this. We can check that out. Now let's talk about building for algorithm for all pair shortest path problem.

10
00:01:46,470 --> 00:02:06,540
The process are the same. If we continue to the source, Vertex will get the shortest path listed here. If you consider when these are serious vertex and you'll get the shortest spot listed here, then if you consider too is our sort of vertex to get this shortest path, then if we consider trees, our source vertex then will get this shortest.

11
00:02:07,050 --> 00:02:17,280
The main difference between these extra and Billman for algorithm is that if a given grab contains a negative cycle, Blanford can detect the negative cycle.

12
00:02:17,430 --> 00:02:28,530
But these extra cannot detect a negative cycle. Billman forward algorithm will work for negative on it, but it won't work for negative cycle, but it struck me.

13
00:02:28,560 --> 00:02:39,870
Works or means it works for negative pages, but for negative cycles. This extra unit works between for Oakland works as well, but Pullman Ford can detect the negative cycle.

14
00:02:40,200 --> 00:02:49,550
Him understood how to solve all peer shortest problem. Using these extra and billion for algorithm Billman for algorithm will take spin off in queue time complexity.

15
00:02:49,560 --> 00:03:03,460
What it is The number of viruses in the given graph we have at the source code of Billman for algorithm for all parachutist. That problem, we're not going to go through the source to the and the explanations we have already talked about in a lot of details.


@@@
1
00:00:01,070 --> 00:00:15,330
Here you are, two guys. Welcome back to this video in this video, we're going to talk about flight Urschel algorithm. No, let's talk about how Floyd Urschel algorithm works for all peer shortest pat problem.

2
00:00:17,700 --> 00:00:31,540
That's Adam. We're giving this graph this edge, our graph data structure. This graph is a weighted directed graph. This is the representation of this graph.

3
00:00:32,340 --> 00:00:55,620
Here we have zero. In this diagonal view, it's, you know, zero zero zero zero zero one one zero two two zero three two zero. Because if the source node is zero and the destination there is zero, then that distant in between zero and zero is zero because we have here know so proof.

4
00:00:56,190 --> 00:01:08,140
Zero one four zero don't want. We have eight four zero two. We have infinity because we do not have any directed edge that goes from zero to two. That's why we have infinity.

5
00:01:08,560 --> 00:01:26,250
We're representing infinity as maximum integer can store in 32 bits. Here we have one due to three. We have that word one, then from one to zero infinity because we do not have an ID from one to zero.

6
00:01:26,610 --> 00:01:37,500
There is no outgoing is from one to zero. That's what we have your infinity and so on. We have understood the representation of this gravity to structure it using this adjacency matrix.

7
00:01:37,980 --> 00:01:49,830
Now let's talk about how Floyd Urschel algorithm works. Flight Urschel algorithms uses the concept of dynamic programming. Now, let's review the algorithm.

8
00:01:50,220 --> 00:02:01,110
Then we will see how this algorithm actually works. We'll go through line by line and we'll explain every bit of information that you need to understand.

9
00:02:01,260 --> 00:02:17,580
Floyd Urschel algorithm we have here this clutch Floyd. Also inside here we have two method Floyd also and print metrics. This algorithm, this function Floyd underscore or show, takes the given graph as input.

10
00:02:17,790 --> 00:02:33,360
The given graph as a adjacency matrix. You are creating Matrix new and this is what it is that we're running this nested for loop to copy the value from our gravity to structure to this new adjacency matrix.

11
00:02:33,930 --> 00:02:50,850
Then we're running this nested falloff to copy the value to Matrix. We're running your algorithm here. We have three nested fall-off and inside here watching if i k plus matrix K is less than matrix idea.

12
00:02:51,330 --> 00:03:03,000
We're applying this formula and at the end are printing The Matrix. Here we have the code for printing The Matrix. Now let's see how this algorithm actually works.

13
00:03:03,540 --> 00:03:16,460
Don't be confused about it. We're going to explain every single information of this algorithm. Let's assume we're giving this graph, and this graph is represented using an adjacency matrix.

14
00:03:16,470 --> 00:03:34,350
This is the adjacency matrix. That's coffee. This graph to this metric. So every copy we get this matrix. Now, first thing, what are we going to do? We're going to find out it, pep, that goes via the Vertex zero.

15
00:03:34,680 --> 00:03:48,750
So here what are going to do. We're going to find it all. Pierce, OK, here every peer first. Zero three zero one zero two bin one two one zero one three and so on.

16
00:03:49,170 --> 00:04:09,480
We're going to generate every single here from this graph, and we will find it the minimum distance between two pairs that goods via the Vertex zero after finding funniest all possible pierce and Coke letting minimum distance.

17
00:04:09,840 --> 00:04:29,040
We will. We will see the minimum distance for the pillar that goes by at one, two and three. Now let's find out the minimum distance for all pierce that goes via the Vertex zero.

18
00:04:29,520 --> 00:04:50,700
Let's see how to find out that. Here we have the iteration. OK? Close to zero. And here we have iJie. We have two nested full of insight. So this to rise to the fall of will execute zero zero zero one zero two zero three one zero one one and so on until three three.

19
00:04:51,180 --> 00:05:07,140
Let's see how to find out. Minimum distance path that goes via zero here zero means K, so we can set the minimum distance path that goes via zero. First, we have zero zero.

20
00:05:07,380 --> 00:05:21,020
Now we're going to check, does this pile goes via the vertex zero? Here we have zero and zero and we see this. Value is zero. Also, you know, we're going to apply this formula.

21
00:05:21,050 --> 00:05:32,400
The distance from zero to zero, that means from I do care and from K2 G from zero to zero and zero two zero. We see for digital and we have values zero.

22
00:05:32,690 --> 00:05:47,750
The path from zero to zero and from zero to zero zero zero, that is zero. And we see that the current value here at zero zero is not less than zero. So this value is evaluated false.

23
00:05:48,020 --> 00:06:03,620
So we'll update this value. OK, now let's move to the next peer. Do you know one? Does this pair go to the Vertex zero? We're going to find out the distance from zero to zero.

24
00:06:03,650 --> 00:06:21,440
There is zero and from zero to one and there is eight zero plus ages eight. It is not less than eight. So we update this current value here. We're generating all possible peer that go through care.

25
00:06:21,830 --> 00:06:34,790
So we have minimum distance. OK. This is kind of a dynamic programming because we're using the previously calculated result to find it our current original.

26
00:06:35,300 --> 00:06:49,310
Now four zero two zero two zero zero. And Judah two Judah two is Infinity Infinity plus zero is Infinity Infinity is not Lisbon Infinity. So we'll give this value women up to this.

27
00:06:49,310 --> 00:07:07,340
Well, let's move forward now. Here we have this current value one and we have zero three zero and three zero and zero. So from zero to zero zero and from zero to three, the value is one one zero is one.

28
00:07:07,580 --> 00:07:22,190
So one is not greater than one. So up to this value, let's move forward. Now we have this peer one zero four one zero one two zero. That means from I took one to zero.

29
00:07:22,580 --> 00:07:34,900
We see that there is no direct path. The values Infinity Infinity plus zero two zero in redeploys zero is not less than infinity. So let's move forward here.

30
00:07:34,910 --> 00:07:49,970
We see that we have the value zero and we have here to peer one and one for one and one. We have the value zero one zero infinity drawn eight in 3D plus eight it in pretty is not less than zero.

31
00:07:50,480 --> 00:08:06,350
So we'll update this current value. Let's move forward. Now we have this peer one two four one two. We see that from one two zero from one two zero Avengers Infinity Infinity plus zero two two zero two two.

32
00:08:06,950 --> 00:08:30,230
We see that the value is infinity. We see that we cannot find it shortest path for this peer that go to zero. So oolleot to this, well, let's move forward now we have your infinity and we have this two vertex on and a three from one to zero from on digital values infinity.

33
00:08:30,700 --> 00:08:43,280
So if we find it infinity, nothing need to be done here. Let's move forward here. We see that two zero four two zero. We see it go to zero. So two to zero is four.

34
00:08:43,730 --> 00:08:56,750
And due to zero zero four plus zero is four and a see four is not greater than four. So let's move forward now. We have your infinity. Now we have this peer to one.

35
00:08:57,200 --> 00:09:18,770
Here we can consider AI as source and as destination. Can we go from this source to this Tunisian Vinayak? Let's see. Two two zero two two zero is four four plus zero two one zero two one is eight four plus eight is 12.

36
00:09:19,010 --> 00:09:31,720
We can write to 12 is less than infinity. So let's update this. Well, here we to help. Well, let's move forward. We see we have here two, two and four two two.

37
00:09:31,750 --> 00:09:43,420
We have no love here to visit. The verdicts due from the verdicts to the minimum distance is zero because it's reversed the same node now two three from two to zero.

38
00:09:43,450 --> 00:10:01,130
We see four plus zero two three zero two three. That is one. So we get here four plus one. That is five. Let's update well with five. So here we see two years source and three is destination to his source.

39
00:10:01,510 --> 00:10:18,810
Three is a destination and we can visit this destination from this source to via the Bartok's zero. So we find out if yellow here. Now, let's move forward.

40
00:10:18,970 --> 00:10:32,140
Now we have three zero four three zero No. From two to Jerusalem infinity, so nothing had to be done here. Let's move forward now. Three two zero three two zero is infinity.

41
00:10:32,380 --> 00:10:47,020
Nothing to to be done here. Three two zero two zero is infinity. We have no outgoing unit is here now. Four two two zero. It's again infinity, so nothing is ever done here.

42
00:10:47,860 --> 00:11:06,820
So we have processed all here that can go via the pot is zero. So we have processed all peer in this graph that might visit the destination from the source here.

43
00:11:07,240 --> 00:11:26,080
Destination is source. So in this graph, we saw that in this graph, we saw that we can move from source to restoration except zero two two one two zero one, two three and two to zero.

44
00:11:26,500 --> 00:11:49,720
Now let's choose the Vertex one here. Now we're going to find out all here that might go via the pot one. Now we have key codes. Two one four three zero zero four zero zero zero two one is eight and one two zero one two zero is infinity.

45
00:11:50,200 --> 00:12:01,960
So let's move forward here because Israeli plus eight is not less than zero. Now we have here eight. We have to visit the Vertex one destination from zero.

46
00:12:02,080 --> 00:12:19,060
So here zero two one is eight and one two one is zero. So we see that we have here eight. So it will not change this. Well, let's move forward. Zero two one is eight and one two two is infinity.

47
00:12:19,060 --> 00:12:30,130
So it will not change this because infinity is not Lisbon Infinity Plus eight. Let's move. Now we have zero two from zero to two. We have to visit this.

48
00:12:30,400 --> 00:12:42,040
Eight plus one is nine. Nine is less than infinity. So let's do this well at nine now. Now we have two two three. So here we see that we cannot go from zero to three via one.

49
00:12:42,340 --> 00:12:57,910
So it will not appear this well here now. Now, from one to one one two one zero and from one to zero is infinity. So it's not up to this value. Then from one to one is zero one two one is zero.

50
00:12:58,160 --> 00:13:13,580
So after this value, here we have one two one is zero and one to two is one. And for this rule, let's move forward and we have here for two to one two two one.

51
00:13:13,600 --> 00:13:27,490
We see that you have trip. And from one to zero, from one to zero infinity. So that after this, well, now we have to from two to one. From two to one is 12.

52
00:13:27,730 --> 00:13:47,170
And from one to one is zero. So why not update this value now for you know, this is not only to find out the value here. This is diagonal, so it will not have any value here that less than zero now four five two two one two two one is 12GB.

53
00:13:47,980 --> 00:13:56,920
We see 2GB is greater than five, so nothing to be compare here. Now we have two in one now from two one, we see four to one. We have to tell with greater than five.

54
00:13:57,850 --> 00:14:10,990
Now for infinity, we see three two one three two one is two and one two zero. What is it? Infinity. So imagine this value now for two three two one is two.

55
00:14:11,560 --> 00:14:31,760
So all the changes value now from three to one we see from two to one is two and one two. Two from one to two is one to two. One is to do plus. One two, two one two two is one two plus one is Theresa, let's up a 293.

56
00:14:32,180 --> 00:14:45,680
Let's move forward. This is diagonal Veloso. There is no value that Lisbon. Zero. Now let's move to the vertex to four Vertex two. We have to find out your path from the source.

57
00:14:45,680 --> 00:14:58,120
That means from items that that go via two from zero to zero, we have zero here, so nothing need to be done here now from zero to two, from zero to two is nine.

58
00:14:58,460 --> 00:15:13,930
We have your eight. Let's move forward now. Zero two two zero two two is nine, so it will not operate zero due to the values nine to this now from one to two from one to two.

59
00:15:14,120 --> 00:15:32,890
We see we have L1 one plus two two zero two two zero five. So one plus four is five. Here we see that we can't visit this vertex zero from this vertex one via two who is having the minimum distance here.

60
00:15:32,900 --> 00:15:46,440
OK, one plus four is five. So let's RBD developed with five. Let's move forward. We have here zero, but need to be done here. Now we have here one one two two now from one to two.

61
00:15:46,490 --> 00:15:59,510
We see that for one or two we have one. So now they need to be done here now for this. So one two two value one one plot two to three two two three is five.

62
00:15:59,540 --> 00:16:11,120
OnePlus five is six. So let's update this well, with six. We see that from one to three, we can visit from one to three via this spot one plus four plus one.

63
00:16:11,120 --> 00:16:25,850
There is six and we have here six. Well understood how this actually works. Let me go through these examples till the end. Now let's move forward. Here we are four from two to zero.

64
00:16:26,330 --> 00:16:43,670
We see we have a path that goes via two. So let's update this well with four. We see that from two to two. From two to two is zero zero plus two two zero two two zero is four, so nothing need to be done here.

65
00:16:44,000 --> 00:16:59,350
Now, from two to two is zero zero plus two to one two two one is 12 a penny to be done here. And same for the rest and same for the rest for this row.

66
00:16:59,420 --> 00:17:13,790
OK, now let's move forward. Here we have infinity. We have three zero four three two two four two two two three three plus two two zero two two zero is four two plus forty seven.

67
00:17:13,790 --> 00:17:27,770
Let's develop with seven. OK, from three to zero, we see you again go from two to zero in this path. We see that we can go from two to zero via two in this path.

68
00:17:27,980 --> 00:17:43,980
Three two one one two two two two zero. OK. And this is the summation of the path. The distance. Him two one four. There is seven we have already calculated for zero and one note we're calculating for two.

69
00:17:44,000 --> 00:17:56,900
OK. We're using pre calculated result to generate this value. Seven. So this is a dynamic programming. Try to relate this with the previous result I've done and put them in table.

70
00:17:57,230 --> 00:18:11,060
This is a little bit intuitive. Now let's move forward now from two to one via two three two two two two two is three times greater than two. Let's move forward now from three to two.

71
00:18:11,330 --> 00:18:21,390
There is three three two two three three two. There is three. Let's move forward now from two to two, there is three. So here is zero. Will not change it.

72
00:18:21,440 --> 00:18:37,430
Let's move to the next Vertex three. Now we're going to find out the minimum shortest path from all here that goes via the Vertex three. Let's see first.

73
00:18:37,890 --> 00:18:52,700
Zero zero zero. So nothing need to be done here. Near zero one zero two three zero to three is one and three two one two. So two plus one equals two three.

74
00:18:52,700 --> 00:19:08,350
Let's update this one with three, because three is less than eight. Let's move forward. Dreaded three. There is one and three two two three two two, there is three OnePlus three Sport.

75
00:19:08,350 --> 00:19:20,740
Let's update this developed with four. And here we see that from zero to two, from zero to two, that goes via three. The hat is one plus two plus one.

76
00:19:21,370 --> 00:19:35,080
That is four. Let's move forward. Zero two three. That is one. So it will not change it now. One two zero here from one to three from one to three is six.

77
00:19:36,640 --> 00:19:46,740
Six is greater than five. Let's move forward here again, six is greater than zero, let's move forward. Let's move forward. Let's move forward now for this fresh look him.

78
00:19:47,280 --> 00:19:59,500
Two two three two two three five I was grabbing for. Let's move forward now. Two to three five five plus two two one three two one two five +3 seven Let's do this.

79
00:19:59,500 --> 00:20:11,310
Well, it's seven. Let's move forward it zero. So it will not change. Let's move forward five two to three five. So let's change it. Let's move forward.

80
00:20:11,320 --> 00:20:29,140
Seven three two three. There is zero zero plus two two zero two two zero seven, so it will not change it two to three zero two two one. Is this fellow, so not tint for the rest we had done?

81
00:20:29,590 --> 00:20:49,780
We find out this. We find out this matrix. Well, Kim and this matrix contains the minimum distance from the Vertex zero two all other heartaches from Vertex one to all other vertex from extra to all other vertex and from Warwick through to all other vertex.

82
00:20:50,440 --> 00:21:09,760
This is called flight urschel algorithms. We are generating all possible here that might go through K and you're calculating the minimum path. And this is called the flight algorithm, since we're generating all here for all vertex.

83
00:21:09,910 --> 00:21:26,620
So you'll have that minimum path. This solution will 2x be go off in queue time complexity, and this solution will 2x bigger off in square space complexity to create this matrix.

84
00:21:26,770 --> 00:21:41,580
OK, and here printing this. Metrics using this function, print metrics over understood how Floyd whistle algorithm works, if you have any question of him in this situation.

85
00:21:42,300 --> 00:21:53,700
Let us know even when the question understanding this with the explanation posted a question on the cuneiform. I'll be glad to help. Thanks for watching this video old suing the next video.


@@@
1
00:00:01,040 --> 00:00:13,770
Welcome back to this video in this video, you're going to talk about minimum spanning tree, minimum spanning tree is also called. Minimum would spanning tree.

2
00:00:15,300 --> 00:00:33,180
A minimum spanning tree or minimum width spanning tree is a subset of the ages or be connected, oited, undirected graph that connects all the vortices together without any cycles with the minimum possible total it.

3
00:00:33,810 --> 00:00:51,230
If you are givony connected or did undirected graph, you have to find out a minimum spanning tree. The properties up minimum spanning tree is that the minimum spanning tree will have no cycle.

4
00:00:51,740 --> 00:01:07,100
We have to include all the vertices to the spanning tree. Also, we can say a minimum spanning tree is a spanning tree in which the sum of the width of the ISS is as minimum as possible.

5
00:01:07,820 --> 00:01:28,520
The total width of it just need to be a minimum of him. So in that spanning tree, we should include all the vertices and you'll have no cycles and you'll have total weight of the edges as minimum as possible.

6
00:01:29,210 --> 00:01:39,530
For example, if you're given this graph, this edge a connected, weighted, undirected graph. What is the minimum spanning tree of this graph? Let's find it.

7
00:01:39,950 --> 00:01:56,000
First, let's find out the spanning tree. OK, this is expanding in this tree. We see that the total weight of houses even we have, you know, a cycle and we have included all the vertices in the spanning tree.

8
00:01:56,600 --> 00:02:10,430
This is also a spanning tree to the weight of just eight. This is also a spanning tree. This is also spanning tree. Now we saw that we have here four spanning tree.

9
00:02:11,210 --> 00:02:25,130
What is the minimum spanning tree in this sprouting with tree that we have to the width of ages seven? So this is the minimum spanning tree for this green graph.

10
00:02:25,820 --> 00:02:40,980
If you you're given this graph due to structure, we have to find it the minimum spanning tree. What is the minimum spanning tree of this graph? This is the minimum spanning tree we see in this tree.

11
00:02:41,130 --> 00:02:58,080
We have included all the vertices in this minimum spanning tree. We see that we have included all the vertices and we have, you know, cycles the sum of what the total weight of.

12
00:02:58,080 --> 00:03:26,790
Is this part of seven for this given spanning tree? And this is the minimum spanning tree we can generate from this given graph. Now let's see the application of a minimum spanning tree to find patterns in the -- were huge minimum spanning tree to design networks like telecommunication networks, water supply networks and electrical grids.


@@@
1
00:00:01,040 --> 00:00:13,070
In this video, we're going to talk about Cream's algorithm. What is Prem's algorithm pimp's algorithm? Find the minimum spanning tree from a given graph.

2
00:00:13,760 --> 00:00:26,150
The graph must be connected. Weighted undirected graph primes algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted, undirected graph.

3
00:00:26,690 --> 00:00:43,460
This means it finds a subset of the ages that forms a tree that includes every vertex or the total weight of all the ages in the tree is minimized. You were given this what did undirected graph?

4
00:00:44,390 --> 00:00:58,280
We have defined it a minimum spanning tree in the tree. We should include all the advantages and we should have. We should have no cycles iand the total.

5
00:00:58,730 --> 00:01:11,550
It would need to be minimum. That steps for implementing Pimp's algorithm are as follows. First, initialize the minimum spanning tree with a vertex Susan at a random.

6
00:01:13,300 --> 00:01:34,770
So we'll choose a vortex randomly, we can choose zero, we can choose one and so on. Been in the second step, we will find all the agents that connect that tree to new viruses, find the minimum and add it to the tree and we'll keep repeating.

7
00:01:34,920 --> 00:01:52,470
Step two This is step two until we get a minimum spanning tree. Now let's see how this algorithm works and how preamps algorithm. Find out a minimum spanning tree in a given wooded, undirected graph.

8
00:01:53,910 --> 00:02:05,610
Let's add you argue in this graph. First, we're going to create an area in this area. We will keep track that selected Vertex. Let's see how this algorithm works.

9
00:02:06,720 --> 00:02:22,400
We're going to. Choose these products zero, so let's select this product zero. We select these vertex zero. Now here we're going to insert two. It means that we have selected the Vertex zero.

10
00:02:23,490 --> 00:02:44,030
Now, let's explore the descent of this vortex zero, the descent is one and three. Now we're going to find out the minimum. Distance from this vortex to the adjacent, that means the minimum weighted age he received for is minimum.

11
00:02:45,190 --> 00:03:01,010
Then five, now I'm going to judge this. Edge, we do it for, so let's select this vortex one. Now let's judge this minimum weight age there is four, so let's select this vortex on here.

12
00:03:01,490 --> 00:03:18,480
Let's select this vortex on and let's cut it here. Here it is for. We have selected these verdicts. OK. So let's insert here, true. At this point, we say that we selected two verdicts, zero and one.

13
00:03:19,410 --> 00:03:43,280
Now, let's find out the minimum age that is at present of zero or this vertex one we see here we have. To age from zero to three and from one to two. And the minimum age it is once it will select this age, Kiribati X2.

14
00:03:43,460 --> 00:03:59,690
So let's select this VORTEX2. Let's correct this age here and here. The point is on. So we selected these verdicts to let's insert here, true. We selected here this part, it's true.

15
00:04:00,170 --> 00:04:20,090
So let's insert your true. Now, let's find out the minimum politics. That is the ad of zero. Or one or two? OK. We see the ad doesn't. We have four two for one, we have to send it zero and two that already selected.

16
00:04:21,140 --> 00:04:35,870
Here we're marking the selected verdicts, so we'll not have any live here now from two to three. We have it or to and from due to three is with five. So it's like this age.

17
00:04:36,200 --> 00:04:50,660
So let's select this age and that weight in this ages, too. So let's connect and the audience to here see the total weight of ages four plus one plus two three seven.

18
00:04:51,410 --> 00:05:04,280
And this is the minimum spanning tree since here we have selected three in stature. True, in a minimum spanning tree will have number of is this B minus one?

19
00:05:04,460 --> 00:05:25,730
What vs the number of viruses? Here we see that we have four particles, so for minus one is three. So we see here we have three is. Here we have created an area the length of this area is the number of verdicts and we're.

20
00:05:26,670 --> 00:05:37,710
Creating this array to mark the selected products. Okay. And this is how this Prima's algorithm works for a better understanding. Let's take another example.

21
00:05:38,790 --> 00:05:53,490
Let's say we're given this graph data structure. First, what are you going to do? We're going to create an array. Mark, the selected vortex using this array, so all will not have any aloof.

22
00:05:54,980 --> 00:06:09,580
We can't ignore Luf by using this array, and we'll keep track the selected verdicts. Let's pick this vortex randomly, zero. If we pick these verdicts randomly, zero.

23
00:06:11,630 --> 00:06:26,270
Here, let's write out this verdict. Zero. And here let's market as selected because we have selected this verdict. Zero or zero is one and seven the minimum age, or it is four.

24
00:06:26,450 --> 00:06:39,620
So let's select this verdicts. One here we have selected these verdicts. One. So let's connect here. This is what is minimum here. OK, now we're going to mark.

25
00:06:40,650 --> 00:06:53,830
Here are the verdicts on a selected. Now for zero and one for this vortex one, we have to add descent to and seven four. Do you know we have to add descent?

26
00:06:54,700 --> 00:07:11,910
We've already selected this adjacent vortex. Now, what are you going to do? We're going to select the minimum age for it. Here we see eight even and eight here we're going to select this verdicts.

27
00:07:12,350 --> 00:07:27,620
OK, so let's select this Vertex seven, because here we have the minimum age it is. Eight will protect the adjacent vertex from zero to b minus one times all c.

28
00:07:27,620 --> 00:07:44,860
When you go to pseudocode, here you'll choose this. Age with wit. Eight. OK, here we are, Vertex seven. So let's pick this Vertex seven here. And here we see the.

29
00:07:46,560 --> 00:08:02,490
EJ, what is eight, so let's add here, and let's add into it here, eight now we selected seven to let market as true. True means selected through means selected.

30
00:08:03,240 --> 00:08:21,870
Now we have here these three verdicts. We have to find out the minimum age weight that the adjustment of these three verdicts. Here we sit. We have one, here we have seven and here you have 11, but one is already selected and for one, we have eight.

31
00:08:22,110 --> 00:08:35,490
We see one is minimum. So let's select your six. Now let's connect here and the edge with each one. So we selected here six, so let's market as selected.

32
00:08:36,360 --> 00:08:50,800
Now let's find out that minimum age weight that is the advent of one seven. And six, here we see a decent of six is here. These verdicts, we enjoy it too.

33
00:08:50,980 --> 00:09:09,000
And this is the minimum. So let's select five here. Let's get. Here it is, too. We selected here five, so let's mark five as selected here. The index is the note or the vertex.

34
00:09:09,870 --> 00:09:24,140
Now we have to find out the minimum age with that is the ages of one, seven, six and five. We see here we have the minimum adjustment for one seven, six five.

35
00:09:24,150 --> 00:09:42,660
Is this it for him? So let's select this Vertex two here and the age weight we see. Four. Let's connected here. So for now, four four six five seven one What is the minimum?

36
00:09:43,990 --> 00:09:57,650
It would that is at the center of this vortex, one, seven, six, five and two year we have selected to so we have to market us true. And we see that the minimum age.

37
00:09:58,310 --> 00:10:16,150
What is this age? So let's select here. Eight. So let's select your eight. And we're going to connect. The age it is to. So we've selected the. Verdicts eight.

38
00:10:16,170 --> 00:10:36,290
So let's. Market as selected, we do not market, then we might come to that again, and that will cut its cycle. Now, let's find out the. Adjutant of. Eight, two, five, six, seven one.

39
00:10:36,530 --> 00:10:50,870
And that is the minimum. And for one, all the adjacent selected for seven, all the adjacent selected for six, all the adjacent selected and here for five and four two are left support.

40
00:10:50,870 --> 00:11:07,470
Two. We have here seven. And for five, we have year 10 and 14 to let's select here. This Vertex three. Let's connected here, and let's add here, seven seven is the way it.

41
00:11:08,480 --> 00:11:27,640
Now for seven and five now four, three and five, the adjacent still in Fortnite, so let's select this age and we are verdicts for so let's select this vortex for let's connected to this vortex, and here we have the edge.

42
00:11:28,040 --> 00:11:47,170
Nine. Here I have selected three who have to market. As true and then we selected for we have to market as true here. And we're done. We have processed zero minus three times we have here we went as one ages.

43
00:11:48,350 --> 00:12:02,670
Here you have total nine verdicts. So nine minutes on his eight. Here we should have total eight, is it one two three four five six seven eight the sum of the ages?

44
00:12:03,390 --> 00:12:15,840
Thirty seven. And this is the minimum spanning tree. This is how previous algorithm works. Now, let's see the pseudocode. This is the sort of code for preamps algorithm.

45
00:12:16,650 --> 00:12:27,690
This function sticks to promulgate a graph and viruses here or declaring a variable enough for infinity. And here, restoring the maximum integer you can store in 32 bits.

46
00:12:28,850 --> 00:12:43,040
Then recruiting here, the array to market the selected varieties is that we have here a number of agents who have been minus one aegis, OK for aspiring tea.

47
00:12:43,400 --> 00:12:55,640
We know that if we have VAR, this is the number of it just must be v minus one. Initially, we're picking the first two particles of value zero and or market as selected.

48
00:12:56,750 --> 00:13:10,260
By inserting this velodrome here or printing. Age or it? Here we have this 12, well, numb underscore it is less than what it is minus one will run this code.

49
00:13:10,920 --> 00:13:23,340
This is the body of this 12. Here we are, initializing the infinity to this minimum variable. And here we have Exegol two digital oracle's digital and it'll keep track the.

50
00:13:24,720 --> 00:13:42,410
Minimum age, it will keep track the age with minimum weight. You have to default for IndiGo's, did you know I lived in Vantage's, I + + inside here, wrote checking if selected equals to two if I is selected.

51
00:13:43,910 --> 00:14:01,880
Well, it we will execute the inner loop here in a loop for it. Zikode less than 40 Elizabeth Vargas zipless pledge and here or checking if the vortex is unvisited only then will process this code.

52
00:14:02,780 --> 00:14:21,070
And here we're checking if Graaff idea is not it to, you know, this is just worth checking the ad, just since we're implementing the gravity to structure using adjacency matrix and here we're checking if minimum is greater than the current value.

53
00:14:21,080 --> 00:14:43,840
OK, then here we're updating minimum. And X to I and why did you? At the end of this falloff, we're printing Aksoy and the current value and remarking that verdict's we as selected by putting true and we're in prison now underscore it.

54
00:14:45,000 --> 00:14:56,760
This is Prince algorithm. Let's see how this actually works. Let's assume or giving this graphic data structure first, what I will do, it will create a Boolean Ari.

55
00:14:57,120 --> 00:15:14,480
This is our Boolean area of lint four, because here we have four vertices. Now let's run this well. First, we have your inserted tool. It means that we selected the node zero, that means the Vertex zero.

56
00:15:15,450 --> 00:15:26,550
Now, let's run this loop, OK? This, while of numbers, is equal to no one, the score is equal to zero initially. It's less than vertices minus one four minus one is three.

57
00:15:27,760 --> 00:15:41,140
So there is less than three let's run this code minimum be colts to infinity explodes, do you don't wake up to your initial? Now we're running your live here from this vortex zero to all other Addison's vortex.

58
00:15:42,330 --> 00:16:04,980
Here I see that one is unvisited, and that is for four is less than infinity. Now we have Exegol Digital and we got to wait for the second iteration of this love bin for I got two, then four to three who have this note, but he received four and five, but we see that four is less than five.

59
00:16:05,040 --> 00:16:23,440
So we'll update X and Y. Now here it will print X, Y and Z, and here the weight. So. First, we selected zero. Then we have the verdicts one. Let's connect it, and let's add here, Whit.

60
00:16:23,670 --> 00:16:38,820
And we're just printing into him, and this is just a logical representation. Zero one x y. And here we have the wit graph x y. Here we should have. Brackets.

61
00:16:40,210 --> 00:16:54,460
Now, let's mark one as visited, one is here. So always visited, no, let's increase now NAM eight equals to one one is less than this what it is. For one, we will have to let's make it two as visited.

62
00:16:54,790 --> 00:17:06,920
So we find out here. Two, because area isn't one and it's already visited. OK, this is already visited. And here we have five four zero and there we see one is minimum.

63
00:17:07,690 --> 00:17:21,570
So let's select the VORTEX2 we market selected. So let's connect it here. And the weight is one. Now, for two, we have your minimum. And here we see two.

64
00:17:21,840 --> 00:17:36,370
So let's select the Vertex three here and wait, here we see two. So here we have two. And let's selected. And we're done. One of the going to go through is iteration.

65
00:17:37,710 --> 00:17:48,970
For better understanding, you can go through this. You can go to iteration of this love. This is the minimum spanning four you can construct from this graph data structure.

66
00:17:49,870 --> 00:18:01,750
This algorithm only takes bigger ofthe log VE time complexity, and it reflects because of the space complexity to construct to construct the Boolean area.

67
00:18:02,480 --> 00:18:15,580
Hope you understood how this algorithm works for a better understanding. Lets me walk through another example. Let's say it were given this graph in this time, and here we have this area.

68
00:18:15,580 --> 00:18:29,220
This is our Boolean area. Now we can connect. The intention with this sort of accord. Let's try it. First, we have inserted here, too. So we selected here zero.

69
00:18:29,940 --> 00:18:43,200
Now the minimum. It is this OK? We'll find it is in this follows for, I guess, two, zero and four goals to one. You'll find it this minimum age. Let's connected here.

70
00:18:43,770 --> 00:19:01,630
So as you know, one here we have went for. So here we have wait for. Now, let's market a selected. Now, I just took one and zero is. Two, seven and seven.

71
00:19:01,870 --> 00:19:29,220
So here we see we have eight, we have eight, which is this eight because we'll iterate from zero to. Eight. And you find out here this fellow. Well, give first, then we'll move from one two zero to eight, then four, we'll process what this note from zero to eight to find to add said since you'll find it this eight first.

72
00:19:29,490 --> 00:19:49,670
So this rule is not less than eight, so you'll have this age. So let's select this verdict seven here. And let's. Draw here. So here eight. Now for seven and one, this is minimum here.

73
00:19:49,870 --> 00:20:13,040
See, this is minimum, so let's draw here. Six. I'm going to work first here. Been for six all have this is minimum five. All right, so let's backtrack when you select seven, we have to market as true when you select six, if the market as true, when I select five, we have to market as true.

74
00:20:14,570 --> 00:20:28,570
And here we have word two now. Four. From here, we see now. From here, we see the minimum added to this note. Two. So let's connected here. Now, from what we see, we have eight.

75
00:20:29,660 --> 00:20:42,990
With the minimum wage rate, that is true, so let's cutting it here and here, we're going to into it and let's adhere to. Now from two to. Three. I'm going to work first here.

76
00:20:44,650 --> 00:20:57,730
Two to three here, your boy at seven and then the minimum. Oh, I'm sorry. I have two marks. All the selected verdicts as true. We have selected two. So let's market as true here.

77
00:20:57,730 --> 00:21:15,610
We selected eight. Let's market as true. We have selected year three of the market as true and then we have here four. So let's market as true. And he let's connect, and we have here with nine total, which is 37.

78
00:21:15,630 --> 00:21:33,620
OK. Nine plus seven plus two plus two plus one plus eight plus four equals to 37. We miss this great hero, Kim. Four plus eight plus one plus two plus four plus two plus seven plus nine, he goes to tardy seven.

79
00:21:34,520 --> 00:21:50,680
This algorithm really ticks me off. He log VE time complexity and big off the space complexity. Obama understood. This preamps algorithm in the next video we talk about crucial to algorithms before.


@@@
1
00:00:00,990 --> 00:00:11,100
Hey, you guys. Welcome back to this video in this video, you're going to talk about this joint site, a data structure. What is the Joint Site data structure?

2
00:00:12,030 --> 00:00:28,380
Two or more set with nothing in common are called a joint set. You were given set. It's only includes two one two three and if it is two, go to four or five in between these two set, it's one and is two.

3
00:00:28,650 --> 00:00:45,030
We see nothing in common. So this two sets are called these joint set. What is the representation of the data structure, how the joint site is represented in computer memory and how it works?

4
00:00:45,360 --> 00:00:59,100
Well, see everything in this video. We'll see how the joint set represented in computer memory and how it works. Now let's talk about the application of the Joint State.

5
00:00:59,710 --> 00:01:12,590
Here we have two uses of the joints. It's crucial to algorithm uses a joint set we can detect cycle in undirected graph using the joint set data structure.

6
00:01:13,980 --> 00:01:33,480
Indeed, Joint said, we have two operations find operation and union operation. We'll see how final operation and union operation works, and you'll see how to detect cycle in undirected graph using the joint state data structure.

7
00:01:34,290 --> 00:01:51,780
Now, let's see the representation of the joint set. Now let's talk about the representation of a D joint set data structure. We can represent the joint set using a simple array the joint set uses assigning to define is set.

8
00:01:51,960 --> 00:02:07,440
The tuning is defined by a parent child relationship. Let's see. We're given this set. We have to represent this the joint set. How did you begin to this set using the joint set data structure?

9
00:02:08,310 --> 00:02:21,300
We're going to implement the joint the structure using simple array. First, we're going to construct a structure. This is structure we can construct. This structure here is parent of one.

10
00:02:21,720 --> 00:02:33,240
And here on this parent, up to and zero is the absolute parent of two. OK. Also, you can construct this structure here. We see the parent up on two is zero.

11
00:02:34,080 --> 00:02:49,500
And here we see the parent of two is one. The parent of zero is true. The absolute parent of zero is one. So we can consider the absolute parent of two and the absolute parent of zero is one.

12
00:02:49,950 --> 00:03:05,520
Now how this is, structure can be represented using a simple array. This structure can be represented using a simple array, something like this. OK. We have here zero zero one A. zero one two.

13
00:03:05,940 --> 00:03:20,880
How it's represented, we have zero. So the parent of zero is zero. OK. That's what we have in zero. Now here one, we see that the parent of one is zero and restoring the parent of one here.

14
00:03:21,270 --> 00:03:33,300
OK. And here we are storing one. One is the parent of two. So we're storing here. One. So one is the parent of two. Zero is the parent of one entity. Is the parent of zero.

15
00:03:33,660 --> 00:03:44,640
Now how to find the absolute parent of two. In order to find that absolute parent of two, first you move to the index one. At Index one, we have value zero.

16
00:03:44,820 --> 00:03:59,730
Now let's move to index zero and at index we have zero. And we see that this is the absolute parent of this node. Two. OK. We can consider here that element as in node.

17
00:04:01,380 --> 00:04:19,470
So this structure is represented something like this. We can have many different structure to represent a set. This is a valid representation of the joint suited to the structure of this set, which contains three elements.

18
00:04:19,650 --> 00:04:31,950
You don't want to. This is how did joint set represented it using a simple array? Now let's see the representation of this structure. This is the representation of this structure.

19
00:04:32,160 --> 00:04:41,340
The parent of zero zero, the parent of one is zero. The parent up to is zero. This is so simple right now. What is the representation of this structure?

20
00:04:41,790 --> 00:04:58,350
What is the representation for this structure? This is the representation of this structure. Here we see that the parent of zero is two and the parent of one is one, and the parent of two is one.

21
00:04:59,280 --> 00:05:19,080
This is a valid, disjoint say to do structure. So we can represent this set in this something like this. Oregon represents something like this, or we can represent something like this, and we can have many different way to represent a set that difference on our implementation.

22
00:05:19,830 --> 00:05:36,000
So this is a simple representation of the joint set the the structure. Now let's see the representation of to set. OK, now we're going to talk about the representation of two set we have this set is one.

23
00:05:36,240 --> 00:05:56,820
You know, one two and have set is two three, four five. How did this to set using one Ari? Let's see. How did this to to set using one Ari and we have two made this to operation find a partition anti-union operation using this find operation.

24
00:05:57,000 --> 00:06:14,010
We will check our two and five in the same set. And using this union operation will merge to set S1 and S2. Let's see how we can represent these two set using the joint set in a structure.

25
00:06:14,910 --> 00:06:27,780
This is our community, OK? This is all given at a hearing of index, and here we are storing the value of him here at index zero zero. At Index one, we have one end at index two.

26
00:06:27,780 --> 00:06:40,680
We have to add index two of three at inexperienced, four at Index five we have five. What does this means when you have the index and the value are the same?

27
00:06:41,040 --> 00:06:58,440
It means that the the element is the disjoint said, OK, this is it. The joint sit here. We have total five, the joint set. We have to we have to construct a set with this three element.

28
00:06:58,500 --> 00:07:12,120
Zero one two. And then we have to construct this set using this three element three four five. How to do this? OK, now here we have individual or distinct set.

29
00:07:12,600 --> 00:07:28,260
All the set added joint we have here. 2.6 set zero one two three four five in this area we have total six did joint set zero one two three four five. Now let's construct a set for this set is one.

30
00:07:29,070 --> 00:07:43,830
First, let joined us through a set of zero and one for that. What I will do will replace this one with zero. Let's replace this one with zero. So here it means that the parent of zero is zero.

31
00:07:44,310 --> 00:08:01,980
The parent of one is zero. OK, so the parent of one is zero. Now we have this set in this area. Now we have total five, the joint set. Now let's join this to set to end this set.

32
00:08:02,130 --> 00:08:16,050
OK, we have two joined two into this set. So what I will do here, we will replace this two with one. So here, let's add one. It means that the parent of two is one.

33
00:08:16,350 --> 00:08:30,870
So let's adhere to. So we get this the joint set, so we get this did joins it. Now in this area, we have total for the joint set. This is a set. Now let's construct this set.

34
00:08:32,010 --> 00:08:43,230
Now let's join this to set here three and four for that. What I will do will replace four with three. So three is the. Parent here is the parent of four.

35
00:08:43,800 --> 00:08:56,670
And here we see that is the parent of three now. Let's join this set five to this set. If we want to join to this set, then what do you do? We will just replace this right with.

36
00:08:56,670 --> 00:09:16,050
For now here we're going to add five. So this is our set. So in this note, we have to design it. Now let's find out. Two and five are two and five in the same set for two.

37
00:09:16,200 --> 00:09:27,720
We see we have here one for one. We have zero four. Do you know we have here? Zero. So what is the absolute parent up to? The abstinence parent of two is zero.

38
00:09:28,680 --> 00:09:42,480
Now let's find out the absolute best of five. The. Parent of five is four, so the parent of four is three. The parent of three is three, so three is the absolute parent of five.

39
00:09:42,840 --> 00:10:03,450
So we see that the absolute parent of five is three and absent parent of two is zero. We see the absolute band are different. So two and five is not in the same set, so it will return false two and five it just in the different set.

40
00:10:03,990 --> 00:10:17,920
Now let's perform this operation. Now let's merge this to asset S1 and S2. How to merge this two set. OK, if we merge these two set, then what's going to happen?

41
00:10:18,460 --> 00:10:31,650
We will have our one absolute route to merge this to set. What I will do, we will first find it the absolute parent in this set and the absolute parent in the set.

42
00:10:31,920 --> 00:10:43,140
The absolute parent in the set is zero. The absolute parent in this set is three. Now what I'm going to do, I'm going to replace this absolute parent three with zero.

43
00:10:43,950 --> 00:10:53,100
So we connected this said something like this. Now we have here one absolute parent that is zero. So let's find out the absolute parent of this node. Four.

44
00:10:53,460 --> 00:11:03,480
So let's find it the absolute point of this node for the parent of forestry, the parent of trees zero zero zero. So if finding the absolute parent here.

45
00:11:03,630 --> 00:11:13,020
So zero is the absolute parent of four. What is the absolute parent of five? The parent of five is for the parent of four is three. The parent of three is zero.

46
00:11:13,200 --> 00:11:26,430
The parent of zero is zero zero is the absolute parent here. So we merges this to set something like this. We just merge the absolute parent for both set.

47
00:11:26,820 --> 00:11:37,710
That means it emerged that two set. This is called the union operation. We're just marching to set into one and we're doing all the operations in this area.

48
00:11:37,770 --> 00:11:49,230
This is just a logical representation and this is called basics did a joint set. Now let's see how to detect a cycle using the joint set to the structure.

49
00:11:49,860 --> 00:12:06,000
Now we're going to talk about how to detect cycle in undirected graph cycle detection works only in undirected graph for the joint set. We cannot use the joint set to predict cycle in a directed graph.

50
00:12:06,300 --> 00:12:19,340
Let's see how the two were given this age. And here we have for age, OK, we have to detect whether we have a cycle or not. Here we have this array. This is our disjoint said.

51
00:12:19,350 --> 00:12:33,930
It had a structure. This is already the structure. We're implementing the joint set using Arrietty to structure. Let's see how can digit cycle an underrated graph first three, zero and one in this area have for the joint state zero one two three?

52
00:12:34,320 --> 00:12:50,910
We have zero and one the absolute point of zero zero the absolute panda boys want. They're different. So let's connect this to politics with an h. Now let's perform union operation for this to the joint set zero and one.

53
00:12:51,420 --> 00:13:03,010
Now what I'm going to do, I'm going to just replace this one with zero. The parent of one is zero. Here, the parent of one is zero. Something like this.

54
00:13:03,510 --> 00:13:16,230
This is the parent. And this is one. Now let's process. The next is this is our mixed age Europe zero and three. The absolute parent of zero zero, the absent parent of three is three.

55
00:13:16,290 --> 00:13:32,700
So they're different. Here we see that we have two distinct set the absolute binding zero zero the absolute band of trees. Three. So we're going to connect this to Vertex because we find it two different absolute parent.

56
00:13:33,300 --> 00:13:46,860
Now let's connect this to the joint set Europe. Zero A. three. So the absolute random zero zero, the absolute band of three is three. So we're going to replace this tree with zero.

57
00:13:48,120 --> 00:13:59,490
So here, what are they doing? We're just setting the absolute count of three. So here we have three. The parent of three zero, the parent tip on is zero.

58
00:14:00,030 --> 00:14:10,950
The absolute right of trees is zero. Now we have this age in this age of two and three for two. We see the absolute brand is two four three. The absolute brand is zero.

59
00:14:11,130 --> 00:14:23,040
So we find it two different absolute parent two and zero. So what we're going to do? We're going to connect two and three. So let's connect these two verdicts with an age.

60
00:14:23,640 --> 00:14:34,560
Now this verdict, OK, you've got that. Let's for one union operation for two and three. So let's park from here, you know? So let's park from here. Union operation.

61
00:14:34,860 --> 00:14:46,080
So here, update this to it. Three. So here we have the root of two is three. So here we see that the parent of two is three. Now let's move to the next stage.

62
00:14:46,110 --> 00:14:59,190
This is our next it. We have one absolute point of one is zero. Europe zero. And the parent of zero zero. So here you find it. The absolute parent astral parent is zero for one and for two.

63
00:14:59,850 --> 00:15:11,760
That's one to three, the parent of three zero and zero zero. So absent parent up to is zero. We find out absolute parent of one and the absolute parent of two aren't the same.

64
00:15:11,980 --> 00:15:24,930
So we find it is cycle here. We see that if we connect then we will have a cycle here. This is how we can detect cycle in undirected graph using the joint set.

65
00:15:25,410 --> 00:15:36,720
Now we can optimize our time complexity from linear to logarithmic time complexity for simple implementation of the joint SUJATA to structure, it all takes linear time complexity.

66
00:15:37,620 --> 00:15:53,430
That means it all takes big off in time complexity and is the number of elements in our array. Now how we get optimized this linear to a logarithmic, let's see that now we're going to use part compression.

67
00:15:53,820 --> 00:16:08,490
Let's see how to represent the joint set. We're using parent child relationship. OK, now we're going to create an area of nodes. The node will have two parts parent and Iraq.

68
00:16:08,700 --> 00:16:20,370
Let's see how this is our area, OK? Here we have parent and a rank four is index. We have parent and rank rank is initially zero. We'll see what is rank.

69
00:16:21,150 --> 00:16:35,100
And here parent is zero. Parent means initially the parent of zero zero bound up on is one. And so on. Here we have total six distinct set. That means we have 2.6 disjoint set.

70
00:16:36,300 --> 00:16:54,930
Now we're going to connect that to set zero and one. OK, let's connected at all parameters to operation. Find operation and union operation first. Let's now let's represent this to set S1 and S2 using this area that we have here.

71
00:16:55,380 --> 00:17:07,560
Index zero. OK, and here at one. Now what are you going to do? We can connect in this way, or we can connect in this way because we have sim rank. Here we have zero.

72
00:17:07,590 --> 00:17:23,100
Here we have zero. We'll move from lower rank to higher rank. If we saw the rank of the SIM, then we'll move in energy directions. Now here what I'm going to do, I'm going to replay this one zero.

73
00:17:24,000 --> 00:17:35,160
So here I'm going to replace this one with is zero. And I'm going to increase this rank so it can go in what direction I'm going to go from here to here or from here to here.

74
00:17:35,550 --> 00:17:51,630
Now here, I'm going to move from one to zero. OK. In this direction. So what I'm going to do now, I'm going to replace one with zero. And we're going to replace zero with one point replacing zero with one.

75
00:17:52,230 --> 00:18:07,770
It means that we're just increasing the rank from zero to one because we have here the same rank. Here we're increasing rank to one because here, you know, is the absolute parent of one.

76
00:18:08,730 --> 00:18:25,230
So the absolute parent up one is zero. If you want to mars another set with this set, then all Mars, the absolute parent of meals set to the absolute dependent of this set from lower rank to higher rank.

77
00:18:25,380 --> 00:18:36,600
Let's see how. Now let's connect two to this said, OK, so we're going to Mars. This two here were just performing union operation. OK, now let's move this to do this set.

78
00:18:37,050 --> 00:18:47,460
So here we see that we have rank zero here of rank one. The absolute absolute band up to is to absolute point of zero zero. So we're going to connect these two with this zero.

79
00:18:48,020 --> 00:18:59,900
So it represented something like this zero and here one. OK, now after that point up to is zero. OK, so we're going to to the absolute parent. That's true.

80
00:18:59,900 --> 00:19:13,460
Hit the absolute paradip is absolute. But in here, then we're going to replace this to it is zero. So here we'll have to. So we represented this citizen in this area and let's represent this set.

81
00:19:13,940 --> 00:19:28,790
First, we have here three and four. So let's move this to the joint set three and four. We have your similar rank. So we'll move from four to three. So here will increase the rank here.

82
00:19:28,820 --> 00:19:41,240
Three is our absolute parent. So let's replace four with three. Now let's March five. That's a good point of this set is three. So let's merge. It's something like this.

83
00:19:41,240 --> 00:19:54,440
Here will replace this five with three. The absolute parent of five is three. It represents something like this three here four and on this side five.

84
00:19:55,760 --> 00:20:10,730
So this is our set representation. This is what we can represent is to set using this area in this area. We're storing in node at every index the node has to attribute parent and rank.

85
00:20:11,870 --> 00:20:30,240
Now we want to merge this to set here. We want to Mars discuss it. Beyond that, let's find it. This operation are two and five in the same set. When you were representing these two set for this set and two, now let's start on this plant operation here.

86
00:20:30,240 --> 00:20:39,200
I have this question hour two and five in the same set. Two for two. Let's find it the absolute parent for 2020 zero four five. The absolute parent is three.

87
00:20:39,680 --> 00:20:49,670
Now what are we going to do? We're going to take the absolute parent. Separate parent are different, so we're not in the same set. We see the absolute parent are similar.

88
00:20:49,850 --> 00:21:01,700
That means two it just in the sims it. But during the different it, since you find it different. Absolute parent. No, let's merge this to set in order to Mars.

89
00:21:01,700 --> 00:21:10,700
This does it for us to find out the absolute parent, the absolute parent for this city zero, the absolute parent for this state is three. So let's connect the assert parent here.

90
00:21:10,820 --> 00:21:22,100
We see the rank are the same so we can connect from two to zero or from zero to three. It's connected to something like this. So here what I will do will replace this tree with zero.

91
00:21:22,730 --> 00:21:36,080
So the absolute best of three zero. We see that by the first three. What is the absolute parent? So the Panda four is three point of three zero and parent of zero zero zero is the absolute parent.

92
00:21:36,610 --> 00:21:50,780
Four five. The parent of five is three, the parent of trees zero, the band of zero zero. So after the parent of five is zero. So here you are, destroying the absolute parent or destroying the parent.

93
00:21:51,170 --> 00:22:03,470
That can be the absolute parent that may or may not be the absolute parent here or an industry only just the absolute parent. We may or may not steward the absolute parent.

94
00:22:03,710 --> 00:22:18,010
We may store the parent OK. This is how we can represent did turn set using our representation. Here, a string node at every index. And here we're just moving.

95
00:22:18,110 --> 00:22:35,650
OK, so you defined zero when you find out zero. We will update the parent of tree with zero. OK. And that's called the path compression. If you want to find out the absolute point of five here have three and four tree.

96
00:22:35,660 --> 00:22:49,370
We see that we have here zero. But you don't. We have zero. So you find this absolute parent and we will replace this with zero. It means that we find out in absolute parent here.

97
00:22:49,850 --> 00:23:02,180
So we're reducing. We're reducing. And this is called path completion. Don't worry about that. Understanding this, I would highly encourage you to check out the source code.

98
00:23:02,750 --> 00:23:15,980
You will see what is path completion? Now, let's see. How did it cycle using this representation, using this kind of representation of the joint set? Let's assume we have these five ages.

99
00:23:16,640 --> 00:23:30,770
And here we have five Vertex. OK, now this is our disjoint switch to the structure. For this, we see that zero and one there having different absolute parent zero and one.

100
00:23:30,800 --> 00:23:42,920
So let's connect them now. Let's Mars zero and one. So what I'm going to do here, I'm going to replace this one with zero. So the absolute band is zero.

101
00:23:43,190 --> 00:23:52,710
So let's increase this rank from zero to one. Now this. Two and three, the absolute parent of two is two absolute brand of trees. Three, they're different.

102
00:23:52,890 --> 00:24:07,900
So let's merge to a tree. Now here we see that we have to the joint set two and three. Let's M.B. We want to merge them, will replace this tree with two and will increase.

103
00:24:07,920 --> 00:24:19,040
This will increase this from zero to one. OK. Now this is our next age one and two. The absolute point of one is zero. The absolute point of two is two.

104
00:24:19,230 --> 00:24:32,820
So they are different. So let's merge one and two. And now let's march here. OK, let's call immune function or immune method for this to set zero one and this set two.

105
00:24:33,330 --> 00:24:42,990
OK, here we have this set to Mars. This to the absolute point of two is two absolute parent of one is zero. So let's embrace this. We're going to replace this to it.

106
00:24:43,080 --> 00:24:55,620
Zero. So we might need it now for this eight, zero and four. The absolute brand zero zero. The absolute point of four is four. So they're different. So let's Mars zero and four.

107
00:24:56,070 --> 00:25:13,140
So let's replace this for with zero. OK. Because it's having the lower rank interconnect from here to here. So as you place this point zero now four, four and three, we see that the absolute band are four is zero absolute band of trees.

108
00:25:14,460 --> 00:25:26,100
Here we have to. The parent of three is to the parent of two is zero zero zero. So the absolute band of three is zero and absolute band are four zero.

109
00:25:26,340 --> 00:25:39,480
So we see that the absolute band are the same. So if we add this eight, three and four, it will form a cycle. So we find it a cycle here. This is what we can detect a cycle unit undirected graph.

110
00:25:39,930 --> 00:25:51,570
This method only works for directed graph because in directed graph, we cannot move backward and forward. That's how we can detect cycle in undirected graph using the joint data structure.

111
00:25:51,960 --> 00:26:06,510
Here we see that we see the absolute band of trees zero. But here we have two so distraught with zero and that is called path compression, and we'll see how to do this in the source code.

112
00:26:07,140 --> 00:26:19,860
Hope you understood that did join City did structure in a very high level for Chris guilts algorithm. You have to understand the the joint city, the structure in the next story that we're going to talk about how to find it.


@@@
1
00:00:00,840 --> 00:00:09,300
Hey, you lots of guys. Welcome back to this video. In this video, we're going to talk about pat competition in the previous video. We have talked about pat competition.

2
00:00:09,570 --> 00:00:22,050
Now let's talk about pat competition in details in this video now here. Let's start with you. Want to find out the absolute parent for the Note five? OK.

3
00:00:22,320 --> 00:00:38,940
And here we have the structure of this disjoint set now in order to find your absolute parent of this note. Five. We have to find it the parent, the parent of five is three.

4
00:00:39,990 --> 00:00:54,690
Three is not the parent of five. So let's move to the Note three, the parent of three zero and the parent of zero zero, so we see that zero is the absolute parent of five.

5
00:00:55,380 --> 00:01:11,610
Now what it will do will replace this zero zero. But here is see, we have zero already. Okay, now let's move to three here. OK, now here what I'm going to do.

6
00:01:11,790 --> 00:01:25,120
I'm going to replace this tree with zero. OK, let's replace this tree with zero. Now here we have this tree. OK, now in this structure, what are you going to do?

7
00:01:25,150 --> 00:01:46,640
We're going to discuss this. We're going to connect this five directly to this zero. OK. So we can find it five in constant time now if we want to find out the absolute parent of four, first of the find it apparent prejudice tree and the parent of three zero a. zero.

8
00:01:46,660 --> 00:02:00,460
OK, let's revisit this zero zero and then let's replace this tree with zero as well. Let's replace this tree with zero. So the absolute point of four is zero led to disconnected.

9
00:02:00,730 --> 00:02:16,780
Let's get to zero. Here we see that four directly connects to zero. So we can exit four five in constant time. This is called pad compression, so we reduced the Pap.

10
00:02:18,070 --> 00:02:35,300
We can find out it in constant time. This is called pat competition. Hope you understood what is pat comprehension? Indeed, John said to the structure when he performed the final operation, then we will reduce the pat something like this.


@@@
1
00:00:00,540 --> 00:00:17,700
Hey, you lots of guys, welcome back to this video in this video or going to talk about Chris Kelts algorithm. Now let's see how to find it. Minimum spanning tree using crushed guilts algorithm Good skills algorithm finds a minimum spanning tree for a wooded, undirected graph.

2
00:00:18,240 --> 00:00:57,380
It is a greedy algorithm in graph theory, as it is esteve. It adds the next lowest IT aid that will not form a cycle to a minimum spanning tree. This is the formal definition of this algorithm, you're given this weighted underrated graph, you have to find it minimum spanning you from this graph that steps for implementing Crossgates algorithm are as follows Sort all the ages, sort all the ages from low wage to high weight, then take the age with the lowest weight and added to the spending tree.

3
00:00:57,620 --> 00:01:10,680
If adding the age graded cycle, then reject this age. We can detect psycho using the joint data structure, so we'll apply here. The joint surgery this doctor to find if cycle.

4
00:01:10,700 --> 00:01:24,980
If you find it is cycle, then it will reject that age and keep adding ages until we reach all parties. This this is the algorithm. OK, this is the cross kelts algorithm.

5
00:01:25,670 --> 00:01:38,420
Now let's see how it works. Let's say we're giving this graph here. We have to know for ages one two three four, this is sourced. This is destination and this is weight.

6
00:01:38,750 --> 00:01:56,510
Now we're going to sort the ages by their weight in increasing order. So we sorted the ages by their weight in increasing order. One two four five. Here we have zero one three two.

7
00:01:56,540 --> 00:02:12,880
Here we have four verdicts. Now let's process this edge. One two. Let's connected. OK, we. Myers, this two verdicts with an H. Then it's it's not for me, cycle.

8
00:02:14,090 --> 00:02:28,610
Then let's process this. Two and three. It's connected. We see if we connect this to Vertex with an age it forms know cycle so we can connect it. Now let's process this.

9
00:02:28,730 --> 00:02:40,200
Zero one, that's connected. It will not form a cycle. Here we have wood associated. So for zero one, let's add in one four two three here two nine four zero one four.

10
00:02:41,060 --> 00:02:56,840
Now for this eight zero three five, the old is five from zero to three. We see that if we add an age here it form is cycle. So we cannot include this age.

11
00:02:57,050 --> 00:03:15,010
We reject this age. How to reject an age. And how to detect cycle will detect cycle using the joint sit data structure, and you'll see how to find it is cycle and how to reject.

12
00:03:15,670 --> 00:03:32,170
And you go through line by line of code. Now let's see how cross kelts algorithm works. Since the ages are sorted by their weight in increasing order, so we find it a minimum spanning tree, this is the minimum spanning tree.

13
00:03:32,500 --> 00:03:42,940
This is how we can find out. Minimum spanning tree using Crossgates algorithm. Now let's see. How did you cycle and how do you reject the eight that form a cycle?

14
00:03:44,230 --> 00:04:03,490
Is it our joint site to structure? This is an array of nodes that note has two attributes parent and rank. The rank initially zero and parent is zero for the index zero for index one, the parent is one and so on.

15
00:04:04,210 --> 00:04:19,330
Here we have total for the joint set zero one two three. Now, let's process this age one two. OK. We see here one, the absolute parent of one is the absolute parent of two is two.

16
00:04:20,140 --> 00:04:37,210
You will find it two different absolute parent, first source and destination. That means it will not form a cycle. It's simple. Okay, so let's connect one and to the let's bottle unit operation for this two, for one and two.

17
00:04:38,350 --> 00:04:49,780
Now I'm going to object to this two one. And let's increase this zero to one. Now here we have one. It means that we have absolute parent one in this set.

18
00:04:50,530 --> 00:05:05,150
One two. OK, now let's process this eight. We have it two three. The absolute parent of two is one absolute parent of three is three. Here we see the parent of two is one, and the parent of one is one.

19
00:05:05,170 --> 00:05:16,600
So one is the absolute banged up two, and the absolute point of three is three, because here we have three. So one and three are not the same. So let's connect here this.

20
00:05:17,530 --> 00:05:36,170
So let's add this h two and three this eight here. Which one? Here we have with two. Now, let's connect this to set one, two and three, the absolute point of this two is one and absolute point of threes.

21
00:05:36,350 --> 00:05:54,200
Three. So what are we going to do now? We're going to replace this tweet with one. We don't have to increase the. Rank here because we have ranked one here, we have this direction of.

22
00:05:55,610 --> 00:06:09,750
Here we see that one is the absolute point of three now. Let's process this eight zero one. Here we see that the absolute point of zero is zero absolute point, a point is one, they're different.

23
00:06:09,960 --> 00:06:26,280
So let me add this h. It will not form a cycle because the absolute bind are different. So here you have the word for area for now. Let's add this to said OK.

24
00:06:26,320 --> 00:06:38,940
Zero. And this said one two three. The absolute point of this set is one element of this set is zero. So that's connected. Here we have one. So will replace this zero with one.

25
00:06:39,090 --> 00:06:53,900
Because here we have higher rank. So we're done. Now let's move to the next age. Let's process this age zero absolute point of zero is one, and the absolute point of three is one.

26
00:06:53,930 --> 00:07:10,420
Okay, so we find it the absent parent one and one, we find it same absolute parent for zero and three. So if we add this age, it will form a cycle. We clearly see that if we add this age, it will form a cycle.

27
00:07:10,480 --> 00:07:25,470
So will reject this age and reprocessed here for Vertex. So we've done. We have processed all the verdicts in the graph, so we're done. This is how Chris gets algorithm works.

28
00:07:26,080 --> 00:07:40,730
Now, let's see, that's what a could. This is the sort of code for Cruz kelts algorithm, this function grows strict, no parameter inside here we're creating an array of ages.

29
00:07:41,850 --> 00:07:54,160
The lenders are eased the number of advantages. Then we have your equals to zero. Because initially, we have protested judo ages Eagles two zero four, Eagles two zero.

30
00:07:54,180 --> 00:08:08,790
I lived in what is a plus plus result. I Goldston, you wait here, you just adding new age to that result. Then here we're sorting the ages in ascending order by their weight.

31
00:08:10,300 --> 00:08:34,340
From lower to height worked, that meant in increasing order. Then here we have this subset. This subset means here we're creating an area of nodes. So it is a note, and this note has two attributes parent and a rank.

32
00:08:35,060 --> 00:08:50,180
The length of this area is the number of vertices we have this area, you are just adding the new subset. That means the new node to the subset. Then here we are running this luf here or inserting.

33
00:08:51,490 --> 00:09:05,620
Well, apparent at Index V, the Value V and the rank is zero initially, then we're resetting it to zero. And here we are running this a while of e less than what minus one.

34
00:09:06,850 --> 00:09:29,580
Because you'll have the total number of agents in the spanning tree, the number of viruses minus one. Then here, current is to new age countries, escorts to is A-plus flights, so we're selecting our current age and we're moving to the next to select the next age.

35
00:09:29,880 --> 00:09:44,610
Now here we're trying to find it. The X X means that absolute parent of the source of our current age and the absolute parent of the destination, we're storing it into this.

36
00:09:44,610 --> 00:09:57,150
Why variable? So X and Y, if X and what is not equal, then you can add that age to our result every welcome. We are pursuing this in an operation in between Exit Y.

37
00:09:58,310 --> 00:10:13,970
Except what is that absolute parents of source and destination of our current age, and we're moving it to the next? OK. It'll point to the next note here we have the age of him.

38
00:10:15,380 --> 00:10:39,220
Then we have this love by this little will print the source destination and it. This is our final operation. It takes two primary just opposite, and I pisodes upset, I don't know goes to I the only recursive recursively call this and this condition is called pad compression here, calling this function recursively.

39
00:10:39,220 --> 00:10:49,960
If subsets I don't parent no records to. I hear we're calling this function find subset subset either parent. We're calling this function recursively.

40
00:10:50,740 --> 00:11:02,290
This is called pad compression. We're just this is called pad compression or just reducing our pad. We'll see how we already saw in that previous video.

41
00:11:03,820 --> 00:11:19,000
I think you'll read him. Supports it. I that parent. We have this union method. It takes three parameter supported X and Y. Here we have, except for x root find subset x the absolute.

42
00:11:20,310 --> 00:11:34,350
Parent of X and here, absolute parent of boy. We're checking the rank in the rank of Absolute U. The rank of absolute parent of X is less than the rank of absolute parent of white.

43
00:11:34,910 --> 00:11:50,830
We will. Will set the absolute parent a boy to the parent of absolute route, if we saw the rank of absolute parent of X is greater than the rank of absolute brand boy.

44
00:11:51,150 --> 00:12:06,180
We will update the absolute parent up white with absolute pride of route the parent to look him. If they are same, then this or be satisfied, then this could all run.

45
00:12:06,750 --> 00:12:34,530
We're setting absolute brand route as the parent of sort of pent up boy. And here we're just increasing the rank of absolute pint of root by one because the rank at the same in this cage, we have to we have to encourage the rank up our absolute parent here and be doing this to absolute parent.

46
00:12:34,860 --> 00:12:50,070
The absolute parent of X will be the rank of absolute parent. You've increased the rank are descent. Now let's see how this works. Let's say we're you this graph and here we have this age.

47
00:12:50,220 --> 00:13:04,560
We saw this eight. We get this age, OK, so we sorted that it just by their weight. This is our the joint search due to structure. And here we have four nodes zero one three two.

48
00:13:05,720 --> 00:13:19,670
So we constructed this using this to on him. This is a subset, and we have this two looks now I to zero current as it calls to this age. Let's process it.

49
00:13:20,720 --> 00:13:35,000
Let's process this age as it happened off on his own absolute pent up to his do. They're different so we can collect it. They're different. We can find out that find it will return one and it will read them too.

50
00:13:36,140 --> 00:13:53,660
So let's take this condition we see. One is not to go to two. So let's continue on into two. Now let's perform union operation. In reading one and two, we see absolute print of one is on absolute brand of twist two, and we see the rank are the same.

51
00:13:53,660 --> 00:14:08,500
So we will apply this code here if we apply this code. We will update this absolute rule the way here this is. This is why. OK, so let's update this one and let's increase this rank to what?

52
00:14:09,590 --> 00:14:32,010
Now let's process this age. OK, we're done. But what is this age? Now here we see X equals two. To hear escalates to the absolute bind up to that is one hearing one of him absolute brand up to his own and the absolute brand of trees three wanted to are not the same.

53
00:14:32,290 --> 00:14:53,610
So it'll connect this edge two and three, two and three. OK? Hurry up with one. Let's so let's add one. So this find will return one for two and it will return three for three.

54
00:14:54,660 --> 00:15:03,740
OK, let's see how it's written. One for two. We'll call this upset at Index two. We have a what? What is the record to two? So we'll call with this here, OK?

55
00:15:04,530 --> 00:15:14,460
Here we see we have one and one equals two one. So it will return one and it will update this one. But here we have already one. Now let's read in on.

56
00:15:15,540 --> 00:15:30,370
OK? This is how this one will read in one. Now we're done. OK, let's add this aids to this result. That means we connect this eight and it is two. We're just storing the H in order here.

57
00:15:30,540 --> 00:15:45,870
This result every now. Let's call this union with one and three. We call it. We call it one in three. Here we see this condition. OK? Absolute pent up to is one absolute brand of threes.

58
00:15:47,720 --> 00:16:02,490
Three. So. Here we see rank equals to one. OK. At one, we have the rank one and here, you know, so. So we have to admit this well, we do want let's update develop with one.

59
00:16:03,390 --> 00:16:14,010
So we're done. Let's move to the next stage. This is our next. It's zero one. That's one of the absolute absolutely zero. The absolute point of one is one.

60
00:16:15,120 --> 00:16:31,050
They're different. So let's add this age to our result. All right. That means we'll create this age zero and one. Let's correct this age. Here we have weighty calls, too for the let's call this union with.

61
00:16:32,340 --> 00:16:44,970
You know, and one here we have raggi goes to one to approve this, 081 will move from lower rank to hiring something like this, OK? This is the absolute truth.

62
00:16:47,460 --> 00:17:03,140
So we're done now, let's move to the next age here, this h assorted point of zero is one absolute brand of tree is one. They're DCIM, so we'll not add the S to our result already.

63
00:17:03,150 --> 00:17:15,090
That means we're not connected because if we're connected, it'll form a cycle. This is how we can detect a cycle and it's a joke. We can't reject the ID that form a cycle.

64
00:17:16,080 --> 00:17:27,100
Now we have processed four verdicts, so we're done. This is how. This Chris Kelts algorithm works. Now, let's take another example for better understanding.

65
00:17:28,420 --> 00:17:41,860
Let's see. We're giving this graph and we have the ages here and we already sorted the ages in ascending order. And we have this area, this is our subsets area.

66
00:17:43,300 --> 00:17:56,350
We constructed this are using this for him is to follow. Now I got to you. Well, then what is this minus one? Here we have total six versus our current edge.

67
00:17:56,350 --> 00:18:09,760
Is this eight? Here we have six verdicts. This is your current age. Hurry up zero and one absolute zero zero. Absolute burned up. One is one. They're not the same.

68
00:18:09,760 --> 00:18:31,100
So let's connect one and zero zero and one here. And what is one now? Let's connect them using this union. The parent are the same school abduct the parent of why here?

69
00:18:31,430 --> 00:18:44,600
This is this is always, let's admit it. It is, you know, and let's update this with one. But this formula, because the rank are the same. Now let's move to the next.

70
00:18:45,740 --> 00:18:57,980
This is the next eight. We have added this aids to this result area. OK, we're here just showing you the logical representation. Now here we have one.

71
00:18:58,790 --> 00:19:11,630
The absolute burned up one is zero. The absolute point of three is three. They're not the same. So let's connect one and three, one and three. OK, we connected here one and three.

72
00:19:11,990 --> 00:19:24,200
The Oit is one. Now let's connect one and three. That's the point of one is zero. And here three. We have high rank arbitrary with zero. But this one?

73
00:19:24,370 --> 00:19:39,050
OK, by this formula software that parent equals to Xer because here we have the higher rank here. If hiring one, it means that this is the absolute. Parent in this set.

74
00:19:40,160 --> 00:19:57,170
So we added this. This is a Detroit seat. This is the joint sit. So we added this side to this seat. Now let's move to the next eight. This is our next us to and for the absolute brand of is to absolute brand of four is for the different.

75
00:19:57,180 --> 00:20:14,000
So let's commit to two and four. Here we see the what is one. So let's add here one. Now let's call this union with two and four. Here we see that the.

76
00:20:15,560 --> 00:20:30,100
At The Sims Abbott here this way, ah, that means the absolute brand of white with X. I'm sort of parent of X. I will increase this zero from zero to one.

77
00:20:31,450 --> 00:20:46,480
So we're done. We have added history just in this reserved area, and we're just showing you the logical representation. Now let's process this. Eight zero to the absolute point of zero zero absolute brand, up to is two.

78
00:20:47,020 --> 00:21:01,870
So we can connect here zero and two. Let's connect zero and two here with two. Now let's call it union with zero and two zero and two, we have the same rank.

79
00:21:02,080 --> 00:21:15,110
So replace this two with zero and you'll increase this rank from one to. To. We have Frank here, too. It means that this is our absolute parent for this state.

80
00:21:15,860 --> 00:21:27,030
This isn't it, and here we have disjointed. We have yet to rejoin it now. Two and three. The absolute opened up to a zero absent parent of three is zero.

81
00:21:27,050 --> 00:21:40,880
Their decision so if we add two and three, it will form a cycle. We clearly see that here this eight, then it will form a cycle here. So it wasn't at this eight year discussion is what?

82
00:21:42,540 --> 00:21:55,070
Now, let's process this. Now, let's process this age here, OK? We don't have to adhere the union because we don't have to apply here union, because we have no age here.

83
00:21:55,410 --> 00:22:05,880
We rejected this age. Now this is your current is three and four. OK? You have three and four. The absolute band of three zero absolute band of four is two.

84
00:22:05,940 --> 00:22:21,060
They're different. No different, actually. The parent of four is to the parent of two zero zero zero. So will appear this zero with zero and then we'll update this to zero.

85
00:22:21,450 --> 00:22:32,700
This is called pact compression and it will return this find it will return zero for four. So we see that four, three and four. If we connect, it will form a cycle.

86
00:22:33,390 --> 00:22:47,880
It will form a cycle of him. If you connect three and four, it will form a cycle, so you'll reject this age. Now, let's move forward. Now, let's process this h one and two here, OK?

87
00:22:48,750 --> 00:23:03,990
Absolute Panda one is zero absolute brand up to zero. So ignore this age. Let's move forward. One and four absolute brand of one is zero absolute brand of four zero that the we add one in four will form a cycle.

88
00:23:03,990 --> 00:23:21,660
We clearly see that for this age as well. The ad wants to inform a cycle. So that's what we ignore that age. Do you see how we're using the joint set to detect cycle and to reject the eight that form a cycle?

89
00:23:22,170 --> 00:23:36,040
Hope you're understanding. Now let's process this age four and five absolute point of four zero and absolute band of five is five. So let's connect this to Vertex here.

90
00:23:36,080 --> 00:23:52,980
Let's add this age four and five. Here we have the it is three. Now let's call this union five and zero. Here we see that five and zero absolute point of four zero absolute band of five is five.

91
00:23:53,970 --> 00:24:05,970
So they're different. And here we see higher rank. This is having higher rank. The absolute point of having higher rank. So I break this five with this value.

92
00:24:05,970 --> 00:24:19,050
Zero. So we're done. Now let's move to the next. This is your next age. Three. Five The absolute brand of zero absolute brand of five zero. So they're the same slot will not add that age.

93
00:24:19,650 --> 00:24:33,720
We're done. We have no more ages here, so we have processed all the ages. We find out this is spanning tree. This is a spanning tree. We find it using Chris Kilts algorithm.

94
00:24:33,780 --> 00:24:57,870
This is called Chris Kelts algorithm. Here, we're using the joint data structure to detect a cycle and to reject the is that might form a cycle. Well understood, Chris crucial algorithm and how we are using the joint sit with Chris Kelts algorithm who understood this algorithm early takes because you log VE time complexity.

95
00:24:58,170 --> 00:25:17,970
This log before this the Joint Site, and here we have these for a number of ages V for a number of parties. OK, OK, here it takes we of the space complexity for this subset area and for this result area where we understood how pushcarts algorithm works here.

96
00:25:17,970 --> 00:25:32,250
This sort algorithm only takes e log each time complexity, so we should adhere e log e so this algorithm or takes total e log v plus e look e time complexity and off the complexity who understood Chris guilts algorithm.


