1
00:00:00,005 --> 00:00:10,005
- [Scott] Dữ liệu thúc đẩy thế giới của chúng ta và SQL là ngôn ngữ chúng ta thường sử dụng để làm việc với dữ liệu đó. Truy vấn cơ sở dữ liệu bằng SQL cho chúng ta khả năng khám phá, phân tích và quan trọng nhất là sử dụng tất cả các loại dữ liệu.

2
00:00:10,005 --> 00:00:21,008
Trong khóa học thử thách mã này, bạn có thể kiểm tra kiến ​​thức của mình về các truy vấn cấp độ trung cấp trong SQL để xây dựng sự tự tin khi làm việc với các công cụ báo cáo và phân tích dữ liệu khác nhau mà nhiều hệ thống quản lý cơ sở dữ liệu quan hệ tương thích với SQL cung cấp.

3
00:00:21,008 --> 00:00:31,007
Tôi là Scott Simpson, Giảng viên nhân viên cấp cao tại LinkedIn Learning và tôi đã tổng hợp năm thử thách mã bao gồm nhiều khái niệm SQL cấp độ trung cấp cho phép chúng tôi sử dụng và chuyển đổi dữ liệu.

4
00:00:31,007 --> 00:00:42,006
Xây dựng và thử nghiệm các giải pháp của bạn cho những thách thức này trong môi trường mã hóa tương tác tích hợp sẵn. Không cần phần mềm đặc
biệt. Và khi bạn hoàn thành giải pháp của mình cho từng thử thách, hãy xem video giải pháp của tôi để biết cách tôi giải quyết chúng. 

@@@



5
00:00:00,005 --> 00:00:09,006
- [Tutor] Trong Khóa học Thử thách Mã này, tôi hy vọng bạn đã quen với việc viết truy vấn trong SQL. Chúng ta sẽ dành thời gian để nhóm và lọc dữ liệu, nối các bảng và chuyển đổi giá trị.

6
00:00:09,006 --> 00:00:22,004
Mỗi thử thách này kết hợp một số khái niệm độ khó trung bình, thường được sử dụng trong báo cáo dữ liệu và chuẩn bị dữ liệu. Nếu bạn cần làm mới kiến ​​thức SQL của mình, hãy xem các khóa học này trong Thư viện Học tập LinkedIn.

7
00:00:22,004 --> 00:00:31,001
Trong các thử thách, chúng tôi cung cấp cơ sở dữ liệu mô tả một nhà hàng nhỏ ở khu vực lân cận. Chúng ta sẽ thấy các bảng như nhân viên, đặt chỗ, đặt hàng, món ăn, v.v.

8
00:00:31,001 --> 00:00:39,006
Mỗi thử thách sẽ cung cấp cho bạn một sơ đồ mối quan hệ thực thể để mô tả bảng hoặc các bảng đang được sử dụng. Và vui lòng CHỌN * trên các bảng để xem dữ liệu thực tế.

9
00:00:39,006 --> 00:00:48,005
Nếu bạn làm vậy, giao diện sẽ hiển thị rằng kết quả đầu ra là một câu trả lời sai. Nhưng đừng lo lắng, không có điểm, thời gian hay bất cứ thứ gì tương tự mà bạn sẽ bị mất hoặc có nguy cơ bị lấy đi.

10
00:00:48,005 --> 00:00:55,000
Để giải quyết những thử thách này, bạn không cần cài đặt bất kỳ phần mềm riêng biệt
nào. Môi trường Thử thách viết mã là một phần của Trang KHÓA HỌC LinkedIn. 

@@@



11
00:00:00,005 --> 00:00:12,000
- [Người hướng dẫn] Khóa học này bao gồm các thử thách mã tự động xuất hiện khi bạn nhấp vào liên kết thử thách trong mục lục của khóa học. Mỗi thử thách bao gồm các hướng dẫn và trình chỉnh sửa mã mà bạn có thể sử dụng để tạo và thử nghiệm giải pháp của riêng mình cho thử thách.

12
00:00:12,000 --> 00:00:24,008
Những thử thách này do CoderPad lưu trữ và chúng xuất hiện trong cùng khu vực của trang khóa học nơi bạn xem video của khóa học. Chúng tôi khuyên bạn nên sử dụng trình duyệt trên máy tính để bàn để có trải nghiệm tốt nhất với các thử thách về mã nhưng bạn có thể sử dụng ứng dụng di động LinkedIn Learning nếu muốn.

13
00:00:24,008 --> 00:00:33,005
Thử thách viết mã có ba khu vực, hướng dẫn ở trên cùng bên trái, bảng điều khiển cho đầu ra ở phía dưới bên trái và trình chỉnh sửa mã cho câu trả lời của bạn ở bên phải.

14
00:00:33,005 --> 00:00:43,006
Bạn có thể sử dụng các tay cầm kéo này để phân bổ không gian theo ý muốn. Để có thêm không gian theo chiều ngang cho trình soạn thảo mã, bạn có thể thu gọn mục lục của khóa học ở bên trái.

15
00:00:43,006 --> 00:00:52,000
Mỗi thử thách đều có hướng dẫn bao gồm mô tả về thử thách và kết quả mong muốn của thử thách. Tạo câu trả lời của bạn trong trình soạn thảo mã.

16
00:00:52,000 --> 00:01:08,008
(nhấp bàn phím) Khi nhấp vào Kiểm tra mã của tôi, bạn sẽ thấy thông báo cho biết liệu mã của bạn có trả về kết quả chính xác và phiên bản dựa trên văn bản của dữ liệu được trả về hay không.

17
00:01:08,008 --> 00:01:20,001
Nếu câu trả lời của bạn không tạo ra kết quả chính xác, bạn sẽ thấy thông báo cho biết mã không chính xác và hiển thị dữ liệu
được trả về. Nếu bất kỳ tin nhắn nào quá dài để vừa với bảng điều khiển, bạn có thể cuộn sang một bên để xem tất cả văn bản. 

@@@



18
00:00:00,005 --> 00:00:09,007
- [Người hướng dẫn] Đây là cách tôi giải quyết thử thách này. Tôi bắt đầu trả lại ID khách hàng, họ và tên của họ cũng như tổng số món ăn mà khách hàng đã đặt.

19
00:00:09,007 --> 00:00:19,009
Điều đó có thể thực hiện được bằng cách nối bảng đơn đặt hàng mà tôi gọi là O trong ký hiệu CTE với bảng đơn đặt hàng mà tôi đặt tên là OD. Và tôi đang khớp ID đơn hàng trên mỗi bảng.

20
00:00:19,009 --> 00:00:28,009
Điều này cho phép tôi nhận được từng mục là một phần của mỗi đơn hàng. Bảng order món ăn lưu trữ ID món ăn và để có được giá món ăn, chúng ta cần tham gia bảng món ăn mà tôi gọi là D.

21
00:00:28,009 --> 00:00:40,006
Dựa trên việc khớp ID món ăn trên các món ăn và món ăn trong đơn đặt hàng, điều đó sẽ hoàn thành tập hợp những thứ chúng ta cần để nhận được giá của các món ăn và đơn đặt hàng. Chúng ta cũng cần tham gia bảng của khách hàng vì chúng ta muốn biết tên của khách hàng.

22
00:00:40,006 --> 00:00:52,009
Bảng đơn hàng chứa ID khách hàng và bảng của khách hàng cũng vậy, vì vậy, chúng tôi đối sánh các bảng đó để cấp cho chúng tôi quyền truy cập vào các trường tên của khách hàng. Chúng tôi nhóm các kết quả này theo ID khách hàng vì chúng tôi đang cộng tổng giá các mặt hàng mà mỗi khách hàng đã chi tiêu.

23
00:00:52,009 --> 00:01:02,002
Vì vậy, chúng tôi chỉ cần có một hàng cho mỗi khách hàng. Nếu không có điều kiện, điều này sẽ đại diện cho tất cả khách hàng của chúng tôi, nhưng thử thách chỉ dành cho những khách hàng đã chi hơn 450 USD.

24
00:01:02,002 --> 00:01:14,000
Vì vậy chúng ta cần đánh giá tổng chi tiêu của từng khách hàng. Tổng chi tiêu là giá trị tổng hợp dựa trên nhiều giá trị của một hàng chứ không phải một giá trị của một hàng. Vì vậy chúng ta cần sử dụng HAVING để kiểm tra giá trị của nó thay vì ở đâu.

25
00:01:14,000 --> 00:01:23,001
Chúng tôi vẫn có thể có mệnh đề Where ở đây để kiểm tra một số giá trị hàng riêng lẻ khác, như trạng thái nhà của khách hàng hoặc thứ gì đó tương tự, nhưng chúng tôi không cần vị trí cho giải pháp cụ thể này.

26
00:01:23,001 --> 00:01:36,000
Cuối cùng, tôi sắp xếp bảng theo tổng chi tiêu giảm dần để đưa người chi tiêu nhiều nhất lên đầu danh sách. Tôi sẽ
chạy cái này và xem nó có hoạt động không. Nó có. Đây là danh sách những người chi tiêu nhiều nhất mọi thời đại. 

@@@



27
00:00:00,005 --> 00:00:14,005
- [Người hướng dẫn] Để giải quyết thách thức này, tôi đã sử dụng GROUP_CONCAT, một hàm trong MySQL và các DBMS tương tự để ghép các mục dựa trên việc nhóm của chúng. Microsoft SQL có một chức năng tương tự được gọi là STRING_AGG, viết tắt của chuỗi tổng hợp, hoạt động theo cách tương tự.

28
00:00:14,005 --> 00:00:22,005
Nếu sử dụng điều đó, bạn sẽ cần phải cung cấp dấu phân cách để làm cho kết quả đầu ra khớp với yêu cầu thử thách, phải là dấu phẩy không có khoảng trắng theo sau.

29
00:00:22,005 --> 00:00:33,009
Hàm này hoạt động cùng với một thuật ngữ nhóm, trong trường hợp này là GROUP BY OrderID. Ở đây chúng ta có thể thấy các phiên bản khác nhau của cú pháp MySQL và MS SQL có cùng kết quả mà chúng ta đang tìm kiếm.

30
00:00:33,009 --> 00:00:43,001
Thử thách cũng yêu cầu danh sách các mục được sắp xếp theo thứ tự bảng chữ cái và ở đây với cú pháp MySQL này, tôi đang thực hiện điều đó với ORDER BY D.Name trong hàm GROUP BY.

31
00:00:43,001 --> 00:00:55,001
Tăng dần là thứ tự mặc định ở đây nên tôi có thể bỏ nó đi. Nhưng nếu tôi muốn rõ ràng hơn, tôi cũng có thể thêm ASC. Với MS SQL, điều đó sẽ khác một chút, bao gồm cả mệnh đề A trong GROUP trong đó thứ tự của D.Name sẽ là.

32
00:00:55,001 --> 00:01:05,002
Quay lại giải pháp của mình ở đây, chúng ta có thể thấy rằng tôi đã kết hợp ba bảng được cung cấp là Món ăn, Món ăn và Đơn hàng để tôi có thể phân giải ID đơn hàng thành tên của các món ăn có trong đó.

33
00:01:05,002 --> 00:01:22,001
Và theo yêu cầu của thử thách, tôi chỉ quan tâm đến các đơn hàng từ ngày 1 tháng 5 năm 2022 hoặc 2022-05-01 trở đi. Sau đó, khi
trả về những tên này, chúng sẽ được liệt kê hoàn toàn theo thứ tự bảng chữ cái, phân tách bằng dấu phẩy, theo từng ID đơn hàng. 

@@@



34
00:00:00,005 --> 00:00:13,000
- [Người hướng dẫn] Để giải thử thách này, tôi đang sử dụng các bảng Đơn hàng, Đơn hàng Món ăn và Món ăn để tìm tất cả các đơn hàng có chứa món ăn có tên "Pizza thủ công". Thử thách yêu cầu số lượng pizza bán được và ngày tháng, hãy bắt đầu với ngày tháng.

35
00:00:13,000 --> 00:00:27,000
Mỗi đơn hàng trong cơ sở dữ liệu của chúng tôi có một giá trị Ngày giờ được liên kết với nó, nhưng chúng tôi chỉ muốn phần ngày, năm, tháng và ngày của giá trị đó. Việc có giá trị ngày này sẽ cho phép chúng tôi nhóm số lượng đơn đặt hàng pizza theo ngày, nhưng hiện tại những giá trị đó vẫn có giá trị thời gian được đính kèm.

36
00:00:27,000 --> 00:00:45,006
Vì vậy, nếu chúng ta cố gắng nhóm theo giá trị hiện tại, chúng ta thực sự sẽ chỉ có một chiếc bánh pizza được đặt hàng vào một thời điểm cụ thể vào một ngày cụ thể. Vì vậy, chúng tôi sẽ sử dụng từ khóa CAST và yêu cầu cơ sở dữ liệu diễn giải lại giá trị OrderDate dưới dạng loại ngày mà chúng tôi chỉ nhận được phần ngày mà không có phần thời gian và chúng tôi sẽ gọi Ngày đó.

37
00:00:45,006 --> 00:00:56,004
Chúng tôi sẽ nhóm các kết quả của mình theo Ngày và sắp xếp chúng theo Ngày. Và chúng ta sẽ sử dụng hàm tổng hợp COUNT để cho biết số lượng pizza đã được bán trong ngày và chúng ta sẽ gọi đó là NumSold.

38
00:00:56,004 --> 00:01:06,000
Tôi sẽ chạy cái này để xem nó có hoạt động không. Và chúng ta bắt đầu, cứ mỗi ngày có một hoặc nhiều chiếc
bánh pizza được đặt hàng, chúng tôi có ngày đó và số lượng bánh pizza giống như thử thách được yêu cầu. 

@@@



39
00:00:00,005 --> 00:00:12,001
- Để giải quyết thách thức này, chúng ta cần sử dụng một số logic để xử lý các tình huống hoặc trường hợp khác nhau. Chúng ta sẽ bắt đầu với một số điều khá đơn giản, như tên món ăn là tên món ăn và giá là giá gốc.

40
00:00:12,001 --> 00:00:22,005
Các trường này đến từ các món ăn và chúng tôi sẽ sắp xếp kết quả theo tên món ăn. Tuy nhiên, thách thức yêu cầu hai cột nữa; phần trăm chiết khấu và giá chiết khấu.

41
00:00:22,005 --> 00:00:34,004
Để nhận được phần trăm chiết khấu, có ba điều kiện phù hợp, tôi sử dụng một câu lệnh tình huống và cung cấp ba điều kiện đó. Khi giá của một món ăn nhỏ hơn bảy, câu lệnh trả về chuỗi văn bản 5%.

42
00:00:34,004 --> 00:00:46,002
Khi giá nằm trong khoảng từ 7 đến 10, câu lệnh trả về chuỗi 10%. Và trong bất kỳ trường hợp nào khác, đối với chúng tôi ở đây có nghĩa là bất kỳ giá nào lớn hơn chính xác 10, câu lệnh sẽ trả về chuỗi 15%.

43
00:00:46,002 --> 00:01:00,007
Điều đó mang lại cho chúng tôi giá trị phần trăm chiết khấu. Vì vậy, tiếp theo, chúng ta cần tính toán giá cho các mặt hàng của mình với số tiền chiết khấu được áp dụng. Ở đây tôi sẽ sử dụng một câu lệnh tình huống khác có cùng điều kiện, nhưng lần này tôi sẽ trả về số thay vì chuỗi.

44
00:01:00,007 --> 00:01:21,003
0,05, 0,1 và 0,15, đại diện cho 5%, 10% và 15%. Con số đó sẽ được trừ đi một, cho chúng tôi phần giá còn lại sẽ tính. Vì vậy, đó sẽ là 0,95% hoặc 95%, 0,9 hoặc 90% và 0,85 hoặc 85%.

45
00:01:21,003 --> 00:01:35,001
Sau đó, chúng tôi nhân giá trị đó với giá của một mặt hàng và làm tròn nó để không nhận được các giá trị thập phân dài mà chúng tôi không thể thực hiện
thay đổi. Chúng tôi đang làm tròn giá trị này đến hai chữ số thập phân theo yêu cầu của thử thách và chúng tôi sẽ gọi giá trị này là giá chiết khấu. 

@@@



46
00:00:00,005 --> 00:00:07,006
- [Người hướng dẫn] Để giải quyết thử thách này, chúng ta sẽ tập trung vào thao tác với chuỗi. Giải pháp của tôi trả về một số giá trị từ bảng của nhân viên, được sắp xếp theo tên.

47
00:00:07,006 --> 00:00:19,001
Nếu không có điều kiện ở đâu, chúng tôi sẽ nhận được tất cả các bản ghi và đó là điều chúng tôi muốn. Mục đầu tiên trong thử thách yêu cầu ID nhân viên có đúng năm chữ số, với các số 0 đứng đầu để lấp đầy khoảng trống ở đầu chuỗi.

48
00:00:19,001 --> 00:00:30,008
Để tạo điều này, tôi đã sử dụng hàm LPAD hoặc hàm đệm trái, hàm này nhận ba đối số, trường cần bao gồm, số chữ số cần đệm và chữ số hoặc ký tự sẽ sử dụng cho phần đệm đó.

49
00:00:30,008 --> 00:00:49,006
Tôi sẽ gọi ID này. Mục tiếp theo trong thử thách là cung cấp tên nhân viên ở định dạng dấu phẩy cuối cùng trước tiên với khoảng trắng ở giữa. Vì vậy, tôi sử dụng hàm concat hoặc hàm nối để trả về một chuỗi được tạo từ giá trị họ, khoảng trắng dấu phẩy của giá trị chuỗi và giá trị tên đầu tiên và tôi sẽ gọi tên này.

50
00:00:49,006 --> 00:00:59,005
Thứ ba, tôi cần tạo tên người dùng không dài hơn tám ký tự và bao gồm tên viết tắt đầu tiên của nhân viên và bất kỳ phần nào trong họ của họ phù hợp với bảy ký tự còn lại.

51
00:00:59,005 --> 00:01:10,000
Tất cả đều cần phải viết thường. Vì vậy, tôi bắt đầu sử dụng chuỗi con để cắt một phần cụ thể của họ và tên của chuỗi. Đối với tên, tôi bắt đầu từ ký tự một và trả về một ký tự.

52
00:01:10,000 --> 00:01:19,008
Đó là ký tự đầu tiên trong chuỗi. Đối với họ, tôi bắt đầu lại từ ký tự một và tôi trả lại bảy ký tự từ thời điểm đó. Nếu một chuỗi dài hơn bảy ký tự, tôi chỉ lấy bảy ký tự đầu tiên.

53
00:01:19,008 --> 00:01:28,002
Và nếu nó ngắn hơn bảy ký tự, tôi sẽ nhận được chuỗi đầy đủ. Sau đó tôi sử dụng hàm concat để nối hai chuỗi này lại với nhau bằng chữ cái đầu tiên đầu tiên.

54
00:01:28,002 --> 00:01:38,004
Và sau đó tôi sử dụng hàm dưới để chuyển đổi tất cả thành chữ thường và chúng tôi sẽ gọi giá trị đó là đăng nhập. Và cuối cùng, chúng tôi sẽ tạo địa chỉ email để nhân viên của chúng tôi có thể liên hệ.

55
00:01:38,004 --> 00:01:45,003
Nhân viên của chúng tôi có tên người dùng trong hệ thống của chúng tôi, nhưng thật không may, tên người dùng đó khác với thông tin đăng nhập mà chúng tôi cần tạo cho họ trên hệ thống khác này.

56
00:01:45,003 --> 00:02:00,009
Ví dụ: người sáng lập và bếp trưởng của chúng tôi lấy tên của họ làm tên người dùng trong hệ thống của chúng tôi, thay vì tên người dùng thông thường như các nhân viên khác. Vì vậy, chúng ta sẽ sử dụng concat lần nữa để gắn tên người dùng thực của mỗi người dùng vào chuỗi đại diện cho miền email của chúng ta ở đây và chúng ta sẽ gọi email giá trị đó.

57
00:02:00,009 --> 00:02:11,000
Tôi sẽ chạy cái này và hãy xem những gì chúng ta nhận được. Tuyệt vời, điều này đã vượt qua thử thách. Chúng ta
thường cần chuyển đổi dữ liệu từ cơ sở dữ liệu của mình theo một cách nào đó thay vì chỉ trả lại nguyên văn. 

@@@



58
00:00:00,005 --> 00:00:09,004
- [Scott] Nếu bạn có thể giải quyết được những thách thức này, xin chúc mừng, còn nếu không, hãy dành chút thời gian để làm mới kiến ​​thức của bạn về các truy vấn SQL trình độ trung cấp và quay lại và thử lại.

59
00:00:09,004 --> 00:00:18,000
Nếu bạn đã sẵn sàng tiếp tục và giải quyết nhiều thử thách hơn, hãy xem các khóa học thử thách mã SQL tương tác khác của chúng tôi tại đây trên LinkedIn Learning. Hẹn gặp lại lần sau.

