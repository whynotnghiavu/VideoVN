1
00:00:00,780 --> 00:00:16,300
Chào mừng bạn đến với cấu trúc dữ liệu và thuật toán cho khóa học phỏng vấn viết mã, tôi đã thiết kế khóa học này với rất nhiều nội dung, nếu bạn muốn xây dựng hiểu biết vững chắc của mình về cấu trúc dữ liệu và thuật toán.

2
00:00:16,920 --> 00:00:33,560
Đây là khóa học hoàn hảo dành cho bạn. Bây giờ, hãy xem chúng ta sẽ học những gì trong suốt khóa học này. Chúng ta sẽ bắt đầu với việc phân tích thời gian chạy. Đầu tiên, chúng ta sẽ xem cách tìm ra độ phức tạp của thuật toán của bạn.

3
00:00:34,510 --> 00:00:51,490
Chúng ta sẽ nói về ký hiệu omega, ký hiệu O lớn và ký hiệu theta. Trong phần còn lại của khóa học, chúng ta sẽ nói về ký hiệu O lớn chỉ dành cho mục đích học tập, chúng ta sẽ nói về ký hiệu omega và phép quay theta.

4
00:00:51,970 --> 00:01:14,160
Trong phần này, bạn sẽ học cách tìm thấy nó. Thời gian, độ phức tạp của một thuật toán qua một số ví dụ sau đó chúng ta sẽ bắt đầu học cấu trúc dữ liệu mảng trong phần cấu trúc dữ liệu mảng, chúng ta sẽ nói về mảng 1D & mảng 2D. Cách tạo mảng, cách sử dụng array.

5
00:01:14,740 --> 00:01:49,020
Và chúng ta sẽ nói về cách thể hiện mảng 1D và 2D trong bộ nhớ máy tính. Sau đó chúng ta sẽ nói về cấu trúc dữ liệu danh sách liên kết. Trong phần này của khóa học này, chúng ta sẽ nói về bốn loại danh sách liên kết, danh sách liên kết đơn, danh sách liên kết đơn vòng, danh sách liên kết đôi và danh sách liên kết đôi vòng. Chúng tôi sẽ triển khai bốn loại danh sách liên kết và chúng tôi sẽ triển khai tất cả chức năng của danh sách liên kết cho bốn loại danh sách liên kết từ đầu.

6
00:01:49,780 --> 00:02:15,850
Sau đó chúng ta sẽ nói về ngăn xếp, chúng ta sẽ triển khai ngăn xếp từ đầu và chúng ta sẽ xem nguyên tắc LIFO hoạt động như thế nào đối với ngăn xếp. Sau đó, chúng ta sẽ nói về cấu trúc dữ liệu Hàng đợi, chúng ta sẽ triển khai Hàng đợi bằng cách sử dụng danh sách và mảng được liên kết và chúng ta sẽ triển khai Hàng đợi từ đầu và bạn sẽ thấy nguyên tắc FIFO hoạt động như thế nào đối với Hàng đợi.

7
00:02:16,060 --> 00:02:32,630
Sau đó, chúng ta sẽ bắt đầu cấu trúc dữ liệu mới của mình. Cây. Đối với cấu trúc dữ liệu cây, chúng ta có nhiều loại cây, nhưng trong khóa học này sẽ nói về cấu trúc dữ liệu cây được sử dụng phổ biến nhất.

8
00:02:33,570 --> 00:02:49,620
Đầu tiên chúng ta sẽ xem cây nhị phân. Chúng ta sẽ xem cách triển khai cây nhị phân, cách duyệt cây nhị phân, chúng ta sẽ duyệt cây nhị phân bằng cách sử dụng phương pháp truyền tải theo chiều rộng đầu tiên (BFS) và sử dụng phương pháp truyền tải theo chiều sâu đầu tiên (DFS).

9
00:02:49,830 --> 00:03:09,890
Điều đó có nghĩa là BFS hoặc DFS Sau đó, chúng ta sẽ nói về tìm kiếm nhị phân và chúng ta sẽ nói về cây AVL, chúng ta sẽ triển khai cây tìm kiếm nhị phân từ đầu và chúng ta sẽ triển khai tất cả các phương pháp của lịch sử nhân loại và cũng sẽ triển khai cây avl từ đầu.

10
00:03:09,900 --> 00:03:25,980
Và chúng tôi sẽ triển khai tất cả chức năng cho cấu trúc dữ liệu Cây AVL từ đầu. Sau đó, chúng ta sẽ nói về cấu trúc dữ liệu trie cho các đề xuất tìm kiếm tự động hoặc để sửa từ mà chúng ta sử dụng cấu trúc dữ liệu đã thử.

11
00:03:26,370 --> 00:03:37,260
Khi bạn gõ nội dung nào đó trên Google, Google sẽ đưa ra cho bạn một số gợi ý và những gợi ý đó xuất phát từ cấu trúc dữ liệu Trie. Sau đó chúng ta sẽ nói về đống nhị phân.

12
00:03:37,380 --> 00:03:49,940
Chúng tôi có hai loại heap nhị phân, heap tối thiểu và heap tối đa, chúng tôi sẽ triển khai heap nhị phân từ đầu hoàn chỉnh. Có một thuật toán nổi tiếng được gọi là thuật toán sắp xếp.

13
00:03:49,950 --> 00:04:03,660
"Sắp xếp đống". Sắp xếp vùng heap sử dụng cấu trúc dữ liệu vùng heap nhị phân và chúng ta cũng sẽ thấy điều đó trong phần thuật toán sắp xếp. Sau đó chúng ta sẽ học các thuật toán sắp xếp. Bạn được cung cấp một mảng chưa được sắp xếp.

14
00:04:03,660 --> 00:04:19,080
Bạn đã sắp xếp mảng theo thứ tự tăng dần. Trong khóa học này, chúng ta sẽ tìm hiểu bảy thuật toán sắp xếp, sau đó là các thuật toán Sắp xếp theo kiểu bong bóng, Sắp xếp chèn, Sắp xếp nhanh, Sắp xếp hợp nhất, Sắp xếp nhóm & Sắp xếp đống.

15
00:04:19,080 --> 00:04:30,330
Chúng ta sẽ thấy đệ quy Đối với bài toán về cây, đệ quy gần như là bắt buộc. Có rất nhiều ứng dụng đệ quy và bạn sẽ thấy trong suốt khóa học này.

16
00:04:30,570 --> 00:04:42,900
Lập trình động sử dụng đệ quy, Đối với các bài toán về cây Hầu hết chúng ta sử dụng đệ quy, Đối với các bài toán đồ thị, Chúng ta sử dụng đệ quy và có rất nhiều bài toán khi chúng ta sử dụng đệ quy.

17
00:04:43,200 --> 00:05:08,430
Sau đó chúng ta sẽ nói về lập trình động. Bằng cách sử dụng quy hoạch động, chúng ta có thể chuyển đổi độ phức tạp theo thời gian theo cấp số nhân thành độ phức tạp theo thời gian tuyến tính mà chúng ta sẽ thấy trong khóa học này, chúng ta sẽ thấy các thuộc tính của quy hoạch động, các bài toán con chồng chéo và cấu trúc con tối ưu. Ngoài ra, chúng ta sẽ thấy đâu là phần dưới cùng cách tiếp cận, cách tiếp cận từ trên xuống của lập trình động là gì.

18
00:05:08,610 --> 00:05:27,420
Sau đó chúng ta sẽ nói về bảng băm (Cấu trúc dữ liệu băm) Cuối cùng, chúng ta sẽ nói về cấu trúc dữ liệu biểu đồ. Trong phần này của khóa học này, chúng ta sẽ có rất nhiều nội dung, nhiều thuật toán và chúng ta sẽ triển khai cấu trúc dữ liệu Biểu đồ từ đầu, chúng ta sẽ có một phần hoàn chỉnh về biểu đồ.

19
00:05:27,570 --> 00:05:41,400
Trong phần này của khóa học này, chúng ta sẽ nói về một số thuật toán phổ biến, thuật toán dijkstra, thuật toán bellman-ford. Thuật toán Floyd-warshall, thuật toán số nguyên tố, thuật toán kruskals.

20
00:05:41,610 --> 00:05:59,910
Và có rất nhiều nội dung sẽ có trong phần này. Chúng ta sẽ có một phần hoàn chỉnh về cấu trúc dữ liệu đồ thị. Nếu bạn muốn làm việc tại một ngành công nghệ lớn như Google, Microsoft, Amazon, Netflix, Uber, v.v., thì bạn phải hiểu cấu trúc dữ liệu và thuật toán.

21
00:06:00,100 --> 00:06:11,100
Sâu sắc cho bạn cuộc phỏng vấn mã hóa. Sau khi kết thúc khóa học này, bạn sẽ hiểu rõ về khái niệm cấu trúc dữ liệu và thuật toán này. Bạn sẽ cảm thấy tự tin.

22
00:06:11,730 --> 00:06:29,010
Sau khi kết thúc khóa học này. Tôi sử dụng các ví dụ video minh họa và chúng tôi sẽ đi qua từng dòng mã và chúng tôi sẽ giải thích từng chi tiết cũng như cách thức hoạt động của thuật toán cũng như cách cấu trúc dữ liệu liên quan đến thuật toán đó.

23
00:06:29,220 --> 00:06:38,910
Nếu bạn muốn đạt thành tích cao trong cuộc phỏng vấn viết mã tiếp theo, khóa học này sẽ giúp bạn rất nhiều. Nếu bạn là một lập trình viên tự học, nếu bạn không có bằng đại học thì cũng đừng lo lắng.

24
00:06:39,060 --> 00:06:50,750
Hãy đăng ký khóa học này và bắt đầu học các cấu trúc dữ liệu và thuật toán từ đầu. Khóa
học này đi kèm với đảm bảo hoàn lại tiền trong 30 ngày. Vậy bạn còn chờ gì nữa? 

@@@



25
00:00:00,570 --> 00:00:15,360
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về một phân tích ngẫu nhiên. Để trở thành một lập trình viên giỏi, bạn phải hiểu cách phân tích ngẫu nhiên của một thuật toán trong video này.

26
00:00:15,390 --> 00:00:30,240
Chúng ta sẽ nói về việc phân tích ngẫu nhiên nó là gì. Bây giờ hãy nói về thuật toán phân tích ngẫu nhiên của nó, phân tích ngẫu nhiên. Đó là ước tính về việc tăng thời gian chạy của thuật toán khi đầu vào của nó tăng lên.

27
00:00:31,080 --> 00:00:42,810
Đây là định nghĩa chính thức của thuật toán, phân tích ngẫu nhiên nên xây dựng thuật toán nào. Chúng ta nên tìm hiểu các phân tích ngẫu nhiên để đo lường hiệu quả của thuật toán.

28
00:00:43,800 --> 00:00:55,950
Để đo lường hiệu quả của thuật toán, bạn nên học phân tích ngẫu nhiên để phân tích ngẫu nhiên. Bạn phải tính hệ số, thời gian, hệ số và hệ số Espace.

29
00:00:56,310 --> 00:01:07,110
Số lượng thao tác cần thiết cho một thuật toán cụ thể được gọi là hệ số thời gian và lượng bộ nhớ được sử dụng bởi thuật toán được gọi là Hệ số Espace.

30
00:01:07,350 --> 00:01:26,040
Hệ số thời gian được gọi là độ phức tạp thời gian và hệ số không gian được gọi là Espace. Sự phức tạp, thời gian. Độ phức tạp đo lường số lượng bản ghi hoạt động cho thuật toán cụ thể và độ phức tạp về không gian đo lượng bộ nhớ được sử dụng bởi một thuật toán cụ thể.

31
00:01:26,610 --> 00:01:38,300
Bây giờ hãy nói về các ký hiệu để phân tích thời gian chạy. Chúng tôi có ba ký hiệu cho thời gian chạy được phân tích sẽ tạo ra ký hiệu ký hiệu begal.

32
00:01:38,820 --> 00:01:58,590
Chúng ta sẽ tạo một ký hiệu chính là trường hợp tốt nhất của thuật toán lớn hoặc chú thích chính, trường hợp xấu nhất của thuật toán. Chú thích, thước đo, trường hợp trung bình của thuật toán cho mục đích phỏng vấn hầu hết sẽ sử dụng các chú thích lớn.

33
00:01:59,010 --> 00:02:12,210
Trong phần còn lại của khóa học này, chúng ta sẽ nói về các ký hiệu Bigo, không phải các chú thích hoặc chú thích OMCG hoặc làm cho các chú thích và chú thích chủ yếu được sử dụng cho mục đích học thuật.

34
00:02:12,540 --> 00:02:35,680
Bây giờ hãy nói về chú thích Omega, chú thích lớn và chú thích. Bây giờ hãy nói về ký hiệu Omega. Ký hiệu này đưa ra giới hạn dưới cho một thuật toán, có nghĩa là cơ sở để có được ký hiệu này được sử dụng để đo lường mức tốt nhất của thuật toán khi chúng ta cần thước đo tốt nhất của thuật toán.

35
00:02:35,710 --> 00:02:46,180
Sau đó chúng ta phải xem xét ký hiệu omega. Bây giờ, hãy nói về một ký hiệu. Ký hiệu này đưa ra giới hạn trên trong các thuật toán có nghĩa là điều tồi tệ nhất được giữ lại.

36
00:02:46,840 --> 00:03:03,640
Ký hiệu này được sử dụng để đo lường việc thiết lập một thuật toán. Bây giờ hãy nói về ký hiệu. Ký hiệu này đưa ra mức trung bình của giới hạn dưới và giới hạn trên của một thuật toán và ký hiệu này được sử dụng để đo lường kịch bản trường hợp trung bình của thuật toán.

37
00:03:04,210 --> 00:03:18,000
Vì vậy chúng ta có thể nói ký hiệu là trung bình cộng của phép cộng chung và ký hiệu be. Bây giờ hãy lấy một ví dụ để hiểu ký hiệu và ký hiệu Omega. Giả sử chúng ta gặp lỗi.

38
00:03:18,070 --> 00:03:33,420
Đây là một mảng các số nguyên. Chúng tôi có số nguyên từ 1 đến 8 để nhập cư để tìm ra một phần tử trong khu vực này. Con mèo tốt nhất là omega của một. Ví dụ: nếu bạn muốn tìm ra nguyên tố một trong lĩnh vực này.

39
00:03:34,060 --> 00:03:47,970
Và chúng ta phải thực hiện ở đây chỉ một thao tác là chúng ta sẽ tìm ra phần tử mong muốn trong một đơn vị thời gian. Và đây là thước đo tốt nhất cho chú thích lớn hơn.

40
00:03:48,280 --> 00:03:59,110
Nó sẽ phát triển theo độ phức tạp về thời gian vì đây là trường hợp xấu nhất. Chúng ta tiến hành tìm hiểu Nguyên tố thứ tám trong lĩnh vực này. Sau đó, bạn phải quét cái này từ trái sang phải.

41
00:03:59,620 --> 00:04:09,790
Và ở đây chúng ta có Nguyên tố thứ tám. Nếu lỗi này kéo dài thì Spiga sẽ gặp phải độ phức tạp về mặt thời gian. Vì vậy, nó sẽ mất trong đơn vị thời gian.

42
00:04:09,820 --> 00:04:29,410
Đây là đứa trẻ lớn nhất và đây là món quà tuyệt vời nhất. Được rồi, trường hợp xấu nhất là chúng ta đi vào và trường hợp tốt nhất là vì có một cái để xoay. Về cơ bản, vòng quay là mức trung bình của Omega và bắt đầu quay và được chia thành mức trung bình được chia hai.

43
00:04:29,560 --> 00:04:37,390
Vì vậy, bạn có thể nói rằng sự bổ sung đó là truyền thống trung bình của người Mỹ và sự bổ sung điển hình của việc hiểu truyền thống, truyền thống và truyền thống của Omega là gì.

44
00:04:37,540 --> 00:04:48,520
Trong phần còn lại của khóa học này, chúng ta sẽ nói về truyền thống và điều này được sử dụng để cài đặt quãng và hầu như ở mọi nơi. Vì vậy, chúng ta sẽ nói về việc trở thành người bổ sung cho phần còn lại của khóa học này.

45
00:04:48,910 --> 00:04:59,710
Bây giờ hãy xem ví dụ về phân tích ngẫu nhiên độ phức tạp của nó. Chúng tôi có cái mới và ở đây chúng tôi có ví dụ lớn hơn về cái này. Điều này được gọi là độ phức tạp về thời gian ràng buộc.

46
00:04:59,830 --> 00:05:16,690
Việc thêm một phần tử vào trước một nhà ngôn ngữ học mất rất nhiều thời gian. Độ phức tạp, đăng nhập lớn hơn. Nó được gọi là độ phức tạp thời gian logarit. Việc sắp xếp một phần tử trong một mảng rắn có độ phức tạp theo logarit.

47
00:05:17,020 --> 00:05:30,520
Bygrave Và đây được gọi là độ phức tạp thời gian tuyến tính. Chắc chắn một phần tử trong một mảng chưa được sắp xếp có độ phức tạp thời gian tuyến tính lớn hơn khi đăng nhập. Điều này được gọi là độ phức tạp thời gian logarit tuyến tính logarit tuyến tính.

48
00:05:30,640 --> 00:05:44,620
Thuật toán sắp xếp Meurs có phạm vi lớn hơn về độ phức tạp thời gian logarit tuyến tính. Điều này được gọi là độ phức tạp thời gian bậc hai. Phần bắn súng giữa hai thành phố trong biểu đồ có độ phức tạp theo thời gian bậc hai.

49
00:05:44,950 --> 00:05:56,290
Điều này được gọi là độ phức tạp của Thời gian Kubic. Phép nhân ma trận cần độ phức tạp về thời gian Kubic. Đây được gọi là đây là Bego up to bar in. Đây được gọi là độ phức tạp theo thời gian theo cấp số nhân.

50
00:05:56,950 --> 00:06:11,770
Giải pháp Knabe của vấn đề thân mật có độ phức tạp theo thời gian theo cấp số nhân bởi vì trên thực tế, Terryl, đây được gọi là độ phức tạp thời gian giai thừa, giải pháp nive của vấn đề nhân viên bán hàng đi du lịch có độ phức tạp theo thời gian giai thừa.

51
00:06:11,890 --> 00:06:26,500
Đây là những ví dụ về ngẫu nhiên. Hãy phân tích nó ngay bây giờ, hãy xem biểu đồ để phân tích ngẫu nhiên biểu đồ độ phức tạp lớn này. Hãy nhanh chóng biểu diễn đồ thị cho độ phức tạp của chúng ta.

52
00:06:26,500 --> 00:06:41,620
Phân tích nó ở đây. Chúng tôi có một số hoạt động và ở đây chúng tôi có trang web của các phần tử ở đây. Đường màu đen này được gọi là Độ phức tạp thời gian không đổi vì nó siêu nhanh.

53
00:06:41,800 --> 00:06:55,390
Sau đó, chúng tôi có thông tin đăng nhập lớn. Đây cũng là lần đầu tiên độ phức tạp cao hơn độ phức tạp thời gian tuyến tính. Đây là khu vực dành cho độ phức tạp thời gian logarit. Sau đó chúng ta có thời gian tuyến tính, độ phức tạp, thời gian tuyến tính của bạn.

54
00:06:55,390 --> 00:07:07,750
Sự phức tạp tốt hơn lớn khi đăng nhập. Điều này được gọi vì khu vực đăng nhập. Được rồi, chúng ta vào bảng để có số mũ của bạn, sau đó chúng ta có giai thừa của bạn.

55
00:07:08,020 --> 00:07:21,930
Giai thừa là tồi tệ nhất bao giờ hết. Điều này được coi là xấu. Đây được coi là nỗi sợ hãi. Điều này là tốt và điều này là tuyệt vời. Vì vậy, hằng số của chúng tôi. Thời gian logarit tuyệt vời.

56
00:07:21,950 --> 00:07:38,450
Công khai thì tốt, linnear thì sợ hơn là đăng nhập thì xấu. Sau đó, chúng tôi gặp vấn đề khủng khiếp đối với giai thừa mũ hoặc
chúng tôi có thể nói đối với Kedrick, cái này lớn hơn hoặc phức tạp hơn, biểu đồ và đây là những điều cơ bản về ngẫu nhiên. 

@@@



57
00:00:00,510 --> 00:00:09,990
Rất nhiều chàng trai sẽ quay lại video này trong video này chúng ta sẽ nói về xung quanh họ, phân tích nó cho họ, phân tích nó. Chúng ta có thời gian, sự phức tạp và phức tạp.

58
00:00:10,200 --> 00:00:20,520
Số lượng bản ghi hoạt động cho một thuật toán cụ thể được gọi là độ phức tạp về thời gian. Lượng bộ nhớ được sử dụng bởi một thuật toán được gọi là độ phức tạp của không gian.

59
00:00:21,610 --> 00:00:46,180
Độ phức tạp về thời gian không nằm ở việc tính giờ với đồng hồ, thuật toán thực hiện trong bao lâu, thay vào đó, có bao nhiêu thao tác được thực hiện, số lượng lệnh được thực thi bởi một chương trình bị ảnh hưởng bởi kích thước đầu vào đối với một chương trình máy tính Apple cấu hình cao sẽ hoạt động. nhanh hơn so với máy tính Apple có cấu hình thấp.

60
00:00:46,480 --> 00:01:01,240
Nhưng với độ phức tạp về thời gian và không gian, việc phân tích sẽ không xét đến sức mạnh của CPU mà chỉ xét đến số lượng thao tác hoặc đơn vị bộ nhớ được lấy bởi một thuật toán.

61
00:01:01,780 --> 00:01:13,000
Phép toán lớn được sử dụng để phân loại thuật toán theo trường hợp xấu nhất. Đó là những gì chúng ta đã nói đến trong video trước. Bây giờ hãy nói về thời gian chạy phổ biến.

62
00:01:14,020 --> 00:01:30,320
Đôi khi tất cả những gì bạn cần là bản ghi các phép tính số học và logic. Cần một đơn vị thời gian để gán và giá trị vùng, và một đơn vị thời gian để đọc và thực hiện đúng thao tác.

63
00:01:30,670 --> 00:01:43,180
Đây là những thời gian chạy phổ biến. Bây giờ hãy nói về thời gian không đổi. Thời gian không đổi là gì? Thời gian không đổi có nghĩa là thời gian chạy không đổi. Nó không bị ảnh hưởng bởi tầm nhìn của đầu vào.

64
00:01:43,180 --> 00:02:04,270
Độ phức tạp theo thời gian không đổi không phụ thuộc vào phía của chức năng nghe được đầu vào. Nếu trong hàm này lấy đầu vào vào bên trong, thì ở đây chúng ta có nó bằng với thời gian ở đây chúng ta khai báo một biến mà ở đây chúng ta đang in một giá trị và ở đây chúng ta trả về một giá trị.

65
00:02:04,390 --> 00:02:18,520
Đây là tất cả các hoạt động thời gian không đổi của chúng tôi, tất cả đều mất một đơn vị thời gian để thực hiện câu lệnh đó. Vì vậy, chương trình này hoạt động với độ phức tạp về thời gian không đổi.

66
00:02:18,820 --> 00:02:28,510
Sự suy thoái biến đổi này mất thời gian không đổi. Việc in lấy thời gian không đổi và trả về một giá trị này mất thời gian không đổi. Thời gian tuyến tính là gì?

67
00:02:28,510 --> 00:02:40,180
Độ phức tạp trong một thuật toán ngoại trừ ở phía đầu vào, nó cũng sẽ hoạt động trong các hoạt động. Ví dụ, ở đây chúng ta có một mảng và ở đây chúng ta có LOOF.

68
00:02:40,420 --> 00:03:08,720
Chúng ta đang lặp lại mảng này từ chỉ mục đầu tiên đến chỉ mục cuối cùng ở phía bên trong của mảng này. Khi đó loof này sẽ chạy 14 lần. Việc khai báo lỗi sẽ lập chỉ mục vì độ phức tạp một lần, nhưng vì độ phức tạp về không gian, bởi vì ở đây chúng ta có một số phần tử và sự sụp đổ của tất cả các lần lặp từ 0 đến thực sự lặp từ 0 đến và trừ một.

69
00:03:08,860 --> 00:03:24,010
Vì thế có thể nói nó bắt đầu từng bước thực hiện tình yêu này. Và bên trong đây chúng ta đang in một giá trị và tất cả điều này mất thời gian và độ phức tạp không đổi. Vì vậy, chúng ta có thể nói rằng điều này đang diễn ra theo độ phức tạp về thời gian.

70
00:03:24,280 --> 00:03:40,720
Vì vậy, bạn có thể nói vấn đề này đang trở nên phức tạp hơn về mặt thời gian. Bây giờ chúng ta hãy nói về thuật toán độ phức tạp thời gian logarit có thời gian chạy hoặc đăng nhập nhanh hơn một chút so với, chẳng hạn như quyết định thuật toán tìm kiếm nhị phân của các nhà cung cấp năng lượng.

71
00:03:40,750 --> 00:03:52,890
Thuật toán cho một thời điểm nằm trong bốn phía của mảng đã cho cho thuật toán nguồn nhị phân này tại đây. Hoạt động này lấy hằng số hoạt động này lấy lý thuyết không đổi thành các biến.

72
00:03:53,110 --> 00:04:03,910
Ở đây chúng ta có loof bằng cách sử dụng vòng lặp này. Chúng tôi đang chia mảng thành hai nửa. Đã đến lúc mọi người phải tỉnh táo và tất cả những điều này đều diễn ra liên tục.

73
00:04:04,210 --> 00:04:18,610
Nếu chúng ta muốn tìm ra độ phức tạp về thời gian cho lần lặp đầu tiên, độ dài của các khu vực được chia cho điểm khởi hành, điều đó có nghĩa là trong lần lặp thứ 4, Leontes sẽ triển khai một và chúng ta chia phần đó thành hai nửa.

74
00:04:18,610 --> 00:04:31,440
Bốn là thời gian cho bước. Nó đưa bất cứ ai đến công viên để phân chia. Độ dài của mảng sẽ là một theo thứ tự bằng một. Và ở đây chúng ta đã giải quyết được vấn đề này và chúng ta đã hoàn tất quá trình đăng nhập.

75
00:04:31,450 --> 00:04:49,150
Và đây là độ phức tạp về thời gian của thuật toán tìm kiếm nhị phân này. Chúng tôi đã hiểu cách tìm độ phức tạp về thời gian của thuật toán nguồn nhị phân. Sự phức tạp về thời gian là do may mắn kết thúc và sự phức tạp về không gian là do một bởi vì chúng ta đang sử dụng một số biến ở đây, trái, phải và gặp nhau.

76
00:04:49,570 --> 00:05:01,180
Bây giờ, hãy nói về độ phức tạp thời gian logarit tuyến tính. Thuật toán này chia vấn đề thành một số vấn đề và sau đó hợp nhất chúng kịp thời. Ví dụ thuật toán Mursau.

77
00:05:01,570 --> 00:05:10,960
Đây là thuật toán của tôi. Đây là một chút quan trọng để hiểu. Chúng tôi có một phần giải thích mọi thông tin về các thuật toán chính.

78
00:05:11,230 --> 00:05:20,650
Chúng tôi có một phần về thuật toán sắp xếp diễn ngôn. Bạn có thể kiểm tra video trong phần đó. Thuật toán của chúng tôi bắt đầu hoạt động và chúng tôi đang chia vấn đề thành.

79
00:05:20,930 --> 00:05:34,850
Có lẽ đã đến lúc hắn xé toạc Châu Âu và Châu Âu cũng phải xâm lược, và ở đây cái này có dung lượng thời gian tuyến tính và nếu chúng ta giải công thức này, thì chúng ta sẽ thấy độ phức tạp về thời gian lớn hơn về mặt đăng nhập và không gian.

80
00:05:34,880 --> 00:05:48,290
Độ phức tạp lớn hơn. Và đây là thời gian, độ phức tạp, phân tích logarit tuyến tính, thời gian, độ phức tạp. Chúng tôi đã giải thích mọi thứ trong video, nắm vững các thuật toán trong phần thuật toán sắp xếp và đây được gọi là phương pháp thay thế ngược.

81
00:05:48,500 --> 00:05:57,470
Bây giờ hãy nói về số lượng thời gian. Nhưng thuật toán cần có thời gian chất lượng và độ phức tạp. Nói cách khác, một ổ bánh mì thay vì một ổ bánh mì được coi là thời gian chất lượng.

82
00:05:57,680 --> 00:06:12,860
Đây là một ví dụ về chất lượng, thời gian, độ phức tạp. Chúng tôi có một công cụ có giá trị cho toàn bộ Ejiro. Tôi liệt kê toàn bộ căn hộ. Phần bên trong ổ bánh mì này ít hơn một chút, từ 0 đến trừ một.

83
00:06:12,860 --> 00:06:26,300
Điều đó có nghĩa là cần có thời gian trong New York Times và vòng lặp này cũng cần có thời gian tăng và tuyên bố để thực thi trong Konstantine. Nếu chúng ta cộng tất cả những thứ đó sẽ trở nên lớn hơn và độ phức tạp theo thời gian bình phương đối với một người ở Ai Cập.

84
00:06:26,300 --> 00:06:39,230
Thời gian của bước di chuyển này, vòng lặp này chiếm đơn vị thời gian tăng gấp 4 theo đơn vị thời gian của giờ này. Aluf rằng trong văn bản vòng lặp tính theo thời gian tính theo đơn vị thời gian đã hiểu độ phức tạp về chất lượng thời gian là gì.

85
00:06:39,620 --> 00:06:50,890
Bây giờ hãy nói về thời gian Kubic, độ phức tạp. Nó có cùng nguyên tắc khi chúng ta đi ra và bình phương. Đây là một thuật toán chậm. Bây giờ chúng ta hãy nói về thời gian theo cấp số nhân, độ phức tạp hoặc lên đến mức tối đa.

86
00:06:50,900 --> 00:07:02,180
Và đó là một thuật toán rất chậm vì sự tăng trưởng đầu vào, nếu có, gần với một không không không không độ phức tạp thời gian sẽ là hai một không không không không không không.

87
00:07:02,540 --> 00:07:14,000
Chúng ta có thể xem xét ví dụ về thuật toán vũ phu. Thuật toán quay lui, thuật toán quay lui mất thời gian theo cấp số nhân, hệ số phức tạp theo thời gian thực, giai thừa lớn hơn.

88
00:07:14,570 --> 00:07:27,800
Đây là thuật toán chậm nhất từ ​​​​trước đến nay. Bây giờ chúng ta đã quen với các thuật toán ngẫu nhiên phổ biến. Bây giờ chúng ta đã quen với sự ngẫu nhiên thông thường. Hãy phân tích nó bây giờ bạn có thể nói, tại sao chúng ta nên học về sự phức tạp?

89
00:07:27,800 --> 00:07:40,280
Phân tích nó. Bây giờ chúng ta hãy trả lời câu hỏi này. Giả sử bạn được cung cấp một đầu vào. Bây giờ, tăng 10 cho đầu vào và chuyển sang 10 ipe cách xa nguồn nhị phân hoặc nguồn tuyến tính.

90
00:07:40,310 --> 00:07:54,020
Sau đó, không có sự khác biệt đáng kể. Nhưng nếu kích thước đầu vào của chúng ta lên tới một tỷ, thì nếu chúng ta thực hiện nguồn tuyến tính, sẽ mất một tỷ mili giây.

91
00:07:54,290 --> 00:08:12,620
Nhưng chúng ta tránh xa sự phá hoại. Ý chí của Banister mất 32 mili giây. Ở đây chúng ta thấy sự khác biệt rất lớn trong một tỷ mili giây. Nếu chúng ta chuyển đổi một tỷ mili giây thành giá trị này thì chúng ta sẽ có bốn mươi sáu ngày cho đầu vào và nó sẽ lên tới một tỷ.

92
00:08:12,800 --> 00:08:27,230
Nếu một đơn vị hoạt động mất một phần nghìn giây thì thuật toán nguồn tuyến tính mất khoảng bốn mươi sáu ngày. Và đây được gọi là thuật toán tuyến tính cho thuật toán Bannister.

93
00:08:27,240 --> 00:08:45,710
Đây được gọi là thuật toán logarit. Thuật toán tìm kiếm tuyến tính mất thời gian tuyến tính. Độ phức tạp của thuật toán phân tích mất thời gian logarit. Tìm kiếm nhị phân phức tạp hoạt động trong 32 mili giây, nhưng thống kê tuyến tính là một tỷ mili giây cho đầu vào và bằng một tỷ.

94
00:08:45,920 --> 00:09:04,070
Thế thì chúng ta có thể thấy ở đây anh ấy đã khác. Đây là lý do tại sao bạn nên học cách phân tích ngẫu nhiên nó. Điều đó có nghĩa là phức tạp, hãy phân tích nó. Nếu chúng tôi viết một thuật toán mà bạn có thể đo lường hiệu quả của thuật toán bằng cách sử dụng độ phức tạp, hãy phân tích nó, bạn có thể thấy mã của mình đã được tối ưu hóa.

95
00:09:04,340 --> 00:09:13,220
Nếu chúng ta không biết độ phức tạp, hãy phân tích nó, thì nó sẽ không biết mã của bạn là gì và hiệu quả của mã đó là gì. Với sự phức tạp đó. Phân tích nó.

96
00:09:13,220 --> 00:09:24,290
Bạn không thể là một lập trình viên giỏi. Phân tích độ phức tạp. Kỹ sư phần mềm Hoffe phải có kỹ năng hiểu độ phức tạp là gì, phân tích nó và những điều cơ bản về độ phức tạp.

97
00:09:24,290 --> 00:09:36,580
Phân tích nó. Bây giờ chúng ta đã có kiến ​​thức cơ bản về độ phức tạp. Phân tích nó trong phần
còn lại của video. Trong các phần này sẽ nói về cách tìm ra độ phức tạp của một thuật toán. 

@@@



98
00:00:00,300 --> 00:00:08,450
Đây rồi các bạn. Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ xem cách tìm thời gian, độ phức tạp của thuật toán. Giả sử bạn được cấp mã này.

99
00:00:08,880 --> 00:00:26,400
Chúng ta có thể thả và chèn vào đây hay chỉ in giá trị của bức tường này bắt đầu từ một và kết thúc ở nếu chúng ta coi đó là sự lặp lại của sluff, nhắn tin một đơn vị thời gian tăng, sau đó đối với bất kỳ lần lặp nào, tình yêu này sẽ diễn ra .

100
00:00:26,410 --> 00:00:42,840
Bạn cần tăng thời gian để chúng tôi có thể xem thời gian. Độ phức tạp thường xuyên và độ phức tạp về không gian lớn hơn một. Điều đó có nghĩa là độ phức tạp không gian không đổi vì chúng tôi không sử dụng bất kỳ cấu trúc dữ liệu bổ sung nào để lưu trữ dữ liệu của mình trong bộ nhớ máy tính.

101
00:00:43,680 --> 00:00:57,940
Vì vậy độ phức tạp về thời gian của thuật toán này thường lớn hơn. Bây giờ hãy lấy một ví dụ khác. Ví dụ: nếu bạn đưa ra thuật toán này ở đây, chúng tôi có loof cho AI từ một đến nhỏ hơn bằng hai ở đây và ở đây.

102
00:00:57,960 --> 00:01:14,580
Tăng thêm hai là thời gian và tốc độ hoạt động mất thời gian không đổi. Bây giờ chúng ta phải tìm ra độ phức tạp về thời gian của thuật toán này. Nếu chúng ta có bất kỳ mục tiêu nào đến 10 thì loof này sẽ lặp lại chia hai lần.

103
00:01:14,850 --> 00:01:27,420
Điều đó có nghĩa là năm lần nếu lặp lại điều này, tình yêu sẽ mất một đơn vị thời gian để đầu vào trong vòng lặp này sẽ nhắn tin ở hai lần còn lại ở Châu Âu về độ phức tạp về thời gian.

104
00:01:27,420 --> 00:01:41,940
Phân tích nó. Liệu nó có coi phần hằng số của chúng ta sẽ lấy mức độ từ biểu thức đó hay không. OK, vậy ở đây ta có in sẽ lấy chỉ in sẽ loại bỏ phần hằng số này ở 2 phần còn lại ở đây.

105
00:01:41,940 --> 00:01:50,940
Hai là một hằng số. Vì vậy độ phức tạp về thời gian của thuật toán này là đủ lớn. Và nếu bạn được cung cấp thuật toán này ở đây, chúng ta sẽ tăng thêm 20 năm nữa.

106
00:01:51,210 --> 00:02:05,250
Loại dầu này có giá trị khoảng hai mươi đơn vị lần cho đầu vào. Và ở đây tất cả những điều này đều không đổi. Chỉ là dù thế nào đi chăng nữa, nếu chúng ta có 100, 200, 300 thì sẽ không tính đến.

107
00:02:05,520 --> 00:02:17,170
Chúng ta sẽ loại bỏ phần đó và sẽ lấy bậc của phương trình. Và thế là xong. Vì vậy, độ phức tạp về thời gian lớn hơn và độ phức tạp về không gian trở thành một vì chúng ta không sử dụng bất kỳ lời nói gốc nào.

108
00:02:17,640 --> 00:02:32,490
Bây giờ hãy lấy một ví dụ khác. Ví dụ: nếu bạn đưa ra thuật toán này và chúng tôi sẽ chia nhỏ nó ra, phép lặp cho vòng lặp Aluf và vòng lặp for, và câu lệnh in này mất thời gian không đổi và độ phức tạp.

109
00:02:32,790 --> 00:02:54,360
Ở đây chúng tôi chia nhỏ việc lặp lại. Bốn tình yêu bên ngoài và bên trong đối với lần lặp đầu tiên của Aluf trong Vòng lặp của chúng ta sẽ không được thực thi trong lần lặp thứ hai của Tình yêu của chúng ta ở Aluf được thực thi một lần cho bất kỳ lần lặp lại nào của tình yêu của chúng ta trong Aluf. Thực thi theo số lần nếu chúng ta cộng tất cả số thực thi bằng 0.

110
00:02:54,360 --> 00:03:05,220
Một, hai, ba, bốn và sau đó chúng ta có được phương trình này. Vì vậy, chúng ta nhận được từ tình huống này theo cộng một chia hai và ở đây chúng ta nhận được bình phương cộng theo hai số còn lại.

111
00:03:05,610 --> 00:03:25,920
Bây giờ để tìm ra thời gian, độ phức tạp từ phương trình này sẽ xét đến mức độ của phương trình này. Bậc của phương trình này là bình phương. Vì vậy, độ phức tạp về thời gian của thuật toán này là do độ phức tạp trong hình vuông và không gian lớn hơn một, bởi vì bạn không sử dụng bất kỳ lời nói bổ sung nào.

112
00:03:26,100 --> 00:03:50,970
Bây giờ hãy lấy một ví dụ khác. Ví dụ: nếu bạn đưa ra thuật toán này, chúng tôi có gần bằng 0 và tôi tin rằng chúng tôi đang chạy vòng lặp này từ 0 đến nhỏ hơn bằng ở đây chúng tôi có Pocket Peeler và bằng in và chúng tôi đang tăng I, tôi có hai tôi cộng với P và ở đây chúng ta có một tuyên bố về cách chúng ta có thể tìm ra thời gian, độ phức tạp của thuật toán này.

113
00:03:51,330 --> 00:04:06,560
Chúng tôi chia nhỏ việc lặp lại cho độ dốc. Được rồi, trước khi tôi đạt đến một vì bằng 0 cộng một cho tôi đến hai vì đến một cộng hai bốn tôi phải giết vì hai một cộng hai cộng ba cộng bốn cộng K.

114
00:04:06,780 --> 00:04:19,670
Nếu chúng ta giả sử B lớn hơn in thì vòng lặp này sẽ dừng lại. Khi E.S.P lớn hơn vòng lặp này sẽ dừng lại. Được rồi, bây giờ chúng ta chuyển sang một cộng hai cộng ba cộng bốn cộng v.v.

115
00:04:19,950 --> 00:04:39,150
Vậy ở đây chúng ta có được từ phương trình này K Damski cộng một chia để có bình phương cộng K chia hai. Bây giờ ở đây lấy bình phương cộng với quân đội đi đến P nên hai lớn hơn N khi chúng ta phát hiện ra điều kiện yêu thích này tất cả ngừng thực hiện.

116
00:04:39,660 --> 00:04:53,820
Bây giờ ở đây sẽ lấy bậc từ phương trình bình phương này. Vì vậy chúng ta sẽ loại bỏ phần K và phần hai này. Vì vậy, bạn nhận được Gascoine lớn hơn trong bốn phân tích ngẫu nhiên.

117
00:04:53,820 --> 00:05:13,250
Chúng ta sẽ chỉ xem xét mức độ của phương trình và ở đây chúng ta có được phương trình của Cagle. Có thể điều chỉnh để chúng tôi tìm ra thời gian của mình, độ phức tạp của thuật
toán này là Rouda, do đó, độ phức tạp về thời gian của thuật toán này là của rober in và độ phức tạp của không gian là không đổi vì bạn không sử dụng bất kỳ Spetz bổ sung nào. 

@@@



118
00:00:00,750 --> 00:00:15,830
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Bạn sẽ biết cách tìm ra độ phức tạp của một thuật toán, chẳng hạn như đã từng cho thuật toán này để tìm ra độ phức tạp của thuật toán này.

119
00:00:16,140 --> 00:00:27,770
Tom, phức tạp và phức tạp. Đầu tiên, chúng ta chia nhỏ sự lặp lại của tình yêu này cho lần lặp đầu tiên. Tôi đi đến một, sau đó lặp lại lần thứ hai. Tôi phải làm cái sâu hơn.

120
00:00:28,350 --> 00:00:45,270
Sau đó, trong thời lượng thứ ba, tôi phải báo cáo ba, vòng lặp Prickett, tôi có hai phần ở phím nguồn vì chúng ta đang nhân giá trị của AI với hai trong lần lặp bên trong của nó.

121
00:00:45,300 --> 00:00:57,750
Ở đây chúng ta có một mệnh đề, mệnh đề này đòi hỏi thời gian không đổi, độ phức tạp và cách chúng ta có thể tìm thấy nó. Thời gian, độ phức tạp của bài toán này ở đây chúng ta thấy đối với phép lặp mèo, tôi đi thẳng đến lũy thừa K.

122
00:00:58,560 --> 00:01:10,650
Nếu chúng ta tìm thấy lớn hơn hoặc bằng N thì tình yêu này sẽ ngừng thực hiện. Vì vậy, ở đây chúng tôi đã chỉ định EcoStar hai vào vòng lặp Kate của Power K Workingmen.

123
00:01:10,650 --> 00:01:28,590
Điều đó có nghĩa là lần lặp lại cuối cùng của tình yêu dành cho vòng lặp này hoặc mức thấp nhất trong quá trình thực hiện nó. Vì vậy, chúng ta có thể nói rằng phần vỏ lớn hơn bằng N và ở đây nếu chúng ta lấy log hai ở cả hai bên, thì chúng ta sẽ có log2 của Cagle.

124
00:01:28,800 --> 00:01:44,100
Và đây là độ phức tạp về thời gian của thuật toán này. Vì vậy, thời gian, độ phức tạp của thuật toán là lock to end và độ phức tạp về không gian là không đổi vì chúng tôi không sử dụng bất kỳ lời nói bổ sung nào hoặc chúng tôi đã hiểu cách tìm ra thời gian, độ phức tạp của thuật toán này.

125
00:01:44,430 --> 00:01:57,990
Bây giờ hãy lấy một ví dụ khác. Ví dụ: nếu bạn được cung cấp thuật toán này, chúng tôi sẽ bắt đầu AI từ trong cho đến khi I lớn hơn nó tiến tới một và không cân nhắc hoặc chia AI cho hai.

126
00:01:58,350 --> 00:02:16,500
Ở đây chúng tôi chia nhỏ sự lặp lại của tình yêu này cho lần lặp đầu tiên. Tôi phải cố gắng thực hiện điệu Bajirao mà chúng ta có thể nghĩ tới. Được rồi, đối với lần lặp đầu tiên, tôi phải thực hiện ở lần lặp đầu tiên, lần lặp thứ hai, tôi phải cố gắng thực hiện lần lặp thứ ba.

127
00:02:16,980 --> 00:02:36,490
Tôi phải cố gắng khởi hành đến đây, không phải chia nhau đến Bajirao để đặt ống thông. Cần nỗ lực để thực hiện công việc. Bây giờ nếu chúng ta thấy một người lớn hơn tôi bất cứ khi nào hình thức này phát hiện ra một người lớn hơn tôi, thì đó là thứ để thực hiện nó.

128
00:02:36,930 --> 00:02:52,950
Ở đây chúng ta đã tìm thấy nó bằng hai phần được chia để thực hiện việc chăm sóc sức mạnh cho phép lặp. Vì vậy, ở đây một lần nữa riblets. Tôi sẽ cố gắng lên tàu và nếu chúng ta nhìn thấy biểu hiện này thì chúng ta sẽ kết thúc với Greg Sheridan Locke.

129
00:02:53,130 --> 00:03:03,950
Vì vậy, đây là độ phức tạp về thời gian của thuật toán này. Vì vậy, thời gian của thuật toán này là khủng khiếp. Được rồi, để kết thúc và độ phức tạp của không gian là không đổi vì chúng ta không sử dụng một điểm nhổ bổ sung.

130
00:03:04,560 --> 00:03:23,190
Bây giờ hãy lấy một ví dụ khác. Chúng tôi đã đến Gerardine, món đồ tôi ít hơn trong mắt. Cộng với Blatche ở đây. Chúng ta có điều kiện là lần nào tôi cũng nghe ở đây, nếu adiam mục thì tôi phải đến n rồi cái thứ Lupul này.

131
00:03:23,790 --> 00:03:46,170
OK, đối với các mục lặp lại cuối cùng tôi có ở đây, các mục tôi có ở Wickwire, vì vậy tôi định đi đến N nên tôi đã root cho N nên tôi phải root. Vì vậy, độ phức tạp về thời gian của thuật toán này là của kẻ cướp in và độ phức tạp của không gian sẽ lớn hơn một vì bạn không sử dụng bất kỳ lời nói gốc nào.

132
00:03:46,740 --> 00:04:04,010
Chúng tôi chỉ đang sử dụng một số biến. Bây giờ hãy lấy một ví dụ khác. Ví dụ: giả sử chúng tôi đưa ra thuật toán này vào năm đầu tiên cho AI. Bạn đi đến ít hơn bất cứ nơi nào, Blatche, chúng tôi có ở đây với chi phí ít hơn trong vụ bắn máu.

133
00:04:04,460 --> 00:04:14,830
Chúng tôi biết rằng thuật toán này có độ phức tạp lớn về thời gian và thuật toán này có độ phức tạp trung gian lớn so với giải thích trước đó. Độ phức tạp thời gian của thuật toán này là gì?

134
00:04:15,180 --> 00:04:30,370
Một lần nữa, thuật toán này sử dụng điều này để làm theo. Nếu chúng ta thêm thời gian khi chúng ta bước đi, chúng ta sẽ trở nên phức tạp về thời gian, phân tích nó sẽ bác bỏ hoặc loại bỏ hằng số partitas.

135
00:04:30,620 --> 00:04:42,590
Vì vậy, độ phức tạp về thời gian của thuật toán này đủ lớn và chúng tôi không xem xét phần không đổi. Vì vậy độ phức tạp về thời gian trong không gian đủ lớn, độ phức tạp là điểm lớn hơn.

136
00:04:42,740 --> 00:04:55,630
Bây giờ hãy lấy một ví dụ khác. Chúng tôi có aanestad cho tất cả. Vì điều này, Wolf, chúng tôi để mắt đến việc giúp chúng tôi lập kế hoạch cho bức tường này với chi phí thấp hơn một ngày so với chi phí thời đó.

137
00:04:56,050 --> 00:05:12,070
Vì vậy, ở đây chúng ta thấy nơi tăng dần một đầu ở đây hoặc tăng bằng cách nhân giá trị của đầu kia với hai. Từ ví dụ trước, chúng ta đã thấy rằng thuật toán này sẽ giảm độ phức tạp thời gian logarit và cho các thuật toán này.

138
00:05:13,230 --> 00:05:26,990
Mất thời gian tuyến tính, độ phức tạp, bởi vì ở đây chúng ta đang lặp từ 0 đến trừ một cho mỗi lần lặp của tình yêu này, vòng lặp này sẽ mất nhiều thời gian hơn bất kỳ lần lặp nào của tình yêu này.

139
00:05:27,330 --> 00:05:46,560
Điều này sẽ gây ra sự phức tạp về thời gian đăng nhập. Bạn đã nhìn thấy bốn trong sự lặp lại của tình yêu này. Chúng ta đang thấy bốn lần lặp lại. Được rồi, nếu tình yêu này lặp đi lặp lại theo thời gian thì thời gian đăng nhập sẽ rất phức tạp.

140
00:05:46,800 --> 00:06:07,210
Một số độ phức tạp về thời gian nằm ở việc đăng nhập. Vì vậy, đối với một lần lặp lại Aluf trong Vòng lặp của chúng tôi, độ phức tạp về thời gian đăng nhập sẽ xảy ra. Đây là phép toán đơn giản. ĐƯỢC RỒI. Đối với bất kỳ sự lặp lại nào về vai trò của sáng kiến, Will sẽ ghi lại.

141
00:06:08,950 --> 00:06:24,110
Khi đăng xuất, độ phức tạp về thời gian, do đó độ phức tạp về thời gian của thuật toán này đủ lớn trong Logan và độ phức
tạp về không gian lớn hơn một vì bạn không sử dụng bất kỳ lời nói bổ sung nào, chúng tôi đã hiểu cách tìm ra nó. 

@@@



142
00:00:00,690 --> 00:00:26,490
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về việc bắt giữ là gì và tại sao chúng ta cần một vùng là một cấu trúc dữ liệu chứa một nhóm phần tử, được xác định bởi chỉ mục của chúng ta và các vùng hướng tới sao cho vị trí của HUMINT có thể được tính toán từ nó có thể lập chỉ mục bằng một công thức toán học.

143
00:00:27,030 --> 00:00:45,470
Đây là định nghĩa chính thức về vùng màu xám sẽ lưu trữ một nhóm tù nhân và chúng ta có thể thoát khỏi bất kỳ phần tử nào trong thời gian không đổi bằng cách sử dụng chỉ mục. Số ba có một số thuộc tính liên quan đến dữ liệu của một số loại khu vực.

144
00:00:45,660 --> 00:01:00,060
Không thể lưu trữ dữ liệu của các loại khác nhau dựa trên dữ liệu cùng loại của vùng có bộ nhớ, vị trí liền kề. Và chúng ta sẽ nói chi tiết trong phần này của khóa học này.

145
00:01:00,720 --> 00:01:16,530
Sau đó thuộc tính tiếp theo là Arrow Index. Bắt đầu bằng số 0, sau đó thuộc tính tiếp theo là trang web của mọi nhu cầu phải được chỉ định bắt buộc và không thể sửa đổi để thông báo của chúng tôi không đổi.

146
00:01:16,530 --> 00:01:32,880
Chúng tôi không thể thay đổi vị trí lỗi sau khi khai báo. Đây là một ví dụ về lỗi. Ở đây chúng ta có tám phần tử và ở đây chúng ta có số chỉ mục. Sử dụng số chỉ mục, chúng ta có thể thoát khỏi bất kỳ phần tử mảng nào trong thời gian không đổi.

147
00:01:33,480 --> 00:01:46,780
Độ dài của lỗi này là 8 và chúng tôi thấy chỉ số bắt đầu từ 0. Chỉ số của phần tử đầu tiên bằng 0. Chỉ số của phần tử thứ hai là một, rồi hai, rồi cứ thế tiếp tục.

148
00:01:47,820 --> 00:01:59,910
Bây giờ bạn có thể hỏi tại sao chúng ta cần một lỗi. Trước khi trả lời câu hỏi của bạn, hãy để tôi hỏi bạn một câu hỏi. Chúng tôi muốn lưu trữ một triệu loại dữ liệu tương tự trong bộ nhớ máy tính.

149
00:02:00,150 --> 00:02:13,640
Sau đó bạn sẽ làm gì? Làm thế nào bạn lưu trữ một triệu loại tương tự trong bộ nhớ máy tính? Bạn có thể nói rằng chúng tôi sẽ khai báo các cấu trúc dữ liệu nguyên thủy như số nguyên, thiếu sót, Boulin, v.v..

150
00:02:14,340 --> 00:02:37,230
Bây giờ vấn đề được giải quyết bằng cách nào bạn sẽ duy trì một danh sách biến lớn như vậy? Bạn phải làm rất nhiều công việc. Giải pháp cho vấn đề này là chúng ta sẽ khai báo diện tích của trang 1000000, sẽ lưu trữ một triệu phần tử trong một mảng và chúng ta có thể thoát phần tử đó theo số chỉ mục trong thời gian không đổi.

151
00:02:37,530 --> 00:02:48,420
Chúng ta không cần phải duy trì một danh sách khổng lồ các biến số. Đây là một ví dụ về một mảng và độ dài của vùng này là 8 và chúng ta có số chỉ mục từ 0 đến 7.

152
00:02:48,630 --> 00:03:03,900
Chúng ta có thể truy cập bất kỳ phần tử nào trong thời gian không đổi bằng cách sử dụng số chỉ mục. Nếu chúng ta có diện tích có chiều dài, một triệu, chúng ta có thể thoát khỏi bất kỳ cách sắp xếp nào khỏi diện tích đó bằng cách sử dụng số chỉ mục trong thời gian không đổi.

153
00:03:05,010 --> 00:03:26,700
Bây giờ hãy lấy một ví dụ. Giả sử chúng ta muốn lưu trữ một trăm số nguyên từ một đến một trăm trong bộ nhớ máy tính. Sau đó bạn sẽ làm gì? Bạn có thể có xu hướng tạo một trăm biến để lưu trữ số nguyên từ một đến một trăm, việc đó sẽ tốn rất nhiều công sức và không hiệu quả.

154
00:03:27,360 --> 00:03:50,340
Nếu chúng ta phải khai báo một trăm biến, họ cần phải duy trì danh sách các biến và việc đó sẽ cần rất nhiều công việc. Khi làm điều đó, anh ta có thể khai báo diện tích đất là một trăm và bạn có thể gán số nguyên cho mảng và điều đó sẽ tốn ít công sức hơn và bạn có thể truy cập bất kỳ mảng nào bị giới hạn bởi số chỉ mục.

155
00:03:50,580 --> 00:04:10,530
Và điều đó cực kỳ hiệu quả. Đây là những gì chúng ta nên sử dụng mảng thay vì biến. Đây là một ví dụ về mảng và độ dài của mảng này là một trăm mốt, hai, ba, bốn, năm, sáu và Door-To-Door sau đó là một trăm.

156
00:04:10,890 --> 00:04:21,510
Chúng tôi có số chỉ mục từ 0 đến 99. Chúng tôi có thể truy cập bất kỳ phần tử nào từ khu vực này bằng cách sử dụng số chỉ mục. Ở đây chúng tôi đang sử dụng dấu chấm khác.

157
00:04:22,230 --> 00:04:37,020
Dù sao thì chúng tôi cũng không thể cho bạn thấy một trăm umid đó trong khu vực này cho trang hiển thị.
Chúng ta đã hiểu diện tích là gì và tại sao chúng ta nên sử dụng mảng. Cảm ơn đã xem video này. 

@@@



158
00:00:00,720 --> 00:00:16,790
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về các loại diện tích khác nhau. Có hai loại mảng, mảng một chiều và mảng nhiều chiều trong video này.

159
00:00:17,400 --> 00:00:33,500
Và trong khóa học này, chúng ta sẽ nói về mảng hai chiều, chứ không nói về mảng ba, bốn hoặc năm chiều đối với hầu hết trẻ em mà chúng ta sử dụng, mảng một chiều và mảng hai chiều là mảng đa chiều trong video này.

160
00:00:33,510 --> 00:00:53,880
Và trong khóa học này, chúng ta sẽ nói về quyết định giám sát, một ví dụ về mảng một chiều, và đây là một ví dụ về mảng. Bây giờ chúng ta hãy nói chi tiết về mảng một chiều trong mảng một chiều là phần tử được biểu thị bằng một chỉ số duy nhất.

161
00:00:54,210 --> 00:01:09,870
Các phần tử được lưu trữ trong bộ nhớ liên tiếp. Vị trí sẽ xem các phần tử được lưu trữ trong bộ nhớ máy tính như thế nào trong video tiếp theo. Ví dụ về mảng ta đã khai báo diện tích mảnh đất là 8.

162
00:01:10,290 --> 00:01:25,800
Kích thước của khu vực này là tám. Và ở đây chúng ta có tám yếu tố. Tất cả đều được đại diện, đại loại như thế này. Chúng ta có số chỉ mục từ 0 đến 7 và chúng ta có phần tử đó từ 1 đến 8 nếu chúng ta thấy vùng một.

163
00:01:26,400 --> 00:01:49,560
Và ở giữa khung này, chúng ta có một. Đây là số chỉ mục. Vì vậy, tại chỉ số một, chúng ta có phần tử thứ hai. Vì vậy, nó sẽ trở về nếu chúng ta nói ở đây mảng cho thì thay vào đó chúng ta làm gì trên ABC và trước đó nó sẽ trả về năm vì nó chỉ số bốn, chúng ta có giá trị năm.

164
00:01:49,920 --> 00:02:04,050
Nếu chúng ta thấy ở đây cứ bảy cái thì nó sẽ trả về cái gì, nó sẽ trả về giá trị tám này vì ở chỉ số bảy chúng ta có Giá trị tám. Chúng ta đã hiểu khái niệm mảng một chiều.

165
00:02:04,200 --> 00:02:21,960
Bây giờ chúng ta hãy nói về mảng hai chiều trong mảng hai chiều là phần tử được biểu thị bằng hai chỉ số dưới, mảng hai chiều trong buy in có imroth và trong các cột và nội dung theo thời gian trong các phần tử.

166
00:02:22,320 --> 00:02:38,490
Và đây là một ví dụ về mảng mảng. Nó có ba quy tắc và bốn cột và tất cả đều được thể hiện. Một cái gì đó như thế này. Đây là hàng. Chúng ta có ba cột hai và chúng ta có bốn cột.

167
00:02:39,180 --> 00:02:58,740
Chúng tôi có số chỉ mục là hàng và cột ở đây. Nếu ta nói diện tích một là hai thì một nghĩa là ở đây, một nghĩa là chỉ số hàng và hai nghĩa là chỉ số cột ở đây là một, đây là một và cột hai.

168
00:02:59,310 --> 00:03:13,740
Vì vậy ở một đầu của cột thứ hai chúng ta có giá trị bốn mươi. Vì vậy, nó sẽ trả về bốn mươi nếu chúng ta nói mảng hai một ở hàng hai và thêm cột một, chúng ta có giá trị ba trăm.

169
00:03:14,010 --> 00:03:33,240
Thế là nó sẽ trả về ba trăm và nó sẽ nói hai ba một lần. Ở hàng thứ ba. Ở cột ba, chúng ta có giá trị 500. Vì vậy, nó được viết giá trị là năm và đây là mảng hai chiều và đây là cách chúng ta có thể chấp nhận bất kỳ phần tử nào trong mảng hai chiều.

170
00:03:33,450 --> 00:03:44,610
Hãy xem nó. Chúng tôi muốn đưa yếu tố đó vào trật tự mới. Chúng ta phải làm, chúng ta phải nói mảng bằng 0 tại Ruggiero tại các cột, bạn biết đấy, có giá trị cho nó.

171
00:03:44,620 --> 00:04:00,960
Chúng tôi muốn nhận được giá trị ba từ hai khu vực này. Sau đó chúng ta sẽ nói bản gốc. Đầu tiên là chỉ
mục của Rolan, chỉ mục của các cột. Chúng ta đã hiểu được khái niệm mảng hai chiều và mảng một chiều. 

@@@



172
00:00:00,750 --> 00:00:16,000
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng ta sẽ nói về cách lưu trữ vùng trong bộ nhớ truy cập ngẫu nhiên. Đầu tiên, chúng ta sẽ nói về cách dạy một độ trong bộ nhớ máy tính.

173
00:00:16,260 --> 00:00:29,280
Sau đó chúng ta sẽ nói về cách lưu trữ Reira trong bộ nhớ máy tính. Bây giờ hãy nói về mảng một chiều. Đây là một ví dụ về một căn phòng có diện tích là 8.

174
00:00:29,280 --> 00:00:40,230
Và chúng ta có ở đây tám yếu tố. Đây là đại diện của mảng này. Chúng tôi có số chỉ mục với số chỉ mục. Chúng ta có thể truy cập bất kỳ phần tử nào của chúng trong thời gian không đổi.

175
00:00:40,950 --> 00:00:55,290
Bây giờ, giả sử đây là bộ nhớ máy tính của chúng ta. Ý tôi là, đây là bộ nhớ truy cập ngẫu nhiên của chúng tôi và chúng tôi cho rằng bộ nhớ này trống. Bây giờ khu vực này sẽ được lưu trữ như thế nào trong bộ nhớ máy tính.

176
00:00:55,890 --> 00:01:13,560
Bộ nhớ máy tính là tập hợp của một khối, được chứ? Trong khối của nó, phần tử của chúng ta sẽ được lưu trữ. Phần tử Ả Rập sẽ được lưu trữ. Phần tử đầu tiên sẽ được chuyển đổi thành nhị phân, sau đó phần tử nhị phân tương đương sẽ được lưu vào bộ nhớ máy tính.

177
00:01:13,920 --> 00:01:35,700
Để dễ hiểu, chúng ta sẽ lưu trữ giá trị thập phân. Vì vậy, bạn có thể nói rằng thỏa thuận sẽ được lưu trữ. Một cái gì đó như thế này một cái sẽ ở đây sẽ ở đây, rồi bốn cái sẽ ở đây, năm cái ở đây, rồi sáu cái ở đây, bảy, tám.

178
00:01:36,610 --> 00:01:50,130
Chúng ta có thể cho rằng sự sắp xếp sẽ được lưu trữ, đại loại như thế này trong định nghĩa mảng. Chúng ta thấy rằng mọi phần tử sẽ lần lượt được lưu trữ ở các vị trí bộ nhớ liên tiếp.

179
00:01:51,300 --> 00:02:09,800
Vì vậy, phần tử mảng sẽ không được lưu trữ như thế này. Nó sẽ được lưu trữ theo cách sử dụng quốc gia lần lượt. Phần tử còn lại sẽ được lưu trữ, đại loại như thế này, rồi hai, rồi ba, rồi bốn, năm, sáu, bảy, tám.

180
00:02:10,740 --> 00:02:27,560
Chúng ta thấy rằng sự sắp xếp được lưu trữ ở các vị trí bộ nhớ liên tiếp, lần lượt từng khối, ở khối đầu tiên chúng ta có khối này. Sau đó, ở khối thứ hai, chúng ta có hai, rồi ba, rồi bốn, năm, sáu, bảy, tám.

181
00:02:27,840 --> 00:02:39,660
Chúng tôi thấy rằng lần lượt được lưu trữ ở vị trí bộ nhớ liên tiếp. Đây là cách lỗi được thể hiện trong bộ nhớ máy tính. Để hiểu hoặc chỉ lưu trữ giá trị số nguyên.

182
00:02:40,140 --> 00:02:50,610
Trên thực tế, phần tử sẽ được chuyển đổi thành tương đương nhị phân và tương đương nhị phân sẽ được lưu trữ trong bộ nhớ máy tính theo tính liên tục, bộ nhớ, vị trí, đại loại như thế này.

183
00:02:51,310 --> 00:03:00,750
Chúng ta đã hiểu mảng một chiều được lưu trữ trong bộ nhớ máy tính như thế nào. Bây giờ hãy nói về cách mảng hai chiều được lưu trữ trong bộ nhớ máy tính.

184
00:03:01,590 --> 00:03:13,980
Đây là một ví dụ thực sự có tới ba hàng, ba hàng, hai cột và tất cả đều được thể hiện. Một cái gì đó như thế này. Bạn có thể cho rằng mảng sẽ được lưu trữ, đại loại như thế này.

185
00:03:13,980 --> 00:03:28,980
Một, hai, ba, bốn, năm, sáu. Bạn có thể nghĩ rằng khu vực bên trong sẽ được lưu trữ ở một vị trí bảo mật chứ không phải toàn bộ khu vực. Điều đó không có nghĩa là khu vực này sẽ không được đại diện, đại loại như thế này.

186
00:03:29,650 --> 00:03:45,400
Khu vực này sẽ được lưu trữ trong bộ nhớ thánh hiến, vị trí, đầu tiên là một, sau đó là hai, sau đó là ba, sau đó là bốn, sau đó là năm và sáu. Những thứ như thế này cái này sẽ được lưu trữ ở đây, rồi hai, rồi ba và bốn, rồi năm và sáu sẽ được lưu trữ.

187
00:03:45,400 --> 00:04:00,840
Một cái gì đó như thế này. Đây là cách Reira được lưu trữ trong bộ nhớ máy tính. Đây là điều
cơ bản. Chúng tôi đã hiểu khái niệm về cách khôi phục truy cập ngẫu nhiên vào bộ nhớ. 

@@@



188
00:00:00,660 --> 00:00:15,210
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về cách chúng ta có thể tạo một cái. Deery trong câu lệnh khai báo sẽ tạo một tham chiếu đến một khu vực sau đó sẽ khởi tạo trong tổ chức đó.

189
00:00:15,210 --> 00:00:29,520
Freij sẽ tạo một mảng sau đó khởi tạo trong Freij khởi tạo. Chúng tôi sẽ khởi tạo các giá trị cho khu vực đó. Bây giờ hãy xem liệu chúng ta có thể khai báo, cách khởi tạo và cách khởi tạo từng cái một hay không.

190
00:00:30,390 --> 00:00:41,230
Đầu tiên chúng ta nói về việc khai báo một mảng cho khai báo Freij. Đầu tiên là tại một thời điểm, sau đó là dấu ngoặc, dấu ngoặc vuông, sau đó là tên của mảng.

191
00:00:41,730 --> 00:00:53,670
Một cái gì đó như thế này vào dấu ngoặc vuông này. Sau đó là tên của mảng. Trong trường hợp này, tên của không có gì khác nhau. Khởi tạo mảng trong phần khởi tạo.

192
00:00:53,790 --> 00:01:10,100
Nó sẽ tạo một tham chiếu đến các kiểu dữ liệu mới thông thường trong trang web. Một cái gì đó như thế này gây khó chịu cho người mới can thiệp vào đây. Chúng tôi đã tạo một mảng và chúng tôi đã gán mảng đó cho biến nums này và chúng tôi sẽ tham chiếu mảng này ở đây.

193
00:01:10,380 --> 00:01:22,440
Sau đó chúng ta sẽ khởi tạo mảng tại phòng Index zero để chèn chỉ mục Ormat hoặc chèn để thêm chỉ mục vào. Chúng ta sẽ chèn ba và tại chỉ số ba, chúng ta sẽ chèn bốn.

194
00:01:22,620 --> 00:01:35,640
Chúng ta có thể khai báo, khởi tạo và khởi tạo mảng trong một câu lệnh, đại loại như thế này trong dấu ngoặc vuông int trong tên của mảng bằng thông qua các bộ tô màu và các phần tử.

195
00:01:36,090 --> 00:01:44,490
Đây sẽ được đại diện một cái gì đó như thế này. Một, hai, ba, bốn. Và chúng ta có chỉ số số một, hai, ba. Đây là cách chúng ta có thể tạo ra một cái.

196
00:01:44,490 --> 00:01:56,070
Deery Việc lặp lại một mảng sẽ mất thời gian không đổi. Tổ chức cũng sẽ mất thời gian liên tục và tất cả các hoạt động này. Tất cả các thao tác chèn đều mất thời gian không đổi.

197
00:01:56,490 --> 00:02:11,630
Và nếu độ dài của lỗi xảy ra thì tất cả quá trình chèn sẽ khiến Spiga gặp phải độ phức tạp về mặt thời gian. Và
nếu chúng ta khai báo đã khởi tạo và khởi tạo mảng trong một câu lệnh, thì độ phức tạp sẽ lớn hơn một lần. 

@@@



198
00:00:00,840 --> 00:00:11,180
Anh ấy sẽ quay lại với video này rất nhiều chàng trai. Trong video này, chúng ta sẽ nói về việc bạn được giao mảng Cidade này phản cách mạng như thế nào.

199
00:00:11,550 --> 00:00:21,300
Ở đây chúng ta có tám yếu tố. Mảng này sẽ được biểu diễn, đại loại như thế này. Chúng tôi có số chỉ mục của bạn cùng với số chỉ mục, chúng tôi có thể truy cập bất kỳ thông tin không liên quan nào trong thời gian không đổi.

200
00:00:22,200 --> 00:00:31,770
Bây giờ, hãy xem làm thế nào chúng ta có thể duyệt qua phần tử này. Đi ngang có nghĩa là chỉ cần truy cập vào mảng đã cho trong năm nay. Tất cả đều được đại diện, đại loại như thế này.

201
00:00:31,770 --> 00:00:43,150
Và sau đó chúng tôi phải theo dõi Ibram do diện tích đất bị trừ một. Và đây là nơi lập chỉ mục cho mảng này, tình yêu này sẽ lặp từ 0 đến 7.

202
00:00:44,040 --> 00:00:54,290
Đó là lý do tại sao chúng tôi có độ dài mảng của bạn, Meynet. Sau đó, chúng tôi chỉ in giá trị của phần tử hiện tại cho lần lặp đầu tiên, giá trị của phần tử đó bằng 0.

203
00:00:54,300 --> 00:01:17,640
Vì vậy, nó sẽ in một, lần lặp thứ hai, giá trị của là một. Nó sẽ in đến lần lặp thứ ba. Giá trị của là hai, nó sẽ in ba. Sau đó, ở lần lặp tiếp theo, nó sẽ in bốn, năm, sáu, bảy và tám bất cứ khi nào chúng ta.

204
00:01:18,680 --> 00:01:34,150
Dựa vào chỉ số này, kẻ lười biếng này sẽ phấn đấu cho thế hệ sau, giá trị của tôi sẽ được đánh giá là 8 và nằm ngoài ranh giới khu vực này. Vậy là chúng ta đã hoàn thành xong mảng này và đây là kết quả dầu hỏa của chúng ta.

205
00:01:34,160 --> 00:01:44,810
Một, hai, ba, bốn, năm, sáu, bảy, tám. Đây là những gì chúng ta có thể duyệt qua một mảng. Nó có trên mảng không? Nó rất đơn giản bằng cách sử dụng nó cho tất cả những gì chúng ta có thể làm đối với mảng.

206
00:01:45,110 --> 00:02:04,240
Bây giờ hãy nói về độ phức tạp về thời gian của việc khai báo lỗi. Nó sẽ mất thời gian liên tục. Độ phức tạp của lịch trình dự kiến ​​này là do độ phức tạp về mặt thời gian là độ dài của lỗi đã cho và sau đó chúng tôi chỉ in phần tử và thao tác in đều có độ phức tạp lớn một lần.

207
00:02:04,250 --> 00:02:16,810
Vì vậy, độ phức tạp về thời gian trung bình là lớn, thường là để thêm mọi thứ. Vì vậy, với mỗi lần vượt
qua, chúng ta sẽ phải trả chi phí. Và đây là sự phức tạp về thời gian. Cảm ơn đã xem video này. 

@@@



208
00:00:00,570 --> 00:00:12,450
Rất nhiều người trong video này sẽ xem cách chúng ta có thể thực hiện các thao tác chèn và cập nhật trong một khu vực đã được cấp cho khu vực này một, hai, ba, bốn, năm, sáu, bảy, tám.

209
00:00:12,480 --> 00:00:23,170
Tất cả đều được đại diện, đại loại như thế này. Bây giờ, trước tiên hãy nói về hoạt động. Đây là một mã giả. Quên các hoạt động được cung cấp cho khu vực này.

210
00:00:24,270 --> 00:00:36,330
Chúng tôi có yếu tố của bạn từ một đến tám. Chúng tôi có một số chỉ mục. Nếu chúng ta gọi cổng hàm này với diện tích và số chỉ mục thì nó sẽ trả về một vì nó là số chỉ mục.

211
00:00:36,330 --> 00:00:54,750
Chúng ta có phần tử một ở chỉ số năm, chúng ta có phần tử sáu và chỉ số bảy, phần tử tám. Và bằng cách sử dụng vùng này, chúng ta chỉ trả phần tử về tập chỉ mục đã cho, chỉ số bảy của Phần tử tám, và nó được gọi là các hoạt động đích.

212
00:00:55,020 --> 00:01:09,270
Nó rất đơn giản. Chúng ta có chức năng này thì mới có văn bản khai báo này. Chúng ta chuyển vùng này cho hàm này và số chỉ mục, sau đó hàm này sẽ trả về giá trị tại chỉ mục đã cho.

213
00:01:09,930 --> 00:01:22,800
Hàm này mất thời gian không đổi, độ phức tạp và câu lệnh bằng văn bản này cũng mất thời gian, độ phức tạp không đổi. Và độ phức tạp thời gian thực của cổng chức năng này bắt nguồn từ một độ phức tạp có nghĩa là độ phức tạp thời gian không đổi.

214
00:01:24,480 --> 00:01:35,280
Bây giờ hãy nói về thao tác chèn. Hãy ở đây chúng tôi được cung cấp tài liệu này. Chúng ta phải điền vào vùng này và đây là mã giả của chúng ta để điền vào mảng này trước tiên.

215
00:01:35,280 --> 00:01:46,290
Nếu chúng ta gọi hàm này, hãy chèn số 0 vào. Và đối số đầu tiên của bạn là mảng. Đối số thứ hai là số chỉ mục. Và phần tử thứ ba chính là giá trị chúng ta phải chèn vào.

216
00:01:46,890 --> 00:02:04,160
Vì vậy chúng ta sẽ chèn vào chỉ mục đầu tiên. Sau đó, nếu chúng ta nói chèn từng cái vào một chỉ mục, một để chèn hai. Sau đó, chúng ta thấy ba đến ba cho biết chúng ta phải chèn ba, sau đó ở chỉ số ba để chèn bốn.

217
00:02:05,360 --> 00:02:17,540
Vì vậy, chúng tôi đã lấp đầy mảng này bằng lệnh gọi hàm này và thao tác này sẽ được thực hiện vì một thao tác có nghĩa là thời gian không đổi, độ phức tạp. Và hoạt động này sẽ giảm vì một.

218
00:02:17,930 --> 00:02:28,140
Điều đó có nghĩa thời gian không đổi, sự phức tạp. Đây là tất cả về hoạt động chèn. Bây giờ hãy nói về hoạt động của OPNET. Đây là người đại diện cho hoạt động ABC.

219
00:02:28,160 --> 00:02:41,000
Thật đơn giản khi bạn được giao khu vực này. Chúng tôi muốn cập nhật giá trị trong mảng này. Đó là bản cập nhật Original Five tại Indexed. Bạn biết đấy, chúng ta sẽ đạt đến chỉ số 0, chúng ta sẽ thay thế phần tử đó bằng phần tử 5.

220
00:02:41,180 --> 00:02:57,020
Vì vậy, hãy thay thế một bằng năm. Sau đó, chúng tôi nói cập nhật air one six ở chỉ số một, chúng tôi sẽ thay thế hai bằng sáu. Sau đó chúng ta nói, cập nhật hai, bảy, tám, hai, chúng ta sẽ thay ba bằng bảy.

221
00:02:58,630 --> 00:03:15,250
Một lần nữa, nếu chúng ta nói một chút, thương mại và công nghiệp của chúng ta, chúng ta sẽ thay thế bốn bằng tám và đây được gọi là các hoạt động cắt bỏ trong một lĩnh vực mà hoạt động trung bình này mất thời gian, độ phức tạp không đổi và hoạt động này cũng sẽ mất thời gian, độ phức tạp không đổi.

222
00:03:15,310 --> 00:03:26,050
Đây là tất cả về hoạt động của Abdelal. Chúng tôi có thể cập nhật bất kỳ và bị giới hạn bởi số chỉ mục, đại loại như chỉ số mảng này bằng giá trị. Bây giờ chúng ta sẽ nói về sự dẫn đầu.

223
00:03:26,090 --> 00:03:41,360
Hoạt động Dẫn hoạt động là siêu đơn giản. Ban đầu, khi chúng ta xây dựng một mảng trong Java, theo mặc định chúng ta có phần tử bằng 0. Nếu chúng ta thay thế phần tử bằng số 0.

224
00:03:41,890 --> 00:03:53,010
Điều đó có nghĩa là chúng tôi đã xóa phần tử. Hãy xem liệu chúng ta có thể thực hiện thao tác tương tự như thao tác cắt bỏ hay không. Chúng tôi chỉ thay thế phần tử bằng 0.

225
00:03:53,010 --> 00:04:06,750
Nếu chúng ta nói xóa Arimidex bằng 0, thì ban đầu nó sẽ chỉ thay thế một bằng 0 khi chúng ta khai báo lỗi. Chúng ta có tất cả phần tử bằng 0. Nếu chúng ta nói lại, hãy xóa mảng một.

226
00:04:06,970 --> 00:04:21,790
Vì vậy, chúng tôi sẽ xóa, thêm hai. Vì vậy, thay thế bằng số không. Nếu chúng ta nói nó là hai thì chúng ta sẽ thay ba bằng số không. Thay thế ở Eretria sẽ thay thế bốn bằng số không.

227
00:04:22,360 --> 00:04:34,570
Và đây được gọi là thao tác xóa trong một khu vực. Và thao tác này sẽ giảm độ phức tạp về
thời gian không đổi. Và đây là tất cả về thao tác chèn cập nhật và xóa trong một mảng. 

@@@



228
00:00:00,450 --> 00:00:12,210
Rất nhiều người sẽ quay lại video này trong video này, chúng ta sẽ nói về các thuật toán tìm kiếm, tìm kiếm nhị phân và tìm kiếm tuyến tính. Đầu tiên, chúng tôi sẽ xem tìm kiếm của bạn hoạt động được bao lâu.

229
00:00:12,510 --> 00:00:34,010
Sau đó chúng ta sẽ xem một tài nguyên hoạt động như thế nào. Sau đó, chúng tôi sẽ giải thích rằng sự phức tạp ngẫu nhiên của tìm kiếm nhị phân nhìn từ đầu đến cuối và chúng ta sẽ thấy trong phần cuối của video này, tìm kiếm tuyến tính sẽ quét mảng từ trái sang phải, từng cái một và điều đó sẽ diễn ra theo thời gian sự phức tạp.

230
00:00:34,230 --> 00:00:46,940
Và điều siêu đơn giản đó sẽ không hiển thị cho bạn mã tìm kiếm tuyến tính. Chúng tôi sẽ chỉ cho bạn cách hoạt động của tìm kiếm tuyến tính. Chúng ta có thể làm điều đó bằng cách đơn giản giảm 4 từ 0 xuống chiều dài của mảng.

231
00:00:47,970 --> 00:01:05,650
Và sau đó chúng tôi có thể kiểm tra xem chúng tôi có tìm thấy bất kỳ phần tử nào trong chỉ mục bị che hay không, sau đó sẽ trả về chỉ mục đó. Và đối với dịch vụ nhị phân, bạn sẽ thấy mọi thông tin bạn cần để hiểu tìm kiếm nhị phân và trong giới hạn, tài nguyên chỉ dành cho mảng được sắp xếp.

232
00:01:06,000 --> 00:01:16,790
Chúng ta có thể thực hiện tìm kiếm tuyến tính cho bất kỳ loại mảng nào và trong video này, tất cả đều tập trung vào tìm kiếm nhị phân cũng như cách hoạt động của tìm kiếm nhị phân và mọi thứ. Bạn cần hiểu các thuật toán tìm kiếm nhị phân.

233
00:01:17,220 --> 00:01:33,480
Ngoài ra, chúng ta sẽ nói về các thuật toán tìm kiếm tuyến tính. Bây giờ hãy nói về tìm kiếm tuyến tính. Sau đó chúng ta sẽ nói về tìm kiếm nhị phân. Ví dụ: nếu bạn sống ở khu vực này và là mục tiêu, tất cả những gì chúng ta phải tìm ra chỉ số của phần tử mục tiêu.

234
00:01:34,140 --> 00:01:46,920
Nếu phần tử mục tiêu không tồn tại trong vùng, chúng ta sẽ trả về trừ một. Nếu mục tiêu này tồn tại trong mảng, chúng ta sẽ trả về chỉ mục của phần tử đó.

235
00:01:47,370 --> 00:01:57,780
Bạn có thể cho rằng mảng đã cho luôn được sắp xếp. Chúng ta có thể giải quyết vấn đề này bằng cách sử dụng tìm kiếm tuyến tính khá dễ dàng bằng cách kiểm tra từng phần tử lỗi.

236
00:01:58,080 --> 00:02:09,450
Hãy xem điều này thực sự hoạt động như thế nào. Đầu tiên, chúng ta sẽ kiểm tra phần tử đầu tiên. Một làm một bằng hai, ba, bốn, không. Vì vậy, chúng ta hãy đi đến yếu tố tiếp theo. Đó là ba Kolstad Takfir.

237
00:02:09,450 --> 00:02:20,550
Không, hãy chuyển sang phần tử tiếp theo. Đó là 5 bằng 34. Không, hãy chuyển sang phần tử tiếp theo. Độ tuổi có bằng nhiếp ảnh gia không? Không, hãy chuyển sang phần tử tiếp theo.

238
00:02:21,270 --> 00:02:37,710
12 không phải là hằng số. Tuy nhiên, chúng ta hãy đi đến phần tử tiếp theo. Bây giờ chúng ta thấy rằng phần tử hiện tại bằng đích. Vì vậy, trong trường hợp này, chỉ trả về chỉ số 5 và đây được gọi là thuật toán nguồn tuyến tính.

239
00:02:38,220 --> 00:02:54,300
Nguồn tuyến tính đều chiếm độ phức tạp về thời gian vì dự đoán đầu tiên chúng ta phải là phần tử một. Vì vậy, độ phức tạp về thời gian của Bekoff trong nguồn tuyến tính không phải là một thuật toán hiệu quả để tìm nguồn một phần tử trong một mảng.

240
00:02:54,750 --> 00:03:11,130
Bây giờ hãy nói về tìm kiếm nhị phân và cách thức hoạt động của nó. Được rồi, bây giờ chúng ta sẽ nói về giá trị nhị phân. Mục tiêu của chúng tôi là 34. Bây giờ chúng tôi phải phục vụ mục tiêu này trong lỗi này với độ phức tạp thời gian logarit.

241
00:03:11,130 --> 00:03:21,270
Đừng lo lắng về độ phức tạp thời gian logarit. Chúng ta sẽ nói chi tiết. Đầu tiên, những gì chúng ta sẽ làm. Chúng ta sẽ tìm phần tử ở giữa trong khu vực này.

242
00:03:21,270 --> 00:03:33,390
Phần tử ở giữa là tám. Bây giờ, mục tiêu của chúng ta là đưa tám số bằng đó vào mục tiêu. Không, bây giờ chúng ta sẽ lấy tám cái đó ít hơn Target. Vâng, đúng vậy.

243
00:03:33,660 --> 00:03:46,580
Nếu phần giữa nhỏ hơn mục tiêu thì chúng tôi sẽ loại bỏ tất cả phần tử ở bên trái, bao gồm cả phần tử ở giữa. Được rồi, chúng tôi đã loại bỏ phần bên trái.

244
00:03:46,810 --> 00:04:00,960
Bây giờ chúng ta hãy tìm hiểu ở giữa khu vực này, Trung Đông, 34, và chúng ta thấy rằng chúng ta đã tìm thấy mục tiêu ở khu vực này. Trong trường hợp này, bạn phải trả lại điều đó khi tìm kiếm trường tiểu học này.

245
00:04:01,330 --> 00:04:11,860
Được rồi. Và đây thực sự là cách hoạt động. Đừng lo lắng. Chúng ta sẽ xem làm thế nào chúng ta có thể tìm thấy phần tử ở giữa. Chúng tôi được giao khu vực và mục tiêu này. Nó tiến tới 34.

246
00:04:12,010 --> 00:04:33,540
Nếu chúng ta chia khu vực này theo phần tử thì sẽ như thế này. Sau đó, nếu chúng ta chia mảng này bằng cách sử dụng sơ cấp trung gian này, thì chúng ta sẽ được như thế này. Được rồi, nếu chúng ta chia sabari này cho phần tử ở giữa, thì bạn sẽ được như thế này.

247
00:04:33,870 --> 00:04:47,400
OK, bây giờ chúng ta thấy đây là đường tìm kiếm nhị phân. Bây giờ điều này thực sự hoạt động như thế nào. Bây giờ, hãy để tôi hỏi bạn một câu hỏi. Làm thế nào để bạn tìm kiếm giá trị đích trong mạch nhị phân?

248
00:04:48,000 --> 00:05:01,100
Đầu tiên, bạn kiểm tra giá trị của nút và giá trị đích. Nếu giá trị đích lớn hơn giá trị của ghi chú, giá trị đó sẽ chuyển đến cây con bên phải.

249
00:05:01,200 --> 00:05:12,660
Nếu chúng tôi thấy mục tiêu nhỏ hơn giá trị của nút thì sẽ chuyển sang cây con bên trái và chúng tôi tiếp tục thực hiện quy trình đó cho đến khi tìm thấy giá trị mục tiêu của mình.

250
00:05:12,720 --> 00:05:24,130
Được rồi, bây giờ chúng ta hãy thử làm quen với mạch nhị phân này. Đầu tiên, chúng ta sẽ lấy 8 và 12 nhân 12 lớn hơn 8. Vâng, đúng vậy. Vì vậy chúng ta hãy đi tới cây con bên phải.

251
00:05:24,360 --> 00:05:38,760
Bây giờ hãy kiểm tra mục tiêu của nó. Và việc nhắm mục tiêu nhỏ hơn 34 sẽ khó hơn rất nhiều. Vì vậy, nó sẽ chuyển sang cây con bên trái. Và chúng tôi đã tìm thấy phần tử này, bạn thấy ở đây, chúng tôi đã tìm thấy 12 x 3 bước.

252
00:05:39,000 --> 00:05:54,020
Được rồi, một bước. Hai bước, hai bước. Chúng ta không cần phải thăm hết tất cả các yếu tố mà chỉ cần thăm quan ba yếu tố. Được rồi, bây giờ hãy xem làm thế nào chúng ta có thể tìm được mục tiêu 5 người trong ngành khai thác mỏ.

253
00:05:54,910 --> 00:06:06,090
Chúng tôi có mục tiêu của bạn. Bạn phải chiến đấu trước. Chúng tôi sẽ kiểm tra nó và thấy mục tiêu lớn hơn tám. Không. Vậy hãy chuyển sang cây con bên trái. Đó là năm lớn hơn ba.

254
00:06:06,130 --> 00:06:18,610
Vâng, đúng vậy. Vì vậy chúng ta hãy đi tới cây con bên phải. Và chúng tôi đã tìm thấy số năm màu vàng này và đây là cách chúng tôi có thể phục vụ nó. Mục tiêu trong thuật toán tìm kiếm nhị phân Sastry nhị phân hoạt động chính xác như thế này.

255
00:06:18,640 --> 00:06:32,980
Bây giờ hãy xem cách chúng ta có thể tìm thấy chỉ mục của phần tử mục tiêu trong một mảng. Chúng ta sẽ tìm chỉ mục cho Target 34. OK, đầu tiên chúng ta sẽ khai báo hai điểm một trái và một phải trái cho phần tử đầu tiên và điểm phải cho phần tử cuối cùng.

256
00:06:33,190 --> 00:06:44,880
Thế thì chúng ta sẽ tìm chỗ giữa và đây là chỗ giữa của chúng ta. Cách tìm phần giữa, chúng ta có thể tìm phần giữa bằng cách thực hiện một công thức cộng đơn giản. Phải. Chia nó bằng không sáu chia cho ba.

257
00:06:44,890 --> 00:06:53,950
Vì vậy, đây là giữa của chúng tôi. Bây giờ chúng ta sẽ kiểm tra xem mục tiêu có lớn hơn phần giữa này không. Vâng, đúng vậy. Vì vậy, nó sẽ di chuyển con trỏ bên trái sang lớp giữa.

258
00:06:54,250 --> 00:07:06,730
Vì vậy, con trỏ nhỏ sẽ trỏ đến phần tử 12 này. Bây giờ, mục tiêu của chúng ta là tìm điểm giữa của khu vực này. Được rồi, vậy bốn cộng sáu chia cho năm. Vậy ba, bốn là ở giữa của chúng ta.

259
00:07:07,270 --> 00:07:27,570
Bây giờ chúng ta sẽ lấy mục tiêu này bằng 34. Đúng vậy. Vì vậy nó sẽ trả về chỉ mục của mục tiêu này. Vì vậy, chúng tôi sẽ trả về chỉ mục của phần tử này là năm và đây là cách chúng tôi có thể làm một phần tử trong một mảng bằng cách sử dụng tìm kiếm nhị phân và số lượng nhân viên chúng tôi đã thực hiện.

260
00:07:27,670 --> 00:07:40,590
Vì vậy, chúng tôi đã tìm thấy 34 vào thứ Ba, chỉ vào thứ Ba. Chúng ta không cần phải duyệt toàn bộ mảng để tìm giá trị. Tuy nhiên, chúng tôi đã tìm thấy bằng cách thực hiện để lưu mô hình này và mô hình này.

261
00:07:40,890 --> 00:07:54,270
Và đây là cách chúng ta có thể đóng vai trò là một phần tử trong mảng bằng cách sử dụng tìm kiếm nhị phân. Bây giờ, hãy để tôi chỉ cho bạn cách nó thực sự hoạt động bằng cách sử dụng mã giả. Đầu tiên, chúng ta sẽ khai báo một hàm lấy một mảng và một mục tiêu làm đầu vào.

262
00:07:54,480 --> 00:08:05,760
Nguồn quản lý mảng được sắp xếp không hoạt động đối với mảng chưa được sắp xếp. Mảng phải được sắp xếp. Sau đó, chúng ta sẽ trỏ điểm trái và điểm phải bên trái vào phần tử đầu tiên.

263
00:08:05,770 --> 00:08:17,250
Điểm đúng đến phần tử cuối cùng. Chúng ta sẽ định giá trị cho đến khi trễ nhỏ hơn hoặc bằng. Ngay sau đó chúng ta sẽ tính phần giữa không có môi cộng với chia lại hai.

264
00:08:17,580 --> 00:08:39,380
Sau đó chúng ta sẽ lấy phần tử ở giữa làm mục tiêu rồi sẽ trả về chỉ mục của phần tử ở giữa. Nếu không, chúng tôi sẽ kiểm tra xem mục tiêu có lớn hơn phần giữa hay không và sau đó chúng tôi sẽ di chuyển con trỏ nhỏ đến phần giữa phía trên tiếp theo, nếu không, chúng tôi sẽ di chuyển con trỏ bên phải đến phần giữa phía trên bên trái ở cuối.

265
00:08:39,380 --> 00:08:54,150
Nếu chúng tôi không tìm thấy mục tiêu này trong khu vực thì sẽ bị trừ một. Bây giờ, hãy xem cách thức hoạt động của nó hoặc cho mảng này và mục tiêu 34, chúng ta phải tìm chỉ mục của giá trị mục tiêu này trong khu vực này.

266
00:08:54,740 --> 00:09:05,840
Đầu tiên, chúng ta sẽ phải chỉ sang trái và phải. Sau đó chúng ta sẽ tìm số ở giữa và số 8 ở giữa. Sau đó chúng tôi sẽ kiểm tra. Phần tử ở giữa có bằng phần tử mục tiêu của chúng ta không?

267
00:09:06,020 --> 00:09:16,550
Không, nó không bằng Tarifa. Sau đó, chúng ta sẽ kiểm tra xem mục tiêu có lớn hơn phần tử ở giữa hay không và sẽ di chuyển sang trái đến phần giữa phía trên tiếp theo. Và chúng ta thấy rằng 34 lớn hơn 8.

268
00:09:16,550 --> 00:09:33,030
Vì vậy, nó sẽ di chuyển sang trái sang giữa. Sau đó chúng ta sẽ tính toán phần giữa cho việc này. Tóm lại, OK, và phần giữa, trong trường hợp này là 34, hiện tại, chúng ta thấy rằng 34 bằng mục tiêu nên nó sẽ trả về phần giữa.

269
00:09:33,210 --> 00:09:48,810
Vì vậy, nó sẽ trả về chỉ số năm nếu chúng ta thấy giá trị mục tiêu không điều chỉnh trong vùng này, sẽ chỉ trả về trừ một. Nếu mục tiêu không tồn tại trong khu vực nhất định thì điều kiện này sẽ không bao giờ đúng, nếu bị cáo buộc.

270
00:09:49,050 --> 00:10:02,660
Đối với đầu vào này, nó sẽ trả về năm. Năm là chỉ số của 134, đó cũng là mục tiêu của chúng tôi. Bây giờ chúng ta hãy xem độ phức tạp về thời gian của bài toán này trong lần lặp đầu tiên, độ dài của các vùng trong đó.

271
00:10:03,880 --> 00:10:27,700
Đó là lỗi của con người và chúng ta có thể làm như thế này trong cách xem xét đầu tiên, vùng đất tự do sẽ thuộc về vì đã đến lúc chia diện tích cho hai bước nhảy cho lần lặp thứ ba và chia cho lần lặp thứ tư và chia tám người đang chia khu vực đó cho hai bước nhảy là thời gian để lặp lại Kett.

272
00:10:28,090 --> 00:10:44,490
Khu đất sẽ được mời đến Bộ phận chăm sóc sau công viên. Chiều dài của khu vực sẽ là một. Trong bộ đó, con trỏ bên trái, điểm bên phải và điểm giữa sẽ trỏ đến cùng một phần tử, khi đó độ dài của mảng cần xem xét sẽ là một.

273
00:10:44,670 --> 00:10:57,480
Sau đó, nếu bạn thực hiện phép tính này để loại bỏ độ phức tạp về thời gian, hãy xem đến cuối. Đúng
không các bạn? Vì vậy, tất cả điều này gây ra sự phức tạp trong Thời gian cuối và chi phí liên tục. 

@@@



274
00:00:00,780 --> 00:00:20,120
Rất nhiều người sẽ quay lại video này trong video này, chúng ta sẽ nói về cách chúng ta có thể tạo ra khu vực này để tạo một nhóm tham chiếu để tuyên bố trong Tuyên bố về cơn thịnh nộ, chúng ta sẽ tạo một tham chiếu đến sau đó một mảng trong quá trình khởi tạo sẽ tạo ra một mảng, sau đó sẽ được khởi tạo.

275
00:00:20,700 --> 00:00:35,620
Sau đó trong quá trình khởi tạo, Frade sẽ gán giá trị cho vùng đó. Trong phần khai báo, Freij sẽ khai báo một mảng, đại loại như thế này, kiểu từ dấu ngoặc vuông đến dấu ngoặc vuông ở đây, sau đó là từ viết tắt, vì đây là mảng hai chiều.

276
00:00:36,630 --> 00:00:50,500
Đây là ví dụ khai báo của chúng ta trong ngoặc vuông, ngoặc vuông. Sau đó, tên của mảng trong tủ khởi tạo sẽ tạo một mảng và gán mảng đó cho tham chiếu khai báo của chúng ta.

277
00:00:51,390 --> 00:01:08,210
Và đây là ví dụ về số đếm cho mục nhập mới để theo dõi số hàng và cột tăng số của nó. Và đây là ví dụ về ba hàng và hai cột thành mảng thành mảng còn gọi là Matrix.

278
00:01:08,580 --> 00:01:28,650
Sau đó, việc khởi tạo Freij sẽ gán giá trị cho mảng. Một cái gì đó như thế này, chúng ta có chỉ số 0 tại chỉ số 0 và 0, chúng ta có một ở chỉ số làm tròn cột 0, chúng ta có hai ở chỉ mục hàng, một cột, chúng ta có ba.

279
00:01:29,190 --> 00:01:45,210
Chỉ mục Net trên chỉ mục cột chỉ khả dụng cho chỉ mục A2 hai sau chúng tôi có năm ở mức bốn, chỉ mục hai và chỉ mục cột một. Chúng ta có sáu hoặc chúng ta có thể khai báo, khởi tạo và khởi tạo bằng cách sử dụng một câu lệnh, đại loại như thế này.

280
00:01:45,720 --> 00:02:05,040
Và cái này tương tự như cái này esteve cái này được rút gọn. Đây là cách chúng ta có thể tạo ra một lý thuyết. Hãy để thời gian phức tạp. Thao tác này mất thời gian không đổi trong suốt thời gian của mảng, sau đó để tạo văn bản gốc cũng hạn chế thời gian.

281
00:02:05,850 --> 00:02:20,220
Sau đó, chúng ta sẽ khởi tạo mảng, sau đó chúng ta sẽ khởi tạo mảng ở đây. Hoạt động của nó sẽ khiến Spiga trở nên phức tạp một thời. Điều đó có nghĩa là sẽ mất thời gian liên tục và phức tạp.

282
00:02:20,670 --> 00:02:43,990
Và ở đây chúng ta thấy chúng ta có sáu bước. Chúng tôi thực hiện sáu hoạt động của họ, chúng tôi có sáu hoạt động. Vì vậy, độ phức tạp về thời gian tổng thể là do cuộc gọi lần. Ở đây chúng ta thấy ba lần ba lệnh gọi tới six và ở đây chúng ta có sáu thao tác hoặc chúng ta khai báo, khởi tạo và khởi tạo vùng trong một câu lệnh.

283
00:02:43,990 --> 00:02:55,650
Thế thì phải mất thời gian liên tục, phức tạp. Chúng ta đã hiểu khái niệm gì, chúng ta có
thể tạo ra mảng như thế nào. Cảm ơn đã xem video này. Cũng trong video tiếp theo. 

@@@



284
00:00:00,650 --> 00:00:12,580
Rất nhiều người sẽ quay lại video này trong video này hoặc thực hiện các thao tác chèn và cập nhật vào khu vực sẽ đi vào khu vực này. Điều này sẽ được thể hiện, đại loại như thế này.

285
00:00:12,590 --> 00:00:35,600
Chúng tôi có ba hàng và hai cột. Bây giờ hãy nói về hoạt động. Đây là mã cho hoạt động. Hàm này sẽ loại bỏ và hủy bỏ chỉ mục X và cột, đồng thời nó sẽ trả về bất kỳ giá trị nào chúng ta có tại chỉ mục X và cột bị hủy hoại mà bạn đã cho mảng EBC này bằng mảng số 0.

286
00:00:35,600 --> 00:00:50,510
Mảng này có nghĩa là mảng này và nó đã hủy hoại X 0 và nó chỉ ra rằng chúng ta có giá trị nên nó được trả về dạng mỏng ở chỉ số một cột cuối cùng, chúng ta có giá trị bốn.

287
00:00:50,510 --> 00:01:04,750
Vì vậy, nó sẽ trả về giá trị cho chỉ số hai và cột của Adirondacks bằng 0. Nó sẽ trở lại. Giá trị của hàm này sẽ nói lên độ phức tạp một lần và thao tác này cũng có độ phức tạp theo thời gian không đổi.

288
00:01:04,850 --> 00:01:16,880
Vì vậy, độ phức tạp về thời gian tổng thể lớn hơn một. Bây giờ hãy nói về thao tác chèn. Đây là chức năng chèn của chúng tôi, nó sẽ đọc chỉ mục, sau đó là chỉ mục cột.

289
00:01:16,880 --> 00:01:29,120
Và đánh giá rằng chúng ta phải chèn vào thì chúng ta đã làm xáo trộn và làm hỏng cột này về mục lục. Chà, giả sử chúng ta được cho cái này trống. Để nhắc lại, chúng ta phải điền vào mảng này một số giá trị.

290
00:01:29,570 --> 00:01:44,880
Nếu chúng ta nói chèn bản gốc khi làm tròn số 0, hãy chèn một số 0, chèn một số 0 ở cột chỉ số 0, lập chỉ mục UNSNAPPED, chèn hai, sau đó thêm hoặc lập chỉ mục một cột chỉ số 0.

291
00:01:44,880 --> 00:02:01,550
Chúng ta phải chèn số ba, sau đó chỉ mục ADIRU vào cột đó. Chỉ mục một chúng ta phải chèn để sau đó tại chỉ mục 0 để chèn năm, sau đó tại chỉ mục hai và chỉ mục cột một, chúng ta phải chèn sáu.

292
00:02:01,820 --> 00:02:12,560
Và đây là cách chúng ta có thể chèn phần tử thứ hai để sắp xếp lại phần tử này vào văn bản hoạt động có độ phức tạp một lần. Và hoạt động này cũng phản ánh sự phức tạp một thời.

293
00:02:12,920 --> 00:02:30,140
Và nếu chúng ta cộng tất cả các thao tác thì sẽ mất độ phức tạp về thời gian của cột Spiga of Rule Times vì ​​chúng ta có các hàm ở đây. Vì vậy, thuật ngữ độ phức tạp đối với các hàm này có cấp độ lớn hơn bởi vì nó cần thực hiện một thao tác tại một thời điểm, bất kể là gì.

294
00:02:30,140 --> 00:02:42,230
Nếu chúng ta sử dụng vòng lặp để chèn giá trị thì sẽ mất M lần độ phức tạp về thời gian, nghĩa là số hàng và số cột.

295
00:02:42,440 --> 00:03:08,570
Và hãy nói về hoạt động Abduh năm nay. Khoảng năm nay được gọi là Visual CustomMade Ablate Operation ABC Ablate 00 tại Rentech. Chúng ta sẽ cập nhật giá trị bằng bảy, sau đó nếu chúng ta nói Aberdare một tám ở chỉ số một cột được lập chỉ mục một, chúng ta sẽ thay thế hai giá trị này bằng tám đến tám.

296
00:03:08,990 --> 00:03:26,050
Nếu chúng ta nói đến hàng ở Riddick's two và chúng ta sẽ cập nhật nó chín thành RBD đó năm với chín nếu chúng ta nói một một mười tại chỉ mục trên và cột của Riddick hoặc học cách cập nhật trong vòng hai năm, chúng ta sẽ phải phát triển với mười .

297
00:03:26,840 --> 00:03:35,600
Và đây là cách chúng ta có thể đáp ứng các hoạt động cắt bỏ và các hoạt động này sẽ mất nhiều thời gian. Và hoạt động này cũng khiến Bego trở nên phức tạp hơn bao giờ hết.

298
00:03:35,900 --> 00:03:47,270
Đây là những hằng số. Việc này mất nhiều thời gian và độ phức tạp mà chúng tôi có thể cập nhật và bổ sung
vào khu vực. Được rồi, các bạn, cảm ơn vì đã xem video này. Tôi sẽ gặp bạn trong video tiếp theo. 

@@@



299
00:00:00,720 --> 00:00:10,230
Rất nhiều chàng trai sẽ quay lại video này trong video này. Hãy xem làm thế nào chúng ta có thể đến khu vực mà bạn được cung cấp mảng ba hàng và hai cột này.

300
00:00:10,560 --> 00:00:20,340
Và tất cả đều được thể hiện, đại loại như thế này. Một, hai, ba, bốn, năm, sáu. Chúng tôi có chỉ mục cột và chúng tôi có chỉ mục của chúng. Và hãy xem liệu chúng ta có thể đi qua khu vực này không.

301
00:00:22,220 --> 00:00:34,700
Đoạn mã để đi qua mảng rối loạn chức năng lấy mảng, sau đó chúng ta có quy tắc gọi đường theo chiều dài cánh tay và nó sẽ trả về số lượng đường mà chúng ta đã có cột.

302
00:00:35,570 --> 00:00:48,070
Nó trả về chiều dài của cột. Sau đó, chúng tôi chạy một vòng để đưa tôi từ nhà tù này sang phòng trừ một. Trừ một. Ở đây chúng ta có ba hàng, vậy độ dài của các hàng là ba.

303
00:00:48,470 --> 00:01:03,350
Vậy ba trừ một bằng hai. Vì vậy chúng ta sẽ lặp lại từ 0 đến 2. Sau đó chúng ta có cái này ở Aluf trong vòng lặp này. Chúng ta có bốn năm từ con số 0 đến Haltzman. Chúng ta cũng hãy lặp từ 0 đến 1 và sau đó chỉ in phần tử hiện tại.

304
00:01:04,580 --> 00:01:15,500
Ở đây chúng ta có phép lặp, chúng ta chia nhỏ phép lặp. Tôi đi đến không không hai không bốn. Tôi đi ghi âm. Nó sẽ in một, rồi bốn. Tôi đi đến địa chất hai đến một.

305
00:01:15,500 --> 00:01:31,890
Nó sẽ in hai. Sau đó tôi đi đến một mã zip để tạo sẽ in ba. Khi đó Eggleston bằng 1, nó sẽ in ra cho bạn xem chỉ mục của Mũi tên và đó là chỉ mục của cột.

306
00:01:33,580 --> 00:01:48,130
Vì vậy, tôi muốn gặp toán tử chỉ mục, một toán tử có một đầu. Các cuộc gọi đến một có nghĩa là chỉ số màu và có một. Vậy một một ở đây chúng ta thấy bốn, rồi bốn.

307
00:01:48,130 --> 00:02:00,460
Tôi đi làm và họ làm mà chúng tôi có năm, rồi bốn bằng gần một. Chúng ta có nguyên tố thứ sáu này và bạc chống lại các tòa tháp trong khu vực. Điều này cực kỳ đơn giản.

308
00:02:01,790 --> 00:02:10,210
Chúng tôi hiểu làm thế nào những kẻ khủng bố có thể viết lại mã này. Tôi có mã nguồn của video này. Chúng ta có thể kiểm tra nó ngay bây giờ. Chúng ta hãy xem sự phức tạp về thời gian.

309
00:02:11,650 --> 00:02:24,190
Bây giờ chúng ta phải tính độ phức tạp thời gian cho hàm này. Hoạt động này tất cả đều mất thời gian liên tục. Thao tác này sẽ mất thời gian không đổi và việc loof này sẽ mất một chút thời gian.

310
00:02:24,640 --> 00:02:36,820
Và điều này sẽ xảy ra vì sự phức tạp theo thời gian. Và thao tác này sẽ loại bỏ Bego một thao tác có nghĩa là độ phức tạp về thời gian không đổi. Bốn lần lặp lại của tình yêu này.

311
00:02:37,270 --> 00:02:52,830
Vòng lặp này sẽ lặp lại. Số lần được gọi, số lần, nếu có bản ghi người gọi, hai, ba, bốn là lần lặp của tình yêu này, vòng lặp này sẽ lặp lại ba lần.

312
00:02:54,030 --> 00:03:14,250
Vì vậy, đơn giản là chúng ta có thể làm một phép toán ở đây để phân tích độ phức tạp. Giả sử rằng chúng ta thực hiện ba cuộc gọi chất lượng, hai đến bốn lần lặp lại điều này. Aluf, Innaloo sẽ thực thi hai lần vì các cột là hai, rồi bốn.

313
00:03:15,180 --> 00:03:40,200
Ba lần lặp lại tình yêu này trong một tình yêu được thực hiện sáu lần đơn giản, bạn có thể biết liệu tình yêu này có được thực hiện khi tình yêu ban đầu sẽ thực hiện theo cột lần để chúng ta có thể nhìn thấy hoặc xem liệu tình yêu của chúng ta có được thực hiện vào những thời điểm mà chúng ta yêu nhau hay không chưa biết thì sáng kiến ​​sẽ được thực hiện.

314
00:03:40,560 --> 00:03:57,320
Ba lần đều đúng. Vì vậy, chúng ta có thể xem thời gian. Độ phức tạp của cột lớn hơn, thời gian để quy tắc hoặc quy tắc lần cột. Vì vậy độ phức tạp về thời gian của thuật toán này là do cột Rule Times.

315
00:03:57,920 --> 00:04:11,410
Chúng tôi đã hiểu thời gian, độ phức tạp, phân tích nó và bạn chỉ cần in phần tử. Nó sẽ không
tốn thêm bất kỳ tốc độ nào. Vì vậy, tất cả đều có độ phức tạp không gian không đổi. 

@@@



316
00:00:00,660 --> 00:00:15,320
Trong video này, chúng ta sẽ giải bài toán một độ, di chuyển các số 0, cho trước một số, phải, một hàm để di chuyển tất cả bồi thẩm đoàn về cuối nó trong khi vẫn giữ nguyên thứ tự của phần tử khác 0 đó để giải bài toán này theo cam kết.

317
00:00:15,330 --> 00:00:26,570
Chúng tôi không thể sử dụng thêm bất kỳ không gian nào ngay cả với khu vực này. Chúng ta đánh giá cao tất cả số 0 ở bên phải bằng cách duy trì thứ tự tương đối của các phần tử khác 0.

318
00:00:27,120 --> 00:00:39,480
Vì vậy, tôi thực sự tin vào một cái gì đó như thế này. Ở đây chúng ta có phần tử và chúng ta đã dịch chuyển và dịch chuyển sang phải. Và nếu bạn được cung cấp thông tin đầu vào này thì sao?

319
00:00:39,540 --> 00:00:56,030
Chúng ta nên quay lại, phải không? Vì vậy, đầu tiên chúng ta có một, sau đó chúng ta có ba, rồi chúng ta có 12, rồi nguy hiểm. Được rồi, chúng ta nên trả lại lỗi này để có thể giải quyết vấn đề này.

320
00:00:56,400 --> 00:01:13,470
Ngoài ra, chúng ta phải giải quyết vấn đề này với độ phức tạp lớn hơn về mặt thời gian. Được rồi, hãy xem tôi nghĩ thế nào về vấn đề này. Nếu bạn đưa ra lỗi cụ thể này thì chúng tôi sẽ bắt đầu tìm kiếm.

321
00:01:13,800 --> 00:01:29,120
Phần tử khác 0 ở đây là phần tử khác 0. Vì vậy nó sẽ thay thế phần tử này ở chỉ số 0. Vì vậy, chúng tôi có giá trị chỉ số kép bằng không. Vì vậy, chúng tôi sẽ thay thế nó bằng giá trị.

322
00:01:29,490 --> 00:01:41,910
OK, sau đó chúng ta thấy chúng ta có Dira, sau đó tôi thấy phần tử khác 0. Vì vậy, chúng ta sẽ phản ánh phần tử ở chỉ mục một. Được rồi, vậy chúng ta sẽ thay thế cái này bằng ba.

323
00:01:42,920 --> 00:02:12,330
Ngay sau đó chúng ta thấy số 12 cũng là phần tử khác 0. Vì vậy, chúng ta sẽ phản ánh điều này với số 12. Sau đó, chúng ta thấy điều đó được phản ánh đối với phần tử, sau đó chúng ta sẽ thay thế cách xử lý bằng Jairus, OK, và đây là tỷ lệ lỗi được sửa đổi của chúng ta và đây là cách chúng ta sẽ giải quyết vấn đề này.

324
00:02:12,720 --> 00:02:26,990
Bây giờ chúng ta hãy xem mã giả. Đầu tiên, tôi sẽ khai báo một hàm di chuyển con quay lấy một mảng nums để dễ hiểu. Giả sử đây là mảng đã cho của chúng tôi.

325
00:02:28,050 --> 00:02:44,160
Sau đó, chúng ta có một biến hiện được gọi là 0. Nó chỉ đến đơn vị đầu tiên trong khu vực của chúng ta xuyên qua chỉ ngay ở đây. Sau đó chúng tôi sẽ chạy nó trực tiếp từ số 0 đến Len No.

326
00:02:44,180 --> 00:02:58,410
Spinetta một. Sau đó, chúng ta sẽ kiểm tra xem phần tử hiện tại có bằng 0 trong khoảng thời gian đầu tiên của vòng lặp này hay không, chúng ta thấy phần tử này bằng 0. Vì vậy điều kiện này không nhiều.

327
00:02:59,190 --> 00:03:14,520
Sau đó, cho lần lặp tiếp theo, chúng tôi có một. Phải? Vì vậy, điều kiện này phù hợp, sau đó điều chúng ta sắp làm là thay đổi dero này thành một. Được rồi, vậy hãy chơi trò này với một người.

328
00:03:15,740 --> 00:03:33,630
Được rồi, chúng ta sẽ thay đổi dòng điện thành phần tử này ngay tại đây cho lần lặp tiếp theo. Chúng tôi đã làm như vậy điều kiện này là sai. Sau đó, ở lần lặp tiếp theo, chúng ta có ba quyền với điều kiện này là khớp.

329
00:03:34,080 --> 00:03:44,310
Sau đó, chúng ta sẽ thay thế cái này bằng ba cái này, sau đó chúng ta sẽ thay đổi dòng điện thành phần tử này hoặc tại hai điểm hiện tại ngay tại đây.

330
00:03:45,420 --> 00:04:03,240
Sau đó, chúng ta có 12 tiếp theo. Vì vậy, nó tạo ra tuyên bố này, sau đó nó phản ánh điều này với 12. Được rồi, vậy là chúng ta đã xong với tình yêu này rồi. Bây giờ chúng ta hãy lấp đầy yếu tố này bằng những vết thương.

331
00:04:04,080 --> 00:04:23,280
Vì vậy, chúng tôi có một động thái khác ở đây đối với EI từ hiện tại sang quản lý cho vay. Được rồi, chuyển Eichhorst sang con quay hồi chuyển. Vì vậy, chúng tôi thay thế phần tử này bằng 0 và nó cũng sẽ thay thế phần tử này bằng 0.

332
00:04:24,390 --> 00:04:48,270
Ngay cuối cùng, chúng ta có mảng được sửa đổi này và đó là câu trả lời của chúng ta. Phải. Đây là giải pháp của chúng tôi cho vấn đề này. Giải pháp
sẽ cất cánh kịp thời. Độ phức tạp hoặc kết thúc là độ dài của mảng nhất định và nó cũng chiếm độ phức tạp không gian không đổi của khái niệm này. 

@@@



333
00:00:00,600 --> 00:00:11,100
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này. Video này sẽ giải quyết một vấn đề rất thú vị, loại bỏ các bản sao khỏi sắp xếp. Đây là bài toán mảng một chiều.

334
00:00:12,480 --> 00:00:26,610
Ngay cả một mảng được sắp xếp cũng loại bỏ các bản sao tại chỗ nói rằng ilmenite chỉ xuất hiện một lần và trả về cái mới. Tuyên bố vấn đề một chút khó hiểu.

335
00:00:27,030 --> 00:00:48,630
Ví dụ: nếu bạn được cung cấp mảng này, bạn sẽ trả về cái gì? Bạn phải trả về 5 vì trong vùng này chúng ta phải có 5 phần tử riêng biệt và dịch chuyển tất cả phần tử riêng biệt và chúng ta sẽ có tất cả phần tử chuỗi từ trái sang phải.

336
00:00:49,260 --> 00:01:08,610
Cho dù chúng ta có bao nhiêu phần tử riêng biệt trong mảng ở khu vực này, chúng ta vẫn có năm phần tử riêng biệt một, hai, ba, bốn, năm. Và năm phần tử riêng biệt mà chúng ta nên có trong mảng này và bên ngoài khu vực này là tám.

337
00:01:08,610 --> 00:01:20,400
Nhưng tầm nhìn của nguyên tố khác biệt ở khu vực này là năm. Từ chỉ số 0 đến chỉ số 4, chúng tôi có phần tử năm của bạn. Không có yếu tố lặp lại. Chúng ta phải giải quyết vấn đề này theo cách chia nhỏ.

338
00:01:20,580 --> 00:01:36,270
Chúng tôi không thể sử dụng bất kỳ công tắc bổ sung nào. Và chúng ta biết rằng phía mảng đã cố định. Chúng ta không thể thay đổi phía khu vực. Vì vậy, chúng ta phải thay đổi giá trị trong vùng này bằng phẳng ở bên trái với phần tử riêng biệt.

339
00:01:36,600 --> 00:01:53,170
Chúng ta không phải lo lắng về bất kỳ yếu tố nào chúng ta có ở phía bên phải. Chúng ta phải xóa phần tử riêng biệt ở bên trái từ bên trái. Được rồi, nếu bạn được cung cấp mảng này, chúng ta phải sửa đổi mảng này, đại loại như thế này và lặp lại độ dài của mảng cho phần tử riêng biệt.

340
00:01:53,220 --> 00:02:01,720
Đến đây chúng ta đã hiểu được vấn đề. Bây giờ hãy xem chúng ta có thể giải quyết vấn đề này như thế nào. Phải. Giả sử bạn được cung cấp mảng này để giải quyết vấn đề này một cách cơ bản.

341
00:02:01,740 --> 00:02:11,490
Đó là hai con trỏ. Con trỏ I sẽ trỏ đến phần tử đầu tiên và con trỏ ban đầu sẽ trỏ đến phần tử thứ hai. Bây giờ chúng ta sẽ làm gì?

342
00:02:11,500 --> 00:02:21,660
Chúng ta sẽ kiểm tra giá trị của hai con trỏ này. Mình đã chỉ trỏ vào phần tử này một và bạn đã chỉ, chỉ vào phần tử này một và giá trị bằng nhau, giá trị giống nhau sẽ di chuyển.

343
00:02:21,840 --> 00:02:31,530
Họ chỉ vào yếu tố tiếp theo. Vì vậy, hãy chuyển sang yếu tố tiếp theo. Trong trường hợp này, chúng ta thấy rằng giá trị mà tôi chỉ ra không giống nhau.

344
00:02:31,530 --> 00:02:45,990
Nếu chúng tôi nhận thấy giá trị không giống nhau thì chúng tôi sẽ chuyển nó sang phần tử tiếp theo và sẽ thay thế giá trị của con trỏ bằng giá trị của con trỏ. Vì vậy, nó sẽ thay thế một bằng hai.

345
00:02:45,990 --> 00:02:54,000
Vì vậy, hãy thay thế một bằng hai. Sau đó, trong các lần lặp tiếp theo, chúng ta sẽ di chuyển phần tử mà chúng trỏ đến phần tử tiếp theo, vì vậy hãy chuyển sang cách xử lý tiếp theo.

346
00:02:54,000 --> 00:03:03,300
Và chúng ta thấy rằng giá trị của con trỏ cũng như nhau. Vì vậy, hãy chuyển sang dây tóc tiếp theo và thay thế con trỏ phát triển bằng con trỏ. Chúng tôi phát triển con trỏ.

347
00:03:03,300 --> 00:03:15,780
Vì vậy, hãy thay thế nó ba. Và bây giờ hãy chuyển sang phần tử tiếp theo, chúng ta thấy rằng giá trị và phần tử được chỉ định giống nhau. Vậy hãy chuyển sang yếu tố tiếp theo đó là Porfiry và bạn không giống nhau.

348
00:03:15,790 --> 00:03:26,830
Vì vậy, hãy chuyển sang phần tử tiếp theo và thay thế giá trị của bộ chỉ định. Chúng ta phát triển con trỏ, vì vậy hãy thay thế giá trị này bằng 4 và chuyển sang phần tử tiếp theo.

349
00:03:26,830 --> 00:03:37,540
Và đó là năm. Năm và bốn không giống nhau. Vì vậy, hãy chuyển sang phần tử tiếp theo và thay thế giá trị của phần tử thứ ba này bằng năm và hãy chuyển nó sang phần tử tiếp theo.

350
00:03:37,810 --> 00:03:45,960
Và chúng ta thấy giá trị của năm và năm là như nhau. Vì vậy, không cần phải làm gì ở đây. Hãy chuyển sang phần tiếp theo và phần này nằm ngoài ranh giới của chúng ta. Vì vậy, chúng tôi đã hoàn thành bây giờ.

351
00:03:45,970 --> 00:04:00,160
Chúng tôi thấy rằng phần tải của chúng tôi được sắp xếp ở bên trái, nhưng chúng tôi không có sự trùng lặp, không có danh tiếng. Và độ dài của cái này là để đơn giản cộng một, và đó sẽ là độ dài của mảng bên trái.

352
00:04:00,520 --> 00:04:15,910
OK, vậy độ dài của mảng này là 5 từ chỉ số 0 đến 4, và chúng ta phải thúc đẩy một khu vực nhất định, đại loại như thế này, và chúng ta phải trả về độ dài mới của SOUTHBURY này và chúng ta không có phần tử riêng biệt.

353
00:04:16,210 --> 00:04:24,910
Đây là cách chúng ta có thể giải quyết vấn đề này. Bây giờ hãy xem cách chúng ta có thể triển khai giải pháp này bằng mã giả. Phải. Đây là mã giả của chúng tôi để giải quyết vấn đề này.

354
00:04:24,910 --> 00:04:35,020
Đầu tiên của chức năng này, loại bỏ, sao chép. Nó lấy đầu vào urías. Thực hiện kiểm tra. Nếu người cho vay bằng 0 thì sẽ trả về 0 hoặc khởi tạo con trỏ I.

355
00:04:35,020 --> 00:04:50,290
Tôi sẽ trỏ đến phần tử đầu tiên, sau đó là một con trỏ khác bên trong phần dự phòng này. Vì vậy, họ sẽ trỏ đến phần tử này một và sau đó chúng ta sẽ lặp từ phần tử này đến cuối bằng cách sử dụng phần tử này, lấy giá trị và chúng không giống như chúng ta thấy.

356
00:04:50,560 --> 00:05:00,580
Vì vậy, hãy chuyển sang yếu tố tiếp theo. Vì vậy họ sẽ chỉ vào phần tử này và chúng ta thấy một và ba không giống nhau. Vì vậy, hãy chuyển sang phần tiếp theo và thay thế giá trị của.

357
00:05:00,760 --> 00:05:10,870
Vì vậy, hãy thay thế giá trị của phần tử này bằng 3 cho lần lặp tiếp theo. Hãy chuyển sang phần tử tiếp theo sẽ trỏ đến phần tử thứ ba ngay tại đây.

358
00:05:11,410 --> 00:05:20,410
Vậy Jasen đang chỉ vào phần tử ba này và chúng ta thấy ba và ba giống nhau. Vì vậy, hãy chuyển sang phần tử tiếp theo một lần nữa. Và chúng ta thấy ba và năm giống nhau.

359
00:05:20,410 --> 00:05:31,690
Vì vậy, hãy chuyển nó sang phần tử tiếp theo. Tôi sẽ chỉ vào đây và chúng ta sẽ thay giá trị của nó bằng 5. Vì vậy, hãy thay thế ba cái này bằng năm. Trong lần lặp tiếp theo.

360
00:05:31,810 --> 00:05:48,070
Chúng ta sẽ chuyển sang phần tử tiếp theo. Chúng ta hãy chuyển sang phần tiếp theo. Chúng tôi có yếu tố mới. Chúng tôi ở ngoài mọi ranh giới. Và bức tường đầy những thứ này ở đây, vì bạn ở ngoài ranh giới khu vực ở đây, nên chúng tôi thấy chúng tôi không có danh tiếng gì về ilmenite và chiều dài là ba.

361
00:05:48,280 --> 00:06:02,230
Vậy chỉ số của là hai. Vậy hai cộng một là ba. Vì vậy, hàm này sẽ trả về ba cho khu vực đã cho này. Và đây là cách chúng ta có thể giải quyết vấn đề này, ngay cả khi hiểu tất cả đều khuyến khích bạn tự xem qua các ví dụ của mình thì sẽ hiểu.

362
00:06:02,650 --> 00:06:14,770
Đây là giải pháp của tôi cho vấn đề này. Giải pháp sẽ cất cánh kịp thời. Độ phức tạp hay kết thúc là độ dài của diện tích cho trước vì bất kể mảng nào từ trái sang phải một lần và giải pháp sẽ mất độ phức tạp không gian không đổi.

363
00:06:14,770 --> 00:06:30,400
Vì chúng tôi đang sửa đổi căn hộ ban đầu nên chúng tôi không phân bổ thêm bất kỳ không gian nào để giải quyết vấn đề này. Vì vậy, độ phức tạp về thời gian sẽ lớn hơn theo thứ tự trong của chúng ta và độ phức tạp của không gian cũng lớn hơn và độ phức tạp của không gian là thứ tự một.

364
00:06:30,670 --> 00:06:40,750
Điều đó có nghĩa là giải pháp có độ phức tạp không gian không đổi. Chúng ta đã hiểu chính lời giải
thích này. Nếu có bất kỳ câu hỏi nào bổ sung, hãy cho chúng tôi biết. Cảm ơn đã xem video này. 

@@@



365
00:00:00,720 --> 00:00:18,970
Chào mừng bạn quay trở lại với video này, bây giờ chúng ta sẽ giải quyết một câu hỏi phỏng vấn viết mã rất phổ biến, xoay hình ảnh. Đây là tuyên bố vấn đề. Bạn đã đưa ra lời mời vào Ma trận đại diện cho một hình ảnh, hãy xoay hình ảnh 90 độ theo chiều kim đồng hồ.

366
00:00:19,680 --> 00:00:37,360
Nhưng hạn chế đối với vấn đề này là chúng ta phải xoay hình ảnh theo cam kết, có nghĩa là chúng ta phải sửa đổi trực tiếp đầu vào thành Ma trận. Chúng tôi không thể phân bổ cái khác vào Ma trận để thực hiện phép quay.

367
00:00:38,130 --> 00:01:00,490
Được rồi. Và đây là tuyên bố vấn đề và đây là hạn chế đối với vấn đề này. Nếu bạn lấy số liệu cụ thể này làm đầu vào thì chúng tôi phải xoay số liệu này theo đồng hồ 90 độ, vì vậy cột đầu tiên này sẽ là hàng đầu tiên liên tiếp của chúng tôi, số liệu được xoay.

368
00:01:01,480 --> 00:01:16,700
Cột thứ hai sẽ là hàng thứ hai của chúng tôi. Cột thứ ba này sẽ là hàng thứ ba của chúng ta và nó sẽ như thế này. Được rồi, cột này là hàng đầu tiên của chúng ta. Cột này là hàng thứ hai của chúng tôi.

369
00:01:16,980 --> 00:01:35,040
Và chuyên mục này là Stargirl của chúng tôi. Được rồi, nếu bạn được cho bốn nhân bốn hoặc Ma trận như thế này, bạn xoay Ma trận này tám x 90 độ. Sau đó, cột đầu tiên này sẽ là cột đầu tiên của chúng ta trong ma trận xoay.

370
00:01:36,000 --> 00:01:53,000
Cột thứ hai sẽ là hàng thứ hai của chúng tôi. Cột thứ ba này sẽ là hàng thứ ba và cột thứ tư này sẽ là hàng thứ tư của chúng tôi. Vì vậy, nếu chúng ta xoay ma trận này 90 độ theo chiều kim đồng hồ thì chúng ta sẽ thấy ma trận này.

371
00:01:53,720 --> 00:02:08,080
Vì vậy, bạn nhìn thấy cuộc chiếm giữ đầu tiên thông qua cuộc bao vây, hàng thứ hai của chúng tôi, cuộc bao vây, hàng thứ ba của chúng tôi và cuộc bao vây. Hàng thứ tư của chúng tôi. Được rồi, bây giờ chúng ta có thể giải quyết vấn đề này như thế nào.

372
00:02:08,560 --> 00:02:21,190
Được rồi, giả sử rằng bạn được cung cấp mảng này làm đầu vào. Đầu tiên, điều chúng ta sắp làm là lật ma trận này theo đường chéo thứ hai.

373
00:02:21,220 --> 00:02:38,400
Đây là đường chéo thứ hai của chúng tôi. Nếu chúng ta lật ma trận này ở đường chéo thứ hai thì ma trận này sẽ thay đổi. Thế là bốn người sẽ đi đây và nó sẽ đi đây. Khi đó hai giá trị này sẽ được thay đổi.

374
00:02:38,920 --> 00:02:54,820
Chín sẽ đi đây và hai sẽ đi đây. Rồi cuối cùng là hai và sáu. Được rồi, sáu người sẽ đi đây, hai người sẽ đi đây. Được rồi. Sau khi lật ma trận này ở giây thứ hai, đường chéo sẽ nhận được ma trận này.

375
00:02:55,090 --> 00:03:08,440
Ma trận này có xoay chín mươi độ theo chiều kim đồng hồ không. Không. Vậy ma trận này vẫn chưa được quay. Làm thế nào bạn có thể xoay nó thực sự. Được rồi, để xoay nó chúng ta phải thực hiện thêm một thao tác nữa trong ma trận này.

376
00:03:08,650 --> 00:03:29,770
Chúng ta phải lật ma trận này theo chiều ngang. Và đây là phần giữa bên phải. Vì vậy chúng ta phải lật ma trận này ở giữa theo chiều ngang. Vì vậy, giá trị này sẽ được thực hiện ở giữa, sau đó việc hiển thị này sẽ được mở rộng ở giữa và cuộc đấu tranh ở mức ba và một sẽ chỉ ở giữa.

377
00:03:30,100 --> 00:03:50,620
Vậy chúng ta đi đây. Chúng ta đi đây. Bốn người sẽ đi đây, sáu người sẽ đi đây, một người sẽ đi đây và ba người sẽ đi đây. OK, sau đó chúng ta sẽ có ma trận này và đây là ma trận xoay 90 độ theo chiều kim đồng hồ mà chúng ta phải trả về, OK, và chúng ta phải thực hiện tất cả Operation Inflate này.

378
00:03:50,620 --> 00:04:02,770
Chúng tôi không thể phân bổ cái khác vào Ma trận để giải quyết vấn đề này. Được rồi. Về cơ bản, chúng ta sẽ lật ma trận theo đường chéo thứ hai, sau đó chúng ta sẽ lật ma trận theo chiều ngang.

379
00:04:02,920 --> 00:04:13,750
Vậy đầu tiên chúng ta phải lật một giây theo đường chéo, sau đó chúng ta phải lật theo chiều ngang. OK, nếu bạn được cung cấp bởi ma trận thứ tự kém, bạn có thể xoay ma trận này như thế nào.

380
00:04:13,960 --> 00:04:22,870
Vậy đây là đường chéo thứ hai của ma trận này, phải không? Vì vậy, chúng ta phải lật ma trận này theo đường chéo này, thì giá trị này sẽ thực sự nằm ở giữa.

381
00:04:23,380 --> 00:04:41,170
Khi đó có hai giá trị, hai và hai sẽ được đổi chỗ, rồi năm và 16 sẽ được đổi chỗ. Rồi có hai, một và bảy sẽ chỉ là chín và mười sẽ có cơ hội ở giữa rồi bốn và sáu sẽ được đổi ở giữa.

382
00:04:41,380 --> 00:04:57,160
Khi ta lật ma trận này theo đường chéo thì ta sẽ được ma trận này. Chúng ta thấy rằng đây không phải là ma trận xoay chín mươi độ theo chiều kim đồng hồ. Để có được ma trận xoay chín mươi độ theo chiều kim đồng hồ, chúng ta phải lật ma trận này theo chiều ngang.

383
00:04:57,160 --> 00:05:11,560
Vì vậy đây là phần giữa. Nếu chúng ta lật ma trận này, thì công cụ này và mười bốn cái này sẽ được hiện thực hóa, rồi sáu và ba. Được rồi, tám và bốn, rồi chín và một.

384
00:05:11,830 --> 00:05:29,170
Vì vậy, tất cả sẽ đi đến đây. Mười bốn sẽ đến đây, sáu sẽ đến đây, ba sẽ đến đây, rồi tám và đối với chín và chín và một thì bạn phải kéo dài mười sáu và mười lăm, rồi bảy rồi mười và hai.

385
00:05:29,290 --> 00:05:44,290
Cuối cùng bạn giành chiến thắng và năm. Và đây là ma trận của chúng tôi. Để có được ma trận này ta lật ma trận đầu tiên, đường chéo thứ hai. Sau đó, chúng tôi lật ma trận chia đường chéo thứ hai đó theo chiều ngang.

386
00:05:44,290 --> 00:05:54,880
Sau đó chúng ta nhận được ma trận này và đây là câu trả lời của bạn, được chứ? Và đó là cách chúng ta có thể giải quyết vấn đề này. Bây giờ, hãy để tôi chỉ cho bạn cách chúng ta có thể giải quyết vấn đề này bằng cách sử dụng mã giả, được chứ?

387
00:05:55,150 --> 00:06:06,760
Giả sử rằng đây là ma trận đã cho của chúng ta và ma trận này bị lật theo đường chéo và ma trận này bị lật theo chiều ngang. Được rồi, đầu tiên chúng ta sẽ khai báo một hàm xoay lấy ma trận đã cho làm đầu vào.

388
00:06:07,030 --> 00:06:18,910
Sau đó chúng ta sẽ lật ma trận theo đường chéo. Đây là chức năng. Được rồi, lật chéo. Điều này lấy ma trận này làm đầu vào. Sau đó, ở đây chúng ta có định nghĩa hàm này, ma trận đường chéo lật.

389
00:06:19,210 --> 00:06:29,710
Sau đó chúng ta có một công cụ của vòng lặp này. Dầu bắt đầu chạy từ số 0 cho đến phút cuối cùng, một trong những ma trận đã cho và giữ nguyên từ Ma trận Lindop trừ tám trừ một.

390
00:06:29,980 --> 00:06:41,050
OK, đừng lo lắng, chúng tôi không hiểu. Vì vậy, đối với lần lặp đầu tiên của tình yêu này, giá trị của các số 0 I và J, nó trỏ tới một. Được rồi. Bây giờ mục tiêu của chúng ta là tìm chỉ số của giá trị này là chín.

391
00:06:41,080 --> 00:06:52,690
Vậy làm sao chúng ta có thể làm được điều đó. Để làm được điều đó, chúng ta có độ dài ma trận của ma trận này, trừ G trừ một, do đó nếu bạn muốn Leontes ba trừ Ejiro trừ một.

392
00:06:52,690 --> 00:07:03,850
Vậy là hai. Vì vậy, nó trỏ đến mảng lồng nhau cuối cùng ở đây. Phải. Và sau đó chúng ta sẽ nhận được giá trị bị mất ở đây. Vậy hãy để ma trận trừ tám, trừ một. Vì vậy chúng ta sẽ chuyển cái này sang.

393
00:07:04,280 --> 00:07:15,740
Và cái này sẽ được thay thế bằng chín. Sau đó, chúng tôi có thông tin hiện tại của bạn về cái này. Vì vậy, chúng ta sẽ chỉ thay số chín này bằng một. Vì vậy, nó sẽ là một. Vậy giá trị đường chéo vẫn giữ nguyên, lần lặp tiếp theo của nước đi này là gì?

394
00:07:15,950 --> 00:07:25,890
Vậy nó sẽ trỏ tới vùng này và trỏ tới vùng cuối cùng ở đây theo quy tắc này ở đây. Vì vậy chúng ta sẽ lật 2 và 6. Vậy hai người sẽ ở đây và sáu người sẽ ở đây.

395
00:07:25,940 --> 00:07:35,090
Được rồi, đối với lần lặp tiếp theo, điều đó cũng sẽ xảy ra. Vì vậy, trong trường hợp này, nó sẽ trỏ đến cây này. Và ở đây bạn cũng có ba. Vì vậy, chúng ta sẽ thay thế ba bằng ba.

396
00:07:35,120 --> 00:07:45,890
Vì vậy, nó vẫn giữ nguyên như vậy đối với lần lặp tiếp theo của vòng lặp này, nó trỏ đến mảng lồng nhau này. OK, lần lặp đầu tiên ở đây, chúng ta có số 0, đúng không. Và ECLSS thành một.

397
00:07:45,980 --> 00:07:58,610
Được rồi, trong trường hợp này, điều chúng ta sắp làm ở đây là chúng ta sẽ mở rộng số này thành 4 và 8. Vì vậy, tám sẽ ở mức của bạn, bốn sẽ ở mức của bạn. OK, vậy là chúng ta đã hoàn thành ma trận đường chéo lật này.

398
00:07:58,940 --> 00:08:12,720
Sau đó chúng ta sẽ lật ma trận này theo chiều ngang. Và đây là mô hình nằm ngang. Phải. Vì vậy, chúng tôi cũng sẽ lật cái này. Vì vậy, chúng ta có một hàm ở đây cho đến khi văn bản được xoay, ma trận A. định nghĩa hàm lật theo chiều ngang, ma trận văn bản làm đầu vào.

399
00:08:12,740 --> 00:08:22,700
Vậy thì chúng ta phải sống ở đây. ĐƯỢC RỒI. Giá trị cho điều này sẽ vẫn như cũ. Vậy là tám, năm và hai, chúng ta phải làm theo điều này. Vì vậy, tôi luôn luôn bằng 0 đối với ma trận này.

400
00:08:22,710 --> 00:08:38,870
Vì vậy, nó đang trỏ đến quy tắc đầu tiên. Sau đó chúng ta sẽ mở rộng hai giá trị ở đây bằng công thức này ở đây. Vì vậy, bảy sẽ đến đây, chín sẽ đến đây, thế thì bốn sẽ tốt hơn sáu ở đây và sau đó một sẽ ở cuối bạn sẽ ở đây.

401
00:08:39,020 --> 00:08:50,310
Nếu bạn thắc mắc nó thực sự hoạt động như thế nào, chỉ cần xem qua mã giả và mã giải pháp được đính kèm với video này. Kiểm tra mã đính kèm. OK, và đây là giải pháp của tôi cho vấn đề này.

402
00:08:50,330 --> 00:09:05,860
Và cuối cùng, chúng ta xoay ma trận này và tất cả đều cần giải pháp vì nó khá phức tạp về thời gian. Độ dài của ma trận đã cho là bao nhiêu? Và tất cả đều có độ phức tạp về không gian không đổi vì chúng tôi đang sửa đổi ma trận tại chỗ.

403
00:09:06,080 --> 00:09:13,610
Và đây là giải pháp của tôi cho vấn đề này. Mã giải pháp có sẵn để tải xuống.
Kiểm tra xem. Cảm ơn đã xem video này. Tôi sẽ gặp bạn trong video tiếp theo. 

@@@



404
00:00:00,480 --> 00:00:16,330
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại video này vào video. Chúng ta sẽ giải một câu hỏi rất phổ biến về ma trận xoắn ốc. Đây có thực sự là một vấn đề khi bằng MBA về Ma trận viết tất cả các phần tử của Ma trận theo thứ tự xoắn ốc?

405
00:00:17,730 --> 00:00:34,480
Ví dụ: nếu bạn được cung cấp ma trận này, bạn phải duyệt ma trận này theo thứ tự xoắn ốc và bạn phải trả về các phần tử theo thứ tự xoắn ốc. Vì vậy, đầu tiên là một và hai, sau đó là ba sáu chín, tám, bảy, bốn, năm.

406
00:00:35,130 --> 00:00:56,770
Vì vậy, nếu bạn được cho ma trận này, bạn phải trả về danh sách này và đây là đường xoắn ốc hoặc đường đi ngang của ma trận này. Ví dụ: nếu bạn được cung cấp ma trận này làm đầu vào, bạn phải duyệt ma trận này theo thứ tự xoắn ốc và bạn phải trả về các phần tử theo thứ tự xoắn ốc.

407
00:00:57,060 --> 00:01:18,090
Vì vậy, đầu tiên Ultravox một, sau đó là hai, rồi ba, rồi bốn. Sau đó, tám, 12, 16, 15, 14, 13, chín, năm, sáu, bảy, 11, 10. Vì vậy, nếu bạn được cung cấp ma trận này làm đầu vào, bạn phải trả về danh sách này và danh sách này chúng ta có được bằng cách duyệt qua ma trận theo thứ tự xoắn ốc.

408
00:01:18,270 --> 00:01:50,170
Bây giờ hãy lấy một ví dụ khác. Ví dụ: nếu bạn lấy ma trận này làm đầu vào, chúng ta phải duyệt ma trận này theo thứ tự xoắn ốc và chúng ta phải trả về danh sách các phần tử theo thứ tự xoắn ốc trước tiên là các tháp một, sau đó là hai, rồi ba, rồi bốn, sau đó năm, mười, mười sáu, hai mươi mốt, hai mươi sáu, 25, 24, 23, 22, 17, 11, sáu, bảy, tám, chín, 15, 2019, 18, 12, 14.

409
00:01:51,150 --> 00:02:03,570
Vì vậy, nếu bạn đưa ra ma trận này, bạn phải trả về danh sách này. Chúng ta có thể có được danh sách này bằng cách duyệt ma trận theo thứ tự xoắn ốc. Bây giờ hãy xem liệu chúng ta có thể giải quyết vấn đề này không.

410
00:02:03,780 --> 00:02:14,450
Để giải quyết vấn đề này. Chúng ta sẽ sử dụng bốn con trỏ Roman Rotu cột một và cột hai. Hãy xem liệu chúng ta có thể giải quyết vấn đề này trước bằng sự hiểu biết hay không.

411
00:02:14,640 --> 00:02:31,640
Hãy lấy một ví dụ. Cho ma trận này, ta phải duyệt ma trận này theo thứ tự xoắn ốc. Còn nếu viết danh sách các phần tử theo thứ tự xoắn ốc thì chúng ta hãy khai báo cho chỉ ra trên hai và sớm thôi và xem con trỏ của mình đều trỏ về hàng đầu tiên nào cả.

412
00:02:31,650 --> 00:02:48,350
Trỏ vào hàng cuối cùng, bảy trỏ vào cột đầu tiên và Sidel trỏ vào cột cuối cùng. Đầu tiên chúng ta sẽ duyệt qua hàng đầu tiên, sau đó là cột cuối cùng, rồi đến hàng cuối cùng và sau đó là cột đầu tiên.

413
00:02:48,870 --> 00:03:00,850
Hãy xem làm thế nào chúng ta có thể làm điều đó. Đầu tiên, chúng ta sẽ duyệt hàng đầu tiên từ bảy đến 0 từ 0 để nói rằng chúng ta có bốn phần tử. Vì vậy, hãy thêm bốn yếu tố này vào danh sách bằng cách sử dụng dự phòng.

414
00:03:01,350 --> 00:03:13,800
Và đây là danh sách của chúng tôi. Danh sách này hiện có bốn yếu tố. Chúng tôi đã khủng bố hàng đầu tiên từ bảy xuống còn hai. Không, hãy duyệt qua cột cuối cùng từ R1 cộng một đến R2.

415
00:03:13,980 --> 00:03:32,810
Ở đây chúng ta có ba phần tử, 8, 12 và 16. Hãy thêm phần tử đó vào danh sách của chúng ta. Sau đó, danh sách sẽ được trình bày, đại loại như thế này. Bây giờ chúng ta phải duyệt hàng cuối cùng để duyệt hàng cuối cùng sẽ đi từ C đến trừ một đến bảy cộng một.

416
00:03:33,720 --> 00:03:50,790
Vậy chúng ta chỉ có hai phần tử, 15 và 14. Hãy thêm 15 và 14 vào danh sách của chúng ta để danh sách sẽ được biểu diễn, đại loại như thế này. Sau đó, để duyệt cột đầu tiên trong cột đầu tiên, chúng ta phải chuyển từ một cộng một của chúng ta sang một cộng một của chính chúng ta.

417
00:03:50,820 --> 00:04:06,200
Chúng ta có ba phần tử, 13, chín và năm. Vì vậy, hãy thêm ba yếu tố vào danh sách của chúng tôi. Danh sách sẽ được trình bày, đại loại như thế này. Vì vậy, khủng bố đầu tiên, nhanh hơn cột cuối cùng hơn rơm cuối cùng ở cột đầu tiên.

418
00:04:06,560 --> 00:04:18,900
Bây giờ chúng ta hãy chuyển sang bước tiếp theo và để xem bạn di chuyển như thế nào. Thành phố của bạn sẽ di chuyển đến đây. Tôi sẽ chuyển đến đây và tôi sẽ chuyển đến đây. Được rồi. Bây giờ hãy áp dụng công thức tương tự.

419
00:04:19,010 --> 00:04:28,490
Đầu tiên, hãy bắt đầu hàng đầu tiên ở hàng đầu tiên. Chúng tôi sắp nói với những kẻ khủng bố rằng chúng tôi phải loại bỏ sáu và bảy. Hãy thêm phần tử đó vào danh sách.

420
00:04:28,670 --> 00:04:37,100
Sau đó, danh sách sẽ được trình bày, đại loại như thế này. Vậy thì hãy trân trọng cột cuối cùng từ phần trên cộng lên phần hai của chúng ta. Chúng tôi chỉ có một yếu tố.

421
00:04:37,100 --> 00:04:50,780
Vì vậy, hãy thêm yếu tố đó vào danh sách của chúng tôi. Bây giờ, hãy bao gồm hàng cuối cùng trong hàng cuối cùng, bất kể giá trị nào từ Setto trừ một đến bảy, cộng một trong trường hợp đó, bảy sẽ lớn hơn 0 và điều đó không hợp lệ.

422
00:04:50,780 --> 00:05:03,650
Và tất cả điều đó sẽ được xử lý khi bạn xem qua mã giả của chúng tôi. Vì vậy, chúng ta không thể đi qua hàng cuối cùng trong trường hợp này. Bây giờ, chúng ta hãy thử cột đầu tiên trong tên khủng bố toàn cầu đầu tiên từ hai đến trên cộng một.

423
00:05:03,650 --> 00:05:23,720
Trong trường hợp đó, bạn chỉ có một yếu tố mười. Vì vậy, hãy thêm vào danh sách của chúng tôi và đây là cách chúng tôi có thể giải quyết vấn đề này. Sau đó, nếu chúng ta di chuyển, C1 và C2 7 sẽ lớn hơn C2 và riêng ở đây sẽ lớn hơn R2 và điều đó không hợp lệ và điều đó sẽ được xử lý khi đi qua mã giả.

424
00:05:23,780 --> 00:05:36,950
Đây là cách chúng ta có thể giải quyết vấn đề này. Vậy chúng ta đã duyệt ma trận này theo thứ tự xoắn ốc, đại loại như thế này. Chúng tôi đã hiểu cách có thể giải quyết vấn đề này để hiểu rõ hơn.

425
00:05:36,970 --> 00:05:46,560
Hãy lấy một ví dụ khác. Giả sử bạn được cho ma trận này. Bây giờ hãy xem liệu chúng ta có thể giải quyết vấn đề này cho ma trận này không. Đầu tiên, hãy khởi tạo Route one.

426
00:05:46,600 --> 00:05:57,370
Đây là điểm 1 giờ sáng của chúng ta đối với quy tắc đầu tiên, sau đó là điểm tổng của chúng ta đối với quy tắc cuối cùng. Rồi xem, khi bạn mở đến cột đầu tiên thì C2C sẽ trỏ đến cột cuối cùng.

427
00:05:57,370 --> 00:06:10,360
Đầu tiên, chúng ta sẽ duyệt qua hàng đầu tiên trong hàng đầu tiên. Chúng ta có năm yếu tố từ C1 để giải quyết. Hãy thêm năm yếu tố này vào danh sách. Chúng ta có thể làm điều đó chỉ bằng cách sử dụng hệ số dự phòng từ 7 đến C2.

428
00:06:10,840 --> 00:06:26,320
Bây giờ chúng ta hãy duyệt qua cột cuối cùng từ dấu cộng của chúng ta sang cột thứ hai. Chúng ta có bốn phần tử, 10, 16, 21, 26. Hãy thêm phần tử đó vào danh sách của chúng ta và bắt đầu Lastra từ SEDAR trừ một đến bảy cộng một.

429
00:06:26,560 --> 00:06:40,450
Vì vậy, trong trường hợp đó, chúng ta có ba phần tử 25, 24, 23. Vì vậy, hãy thêm phần tử đó vào danh sách của chúng ta. Được đại diện, đại loại như thế này. Sau đó, hãy duyệt qua cột đầu tiên từ R sang để cộng thêm một.

430
00:06:40,570 --> 00:06:52,000
Ở đây chúng ta có bốn phần tử 24, 22, 17, 11 và sáu. Hãy thêm bốn yếu tố đó vào danh sách của chúng tôi. Sau đó, danh sách sẽ được trình bày, đại loại như thế này. Bây giờ chúng ta đã hoàn tất.

431
00:06:52,000 --> 00:07:06,240
Chúng tôi đã xử lý hai cột. Và Tuross, hãy chuyển sang tập tiếp theo. Chúng tôi sẽ thả ra ở phía dưới và ở trên cùng. Sau đó nó sẽ được đại diện. Giống như thế này ở hàng một, chúng ta có ba phần tử chưa được xem.

432
00:07:06,460 --> 00:07:19,450
Bây giờ, chúng ta hãy duyệt qua hàng đầu tiên mà bạn muốn xem liệu chúng ta có ba phần tử bảy, tám, chín. Hãy thêm yếu tố đó vào danh sách của chúng tôi. Sau đó hãy thay đổi cột cuối cùng ở đây.

433
00:07:19,450 --> 00:07:32,740
Chúng ta có hai phần tử từ cộng một đến R2. Hãy thêm nó vào danh sách của chúng tôi bây giờ. Hãy thử hàng cuối cùng từ âm một đến bảy cộng một. Chúng tôi chỉ có một yếu tố vào đêm khuya trong danh sách của mình.

434
00:07:32,890 --> 00:07:43,330
Bây giờ chúng ta phải duyệt qua cột đầu tiên trong cột đầu tiên. Chúng ta phải loại bỏ unvisited từ đến plus one của chúng ta. Chúng ta phải loại bỏ 18 và 12. Vậy hãy thêm nó vào danh sách.

435
00:07:43,510 --> 00:07:57,340
Bây giờ, chúng tôi chỉ có một yếu tố cho anh ấy. Chúng ta hãy tiếp tục ở đây. Ngồi ngay đây có một cái ngay đây và R2 ngay đây. Bây giờ, bảy mươi hai không chỉ vào cột này và nghệ thuật của chúng ta đang chỉ vào cột này.

436
00:07:57,340 --> 00:08:11,920
Vì vậy, hãy che hàng đầu tiên từ bên này sang bên kia. Chúng ta chỉ có một yếu tố thứ mười bốn. Vì vậy, bây giờ hãy thêm bốn vào danh sách của chúng ta về phía cột cuối cùng từ R1 cộng một đến R2 và điều đó sẽ không hợp lệ.

437
00:08:12,160 --> 00:08:23,710
Tôi sẽ lớn hơn R2 và điều đó sẽ được xử lý khi bạn xem qua bản ghi này. Được rồi. Đây là cách chúng ta có thể giải quyết vấn đề này. Vì vậy chúng tôi đã khủng bố ma trận này theo thứ tự xoắn ốc này.

438
00:08:24,310 --> 00:08:41,310
Đây là thứ tự xoắn ốc. Được rồi, một, hai, ba, bốn, năm, mười, mười sáu. Hai mươi mốt. Hai mươi sáu. Hai mươi lăm. Hai mươi bốn. Hai mươi ba, hai mươi hai, mười bảy mười một sáu bảy tám chín mười lăm hai mươi mười chín mười tám 12, 14.

439
00:08:41,350 --> 00:08:58,840
Đây là cách chúng ta có thể giải quyết vấn đề này. Chúng tôi đã hiểu khái niệm này. Bây giờ hãy để tôi chỉ cho bạn cách chúng tôi có thể triển khai giải pháp này bằng mã giả. Đây là mã giả để giải quyết vấn đề này trước tiên với hàm này là một phần của Ma trận, nó lấy ma trận làm đầu vào.

440
00:08:58,840 --> 00:09:09,190
Sau đó, chúng tôi đang tạo ra một danh sách. Danh sách này sẽ lưu trữ các phần tử theo thứ tự xoắn ốc. Sau đó, chúng tôi đang kiểm tra xem độ dài của ma trận có bằng không hay không. Họ đang trả lại danh sách trống.

441
00:09:09,190 --> 00:09:23,110
Nếu không, thì chúng ta đang khai báo R2 của chính mình. Tôi sẽ trỏ đến hàng đầu tiên, chỉ đến hàng cuối cùng, sau đó là C khi bạn mở đến cột đầu tiên. Vì vậy nó sẽ trỏ đến cột cuối cùng, sau đó chúng ta sẽ chạy.

442
00:09:23,110 --> 00:09:36,880
Aluf, tại sao cứ để yên lại nhỏ hơn hoặc bằng kết thúc sớm của chúng ta lại nhỏ hơn hoặc bằng Sido. Sau đó, cái mướp này sẽ đi qua hàng đầu tiên. Loof này sẽ đi qua cột cuối cùng.

443
00:09:36,880 --> 00:09:56,470
Việc kiểm tra nếu ta có hai hàng và hai cột thì tất cả sẽ hướng về hàng cuối cùng, sẽ hướng về cột đầu tiên. Và khi đó chúng ta đang di chuyển mũi tên sang phòng bên cạnh giây trước đó sang cột tiếp theo và nhường lại cho cột trước đó.

444
00:09:56,470 --> 00:10:06,490
Và cuối cùng chúng tôi sẽ trả lại danh sách đó. Bây giờ hãy xem nó hoạt động như thế nào. Đây là danh sách trống chúng tôi đã tạo ngay tại đây. Giả sử rằng đã được đưa ra ma trận này.

445
00:10:06,640 --> 00:10:20,080
Vì vậy tôi sẽ trỏ đến hàng đầu tiên này và tôi chỉ đến điểm cuối cùng, đến cột đầu tiên. Nó sẽ trỏ đến cột cuối cùng. Bây giờ, chú wallaby này đúng vì chú chuột túi của chúng tôi nhỏ hơn hai chú wallaby của chúng tôi và chẳng bao lâu nữa sẽ nhỏ hơn chú chuột túi Sido.

446
00:10:20,200 --> 00:10:43,180
Bây giờ, hãy duyệt qua hàng đầu tiên C từ thứ hai đến C2 và chúng ta sẽ thêm hàng đầu tiên vào danh sách của mình. Đây là một là không đổi. Nó trỏ đến. Strozzi là một động sẽ lặp lại từ sớm đến Sido, vì vậy nó sẽ thêm một, hai, ba, bốn người cao nhất, danh sách sẽ được trình bày, đại loại như thế này.

447
00:10:43,360 --> 00:11:04,690
Và hãy duyệt qua cột cuối cùng để tìm cột từ cộng một đến cột cuối cùng của chúng ta. Vì vậy, chúng tôi là những kẻ khủng bố trong cột này từ cột chưa được chuyển đến cột thứ hai của chúng tôi, chúng tôi có ba phần tử tám, 12, 16 của bạn ở đây, Hằng số Sidwell vì bạn là cột cuối cùng và có nguồn gốc động từ khoảng cộng một đến R-2.

448
00:11:05,350 --> 00:11:23,950
Vì vậy, nó sẽ thêm tám, 12 và 16 vào danh sách. Sau đó, danh sách sẽ được trình bày, đại loại như thế này. Sau đó, chúng tôi đang kiểm tra xem chúng tôi có hai hàng và hai cột hay không và ở đây chúng tôi thấy rằng tác phẩm của chúng tôi và tác phẩm của chúng tôi không trỏ đến các quy tắc giống nhau, v.v., và do đó, nó không trỏ đến cùng một cột.

449
00:11:23,950 --> 00:11:42,280
Vậy hãy duyệt hàng cuối cùng từ C đến trừ một để thấy một cộng một. Vì vậy, nó sẽ đi qua 15 và 14. Ở đây chúng ta thấy động mạch đó không đổi vì chúng ta đang truy tìm hàng cuối cùng và Sounness động lặp lại từ 0 trừ một thấy bảy cộng một.

450
00:11:42,760 --> 00:11:58,960
Vì vậy, nó sẽ thêm phần này để giới hạn ở danh sách 15 và 14. Sau đó, danh sách sẽ được trình bày, đại loại như thế này. Bây giờ chúng ta hãy duyệt qua cột đầu tiên bằng cách sử dụng phần dự phòng này để tính từ hai đến cộng một của chính chúng ta.

451
00:11:59,080 --> 00:12:08,770
Và ở đây chúng ta thấy rằng Sounness không đổi vì bạn đang duyệt qua cột đầu tiên và linh hoạt như đang lặp vì bạn đang lặp từ R2 đến xung quanh chúng ta.

452
00:12:08,770 --> 00:12:19,230
Vậy chúng ta có ba yếu tố, ba mươi chín và năm. Vì vậy, hãy thêm yếu tố đó vào danh sách của chúng tôi. Sau đó, danh sách sẽ được trình bày, đại loại như thế này, và chúng ta cũng đã hoàn thành lần lặp đầu tiên của danh sách này.

453
00:12:19,480 --> 00:12:32,140
Bây giờ chúng ta đã duyệt qua quy tắc đầu tiên, Lastra cột cuối cùng trong cột đầu tiên. Bây giờ chúng ta hãy chuyển sang cột tiếp theo phù hợp với cột trước đó và thêm vào hàng tiếp theo được thêm vào hàng trước.

454
00:12:32,140 --> 00:12:46,150
Ở đây chúng ta có công thức này, máu của chúng ta bắn tung tóe đến âm trừ bảy cộng cộng trừ trừ. Vì vậy, nó sẽ được đại diện như thế này. Và hãy thử hàng đầu tiên này từ hàng thứ hai đến hàng C2 bằng cách sử dụng phần dự phòng này.

455
00:12:46,480 --> 00:12:57,760
Vì vậy, hãy thêm sáu và bảy vào danh sách của chúng tôi. Bây giờ, hãy duyệt qua cột cuối cùng từ các số của chúng ta sang R2 và điều đó sẽ chỉ trỏ đến phần tử này một phần tử.

456
00:12:57,760 --> 00:13:12,070
Vì vậy, hãy thêm vào danh sách của chúng tôi bây giờ. Theo dõi điều kiện này, chúng ta thấy rằng vai trò của chúng ta nhỏ hơn R2, v.v. nhỏ hơn 0. Nó có nghĩa là chúng ta có ít nhất hai hàng và hai cột.

457
00:13:12,160 --> 00:13:27,940
Bây giờ, bằng cách sử dụng kết quả dự phòng này, chúng ta sẽ hội tụ vế cuối cùng trong công thức này, chúng ta thấy rằng C hai trừ một thành phố, trừ một là một để thấy một cộng một, bảy cộng một là đến hoặc lặp từ một đến hai.

458
00:13:28,090 --> 00:13:38,530
Và đó là mặc định tôi có mã nguồn của video này, mã nguồn. Sau đó nó sẽ xem nó đánh giá rơi vào mã nguồn như thế nào tôi đã đính kèm vào video này.

459
00:13:38,560 --> 00:13:48,970
Sau đó, bạn sẽ thấy người tàn tật này rơi như thế nào. Sau đó, hãy duyệt qua cột đầu tiên trong cột đầu tiên để lấy lại từ hai của chúng ta thành trên cộng một và chúng ta chỉ có một phần tử.

460
00:13:48,970 --> 00:14:03,760
Vì vậy, hãy bước sang tuổi mười và hãy thêm nó vào danh sách của chúng ta và chúng ta đã hoàn thành. Và một lần nữa, hãy chuyển sang điểm ban đầu tiếp theo ở đây. Và tại một điểm ở đây, điểm trung tâm ở đây và điểm trung tâm ở đây.

461
00:14:03,790 --> 00:14:15,640
Và chỉ riêng điểm phá vỡ này trong trường hợp đó đã lớn hơn hai và hai của chúng ta và lớn hơn 0. Và đó là lý do tại sao điều này sẽ dừng lại, vì điều kiện này là sai.

462
00:14:15,640 --> 00:14:28,570
Và cuối cùng, chúng tôi sẽ trả lại danh sách. Đây là danh sách chúng ta có được trong danh sách này, tùy theo danh sách nào trong ma trận này, theo thứ tự xoắn ốc, đại loại như thế này. Đây là phép duyệt theo thứ tự xoắn ốc của ma trận này.

463
00:14:29,230 --> 00:15:01,150
Chúng tôi đã hiểu điều này với lời giải thích. Giải pháp sẽ chiếm dung lượng lớn hơn, chỉ mất M lần độ phức tạp về thời gian trong đó là chiều cao của ma trận và là trọng số của ma trận vì bạn nhìn thấy tất cả phần tử trong ma trận một lần, bất kể thế nào, cho dù chúng ta có bao nhiêu giá trị ở đây và bao nhiêu falu lồng nhau và chúng ta có bao nhiêu lồng nhau ở đây, nó sẽ chỉ mất đi M lần trong thời gian.

464
00:15:01,150 --> 00:15:26,560
Độ phức tạp hay M là chiều cao của ma trận và nó là chiều rộng của ma trận. Và giải pháp sẽ chiếm một độ phức tạp về không gian nếu chúng ta loại trừ khỏi phân tích độ phức tạp của mình, nếu chúng ta đưa danh sách đầu ra của mình vào độ phức tạp, hệ thống và khi đó độ phức tạp của không gian sẽ lớn gấp M lần bất kể chiều cao và chiều rộng là bao nhiêu của ma trận đã cho mà chúng ta đã hiểu thực sự là biểu thức.

465
00:15:27,010 --> 00:15:37,050
Nếu bạn không hiểu chính lời giải thích này hoặc nếu bạn có bất kỳ câu hỏi nào hoặc nếu đó là a.
Hãy cho chúng tôi biết, cảm ơn vì đã xem video này. Tôi sẽ gặp bạn trong video tiếp theo. 

@@@



466
00:00:00,480 --> 00:00:09,570
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng ta sẽ nói về cấu trúc dữ liệu ngôn ngữ. Danh sách liên kết là một cấu trúc dữ liệu động.

467
00:00:09,630 --> 00:00:27,300
Ilmenite được gọi ở đâu? Nút được tạo thành từ hai mục. Dữ liệu và phản hồi tham chiếu hoặc con trỏ tới danh sách nút tiếp theo là một tập hợp các nút hoặc nút được kết nối với con trỏ ba nút tiếp theo hoặc một tham chiếu.

468
00:00:28,790 --> 00:00:43,850
Đây là định nghĩa chính thức về cấu trúc dữ liệu ngôn ngữ học cho mọi phần tử. Chúng tôi chỉ có một mục cho yếu tố ngôn ngữ học. Chúng tôi có hai mục. Một, một giá trị hoặc một dữ liệu và một con trỏ hoặc một sự khác biệt.

469
00:00:44,420 --> 00:01:03,610
Được rồi, một ghi chú có hai phần. Một phần được lưu trữ dữ liệu hoặc giá trị và phần còn lại được lưu trữ tham chiếu hoặc con trỏ. ĐƯỢC RỒI. Đây không phải là sự thể hiện việc anh ta sử dụng điểm này, nó sẽ kết nối cái này chứ không phải với cái khác.

470
00:01:04,370 --> 00:01:19,670
Đây là một ví dụ về một danh sách. Nốt đầu tiên được gọi là phần đầu và nốt cuối cùng được gọi là câu chuyện. Trong danh sách liên kết này, chúng tôi có bốn nút. Trang web của danh sách liên kết này dành cho nút này được kết nối bằng con trỏ tới nút này.

471
00:01:20,120 --> 00:01:30,500
Nút này sẽ truy cập ghi chú này bằng con trỏ này. Ghi chú này được kết nối với nút này và ghi chú này được kết nối với nút hiện tại. Điều đó có nghĩa là không có gì bởi vì bây giờ không có nghĩa gì cả.

472
00:01:30,530 --> 00:01:40,850
Hiện tại không có sự tồn tại nào trong bộ nhớ máy tính của nút. Đây là một đại diện cấp cao của một danh sách liên kết. Nốt đầu tiên được gọi là nốt cuối cùng được gọi là nốt đuôi.

473
00:01:41,060 --> 00:01:56,180
Nút này được lưu trữ hai mục. Một là Dhara và một là địa chỉ của nút khác và địa chỉ của nút này được định hướng. Con trỏ ban đầu hoặc con trỏ lần truy cập trỏ đến thời điểm được cho là lần truy cập.

474
00:01:56,570 --> 00:02:13,560
Khi đó có nghĩa là chúng ta đang gọi nút của địa chỉ này. Và ở đây ghi chú này được kết nối với nút này bằng địa chỉ này. Và chính trong quá trình địa chỉ của nút này khôi phục lại địa chỉ của ghi chú này ở đây, khôi phục địa chỉ của nút này và khôi phục không có ý nghĩa gì.

475
00:02:13,750 --> 00:02:26,900
Bây giờ, đây là một ví dụ về danh sách liên kết, chúng ta đã hiểu liên kết là gì, cấu trúc dữ liệu này. Bây giờ chúng ta hãy nói về pháp lý và mảng bên lên. Danh sách không cố định.

476
00:02:27,150 --> 00:02:38,690
Chúng tôi có thể thay đổi hoặc sửa đổi trang web theo ngôn ngữ học trong thời gian đó, nhưng trang web có lỗi đã được sửa. Chúng tôi không thể thay đổi trang web có lỗi trong thời gian chạy.

477
00:02:38,870 --> 00:02:51,440
Chúng tôi không thể truy cập nó, không phải ngẫu nhiên, nhưng chúng tôi có thể thoát khỏi một phần tử một cách ngẫu nhiên do lỗi. Chúng tôi không thể thoát khỏi một nút một cách ngẫu nhiên trong thời gian dài nhất mà có lỗi. Chúng ta có thể truy cập một phần tử ngẫu nhiên theo chỉ mục.

478
00:02:51,440 --> 00:03:05,960
Không có danh sách liên kết nào được lưu trữ ở vị trí bộ nhớ không liên tiếp, nhưng lỗi lần lượt được lưu trữ liên tục ở vị trí bộ nhớ. Ví dụ: mỗi năm chúng tôi có năm yếu tố và chúng tôi có số chỉ mục của bạn.

479
00:03:06,200 --> 00:03:15,440
Với số chỉ mục, chúng ta có thể truy cập bất kỳ sự sắp xếp nào trong thời gian không đổi. Đây là một ví dụ về nhà ngôn ngữ học. Nốt đầu tiên được gọi là nút cuối cùng được gọi tới đây.

480
00:03:15,440 --> 00:03:26,720
Chúng tôi không thể chấp nhận bất kỳ nút nào một cách ngẫu nhiên. Để truy cập bất kỳ nút nào, chúng ta phải duyệt qua danh sách liên kết từ trái sang phải. Giả sử chúng ta muốn tìm giá trị của nút này.

481
00:03:26,900 --> 00:03:40,560
Sau đó chúng ta phải nói, này, dot next dot eval, thì nó sẽ nhận được giá trị này. Vì vậy, để tìm ra giá trị của một nốt nhạc cụ thể, chúng ta phải sử dụng một vòng lặp. Nhưng nếu có lỗi, chúng ta có thể truy cập nó trong thời gian không đổi.

482
00:03:40,850 --> 00:03:54,500
Bây giờ hãy xem cách biểu diễn mảng và ngôn ngữ học trong bộ nhớ máy tính. Đây là mảng của chúng tôi và đây là một ví dụ về bộ nhớ truy cập ngẫu nhiên hoặc ngẫu nhiên và sẽ được lưu trữ như thế này.

483
00:03:54,770 --> 00:04:05,660
Phần tử đầu tiên sẽ được chuyển đổi thành nhị phân. Tương đương nhị phân sẽ được lưu trữ trong RAM. Nhưng để dễ hiểu, chúng tôi đang hiển thị biểu diễn số nguyên.

484
00:04:05,840 --> 00:04:15,440
Đầu tiên nó sẽ lưu trữ một, sau đó là hai và ba, sau đó là năm. Điều này được lưu trữ ở vị trí bộ nhớ liên tiếp, do đó mảng được lưu trữ ở vị trí bộ nhớ liên tiếp.

485
00:04:15,440 --> 00:04:27,020
Đầu tiên là một, sau đó là hai và ba và bốn và năm. Không có khoảng cách ở giữa. Bây giờ chúng ta hãy xem biểu diễn danh sách liên kết trong bộ nhớ máy tính. Danh sách liên kết Erguven này và danh sách liên kết này sẽ được trình bày.

486
00:04:27,020 --> 00:04:40,670
Một cái gì đó như thế này, đáng tiếc là danh sách liên kết được thể hiện ở vị trí bộ nhớ liên tiếp trong năm nay. Nút đầu tiên một, sau đó là hai, rồi ba, rồi bốn và năm là nút đầu của bạn.

487
00:04:40,970 --> 00:04:49,160
Sau đó ghi chú này được kết nối với nút này. Nút này được kết nối với ghi chú này. Ghi chú này được kết nối với nút này và ghi chú này sẽ đến nút này và đây được gọi là đuôi.

488
00:04:49,370 --> 00:04:59,840
Và chúng tôi thấy có nhiều khoảng trống ở giữa là node. Nhưng đối với tính liên tục, bộ nhớ, vị trí, không có khoảng cách nào nối tiếp nhau mà danh sách liên kết được thể hiện như thế này.

489
00:05:00,080 --> 00:05:11,120
Nó có thể ở bất cứ đâu trong bộ nhớ máy tính và chúng ta có liên kết để nó có thể đi từ
nốt này sang nốt khác. Đây là cách liên kết được thể hiện trong bộ nhớ máy tính. 

@@@



490
00:00:00,870 --> 00:00:16,860
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này chúng ta sẽ nói về các loại danh sách liên kết. Có bốn loại danh sách liên kết, danh sách đơn, vòng tròn, danh sách đơn, danh sách nhân đôi, tìm kiếm, danh sách nhân đôi.

491
00:00:17,530 --> 00:00:34,950
Bây giờ, hãy xem chi tiết tất cả chúng trong một danh sách. Chúng tôi có các loại nút này. Các nút chứa hai mục. Mục đầu tiên được gọi là giá trị hoặc dữ liệu và mục thứ hai được gọi là con trỏ hoặc một nút khác.

492
00:00:35,790 --> 00:00:48,060
Đây là định nghĩa chính thức của một danh sách đơn trong một danh sách liên kết đơn không có trong danh sách lưu trữ, dữ liệu của nút và tham chiếu hoặc trỏ đến nút tiếp theo trong danh sách.

493
00:00:48,600 --> 00:01:02,250
Nó không lưu trữ tham chiếu hoặc trỏ đến nút trước đó. Đây là ví dụ về một danh sách đơn không nằm trong danh sách đơn, chứa hai mục, dữ liệu và con trỏ.

494
00:01:02,970 --> 00:01:19,340
Đây là dữ liệu và đây là con trỏ. Còn cái điểm này thì nó trỏ vào cái này chứ không phải theo địa chỉ này. Bây giờ, hãy nói về nhà phân tích đơn lẻ của Circler. Danh sách liên kết đơn Circler giống nhau ở danh sách đơn, nhưng chỉ có một điểm khác biệt.

495
00:01:19,710 --> 00:01:30,980
Nút cuối hoặc nút cuối cùng trong danh sách được kết nối với nút đầu tiên của danh sách liên kết. Một cái gì đó như thế này. Nút cuối cùng được kết nối với nút đầu tiên.

496
00:01:31,140 --> 00:01:46,550
Điều đó có nghĩa là phần đuôi được kết nối với nút và đây được gọi là lãi đơn vòng trong danh sách liên kết đơn. Nút đuôi được kết nối để bao gồm việc nó không được kết nối với gì ngoài các vòng tròn, bao gồm cả nút này.

497
00:01:46,890 --> 00:02:21,890
Nút cuối cùng được kết nối với nút đầu tiên. Bây giờ hãy nói về sự quan tâm gấp đôi trong danh sách. Chúng tôi có ghi chú khác trong danh sách. Nút này chứa ba mục, một dữ liệu và hai con trỏ, ba con trỏ và con trỏ tiếp theo, ba con trỏ trỏ đến nút trước và con trỏ tiếp theo trỏ đến nút tiếp theo trong danh sách DoubleLine không chứa một dữ liệu và hai tham chiếu hoặc con trỏ tham chiếu hoặc trỏ đến nút trước và nút tiếp theo.

498
00:02:22,170 --> 00:02:37,410
Đây là một ví dụ về danh sách nhân đôi. Đây là nút đầu của chúng tôi. Và địa chỉ của nút này là địa chỉ này không chứa ba mục, hai con trỏ, ba con trỏ và con trỏ tiếp theo hoặc một tham chiếu.

499
00:02:37,710 --> 00:02:58,800
Và dữ liệu và dữ liệu cho nút này, con trỏ không trỏ đến đâu cả. Và điểm tiếp theo, phản hồi nút này và không phải, nó chứa ba mục, ba con trỏ, trỏ đến nút này và một dữ liệu và con trỏ tiếp theo trỏ đến nút này để nhân đôi danh sách.

500
00:02:58,980 --> 00:03:10,940
Chúng ta có thể tiến và lùi, nhưng để tăng một lần, chúng ta chỉ có thể tiến từ trái sang phải. Nhưng đối với một danh sách, chúng ta có thể di chuyển từ trái sang phải và chúng ta cũng có thể di chuyển từ phải sang danh sách đó.

501
00:03:11,730 --> 00:03:29,430
Và hãy nói về danh sách vòng tròn. Danh sách tròn, giống hệt như nhân đôi danh sách, nhưng chỉ khác một danh sách. Nút cuối cùng trong danh sách được kết nối với nút đầu tiên và nút đầu tiên được kết nối với phút cuối cùng của danh sách liên kết, đại loại như thế này.

502
00:03:29,430 --> 00:03:45,880
Nốt đầu tiên được kết nối với nút cuối cùng và nốt cuối cùng được kết nối với nút đầu tiên. Và đây được gọi là Danh sách đường xuống tròn.
Chúng ta đã hiểu bốn loại danh sách liên kết lên, danh sách liên kết đơn, danh sách liên kết đơn vòng, danh sách nhân đôi và danh sách vòng. 

@@@



503
00:00:00,420 --> 00:00:10,570
Rất nhiều chàng trai sẽ quay lại video này trong video này. Chúng ta sẽ tạo một sở thích duy nhất và hãy xem cách chúng ta có thể tạo một thuật toán ngôn ngữ duy nhất để tạo một danh sách duy nhất.

504
00:00:10,590 --> 00:00:23,130
Đầu tiên sẽ tạo một nút lớp với hai thuộc tính, data. Và next next là một con trỏ tới nút tiếp theo. Sau đó, chúng ta sẽ tạo một lớp khác có hai thuộc tính là đầu và đuôi.

505
00:00:24,180 --> 00:00:36,720
Sau đó, bạn sẽ tạo một phương thức, thêm nút, thêm phương thức sẽ thêm kiến ​​thức mới vào danh sách. Và sẽ tạo một phương thức, phương thức in, sẽ in phần không có trong danh sách.

506
00:00:37,260 --> 00:00:51,210
Đây là nút lớp và đây là danh sách liên kết đơn của tôi, nhưng đây là ghi chú lớp đầu tiên của chúng tôi và đây là danh sách liên kết còn thiếu của chúng tôi, Clutz. Bây giờ, hãy kết hợp chúng lại với nhau.

507
00:00:51,420 --> 00:01:03,370
Nếu chúng ta kết hợp chúng lại với nhau thì chúng ta sẽ nhận được mã này ở đây. Chúng ta có bên trong lớp này, chúng ta có một lớp không phải lớp này, không đại diện cho một nút. Nó chứa hai thuộc tính thành giá trị.

508
00:01:03,780 --> 00:01:16,290
Chúng ta có thể xem tất cả dữ liệu và con trỏ tiếp theo. Sau đó, chúng tôi có nút đầu và đuôi của bạn. Không phải điều đó trỏ đến nút bây giờ. Và sau đó chúng ta có phương thức thêm nút ở đây và chúng ta có print.

509
00:01:16,890 --> 00:01:33,150
Và đây là nút, được chứ? Nó chứa dữ liệu ở đây, chúng tôi cũng có dữ liệu và con trỏ tiếp theo và bây giờ chúng tôi có nút OK ở đây. Ghi chú này chứa dữ liệu null và bây giờ là con trỏ và nhấn và nói không trỏ đến nút này.

510
00:01:33,540 --> 00:01:47,360
Bây giờ, giả sử mã cho addNode, ban đầu chúng ta có đầu và đuôi nút này trỏ đến một bản tải xuống. Bây giờ ở đây chúng ta có phương thức thêm nút này. Nó lấy một dữ liệu tham số.

511
00:01:47,700 --> 00:01:57,330
Sau đó, chúng ta sẽ tạo một nút mới với dữ liệu và ghi chú, kiểm tra xem kênh Heracles có tạo ghi chú mới và sẽ xử lý phần đầu cho đến khi được trỏ đến nút đó hay không.

512
00:01:57,720 --> 00:02:17,190
Nếu không, sẽ thêm ghi chú mới vào ghi chú tiếp theo và sẽ di chuyển phần đuôi sang nút mới tạo. Hãy xem làm thế nào chúng ta có thể làm điều đó. Nếu chúng ta gọi hàm này là addnode một thì chúng ta sẽ tạo một nút một và tất cả cùng một lúc ở đây, đồng bộ hai đầu và đuôi con trỏ.

513
00:02:17,190 --> 00:02:28,470
Đầu của chúng tôi ban đầu trống rỗng. Sau đó, nếu chúng ta gọi lại hàm này ở nút hai, thì chúng ta sẽ tạo một nút hai khác và sau đó chúng ta sẽ nói tailcoat tiếp theo.

514
00:02:28,650 --> 00:02:48,580
Vì vậy, tại thời điểm này tới nút này và chúng ta sẽ di chuyển đuôi đến nút này, sau đó nó sẽ được biểu diễn, đại loại như thế này. Chúng ta gọi hàm này là addNode ba, sau đó sẽ tạo một nút mới và sẽ thêm điểm này vào nút này và nó sẽ di chuyển đuôi đến nút này, sau đó nó sẽ được biểu diễn giống như thế này.

515
00:02:49,000 --> 00:03:00,040
Sau đó, nó sẽ gọi hàm này thêm nút cho nút mới tạo cho và tất cả tại liên kết này đến nút này ở đây, chúng ta sẽ nói tiếp theo là đi qua đơn vị.

516
00:03:00,040 --> 00:03:10,340
Vì vậy, chúng tôi đang ngắt kết nối liên kết này và chúng tôi đang kết nối với ghi chú này và chúng tôi sẽ di chuyển đuôi đến nút này. Telecaster, Leonhard và Linguist's sẽ được đại diện, đại loại như thế này.

517
00:03:10,870 --> 00:03:22,000
Bằng cách gọi hàm này bốn lần, chúng ta có được danh sách này, đại loại như thế này. Bây giờ hãy xem phương pháp in của chúng tôi, cách chúng tôi có thể duyệt qua danh sách liên kết này và cách chúng tôi có thể in các giá trị nút.

518
00:03:22,900 --> 00:03:33,880
Đây là mã để in các giá trị nút. Chức năng in không có tham số nào cả. Kiểm tra xem Sternhell có in danh sách trống hay không và nó sẽ in ra câu lệnh bằng văn bản này.

519
00:03:34,960 --> 00:03:45,060
Nếu không, thì chúng tôi đang tạo một con trỏ hiện tại tới nút đầu và sau đó chúng tôi đang kiểm tra. Vâng, hiện tại không phải là bên ngoài. Chúng ta sẽ in dữ liệu hiện tại và sau đó chúng ta sẽ chuyển sang dữ liệu tiếp theo.

520
00:03:45,070 --> 00:04:00,290
Và cho đến hiện tại, nút hiện tại ban đầu là nút hiện tại đáp ứng nút đầu này và bây giờ chúng ta thấy ghi chú này không phải là nút khác. Vì vậy, hãy in một cái và chuyển sang nút tiếp theo, không tương tự với việc hãy in phát triển không phải là dữ liệu hiện tại của tôi.

521
00:04:01,150 --> 00:04:17,890
Bây giờ chúng ta hãy chuyển sang nút tiếp theo và phát triển nút này chứ không phải ba nút. Hãy chuyển sang nút tiếp theo và mang giá trị của nút này vào và chúng ta nhận được kết quả đầu ra này và đây là những gì chúng ta có thể in giá trị lên các giá trị nút ngôn ngữ học.

522
00:04:19,000 --> 00:04:29,530
Hàm này sẽ loại bỏ Spiga về độ phức tạp về thời gian vì chúng ta đang tách danh sách liên kết từ trái sang phải và nó sẽ có độ phức tạp không gian không đổi.

523
00:04:29,680 --> 00:04:50,530
Vì bạn không sử dụng bất kỳ lời nói gốc nào nên chúng tôi chỉ sử dụng một dòng con trỏ và ở đây hàm này sẽ có độ phức tạp một lần lớn hơn vì chúng tôi đang thêm nút vào đuôi trong thời gian không đổi và nó cũng có độ phức tạp không gian không đổi vì bạn đang chèn một nút tại một thời điểm.

524
00:04:50,800 --> 00:05:01,060
Chúng tôi thêm tất cả các chức năng của chúng. Nếu chúng ta xem xét thì sẽ mất đi độ phức tạp về thời gian. Số lượng nút là bao nhiêu? Và ở đây chúng ta nói điểm đối lập này đang trỏ đến nút cuối cùng.

525
00:05:01,330 --> 00:05:11,460
Trong lần lặp tiếp theo, nó sẽ trỏ đến nút bây giờ khi nó trỏ đến phong bì này sẽ
được nhét vào. Và đây là cách chúng ta có thể in giá trị của các nút rồi. 

@@@



526
00:00:00,610 --> 00:00:14,080
Rất nhiều chàng trai sẽ quay lại video này trong video này. Chúng ta sẽ xem thao tác chèn vào. Một nhà phân tích trong video này sẽ thực hiện ba thao tác và một trạng thái được thêm vào và thêm chỉ mục.

527
00:00:15,190 --> 00:00:28,420
Bây giờ, hãy thực hiện tất cả các thao tác ngay trong video này. Đầu tiên, chúng ta sẽ thấy sự căm ghét được thêm vào, sau đó được thêm vào chỉ mục mới được thêm vào. Đầu tiên, hãy nói về sự ghét bỏ thêm.

528
00:00:29,480 --> 00:00:41,800
Đây là đại diện danh sách liên kết của chúng tôi. OK, trước tiên, chúng tôi thấy điều này không thành công cho đến khi Point trỏ đến phần tải xuống và ban đầu chúng tôi có lệnh gọi về 0.

529
00:00:42,460 --> 00:00:58,590
Bây giờ chúng ta hãy xem mã cho và ghét. Đọc mã nối tiếp để khuấy và ban đầu chúng ta có chu kỳ về 0. Đây là phương pháp của chúng tôi thêm ghét. Nó lấy một dữ liệu tham số.

530
00:00:59,200 --> 00:01:08,310
Bạn đang tạo một nút có dữ liệu và chúng tôi đang kiểm tra trang web gần bằng 0. Sau đó, chúng ta sẽ nói chiến lược Hiriko gọi tới nút và những thứ tương tự như thế này.

531
00:01:09,240 --> 00:01:24,300
Nếu không, thì chúng ta sẽ nói không, tiếp theo chúng ta phải tấn công và chúng ta sẽ nói Heracles với Node. Và ở đây chúng ta chỉ đang kết nối nút hiện tại với sự căm ghét và chúng ta sẽ chuyển sự căm ghét sang nút hiện tại của mình.

532
00:01:24,930 --> 00:01:41,790
Và cuối cùng chúng tôi sẽ tăng trang web. Chúng ta cần theo dõi trang web. Khi chúng tôi triển khai chỉ mục adead, chúng tôi cần trang web của danh sách kinh khủng. Nếu chúng ta gọi hàm này, hãy thay đổi giá trị nút cho nút mới được tạo, đại loại như thế này.

533
00:01:42,330 --> 00:02:00,450
Và sau đó chúng ta sẽ khởi tạo. Hayden đã chỉ ra ghi chú này vì ban đầu trang web gọi số 0. Vì vậy, hãy đứng đầu và yêu cầu người điểm trỏ đến nút này và cuối cùng hoặc chỉ tăng kích thước của trang web trở thành một, sau đó hãy gọi lại hàm này với ba được thêm vào.

534
00:02:01,020 --> 00:02:17,550
Sau đó chúng ta sẽ tạo một nút. Và trong trường hợp này nó sẽ không nói là không có dấu chấm. Tiếp theo, đây là nút hiện tại của chúng tôi. Vì vậy, chúng ta sẽ kết nối liên kết này với nút này và chúng ta sẽ di chuyển con trỏ nhấn đến nút này để nó được biểu thị giống như thế này.

535
00:02:17,790 --> 00:02:38,230
Ba, bốn, ba là cái đầu. Được rồi, và trang web có thể gọi lại chức năng này và trước hết chúng ta sẽ tạo một nút, đại loại như thế này, sau đó chúng ta sẽ ngắt kết nối liên kết này và chúng ta sẽ kết nối với sự căm ghét và chúng ta sẽ để di chuyển về phía trước đến nút này.

536
00:02:38,740 --> 00:02:48,970
Sau đó, nó sẽ được trình bày, đại loại như thế này, và trang web sẽ được mở rộng. Vì vậy, các nhà ngôn ngữ học sẽ được biểu diễn, đại loại như thế này, nếu chúng ta gọi lại hàm này bằng hàm agitate.

537
00:02:50,120 --> 00:03:05,120
Vì vậy, chúng tôi sẽ tạo một ghi chú mới về Giá trị một và chúng tôi sẽ ngắt kết nối liên kết này từ bây giờ và chúng tôi sẽ kết nối với head và chúng tôi sẽ chuyển lượt truy cập của chúng tôi trỏ đến ghi chú này và nhà ngôn ngữ học của chúng tôi sẽ được đại diện giống như cái này, và nó sẽ được tăng từ ba lên bốn.

538
00:03:05,870 --> 00:03:20,030
Và đây sẽ là sự thể hiện của một danh sách liên kết nếu chúng ta thực hiện lệnh gọi đầy đủ chức năng này. Chúng tôi đã hiểu quảng cáo ở phương pháp Haid. Bây giờ, hãy nói về phương thức tail được thêm vào trước đó.

539
00:03:20,270 --> 00:03:31,640
Giả sử thời gian, độ phức tạp, thời gian, độ phức tạp của vấn đề này lớn hơn một, bởi vì bạn đang chèn một ghi chú vào đầu và độ phức tạp về không gian cũng lớn hơn.

540
00:03:32,300 --> 00:03:46,510
Bây giờ chúng ta hãy xem. Đã thêm phương pháp đuôi. Được rồi, đây là phương pháp ED của chúng tôi. Ban đầu, chúng tôi có lưu ý này, OK, nhấn và nói điểm đang trỏ đến việc dỡ hàng bên trong studio.

541
00:03:47,410 --> 00:03:58,840
Đây là phương pháp của chúng tôi được thêm vào chương trình này lấy một tham số và tuyển dụng một tham số mới không. Nếu được quyết định, chúng tôi sẽ khởi tạo phần đầu của bạn và trỏ đến nút hiện tại của chúng tôi.

542
00:03:59,410 --> 00:04:12,760
Nếu không, chúng tôi cũng sẽ thêm ghi chú vào đó và chúng tôi sẽ di chuyển đuôi đến nút hiện tại và chúng tôi sẽ tăng trang web. Nếu chúng ta gọi hàm này với phần đuôi được thêm vào thì sẽ tạo một nút, đại loại như thế này.

543
00:04:12,940 --> 00:04:27,290
Và ban đầu, chúng tôi đã chuyển qua số 0 vì ban đầu chúng tôi đã Santigold cho tất cả các phần đầu và đuôi của ETA được chỉ ra ghi chú này bằng tuyên bố này, sự căm ghét tương đương với việc thường xuyên đi qua nút và trang web trở thành một.

544
00:04:27,430 --> 00:04:42,040
Bây giờ chúng ta hãy gọi lại hàm này và thêm vào nút có giá trị để sau đó chúng ta sẽ thực hiện lệnh gọi tiếp theo tới nút. Vì vậy, cho đến khi nút tiếp theo bằng nút, chúng ta sẽ kết nối với nút và chúng ta sẽ di chuyển đuôi đến nút này.

545
00:04:42,320 --> 00:04:53,440
Vì vậy, liên kết giống như thế này và trang web bây giờ được gọi là chức năng này được thêm vào nó sẽ tạo ra một nút có giá trị ba. Và chúng ta sẽ ngắt kết nối liên kết này.

546
00:04:53,440 --> 00:05:01,690
Chúng ta sẽ kết nối với nút này và chúng ta sẽ di chuyển đuôi đến nút này trong liên kết. Điều này sẽ được biểu diễn giống như thế này và câu trả lời sẽ tăng lên một.

547
00:05:01,870 --> 00:05:11,830
Và nếu lúc này bạn gọi hàm được thêm vào là đuôi để tạo một nút mới và chúng ta sẽ ngắt kết nối nút này và sẽ kết nối với nút này và chúng ta sẽ chuyển đuôi sang nút này.

548
00:05:12,160 --> 00:05:25,770
Vì vậy, nhà ngôn ngữ học sẽ được biểu diễn một cái gì đó như thế này, hoặc chúng tôi đã hiểu thêm vào phương pháp. Phương pháp này sẽ có độ phức tạp một lần lớn hơn và độ phức tạp một không gian lớn hơn.

549
00:05:26,050 --> 00:05:36,820
Độ phức tạp một lần sẽ lớn hơn vì chúng ta đang thêm nút vào đuôi trong thời gian không đổi. Chúng tôi hiểu thêm vào phương pháp. Bây giờ hãy nói về phương pháp chỉ mục được thêm vào.

550
00:05:37,030 --> 00:05:49,030
Bây giờ chúng ta sẽ nói về phương pháp chỉ mục được thêm vào. Để triển khai phương pháp chỉ mục Adut, chúng tôi cần thêm ghét, thêm chi tiết và nhận node. Vì vậy, đây là chức năng của chúng tôi.

551
00:05:49,300 --> 00:06:08,770
Hàm này lấy hai tham số là chỉ mục và dữ liệu, số chỉ mục nơi chúng ta muốn chèn nút hiện tại. Và điều gì sẽ xảy ra nếu chỉ mục nhỏ hơn 0 hoặc các chỉ mục lớn hơn kích thước không tồn tại để giữ Indexical 2.0, thì chúng ta phải gọi thêm Haid if indexical để thay đổi số gọi hàm này là phụ gia.

552
00:06:09,010 --> 00:06:19,870
Vì vậy, hãy nói về việc ghét và thêm Arijit vào phương pháp này, chúng ta đã thảo luận về việc chỉnh sửa và thêm chi tiết ở rất nhiều chi tiết trong slide trước.

553
00:06:20,230 --> 00:06:28,600
Nếu không, chúng ta sẽ lấy nút trước đó của chỉ mục hiện tại. Sau đó, chúng ta sẽ tạo một nút mới và chúng ta sẽ nói không tiếp theo. Chúng ta phải làm gì tiếp theo?

554
00:06:28,930 --> 00:06:39,730
Và chúng không phải là nút tiếp theo và kích thước cộng thêm. Ngoài ra, chúng ta sẽ xem nó hoạt động như thế nào. Và đây là chúng ta đang tìm hiểu xem nó sẽ trả về nút hiện tại theo phương thức nào vào mùa thu này.

555
00:06:39,970 --> 00:06:50,580
Để dễ hiểu, giả sử chúng ta được cung cấp danh sách liên kết này và trang web là hai. Đây là nút đầu của chúng tôi và mức độ nổi tiếng của số chỉ mục mà chúng tôi có ở đây từ 0 đến 1.

556
00:06:50,590 --> 00:07:02,860
Đây là nút bản địa của nút chỉ số một. Bây giờ chúng ta gọi hàm này đã thêm chỉ mục vào tại chỉ mục một và tại Index Wallerawang để thêm vào để nút sẽ nằm giữa hai nút này.

557
00:07:03,550 --> 00:07:12,950
Vì vậy, hãy tạo một nút mới ở đây. Đây là nút mới mà chúng tôi đã tạo bằng cách sử dụng câu lệnh này và đây là nút thứ ba trước đó. Và đây là ghi chú trước đó của bạn.

558
00:07:12,980 --> 00:07:25,300
Được rồi, bây giờ chúng ta sẽ xem những niềm hân hoan tiếp theo của Peanut Dot. Chúng tôi sẽ ngắt kết nối này. Chúng tôi sẽ kết nối liên kết này với nút này và sau đó chúng tôi sẽ tách riêng ghi chú đó bên cạnh node.

559
00:07:25,450 --> 00:07:34,570
Vì vậy, chúng tôi sẽ ngắt kết nối cái này và chúng tôi sẽ kết nối cái này với nút này và chúng tôi sẽ chỉ tăng trang web. Hội sẽ được đổi thành ba và danh sách liên kết sẽ được đại diện.

560
00:07:34,570 --> 00:07:48,810
Một cái gì đó như thế này. Một, hai, bốn. Một là đầu và bốn là đuôi. Vậy Linkous đại diện cho điều gì đó như thế này. Nếu chúng ta gọi hàm này là hai, ba ở chỉ số hai, ở chỉ số hai, chúng ta phải thêm nút ba.

561
00:07:49,090 --> 00:07:58,600
Vì vậy, nút ba sẽ nằm giữa hai nút này, nút hai và nút ba. Vì vậy, điều này không phải tất cả đều diễn ra giữa hai nút này trước tiên. Hãy tìm hiểu nút trước đó.

562
00:07:58,600 --> 00:08:13,990
Đây là nút trước đó và hãy tạo một nút bằng nút quyết định câu lệnh này. Và bây giờ mục tiêu tiếp theo là xem trước mục tiếp theo. Vì vậy, chúng ta sẽ kết nối cái này với nút này và chúng ta sẽ ngắt kết nối cái này và chúng ta sẽ kết nối cái này với nút này.

563
00:08:14,170 --> 00:08:23,140
Và chúng tôi sẽ tăng cường trang web sẽ được đánh giá và liên kết sẽ được đại diện, đại loại như thế này. Đây là cách phương pháp chỉ mục khác này hoạt động.

564
00:08:23,510 --> 00:08:35,290
Chúng ta đã hiểu điều này các thao tác thêm chỉ mục, thao tác chèn, thêm chỉ mục nên chúng ta có thể thêm một nút vào bất kỳ chỉ mục nào. Phương pháp này sẽ đưa Spiga cất cánh kịp thời.

565
00:08:35,290 --> 00:08:52,150
Độ phức tạp cho. Chúng tôi lo sợ vì chúng tôi phải tìm ra cái giá của việc không sử dụng dự phòng này, sử dụng phương pháp này, Guignard và giải pháp này sẽ chiếm một không gian phức tạp vì chúng tôi có thêm hay không vào thời điểm mà chúng tôi đã hiểu chính lời giải thích này trong video này .

566
00:08:52,170 --> 00:09:02,610
Chúng tôi đã đề cập đến ba phương pháp thêm ghét và thêm chỉ mục. Cảm ơn đã xem video
này. Nếu có bất kỳ câu hỏi bổ sung nào, hãy cho chúng tôi biết. Cảm ơn đã xem. 

@@@



567
00:00:00,570 --> 00:00:12,980
Rất nhiều chàng trai sẽ quay lại video này trong video này, chúng ta sẽ nói về chủ nghĩa khủng bố và việc tìm kiếm một nhà ngôn ngữ học trong video này. Chúng tôi sẽ triển khai điều này trên metaverse và tìm kiếm phương pháp này.

568
00:00:12,990 --> 00:00:25,230
Những kẻ khủng bố sẽ làm điều này từ trái sang phải? Và nó sẽ in các ghi chú từ trái sang phải. Và phương pháp này sẽ đạt được chỉ số của một ghi chú nhất định. Nếu ghi chú không tồn tại thì nó sẽ trả về âm một.

569
00:00:25,560 --> 00:00:37,340
Bây giờ, hãy xem cách chúng ta có thể triển khai điều này để lập phương pháp biểu diễn ngôn ngữ học nối tiếp. Được rồi, chúng ta có lớp học này. Sau đó, chúng ta có hai con trỏ đầu và đuôi này và chúng ta có phương thức nhiễu bên trong phương thức này.

570
00:00:37,350 --> 00:00:46,660
Chúng tôi sẽ kiểm tra xem Heracles có quay lại bằng văn bản này hay không. Nó sẽ chỉ là Edgett. Sau đó, chúng ta tạo một dòng con trỏ sẽ trỏ đến nốt đầu, sau đó chúng ta sẽ chạy một lúc.

571
00:00:46,660 --> 00:00:57,960
Livewell hiện tại thì không. Sternhell sẽ in ghi chú hiện tại, sau đó chúng ta chuyển dòng hiện tại sang ghi chú tiếp theo. Hãy xem nó hoạt động như thế nào sau này. Chúng tôi được cung cấp danh sách liên kết điểm-điểm hiện tại đầu tiên này tới nút đầu tiên.

572
00:00:58,230 --> 00:01:07,440
Như vậy chúng ta thấy nút này không phải là một nhà vệ sinh bình thường. Vì vậy, hãy in một cái. Bây giờ chúng ta hãy chuyển sang phần tiếp theo. Ghi chú này không phải là một nút, vì vậy hãy in giá trị của ghi chú này.

573
00:01:07,740 --> 00:01:20,550
Bây giờ chúng ta hãy chuyển sang ghi chú tiếp theo. Phát triển thông báo này thông qua lưu ý này không phải bây giờ, không phải vậy. Hãy in ba. Bây giờ, hãy chuyển sang nút tiếp theo và hãy in phát triển nút này một lần nữa, hãy chuyển sang nút tiếp theo.

574
00:01:20,580 --> 00:01:36,300
Bây giờ chúng ta thấy rằng con trỏ hiện tại của chúng ta đang trỏ đến một thứ không quá cũ. Đây là cách chúng ta tiếp cận một nhà ngôn ngữ học. Phương pháp này sẽ phát huy được độ phức tạp về thời gian và độ phức tạp về không gian không đổi vì chúng ta không sử dụng bất kỳ lời nói gốc nào.

575
00:01:36,780 --> 00:01:55,620
Bây giờ hãy nói về phương pháp Sarsae. Đây là phương pháp của chúng tôi về phương pháp này có một tham số. Chà, chúng tôi sẽ tìm kiếm giếng trong thời gian dài nhất nếu chúng tôi tìm thấy giếng trong thời gian dài nhất sẽ trả về chỉ mục của nút đó trong quá trình kiểm tra của bạn, nếu bạn chuyển sang null, sẽ trả về trừ một.

576
00:01:56,050 --> 00:02:06,660
Sau đó, chúng tôi có chỉ mục. Ban đầu, chỉ số 0 có nghĩa là nút đầu tiên ban đầu được lập chỉ mục theo chỉ mục của nốt đầu tiên, sau đó được khởi tạo theo dòng hiện tại trỏ đến nút đầu.

577
00:02:07,080 --> 00:02:24,750
Sau đó, chúng tôi đang chạy một lúc, hiện tại không phải là rỗng. Chúng tôi sẽ kiểm tra xem thẻ vàng có bằng toàn khu vực hay không, chỉ số sau đó sẽ tăng chỉ số và sau đó chúng tôi sẽ chuyển sang nút tiếp theo nếu chúng tôi không tìm thấy giá trị trong nút của chúng tôi đã có ở Minnesota.

578
00:02:24,930 --> 00:02:35,930
Hãy xem cách nó hoạt động khi tìm kiếm cây giá trị mà phần đầu cũng không phải là điểm điểm-điểm hiện tại tới nút này và giá trị không bằng ba.

579
00:02:35,940 --> 00:02:52,480
Vì vậy, hãy chuyển sang nút tiếp theo và chúng ta thấy giá trị không bằng ba. Vì vậy, hãy chuyển sang nút tiếp theo và chúng ta thấy giá trị gần bằng ba. Vì vậy, chúng tôi sẽ trả lại chỉ mục và chúng tôi đang theo dõi chỉ mục hiện tại của chúng tôi không sử dụng tra cứu biến chỉ mục này.

580
00:02:52,860 --> 00:03:05,370
Nếu chúng tôi đang tìm nguồn giá trị của năm và giá trị đó không tồn tại trong danh sách liên kết này thì con trỏ hiện tại sẽ trỏ đến nút này để lấy nội dung có giá trị này và nó sẽ chỉ trả về mạng của tôi.

581
00:03:06,080 --> 00:03:18,840
Chúng tôi đã hiểu phương pháp nguồn và đây là cách nó hoạt động. Phương pháp này sẽ, do độ phức tạp về thời gian đối với trường
hợp xấu nhất và tất cả đều chiếm không gian không đổi, độ phức tạp hoặc không sử dụng bất kỳ sự phân chia bổ sung nào. 

@@@



582
00:00:01,350 --> 00:00:18,600
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ xem cách xử lý hoạt động dẫn đầu trong một danh sách tiêu diệt duy nhất. Trong video này chúng ta sẽ triển khai xây dựng Operation Delete theo chỉ mục và xóa nội bộ.

583
00:00:19,140 --> 00:00:30,940
Phương thức này sẽ xóa một nút tại một chỉ mục nhất định và phương thức này sẽ xóa toàn bộ danh sách. Đầu tiên, hãy xem chúng ta có thể triển khai phương pháp này như thế nào. Sau đó, bạn sẽ thấy phương pháp này.

584
00:00:32,640 --> 00:00:48,810
Đây là mã của chúng tôi. Điều này sẽ xóa ở phương thức chỉ mục. Phương thức này lấy một chỉ mục tham số và ở đây chúng tôi đang kiểm tra xem chỉ mục là của liên lạc hay chỉ mục có bằng hoặc lớn hơn kích thước hay không, sau đó chúng tôi sẽ trả về.

585
00:00:49,380 --> 00:01:01,300
Nếu chỉ số bằng 0 thì chúng tôi sẽ chuyển điểm truy cập của mình sang điểm tiếp theo. Được rồi, nếu không, chúng ta sẽ lấy nút trước đó. Sau đó chúng ta sẽ gặp Peter bên cạnh nó vào năm tới.

586
00:01:01,350 --> 00:01:17,190
Năm tới, chúng tôi chỉ giữ nút hiện tại của mình và sau đó kiểm tra xem chỉ mục có phải là nút cuối cùng hay không, sau đó chúng tôi phải chuyển đuôi sang nút mang thai và ở đây chúng tôi chỉ giảm trang web.

587
00:01:17,820 --> 00:01:30,480
Bây giờ hãy xem nó hoạt động như thế nào. Giả sử chúng tôi đưa ra phương thức này dài nhất và chúng tôi gọi phương thức này là xóa tại chỉ mục bằng ba. Vì vậy công việc của chúng ta là loại bỏ nút số 4 này khỏi danh sách liên kết.

588
00:01:30,780 --> 00:01:40,770
Vì vậy, đối với những gì chúng ta sắp làm, chúng ta sẽ nhận được quyết định về nút trước đó, nút trước đó của chúng ta. Được rồi, chúng ta sẽ nói P'-- tiếp theo hãy chuyển đến Peter tiếp theo DOT tiếp theo.

589
00:01:40,780 --> 00:01:51,160
Vì vậy, chúng ta sẽ ngắt kết nối điểm này và chúng ta sẽ chỉ vào ghi chú này một cách xảo quyệt tiếp theo. Đây là lưu ý tiếp theo. Vậy bên cạnh, tiếp theo là gì? Điều đó có nghĩa là bây giờ node.

590
00:01:51,630 --> 00:02:05,520
Vì vậy, nút này hiện không trỏ đến gì cả. Không có gì trỏ đến nút này. Vì vậy Garrick's Collector sẽ loại bỏ nút này khỏi bộ nhớ máy tính trong bộ nhớ máy tính.

591
00:02:05,520 --> 00:02:23,060
Nghĩa là trong bộ nhớ truy cập ngẫu nhiên hay trong IRAM đều có bộ thu gom rác, bộ thu gom rác, tất cả chỉ là tìm kiếm những dữ liệu không được sử dụng. Trong RAM, bất cứ khi nào nó tìm thấy dữ liệu không được sử dụng, dữ liệu sẽ bị trình thu gom rác xóa.

592
00:02:23,730 --> 00:02:37,170
Sau đó, chúng ta thấy chỉ số đó theo kích thước trừ một. Vì vậy, chúng ta sẽ di chuyển cái đuôi của mình hướng tới nút này. Vì vậy danh sách liên kết này sẽ được đại diện. Những thứ như thế này chúng tôi gọi hàm này là xóa ở chỉ mục một.

593
00:02:37,170 --> 00:02:48,050
Trong trường hợp này, chúng tôi sẽ xóa nút này vì điều đó. Những gì chúng ta sắp làm, chúng ta sẽ lấy nút trước đó. Đây là nút trước, sau đó là nút tiếp theo.

594
00:02:48,450 --> 00:02:58,110
Vì vậy, chúng tôi sẽ ngắt kết nối liên kết này và chúng tôi sẽ kết nối với nút này. Và trong trường hợp này, điều kiện này là sai và sẽ chỉ tạo lại trang web.

595
00:02:58,290 --> 00:03:08,850
Và bây giờ chúng ta thấy rằng không có gì trỏ đến nút này. Vì vậy nút này sẽ bị người thu gom rác loại bỏ. Vì vậy, danh sách liên kết sẽ được trình bày như thế này.

596
00:03:09,250 --> 00:03:20,280
Đây là cách xóa tại chỉ mục hoạt động. Hãy gọi xóa ở chỉ số 0. Trong trường hợp này, bạn sẽ làm gì trong trường hợp này? Bạn sẽ di chuyển đầu của bạn chỉ vào nút tiếp theo.

597
00:03:20,280 --> 00:03:31,900
Vì vậy nó sẽ trỏ đến nút này và nút này. Vì vậy, nó sẽ trỏ đến ghi chú này và không có gì trỏ đến nút này. Vì vậy tờ ghi chú này sẽ bị người sưu tập của Garrick xóa đi.

598
00:03:32,100 --> 00:03:53,960
Vì vậy, nó sẽ được đại diện như thế này. Chúng tôi chỉ có một nút trong tất cả điều này. Đây là cách chúng tôi xem xét hoạt động của phương pháp chỉ mục. Phương pháp này thực hiện vì độ phức tạp về thời gian, vì chúng ta phải tìm ra nút trước đó của mạch và nó sẽ có độ phức tạp không gian không đổi.

599
00:03:54,210 --> 00:04:05,850
Chúng tôi không sử dụng bất kỳ nhổ bổ sung. Bây giờ hãy xem cách chúng ta có thể xóa danh sách liên kết. Bây giờ hãy xem cách chúng ta có thể xóa danh sách liên kết. Đây là phương pháp xóa danh sách nhập của chúng tôi.

600
00:04:06,000 --> 00:04:18,000
Và ở đây chúng tôi chỉ nói đến cụm Haiti null. Giả sử bạn được giao cho nhà ngôn ngữ học này, sau đó chúng ta gọi hàm này là xóa danh sách nhập và ở đây chúng ta chỉ di chuyển đến đây cho đến nút rỗng.

601
00:04:18,230 --> 00:04:27,750
OK, bây giờ chúng ta thấy rằng không có gì trỏ đến nút này. Vì vậy, đây là dữ liệu không được sử dụng trong RAM. Vì vậy, trình thu gom rác sẽ thu thập và xóa nút này khỏi chúng.

602
00:04:28,350 --> 00:04:40,410
Sau đó chúng ta có nút này. Không có gì trỏ đến nút này vì nút này đã bị bộ thu gom rác xóa. Vì vậy, ghi chú này cũng sẽ bị người thu gom rác xóa.

603
00:04:41,010 --> 00:04:54,000
Sau đó, nút thứ ba này, chúng ta thấy rằng không có gì khác trỏ đến nút này. Vì vậy đồng nghiệp không và sẽ trì hoãn ghi chú này từ RAM. Rồi cái nút này ta thấy có gì là trỏ tới cái này đâu phải không.

604
00:04:54,000 --> 00:05:10,770
Ghi chú này sẽ bị người thu gom rác xóa và sau đó chúng tôi không có nghĩa là gì cả. Đây là cách làm việc của toàn bộ nhà báo, nếu chúng ta vẫn muốn biết thì nhà ngôn ngữ học này sẽ bị xóa khỏi bộ nhớ máy tính của chúng ta.

605
00:05:10,950 --> 00:05:25,330
Đây là cách phương pháp này hoạt động và nó cần có thời gian, độ phức tạp và độ phức tạp không gian không đổi vì chúng tôi đang di chuyển cho đến khi Hayden biết về việc tải xuống, chúng tôi không làm gì ngoại trừ những thao tác này.

606
00:05:25,380 --> 00:05:37,930
Vì vậy, chúng tôi cần có thời gian liên tục và độ phức tạp về không gian liên tục để hiểu được lời giải thích của video này,
nếu có bất kỳ câu hỏi nào, nếu chúng tôi có bất kỳ vấn đề nào trong việc hiểu lời giải thích này, thì chúng tôi không cần. 

@@@



607
00:00:00,420 --> 00:00:14,270
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ xem cách tạo một nút quyết định danh sách đơn hình tròn. Một lần nữa, nút này chứa hai thuộc tính, dữ liệu và con trỏ tiếp theo.

608
00:00:14,790 --> 00:00:29,430
Và chúng ta có một cái đầu tròn và các xúc tu này vô giá trị và chu kỳ về 0. Ban đầu, đây là đại diện nút và liên kết của chúng tôi. Ban đầu, Hayden đang trỏ đến node.

609
00:00:29,430 --> 00:00:41,790
Điều đó có nghĩa là nó không trỏ đến gì cả. Đây là danh sách gửi thư mã của chúng tôi. Đây là danh sách đơn mẫu của tôi. Chúng tôi có nút lớp này. Sau đó chúng ta có quyền kiểm soát dữ liệu ẩn bên trong được gọi là Cejudo.

610
00:00:42,210 --> 00:00:54,180
Ban đầu chúng tôi có nút này trong video này. Chúng ta sẽ triển khai thêm nút và phương thức này sẽ thêm nút vào đuôi và sẽ in các giá trị nút.

611
00:00:54,720 --> 00:01:08,760
Và tôi sẽ chuyển đổi mã này thành mã giả để nó sẽ ít nói hơn trên màn hình máy tính của chúng ta. Bây giờ hãy thêm phương thức nút. Họ nói rằng họ muốn thêm phương thức nút.

612
00:01:08,770 --> 00:01:19,950
Phải mất một tham số, sau đó chúng tôi sẽ tạo một nút mới và bạn đang tuyển dụng nút mới. Và sau đó chúng tôi đang kiểm tra liên quan đến node. Và sau đó chúng ta sẽ gán Headend trỏ tới ghi chú mới.

613
00:01:20,160 --> 00:01:31,650
Sau đó chúng tôi nói rằng Taylor cần phải làm điều đó. Nếu không, thì chúng ta sẽ nói rằng Taylor cần chuyển đến nút mới 900 960 để đến đầu và cuối đơn vị Coldstone. Và sau đó chúng tôi sẽ tăng quy mô nhà ngôn ngữ học của chúng tôi.

614
00:01:32,610 --> 00:01:45,720
Hãy gọi phương thức này là addnode bằng một. Bây giờ chúng ta sẽ làm gì? Chúng ta sẽ tạo một nút mới có giá trị bằng một và sau đó chúng ta sẽ chỉ định Hayden chỉ vào ghi chú này vì ban đầu anh ấy không biết.

615
00:01:46,710 --> 00:01:59,410
Và địa chỉ của nút này là 0 không 0 chẳng hạn. Bây giờ chúng ta đang nhìn thấy Taylored bên cạnh nó. Vì vậy, chúng ta sẽ thêm con trỏ này vào nút này.

616
00:01:59,700 --> 00:02:12,300
OK, vậy ở đây chúng ta đang lưu trữ địa chỉ của nút này. Vậy ghi chú này sẽ được trình bày, đại loại như thế này. Vậy là chúng ta có mối liên hệ giữa câu chuyện này với sự căm ghét.

617
00:02:12,600 --> 00:02:24,660
ĐƯỢC RỒI. Bây giờ, trang web của tất cả những thứ này là trang web mà chúng ta hãy gọi hàm này là giá trị gia tăng. Trong trường hợp này, chúng ta sẽ tạo một nút mới. Vì vậy, hãy tạo một nút khám phá mới.

618
00:02:24,870 --> 00:02:36,870
Và rồi ta thấy ở đây không bằng bây giờ và ta thấy ở đây không bằng bây giờ. Vì vậy bây giờ chúng ta đang xem tuyên bố ILD này ở đây. Chúng ta sẽ xem lớp học tiếp theo dành cho trẻ sơ sinh.

619
00:02:37,080 --> 00:02:53,730
Vì vậy, chúng ta sẽ ngắt kết nối con trỏ này và chúng ta sẽ kết nối với nút này. Được rồi, vậy bạn đến Coldstream tiếp theo. Vì vậy, chúng ta sẽ kết nối điểm này với nút này và sau đó chúng ta sẽ di chuyển đuôi đến nút này.

620
00:02:54,240 --> 00:03:08,960
Sau đó, danh sách liên kết này sẽ được trình bày, đại loại như thế này. Và trang web của danh sách liên kết này là kết thúc. Nút này được kết nối với nút Hayden của chúng tôi. Bây giờ hãy gọi và nút có giá trị ba.

621
00:03:09,660 --> 00:03:32,850
Bây giờ chúng ta đã tạo một nút mới ở đây, được chứ? Và chúng ta thấy nó không bằng bây giờ. Vì vậy, chúng ta sẽ thực hiện cuộc gọi tiếp theo tới nút mới. Vì vậy, chúng ta sẽ ngắt kết nối cái này và chúng ta sẽ kết nối với nút này và sau đó chúng ta sẽ gửi lớp tiếp theo để ghét và sau đó yêu cầu chuyển đến nút mới này và sau đó nhà ngôn ngữ học sẽ được đại diện, đại loại như thế này.

622
00:03:33,150 --> 00:03:45,090
Và chúng ta thấy ở đây chúng ta có một chu trình. Chúng ta có thể đi từ một đến hai, từ hai đến ba, từ theta một. Chúng ta có một chu kỳ ở đây, được chứ? Đây được gọi là nhà ngôn ngữ học đơn tròn.

623
00:03:46,200 --> 00:04:05,780
Đây là cách chúng ta có thể thêm nút vào đuôi. Phương pháp này sẽ có độ phức tạp một lần lớn hơn và độ phức tạp không gian lớn hơn. Bây giờ hãy xem phương pháp in của chúng ta, cách chúng ta có thể in giá trị của danh sách phân lớp.

624
00:04:06,110 --> 00:04:20,820
ĐƯỢC RỒI. Ban đầu nó sẽ in giá trị của một nút. Vì vậy, chúng tôi đã in giá trị của một nút. Sau đó, con trỏ hiện tại và con trỏ hiện tại của chúng ta sẽ trỏ đến nút này và chúng ta thấy nút này không phải là nút đầu của chúng ta.

625
00:04:20,940 --> 00:04:33,940
Vì vậy, hãy mang giá trị của nút này. Vì vậy, hãy mang nó đến bây giờ, hãy chuyển hiện tại sang nút tiếp theo. Bây giờ con trỏ hiện tại của chúng ta sẽ trỏ đến nút ba này và hãy mang giá trị của Nút ba này.

626
00:04:34,320 --> 00:04:49,890
Sau đó, hãy chuyển dòng điện sang nút tiếp theo hoặc nút tiếp theo của đuôi nút này là ghét vì chúng ta có một vòng tròn ở đây. Vì vậy hiện tại sẽ trỏ đến ghi chú này. Và trong trường hợp này, chúng ta thấy nút hiện tại của chúng ta ở đây.

627
00:04:50,220 --> 00:05:10,950
Vì vậy chúng ta sẽ dừng lại. Chúng ta có kết quả này là một, hai và ba. Đây là những gì chúng ta có thể in các giá trị nút của một vòng tròn. Tiếng Anh, cảm ơn. Trong video này, tôi sẽ gặp các bạn ở video tiếp theo, ồ, độ phức tạp về thời gian cho vấn đề này lớn hơn việc đồng bộ hoặc di chuyển dài nhất từ ​​​​trái sang phải một lần.

628
00:05:11,550 --> 00:05:25,360
Và tất cả đều có độ phức tạp về không gian không đổi vì chúng tôi không sử dụng bất kỳ phần bổ sung nào. Được rồi các bạn, chúng ta đã
hiểu video giải thích này rồi. Nếu có bất kỳ câu hỏi nào về bất kỳ vấn đề nào, hiểu rõ lời giải thích này, hãy cho chúng tôi biết. 

@@@



629
00:00:00,630 --> 00:00:22,260
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ điểm qua và tìm kiếm người theo chủ nghĩa pháp lý duy nhất trong Circler. Chúng tôi sẽ triển khai hai phương thức khách du lịch và phương thức làm xáo trộn dịch vụ sẽ duyệt qua danh sách liên kết từ trái sang phải và nó sẽ in các giá trị nút và phương thức dịch vụ sẽ tìm kiếm các giá trị nút cụ thể.

630
00:00:22,530 --> 00:00:36,180
Nếu các giá trị tồn tại thì nó sẽ trả về chỉ mục của nút cụ thể đó. Nếu giá trị không tồn tại thì nó sẽ trả về trừ một giá trị đầu tiên đối với phương thức, sau đó là phương thức Altisource.

631
00:00:37,440 --> 00:00:48,450
Đây là quy tắc của chúng tôi và đây là phương pháp khủng bố của chúng tôi. Ví dụ: sẽ kiểm tra xem haricots có biết sẽ in danh sách trống hay không và sẽ chỉ bằng câu lệnh bằng văn bản này.

632
00:00:49,080 --> 00:00:58,990
Nếu không, chúng tôi sẽ in giá trị lần truy cập, sau đó chúng tôi sẽ khởi tạo điểm hiện tại cho nút tiếp theo hoặc chưa có loại Organa nào chạy hoang dã.

633
00:00:58,990 --> 00:01:13,500
Có phải Noriko ghét bản in cũ, giá trị ghi chú hiện tại và sau đó chúng ta sẽ chuyển hiện tại sang nút tiếp theo. Phương pháp này hoàn toàn giống với phương pháp in mà chúng ta đã học trong video trước.

634
00:01:14,070 --> 00:01:26,910
Chúng ta sẽ có điều này một lần nữa. Lần này tên phương thức này là Devers. Vì vậy, ban đầu nó sẽ in giá trị của các nút ẩn của chúng tôi. Vì vậy, chúng tôi sẽ in một cái, sau đó chúng tôi sẽ khởi tạo nó.

635
00:01:26,910 --> 00:01:36,830
Được chỉ vào ghi chú này, đây là nút tiếp theo hoặc nút ghét và đây là nút hiện tại của chúng tôi. Và chúng tôi thấy nút hiện tại này không dành cho Hayden. Vì vậy, hãy in giá trị của nút này.

636
00:01:37,350 --> 00:01:47,520
Hãy chuyển sang phần tiếp theo. Chúng tôi thấy ghi chú này không phải là hadler của chúng tôi. Vậy chúng ta hãy phát triển cái này chứ không phải ba. Hãy di chuyển dòng điện tới nút tiếp theo và nút tiếp theo lên thợ may.

637
00:01:47,700 --> 00:02:09,390
Vì ở đây chúng ta có một vòng tròn và chúng ta thấy rằng không có nút ghét nào hiện tại. Vì vậy, tất cả mọi thứ. Và đây là kết quả Tamasi của chúng ta và phương pháp này sẽ tính toán Spiga về thời gian, độ phức tạp hoặc bất kỳ liên kết nào từ trái sang phải một lần và nó sẽ có độ phức tạp không gian không đổi vì chúng ta chỉ sử dụng một dòng con trỏ.

638
00:02:10,260 --> 00:02:24,000
Bây giờ hãy xem phương pháp sers. Đây là phương pháp nguồn của chúng tôi. Đầu tiên chúng ta sẽ kiểm tra xem Haiti có trở thành null hay không và sẽ trả về âm một. Nếu giá trị của hidenori của chúng ta giảm xuống, nó sẽ trả về chỉ mục của nút của chúng ta.

639
00:02:24,420 --> 00:02:35,220
Đó là chỉ số dựa trên số 0 của nút này trên chỉ số 0 của nút này so với chỉ số một của NE này. Sau đó chúng ta sẽ khởi tạo một biến int có chỉ số gần bằng một.

640
00:02:35,520 --> 00:02:47,340
Sau đó, chúng tôi đang khởi tạo một dòng con trỏ tới nút chi phí mạng tiếp theo của chúng tôi. Sau đó chúng ta sẽ kiểm tra xem dòng điện có phải là của Noriko hay không. Chúng tôi sẽ kiểm tra xem giá trị hiện tại có trả về chỉ mục hay không.

641
00:02:47,910 --> 00:03:00,250
Nếu không, chúng tôi sẽ tăng chỉ số và sau đó chúng tôi sẽ chuyển đi. Hiện tại trỏ đến nút tiếp theo sau khi thực hiện việc này. Trong khi nếu chúng ta không tìm thấy Derechos hiện tại quá tốt, thì chúng ta sẽ trả về điểm trừ một.

642
00:03:00,660 --> 00:03:11,760
Bây giờ hãy gọi hàm SERS ba. Bây giờ chúng ta sẽ tìm kiếm cây giá trị trong danh sách liên kết này và sẽ trả về chỉ mục của nút ba.

643
00:03:12,060 --> 00:03:19,560
Nếu không tìm thấy thì nó chưa có trong danh sách liên kết, trừ một. Vì vậy, đầu tiên chúng ta sẽ kiểm tra điều này. Vâng, những gì chúng ta không thấy một là không gần với ba.

644
00:03:19,740 --> 00:03:28,740
Vì vậy, hãy khởi tạo bổ nhiệm này, không phải hai. Sau đó chúng ta sẽ kiểm tra hai và ba. Vậy là chúng vẫn chưa bằng nhau. Vì vậy, hãy chuyển hiện tại sang tiếp theo.

645
00:03:29,400 --> 00:03:41,310
Bây giờ chúng ta thấy ba bằng hai ba. Vì vậy nó sẽ trả về chỉ số của nút này ba. Đó là hai. Vì thế nó sẽ quay về và đếm chỉ số theo biến chỉ số này.

646
00:03:41,610 --> 00:03:54,900
Được rồi, nếu bạn chắc chắn rằng điều đó không tồn tại trong danh sách liên kết này thì tôi sẽ quay lại. Được rồi. Đây là cách hoạt động của sự quấy rối này. Phương pháp này sẽ phát huy được độ phức tạp về thời gian đối với trường hợp xấu nhất.

647
00:03:55,380 --> 00:04:08,190
Và nó sẽ có độ phức tạp về không gian không đổi vì bạn chỉ sử dụng hai biến chỉ số và hiện
tại ở đây. Hiện tại là một con trỏ. Chúng tôi đã hiểu lời giải thích thực sự này. 

@@@



648
00:00:00,300 --> 00:00:15,960
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ xem cách chèn đơn Enquist hình tròn trong video này. Chúng ta sẽ gặp ba thao tác được thêm vào ghét, thêm chi tiết, thêm chỉ mục.

649
00:00:16,740 --> 00:00:27,520
Đầu tiên, chúng ta sẽ bắt đầu với phương pháp này, thêm vào đó là sự căm ghét. Sau đó, bạn thấy chi tiết được thêm vào, sau đó sẽ thấy chỉ mục được thêm vào. Đầu tiên, chúng ta hãy xem phương pháp head được thêm vào.

650
00:00:27,990 --> 00:00:42,750
Được rồi. Đây là phương pháp căm thù bổ sung của chúng tôi. Ban đầu chúng tôi có nhà ngôn ngữ học này và quyết định đi. Phương thức này lấy một tham số. Chà, bên trong đây, chúng ta đang tạo một ghi chú mới có giá trị.

651
00:00:43,230 --> 00:01:00,390
Sau đó, chúng tôi đang kiểm tra xem từ Citronelle dị giáo có gán đầu và đuôi cho nút mới hay không. Sau đó chúng ta sẽ nói cho đến khi mục tiêu tiếp theo là đạt được nó. Nếu không ở phía trước bằng null mới, không phải cái tiếp theo đi tới bên cạnh không thực sự là đơn vị và kích thước Coldstone cộng với klatsch.

652
00:01:00,810 --> 00:01:13,920
Nếu chúng ta gọi phương thức này vào một ngày bằng một, thì chúng ta sẽ tạo một nút mới có giá trị là một và chúng ta sẽ nói ở đây hadit train bằng với nút mới.

653
00:01:14,580 --> 00:01:30,390
Vì vậy, chúng tôi đang chỉ định lượt truy cập không chi tiết được trỏ đến nút mới và sau đó chúng tôi sẽ nói ở đây là Geldart Mixteco đáng ghét. Vì vậy, chúng tôi đã kết nối đuôi với ghi chú này để chúng tôi nghiên cứu địa chỉ của nút này có thể được gọi lại là chức năng này.

654
00:01:31,770 --> 00:01:43,610
Sau đó chúng ta sẽ tạo một nút mới, được thôi. Và trong trường hợp này nó không bằng bây giờ. Vậy chúng ta sẽ làm gì sẽ nói gì mà lớp tiếp theo lại ghét.

655
00:01:43,620 --> 00:02:00,960
Vì vậy, điều này là không thể. Đây là nút mới. Được rồi, vậy nút mới dấu chấm tiếp theo tương đương với sự ghét bỏ và thông báo cho lớp tiếp theo về nút mới và chúng ta sẽ chuyển sang nút này.

656
00:02:01,680 --> 00:02:15,530
Vì vậy, liên kết này sẽ được thể hiện, đại loại như thế này. Đây là nút ghét của chúng ta còn đây không phải là đuôi của chúng ta và cái đuôi này được kết nối với nút ghét này. Được rồi, đây là cách hoạt động của phương thức thêm vào ghét này.

657
00:02:15,660 --> 00:02:32,640
Phương pháp này sẽ khiến Spiga có độ phức tạp một lần và độ phức tạp một không gian. Bây giờ hãy nói về phương pháp thêm đuôi. Ban đầu chúng ta có nhà ngôn ngữ học này, OK, ở đây, phương thức này lấy một tham số chuông ở đây, tạo nút mới.

658
00:02:32,880 --> 00:02:42,750
Và sau đó chúng ta sẽ kiểm tra xem liệu chúng ta có định gán điểm ẩn cho nút mới hay không, sau đó chúng ta sẽ nói Taylored tiếp theo là đi thẳng, nếu không phải đến tuần sau.

659
00:02:43,110 --> 00:02:53,610
Mục tiêu tiếp theo là ghét Coldstone Node và tăng cường trang web. Bây giờ hãy gọi phương thức này được thêm vào bằng một. Vì vậy, chúng ta sẽ tạo một nút mới.

660
00:02:53,760 --> 00:03:09,760
Và ở đây chúng tôi đang gửi Con trỏ Hidell tới nút mới này. Và ở đây chúng ta thấy rằng ở đây tương đương với bây giờ. Vì vậy, chúng tôi đang chỉ định lượt truy cập và tiêu diệt cho mục tiêu này, chứ không phải cho đến mục tiêu tiếp theo để nối tiếp lệnh gọi tiếp theo đó.

661
00:03:10,050 --> 00:03:18,300
Vì vậy, chúng tôi đang kết nối con đường này với sự căm ghét này. Vì vậy nó vẫn sẽ ghét địa chỉ. Không không không một. Vì vậy, danh sách liên kết sẽ được trình bày như thế này.

662
00:03:19,230 --> 00:03:36,300
OK, đây là cách biểu diễn và kích thước bằng một. Bây giờ bạn gọi lại chức năng này được thêm vào hai. Và ở đây chúng ta đang tạo một nút mới và chúng ta thấy ở đây không phải là Egleston mà là Taylored bên cạnh nút mới không bị ngắt kết nối.

663
00:03:36,330 --> 00:03:51,720
Hãy kết nối với nút này và sau đó đơn vị tiếp theo tương đương với sự căm ghét. Vì vậy, chúng ta sẽ kết nối với sự căm ghét này và chúng ta sẽ di chuyển đuôi đến nút này. Và danh sách liên kết đã đại diện cho một cái gì đó như thế này.

664
00:03:52,380 --> 00:04:05,550
OK, nhà ngôn ngữ học sẽ được thể hiện như thế này. Đây là HAID và đây là sự thật. Đây là cách phương pháp có thể chỉnh sửa hoạt động. Phương pháp này cũng khiến Bego có độ phức tạp một lần và độ phức tạp lớn hơn về không gian.

665
00:04:06,120 --> 00:04:18,970
Bây giờ hãy nói về phương pháp chỉ mục được thêm vào. Tất cả điều này đã được thêm vào phương thức chỉ mục cho phương thức này. Chúng ta cần một phương thức trợ giúp để lấy nút, được chứ? Phương thức này có hai tham số là chỉ mục và eval.

666
00:04:19,720 --> 00:04:32,520
Chỉ mục kiểm tra nhỏ hơn 0 hoặc chỉ mục lớn hơn trang web và sẽ trả về đây nếu chỉ mục sẽ áp dụng ở chỉ mục trạng thái bằng với trang web và tất cả đều áp dụng ở đây tại bảng.

667
00:04:32,850 --> 00:04:48,630
Và 2 phương pháp này chúng ta đã học ở slide trước, nếu chỉ số không bằng 0 và chỉ mục không bằng trang web thì câu lệnh ELT này sẽ được thực thi tại đây, sẽ tạo một nút mới, khi đó chúng ta sẽ lấy được lệnh trước đó , không phải nút trước đó.

668
00:04:48,630 --> 00:04:59,820
Cụm tiếp theo là sơ sinh 900, cụm tiếp theo không chấm tiếp. Và ở đây để lấy trước không sẽ gọi đây là phương thức trợ giúp. Và ở đây chúng ta có một con trỏ hiện tại và chúng ta đang chạy một chút.

669
00:04:59,920 --> 00:05:16,330
Để tìm ra không ở chỉ số trừ một, chúng ta phải tìm nó vào đêm hôm trước, ví dụ, sau khi cho liên kết này và chúng ta phải thêm chỉ mục phản hạt vào nhà ngôn ngữ học này, hãy gọi hàm này được thêm vào chỉ số là bốn.

670
00:05:16,360 --> 00:05:29,620
Vì vậy chúng ta cũng phải thêm ghi chú này để thêm chỉ mục. Vì vậy, ngay giữa phần ghi chú này, chúng ta hãy tạo một ghi chú mới ở đây. Đây là nút mới của chúng tôi. Vì vậy, chúng ta sẽ lấy ghi chú trước đó vào nút trước của chỉ mục.

671
00:05:29,620 --> 00:05:44,640
Hai là ghi chú này. Đây là lần trước của chúng tôi không được tổ chức như vậy. Dấu chấm trước bên cạnh các chữ số được kết nối sẽ kết nối với nút này. Sau đó chúng ta sẽ nói, bạn biết đấy, điều tiếp theo tương đương với việc ngăn chặn điều tiếp theo.

672
00:05:44,650 --> 00:05:54,850
Vì vậy, chúng ta sẽ kết nối ghi chú này với ghi chú này. Vì vậy ghi chú này sẽ được chèn ngay vào giữa hai nút hai và ba này. Vậy nhà ngôn ngữ học đó sẽ được đại diện, đại loại như thế này.

673
00:05:56,260 --> 00:06:07,960
Đây là cách phương thức chỉ mục được thêm này hoạt động. Phương pháp này thực hiện vì độ phức tạp về thời gian, vì chúng ta phải tìm ra nút trước đó trong trường hợp xấu nhất và nó sẽ xử lý độ phức tạp về không gian.

674
00:06:08,350 --> 00:06:17,950
Vâng, chúng tôi đã hiểu lời giải thích này. Nếu bạn có bất kỳ vấn đề nào khi hiểu lời giải thích
này, hãy cho chúng tôi biết. Cảm ơn đã xem video này. Tôi sẽ gặp bạn trong video tiếp theo. 

@@@



675
00:00:00,360 --> 00:00:24,870
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng tôi sẽ thực hiện thao tác y tế dư thừa, bao gồm cả phần cuối cùng trong video này, chúng tôi sẽ triển khai để xóa tại chỉ mục và xóa, phương pháp xóa và lập chỉ mục xen kẽ sẽ xóa ghi chú tại một chỉ mục cụ thể và xóa nhập danh sách tất cả xóa toàn bộ danh sách.

676
00:00:24,920 --> 00:00:43,530
Bây giờ hãy xem chúng ta có thể triển khai phương thức này như thế nào. Đầu tiên, hãy nói về phương pháp chỉ mục đã xóa này và chúng ta sẽ nói về phương pháp dẫn vào danh sách. Đây là mã của chúng tôi để xóa tại chỉ mục, phương thức trợ giúp nối tiếp mà chúng tôi cần để triển khai phương thức này.

677
00:00:43,530 --> 00:00:54,120
Xóa tại chỉ mục. Phương thức này lấy một tham số. Sau đó, ở đây chúng tôi đang kiểm tra chỉ số nhỏ hơn 0 hoặc chỉ số lớn hơn hoặc bằng. Xã hội sẽ thoát ra bằng tuyên bố bằng văn bản này.

678
00:00:54,600 --> 00:01:08,470
Nếu chỉ số bằng 0 thì chúng ta di chuyển nó trỏ đến nút tiếp theo. Nếu không, thì chúng ta sẽ lấy phương pháp trước đó không sử dụng phương pháp này ở đây, sau đó chúng ta sẽ tách giai đoạn cụm tiếp theo.

679
00:01:08,490 --> 00:01:19,180
Tiếp theo tiếp theo. Và ở đây, nếu tìm ra thẻ mục lục có kích thước trừ một thì chúng ta phải di chuyển đuôi chỉ vào ghi chú đó và chúng ta chỉ đang chiêu mộ trang web thôi.

680
00:01:20,340 --> 00:01:34,210
Bây giờ, hãy xem nó hoạt động như thế nào. Nếu chúng ta gọi phương thức này là xóa ở chỉ mục một. Vì vậy chúng ta phải xóa ghi chú này. Vậy làm thế nào để chúng ta có thể làm điều này trước tiên để lấy được ghi chú trước đó, ghi chú trước đó của bạn rồi sắp xếp nó.

681
00:01:34,290 --> 00:01:46,500
Tiếp theo đi đến dấu chấm tiếp theo. Tiếp theo, chúng ta sẽ bỏ qua ghi chú này và sẽ kết nối với ghi chú này. Không phải bây giờ. Chúng tôi thấy rằng không có gì chỉ ra điều này. Không phải người thu gom rác sẽ thu thập ghi chú này và xóa ghi chú này khỏi RAM.

682
00:01:47,460 --> 00:02:01,890
Bạn biết đấy, trong phòng máy tính có một cái máy thu gom rác, chỉ thế thôi. Tôi vừa tìm kiếm dữ liệu không sử dụng. Nếu tìm thấy bất kỳ dữ liệu không sử dụng nào, trình thu gom rác sẽ xóa dữ liệu không sử dụng đó khỏi RAM.

683
00:02:02,520 --> 00:02:21,900
Vì vậy, điều này sẽ được đại diện. Một cái gì đó như thế này. Chúng ta gọi lại phương thức này với chỉ mục này là một, vậy điều gì sẽ xảy ra trong trường hợp này? Chúng tôi sẽ nhận được ghi chú trước đó và chúng tôi sẽ nói không phải vào tuần tới mà tiếp theo ngay bên cạnh nó sẽ ngắt kết nối và nó sẽ kết nối với nút này.

684
00:02:22,680 --> 00:02:37,950
Vì vậy, nó sẽ trỏ đến cùng một nút này. Và bây giờ chúng tôi nói rằng không có gì trỏ đến nút này. Vì vậy rác được thu gom không và sẽ xóa ghi chú này. Và chúng tôi cũng sẽ hướng cái đuôi của mình về phía này, trong trường hợp này là chỉ mục, tẩy chay Meynet.

685
00:02:38,090 --> 00:02:58,110
Được rồi, danh sách liên kết sẽ được trình bày như thế này. Chúng tôi đã hiểu vấn đề này nên xóa tại mục lục. Phương pháp này sẽ khiến Spiga có độ phức tạp về thời gian trong trường hợp xấu nhất, bởi vì chúng ta phải tìm ra nút trước đó của một chỉ mục nhất định và nó sẽ có độ phức tạp không gian không đổi.

686
00:02:59,100 --> 00:03:12,630
Bây giờ hãy nói về việc xóa danh sách nhập. Phương thức này không có tham số và ở đây chúng ta sẽ kiểm tra. Nếu quy mô không phải là Citronelle, thì chúng tôi sẽ giải quyết bên ngoài tiếp theo và Head and Chillicothe's Tranel và chúng tôi sẽ gác Hiến pháp sang một bên.

687
00:03:13,050 --> 00:03:24,440
Vì vậy, tất cả những điều này có nghĩa là gì, trước tiên, chúng ta sẽ kiểm tra xem nó có bằng null hay không nếu lệnh của Tali ở đuôi tàu hải lý và loại bỏ đối với D-Link bằng cách nói Chillicothe's với con của chúng ta tiếp theo.

688
00:03:24,450 --> 00:03:40,130
Cottonelle OK vậy là nó sẽ ngắt link này ra nên không có gì trỏ tới cái này cả. Không có ai ngoại trừ con trỏ phía trước. Bây giờ chúng ta sẽ làm gì. Chúng ta sẽ loại bỏ hai con trỏ này và bây giờ chúng ta sẽ trỏ hai con trỏ này tới nút đó.

689
00:03:40,530 --> 00:03:58,050
Vì vậy, nó không trỏ đến nút này, cho đến khi nó không trỏ đến nút này. Và chúng ta thấy bây giờ không có gì chỉ ra điều này. Không phải vậy, ghi chú này sẽ được người thu gom rác thu thập và nó sẽ bị xóa sau đó nút này không có gì trỏ đến điều này, không phải vì nút này đã bị người thu gom rác xóa.

690
00:03:58,200 --> 00:04:06,810
Vì vậy, nút này cũng sẽ được thu thập bởi trình thu gom rác và trình thu gom rác sẽ loại bỏ nút này, sau đó là nút này. Và không có gì trỏ đến nút này.

691
00:04:06,810 --> 00:04:19,650
Vì vậy nút này cũng sẽ bị người thu gom rác loại bỏ. Và bây giờ chúng ta thấy không có gì trong bộ nhớ máy tính của mình và đây là cách hoạt động của phương pháp này. Chúng tôi đã hiểu phương pháp này.

692
00:04:20,010 --> 00:04:29,940
Phương pháp này hoạt động trong thời gian không đổi và độ phức tạp không gian không đổi. Vì chúng ta phải gặp những thao tác này ở đây nên chúng ta đã hiểu điều này với những giải thích.

693
00:04:29,940 --> 00:04:37,350
Nếu bạn có bất kỳ vấn đề nào khi hiểu phần giải thích về tốc độ, hãy cho chúng tôi biết
mã nguồn được đề cập đến video này. Hãy kiểm tra nó. Cảm ơn đã xem video này. 

@@@



694
00:00:01,260 --> 00:00:14,340
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng ta sẽ xem cách tạo một danh sách xử lý kép trong giờ này, không phải để tăng lên. Chúng tôi có ba thuộc tính cần ngăn chặn vào năm tới.

695
00:00:14,340 --> 00:00:26,600
Hai con trỏ riêng tư. Và tiếp theo, đây là danh sách tải xuống của chúng tôi. Ban đầu, đầu và đuôi bây giờ hướng về phía bắc và phía nam. Kojiro, đây không phải là sự đại diện mà chúng tôi phải chỉ ra.

696
00:00:26,940 --> 00:00:45,750
Và tiếp theo, chúng ta có một dữ liệu, nhà ngôn ngữ học của chúng ta ban đầu, OK, ngay bây giờ, không có cú đánh và nói nào sẽ trỏ đến ghi chú này. Đây là mã của chúng tôi, chúng tôi có ở đây. Lưu ý nó chứa ba thuộc tính, Daraprim và tiếp theo.

697
00:00:45,930 --> 00:00:57,320
Và ở đây chúng ta có ghi chú trống này. Đây là đại diện mới của chúng ta, được chứ? Và ở đây chúng tôi đã thêm hai vấn đề. Nó lấy dữ liệu và chúng tôi đang tạo một nút mới bên trong.

698
00:00:57,320 --> 00:01:08,880
Sau đó chúng tôi sẽ kiểm tra. Nếu ẩn bằng null thì chúng ta sẽ nói ở đây là thông báo bằng nút mới ở đây mà chúng ta đang chỉ định. Hillendale chỉ vào nút, nếu không thì phải đến ngày hôm sau mới chuyển sang nút mới.

699
00:01:09,530 --> 00:01:20,700
Biết xương đòn đó hãy nói với Anteriorly Goldstone và chúng tôi sẽ tăng cường trang web sau này. Nó hoạt động. Chúng tôi gọi phương pháp này. Thêm một chi tiết vào, sau đó chúng ta sẽ tạo một nút mới, được chứ?

700
00:01:21,120 --> 00:01:33,150
Và chúng ta sẽ gán ở đây đồng bộ head và tail ban đầu là null, vì vậy nó sẽ gán con trỏ head và tail cho nút này. Bây giờ hãy gọi lại hàm này.

701
00:01:33,330 --> 00:01:46,200
Bây giờ chúng ta sẽ tạo một nút khác có giá trị hiện tại. Ở thời điểm này ta thấy ở đây nó không bằng bây giờ nên năm sau mới không bằng nên tiếp theo bằng 2 nút mới vẫn là đuôi.

702
00:01:46,800 --> 00:02:03,270
Vì vậy, nó sẽ kết nối nút này, đại loại như thế này, cho đến nút mới tiếp theo. Sau đó, bạn biết rằng đi đến đuôi. Vì vậy, nó sẽ kết nối nút này, đại loại như thế này và sau đó từ Chillicothe đến niños, nó sẽ di chuyển đuôi đến nút này để danh sách liên kết sẽ được trình bày.

703
00:02:03,270 --> 00:02:13,950
Một cái gì đó như thế này. Chúng tôi có địa chỉ của bạn. Chúng tôi đã làm vậy. Tôi chỉ bạn có thể thấy nó thực sự hoạt động như thế nào hoặc xâu chuỗi địa chỉ ngay tại đây của ghi chú này và ngay tại đây của ghi chú này.

704
00:02:14,610 --> 00:02:32,040
Nếu chúng ta gọi lại vấn đề này bằng ba thì chúng ta sẽ tạo lại một nút mới và sẽ thêm vào đây cho đến nút tiếp theo, chúng ta chuyển sang nút mới, đại loại như thế này, sau đó Ninon đi đến đuôi và Chillicothe hợp nhất.

705
00:02:32,400 --> 00:02:44,160
Vì vậy, các liên kết sẽ được đại diện. Một cái gì đó như thế này. Đây là cách chúng ta có thể tạo một danh sách. Phương pháp này sẽ có độ phức tạp về không gian và thời gian không đổi vì chúng ta đang thực hiện một thao tác tại một thời điểm.

706
00:02:44,550 --> 00:02:56,770
Và quy mô của nhà ngôn ngữ học này là một lời giải thích video mà chúng tôi đã hiểu. Nếu có vấn đề
cần hiểu điều này cùng với lời giải thích, hãy cho chúng tôi biết. Cảm ơn đã xem video này. 

@@@



707
00:00:00,450 --> 00:00:17,200
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng tôi sẽ triển khai phương pháp tìm kiếm hai xương bàn chân và hai tòa tháp. Tất cả các tìm kiếm cho một giá trị cụ thể trong phương pháp đầu tiên và phương pháp chống khủng bố sẽ vẫn tồn tại từ trái sang phải.

708
00:00:17,790 --> 00:00:31,650
Bây giờ, hãy nói về điều đó trước. Hãy nói về phương pháp khủng bố. Phương pháp này lấy những phương pháp khủng bố này không có tham số ở đây. Chúng tôi đang tiến gần đến thời điểm hiện tại, sẽ in danh sách và sẽ nhận được bằng văn bản này.

709
00:00:31,650 --> 00:00:44,670
Nếu không, chúng ta sẽ khởi tạo dòng điện trỏ tới Hadnot và sẽ chạy một lúc là hàng hải. Citronelle sẽ in dữ liệu hiện tại. Điều đó có nghĩa là các giá trị nút hiện tại sẽ chuyển thành hiện tại.

710
00:00:44,850 --> 00:00:52,940
Tiếp theo ở đây chúng ta đang di chuyển dòng điện trỏ tới biểu đồ tiếp theo. Nếu chúng tôi gọi phương pháp này là ba lần và nếu bạn được cung cấp danh sách liên kết này thì điều gì sẽ xảy ra?

711
00:00:53,310 --> 00:01:02,550
Đầu tiên chúng ta sẽ kiểm tra xem có bên ngoài không. Không, bây giờ nó không phải là Goldstar. Vì vậy, hãy tạo một con trỏ mới trỏ đến nút này. Và ghi chú này không phải là một bản tải xuống.

712
00:01:02,550 --> 00:01:18,090
Vì vậy, hãy in một cái và di chuyển hiện tại sang điểm cũ không còn hiện tại nữa tới nút này. Và chúng tôi thấy nút này là chưa đủ. Hãy in ở đây và chuyển sang phần tiếp theo.

713
00:01:18,090 --> 00:01:29,620
Không quá hiện tại sẽ trỏ đến nút này và hãy in ở đây ba. Bây giờ chúng ta hãy chuyển sang nút tiếp theo với dòng điện trỏ đến nút tiếp theo và nút này không phải là nút khác.

714
00:01:29,640 --> 00:01:40,920
Vì vậy, hãy mang lại giá trị để chúng ta chuyển sang nút tiếp theo một lần nữa. Và bây giờ chúng ta thấy điểm hiện tại phản hồi lại nút hiện tại này. Vì vậy, toàn bộ vòng lặp này và chúng tôi nhận được kết quả này.

715
00:01:40,920 --> 00:02:01,590
Một, hai, ba, bốn. Đây là cách hoạt động của các phương pháp khác nhau. Tất cả điều này diễn ra theo độ phức tạp về thời gian vì bạn phải duyệt qua danh sách liên kết từ trái sang phải một lần và nó sẽ có độ phức tạp về không gian không đổi vì bạn chỉ đang sử dụng một con trỏ được hiểu theo phương pháp khủng bố hiện tại.

716
00:02:01,770 --> 00:02:15,390
Bây giờ hãy nói về phương pháp nguồn. Bây giờ hãy nói về phương pháp nguồn. Phương thức này lấy tham số ở đây. Thay vào đó, chúng tôi đang kiểm tra xem nó có bằng null hay không, vùng trừ một hay khởi tạo chỉ số biến bằng 2.0.

717
00:02:15,810 --> 00:02:26,970
Sau đó, bạn đang tạo một điểm mới sẽ trỏ đến nút đầu. Sau đó, chúng tôi đang chạy một con chim hoang dã. Hiện tại không phải là bên ngoài, bên trong kiểm tra nó theo hướng dẫn của dữ liệu sau đó sẽ trả về chỉ mục.

718
00:02:27,450 --> 00:02:52,350
Nếu không, hãy chuyển sang nút tiếp theo và sẽ tăng chỉ mục của chúng tôi nếu chúng tôi không thấy tuyên bố này không hợp lệ. ĐÚNG VẬY. Chà, việc chạy trực tiếp này và sẽ trả về mạng của tôi nếu chúng ta gọi hàm này, nếu chúng ta gọi phương thức này là nguồn bằng ba và nếu bạn được cung cấp danh sách liên kết này, thì trước tiên chúng ta sẽ kiểm tra nút này ở đây không phải là bên ngoài.

719
00:02:52,680 --> 00:03:02,740
Chúng ta thấy nó không ở bên ngoài nên sẽ không trở lại. Mindich một chúng ta có chỉ số của bạn bằng 0 sẽ tiếp tục theo dõi chỉ số hiện tại của chúng ta, không sử dụng biến chỉ số này.

720
00:03:02,920 --> 00:03:13,620
Sau đó, chúng ta sẽ nhận được một vài con trỏ hiện tại sẽ trỏ đến nút này. Sau đó chúng tôi đang chạy tốt đếm không phải là Gosta. Hiện tại, các bản ghi mà chúng ta thấy ba không bằng một.

721
00:03:13,620 --> 00:03:28,480
Vì vậy, hãy chuyển sang phần tiếp theo, không phải ba. Hiện tại của chúng tôi không và chúng tôi thấy hai không gần với ba. Vì vậy, hãy chuyển sang nút tiếp theo. Hiện tại đang trỏ đến nút này và trong trường hợp này chúng ta thấy rằng giá trị của nốt này bằng hai ba.

722
00:03:28,620 --> 00:03:43,620
Vì vậy, trong trường hợp này, sẽ trả về chỉ mục của nút này. Chỉ số của nút này là hai. Vì vậy, nó sẽ quay trở lại cho lệnh gọi hàm này. Nếu chúng ta gọi phương thức này là nguồn bằng năm thì nó sẽ trả về âm một, vì năm không chỉ có trong danh sách liên kết này.

723
00:03:44,250 --> 00:04:04,510
Đây là cách phương pháp tìm kiếm này hoạt động. Điều này sẽ khiến Spiga mất độ phức tạp về thời gian trong trường hợp xấu nhất, vì với trường hợp xấu nhất, chúng ta phải duyệt qua danh sách liên kết này từ trái sang phải và nó sẽ có độ phức tạp không gian không đổi hoặc sử dụng một chỉ mục biến và một dòng con trỏ.

724
00:04:04,970 --> 00:04:14,290
Những gì chúng tôi đã hiểu lời giải thích này của Aveda, nếu có vấn đề gì. Hiểu được điều này
kèm theo lời giải thích, hãy cho chúng tôi biết mã nguồn được đính kèm theo nhu cầu này. 

@@@



725
00:00:00,960 --> 00:00:13,020
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng ta sẽ nói về việc chèn vào danh sách DoubleLine trong video này, tất cả sẽ triển khai để thêm vào chỉ mục ghét và thêm.

726
00:00:14,280 --> 00:00:25,410
Bây giờ hãy nói về sự ghét bỏ thêm. Sau đó chúng ta sẽ nói về chỉ mục được thêm vào. Điều này nó thêm phương pháp ghét. Phương thức này lấy một tham số ở đây. Chúng tôi đang tạo một nút mới với dữ liệu.

727
00:00:25,770 --> 00:00:35,160
Họ đang kiểm tra xem có ổn không thì chúng ta sẽ khởi tạo con trỏ Hadil cho trẻ sơ sinh. Điều đó có nghĩa là chúng ta sẽ gán điểm Hadil cho nút mới.

728
00:00:35,760 --> 00:00:50,970
Nếu không, chúng ta sẽ cử người tiếp theo đi ghét. Ghét nó. Chúng ta phải có nút mới và kích thước mới chứ không phải Heracles cộng với Blatche. Nếu chúng ta gọi siêu dữ liệu này bằng một siêu dữ liệu sẽ tạo ra một con trỏ mới không được xác định chính xác là bây giờ và con trỏ tiếp theo là bây giờ.

729
00:00:50,970 --> 00:01:06,780
Và dữ liệu hiện tại và dữ liệu là một và chỉ ngẫu nhiên được trỏ đến nút Sternhell tổng hợp này ban đầu. Và trang web của danh sách liên kết này là trang mà chúng tôi gọi là rối loạn chức năng cộng thêm sự căm ghét sẽ tạo ra một nút mới trong mạch.

730
00:01:06,780 --> 00:01:22,560
Chúng tôi sẽ áp dụng tuyên bố này. Nunatak bên cạnh kêu gọi ghét nên Nunatak tiếp theo chúng ta phải ghét, rồi tiến rất gần đến nút mới, nên tiến rất gần đến nút mới.

731
00:01:23,010 --> 00:01:47,790
Và chúng ta sẽ tiến tới nút này. Việc xác định vị trí của người theo chủ nghĩa pháp lý sẽ được thể hiện, đại loại như thế này. Nếu chúng ta gọi lại chức năng này trong việc tuyển dụng nút mới, đây không phải là ba, thì chúng ta sẽ thấy một lệnh gọi mới không phải là lệnh gọi tiếp theo ghét nút riêng tư bằng với nút mới và các lệnh gọi hayday tới nút mới này trong danh sách liên kết sẽ được thể hiện , một cái gì đó như thế này.

732
00:01:48,670 --> 00:02:00,130
Được rồi, đây là cách phương pháp này hoạt động. Phương pháp này sẽ đưa Spiga có độ phức tạp một lần và chúng ta sẽ có độ phức tạp một không gian. Chúng tôi đã hiểu phương pháp này, Haid nói thêm.

733
00:02:00,150 --> 00:02:11,130
Bây giờ hãy nói về phương pháp chỉ mục được thêm vào. Được rồi, đây là phương pháp lập chỉ mục được thêm vào của bạn. Để thực hiện phương thức này, chúng ta cần một phương thức khác lấy node. Đây là một phương thức trợ giúp và tất cả những gì đã được gọi.

734
00:02:11,130 --> 00:02:22,320
Và trong đoạn mã bạn sẽ thấy phương thức này. Phương thức này lấy ba tham số là chỉ mục và dữ liệu. Đó là chỉ số được gọi để đơn vị sẽ áp dụng phương pháp căm ghét bổ sung nếu việc tẩy chay chỉ số sẽ được áp dụng ở đây.

735
00:02:22,320 --> 00:02:36,660
Đã thêm phương thức chi tiết nếu chỉ mục liên quan đến Duroux và chỉ mục không có kích thước sẽ áp dụng mã này. Hãy xem điều này thực sự hoạt động như thế nào. Hãy xem. Chúng tôi gọi phương thức này là chỉ mục được thêm vào, cả ba một là chỉ mục và ba là dữ liệu.

736
00:02:36,660 --> 00:02:46,800
Vì vậy chúng ta sẽ chèn một nút vào giữa hai nút này. Vì vậy, thay vì ở giữa hai điều này. Vì vậy, hãy tạo một nút có giá trị ba. Sau đó, chúng ta sẽ làm ở đây, chúng ta sẽ lấy nút trước đó.

737
00:02:46,800 --> 00:03:07,680
Đây là nút trước đó, sau đó là nút dữ liệu tiếp theo. Vì vậy, chu kỳ chấm tiếp theo không bằng trẻ sơ sinh. OK rồi trước đó, tiếp theo bằng nút này, sau đó các bản ghi trước để chứng minh nút sẽ kết nối với nút này và Nunatak tiếp theo bằng nút tiếp theo này.

738
00:03:07,830 --> 00:03:16,920
Sau đó nó sẽ được đại diện như thế này. Đây là cách phương pháp này hoạt động để hiểu rõ hơn về dữ liệu, mọi thứ đều nằm trên một tờ giấy. Sau đó, nó sẽ thấy nó thực sự hoạt động như thế nào.

739
00:03:17,460 --> 00:03:28,440
Vật liệu này cần độ phức tạp về mặt thời gian đối với trường hợp xấu nhất, đối với phương pháp nút cổng
này và nó sẽ có độ phức tạp không gian không đổi. Vâng, chúng tôi đã hiểu lời giải thích này. 

@@@



740
00:00:00,510 --> 00:00:12,430
Rất nhiều chàng trai sẽ quay lại với video này. Trong video này chúng ta sẽ nói về tôn giáo trong a e, trong video này chúng ta sẽ triển khai phương pháp này để xóa khi được lập chỉ mục và xóa trong nội bộ.

741
00:00:12,450 --> 00:00:25,550
Đầu tiên, hãy nói về việc xóa tại Indexed và chúng ta sẽ nói về việc xóa danh sách nhập. Đây là mã của chúng tôi để xóa tại index. Đầu tiên chúng ta sẽ kiểm tra ranh giới đó.

742
00:00:25,560 --> 00:00:35,010
Nếu chỉ số nhỏ hơn 0 hoặc chỉ mục lớn hơn hoặc bằng kích thước thì tất cả đều tồn tại bởi câu lệnh bằng văn bản này. Đó là chỉ số kỹ thuật số. Sau đó nó sẽ di chuyển.

743
00:00:35,010 --> 00:00:46,000
Nó trỏ đến nút tiếp theo và nó sẽ ngắt kết nối nút trước đó để có chiều cao mới của chúng ta. Nếu chỉ mục không liên quan đến câu lệnh ELT này sẽ được thực thi trước.

744
00:00:46,000 --> 00:00:54,440
Ở lưu ý trước, chúng ta cần phương pháp này. Chúng tôi không xuất hiện ở đây. Phương pháp chúng tôi có trong mã của video này, hãy kiểm tra xem trong mã nguồn.

745
00:00:54,450 --> 00:01:06,990
Chúng tôi có phương pháp này và nó rất đơn giản. Chúng ta có thể lấy đêm hôm trước bằng cách sử dụng theo dõi và con trỏ, sau đó chúng ta thấy ở đây dấu chấm cố định bên cạnh các mã để ngăn việc kiểm tra tiếp theo tiếp theo.

746
00:01:06,990 --> 00:01:16,730
Nếu không phải là phần tiếp theo thì không phải là reelzChannel. Họ sẽ nói vĩnh viễn vào lần tiếp theo nó sẽ xoay vòng. Bạn thực sự phải lập chỉ mục trừ một cái sẽ di chuyển.

747
00:01:16,740 --> 00:01:40,200
Nó chỉ vào chủ tịch rồi nó sẽ giảm kích thước site này xuống ngay đây. Được rồi, bây giờ hãy xem nó thực sự hoạt động như thế nào. Nếu chúng ta gọi hàm này với chỉ số 0, thì những gì sắp xảy ra sẽ chuyển sang not và sẽ ngắt kết nối con trỏ trước đó và nó sẽ trở thành bây giờ, sau đó danh sách sẽ được biểu diễn, đại loại như thế này.

748
00:01:41,790 --> 00:01:53,010
Được rồi, hãy lấy một ví dụ khác khi hiểu rằng bạn đã được cung cấp danh sách liên kết này và chúng tôi gọi hàm này bằng chỉ mục để cho biết chúng tôi sẽ làm gì hoặc sẽ tìm thấy nó ở hàm trước đó không phải của chỉ mục hai.

749
00:01:53,050 --> 00:02:08,820
Đây là ghi chú về chỉ mục cho nút trước đó thực hiện hai lệnh gọi đến nút trước đó. Kế tiếp. Kế tiếp. Kế tiếp. Vì vậy, con trỏ này trỏ tới nút hiện tại. OK, điều đó có nghĩa là bây giờ tất cả đều trỏ đến nút giống như thế này.

750
00:02:09,000 --> 00:02:19,500
Nó đang trỏ tới nút bây giờ ở bốn và bây giờ chúng ta sẽ kiểm tra nút trước đó ở nút tiếp theo, nút hải lý tiếp theo hai. Bây giờ chúng ta sẽ áp dụng công thức này.

751
00:02:19,620 --> 00:02:28,200
Nhưng trong trường hợp này, chúng tôi thấy rằng trước dấu chấm tiếp theo bên cạnh Không. Vì vậy, câu lệnh này sẽ không được thực thi trong quá trình kiểm tra phúc âm của chúng tôi để chỉ ra điểm trừ một.

752
00:02:28,470 --> 00:02:37,440
Trong trường hợp này. Đó là sự thật. Vì thế nó sẽ chuyển đuôi về nốt này. Vì vậy, danh sách liên kết đại diện cho một cái gì đó như thế này để hiểu rõ hơn. Hãy lấy một ví dụ khác.

753
00:02:37,950 --> 00:02:52,580
Giả sử bạn được cung cấp danh sách dài này và chúng tôi gọi hàm này bằng chỉ mục một. Vì vậy, đây là nút của chỉ mục đầu tiên. Chúng ta sẽ làm gì? Chúng ta sẽ thấy rằng các nút trước đó trong nút trước đó sẽ sắp xếp nút trước đó tiếp theo để đi đến nút trước đó, nút đó bên cạnh nút tiếp theo.

754
00:02:52,590 --> 00:03:03,600
Vì vậy, chúng ta sẽ ngắt kết nối ghi chú này và chúng ta sẽ kết nối với nút này, sau đó chúng ta sẽ kiểm tra kiến ​​thức trước đó của bạn. Bên cạnh cái tiếp theo không phải là bây giờ chúng ta sẽ nói trước đó bên cạnh cái tiếp theo.

755
00:03:03,750 --> 00:03:13,650
Lệnh gọi quyền riêng tư để ngăn chặn tình trạng này có liên quan đến tuyên bố này sẽ không được thực thi. Và ở đây chúng ta thấy rằng không có gì trỏ đến nút này.

756
00:03:13,800 --> 00:03:21,630
Vì vậy nút này sẽ được thu thập bởi trình thu gom rác và trình thu gom rác sẽ xóa ghi chú này khỏi RAM. Sau đó, nhà ngôn ngữ học của chúng tôi sẽ được đại diện, đại loại như thế này.

757
00:03:22,260 --> 00:03:34,110
Chúng ta đã hiểu lời giải thích hàng ngày này. Phương pháp này cần độ phức tạp về thời gian lớn hơn để tìm thấy nút trước đó và sẽ có độ phức tạp không gian không đổi.

758
00:03:34,590 --> 00:03:44,820
Bây giờ hãy nhập phương thức danh sách. Đây là phương pháp danh sách Diligenta của chúng tôi để chúng tôi có con trỏ hiện tại này và chúng tôi sẽ xóa con trỏ tiếp theo. Đây là con trỏ tiếp theo.

759
00:03:44,820 --> 00:03:56,500
Đây là con trỏ tiếp theo của bạn. OK, chúng tôi đã xóa con trỏ tiếp theo. Sau đó, chúng ta sẽ xóa con trỏ đầu và đuôi khỏi đầu cho đến nút và chúng ta sẽ di chuyển con trỏ đó đến nút bây giờ.

760
00:03:57,420 --> 00:04:05,310
Bây giờ chúng ta thấy rằng không có gì khác chỉ vào ghi chú này. Vì vậy, ghi chú này sẽ là trình thu gom rác có thể thu thập và nó sẽ tự động bị người thu gom rác xóa.

761
00:04:05,460 --> 00:04:12,390
Trong ghi chú này, không có gì sẽ đi vào nút này. Vì vậy ghi chú này sẽ bị người thu gom rác loại bỏ. Thì ghi chú này là không có gì trỏ tới nút này.

762
00:04:12,540 --> 00:04:24,060
Vì vậy, trình thu gom rác sẽ xóa ghi chú này khỏi RAM và đây là cách hoạt động. Giải pháp sẽ khiến
Spiga trở nên phức tạp về thời gian và không gian. Chúng ta đã hiểu chính lời giải thích này. 

@@@



763
00:00:00,330 --> 00:00:11,760
Này các bạn quay lại với video này nhé, trong video này chúng ta sẽ thấy sự sáng tạo của Sakala, video này, không phải trong danh sách đâu nhé? Không phải tất cả họ đều được đại diện, đại loại như thế này.

764
00:00:11,760 --> 00:00:24,810
Và chúng ta có lớp học của chúng ta ở đây, danh sách vòng tròn của tôi. Và về cơ bản, danh sách liên kết hiện có đầu và đuôi nhọn, được trỏ tới Knowland và gần bằng 0. Đây là mọt sách của chúng tôi a.

765
00:00:25,780 --> 00:00:39,060
Được rồi, và ban đầu chúng tôi không có quyết định nào về việc tải xuống cho đến thời điểm này. Và kích thước bằng không. Và đây là phương pháp đuôi được thêm vào của chúng tôi.

766
00:00:39,060 --> 00:00:50,790
Phương thức này lấy 1 tham số data trong tuyển mới không phải ở đây, không kiểm tra từng bên bằng 0 để khởi tạo ở đây cho đến khi trỏ tới một ghi chú mới. Sau đó, chúng ta sẽ nói cho đến khi mục tiêu tiếp theo là đạt được chủ nghĩa khoái lạc tiếp theo.

767
00:00:50,890 --> 00:01:04,370
Tuy nhiên, nếu không mới, không phải là tiếp theo hãy đi thẳng đến lớp tiếp theo để biết bạn cần thông báo các cuộc gọi hàng ngày để không có nút mới và kích thước cộng thêm. Nhưng bây giờ hãy xem điều này thực sự hoạt động như thế nào.

768
00:01:04,380 --> 00:01:15,720
Ban đầu, chúng tôi có cái dài nhất này, chúng tôi gọi đây là phương thức có một, sau đó sẽ tạo một nút mới với dữ liệu một. Và chúng tôi có con trỏ tiếp theo của bạn vì liên kết có thể trích dẫn bằng 0.

769
00:01:15,810 --> 00:01:23,060
Vì vậy, hãy khởi tạo ẩn cho đến khi được trỏ đến ghi chú này và chúng tôi sẽ điều chỉnh để đạt được tiêu đề vào tuần tới hoặc hai tuần tới. Vì vậy, danh sách dài sẽ được đại diện.

770
00:01:23,070 --> 00:01:35,760
Một cái gì đó giống như thế này, chúng tôi đang lưu trữ dưới dạng riêng tư các cạnh của ghi chú này và các cạnh tiếp theo của ghi chú này. Vì vậy, chúng tôi có một vòng tròn ở đây. Chúng ta có thể đi từ đây đến đây và chúng ta có thể đi từ đây đến đây.

771
00:01:35,970 --> 00:01:45,840
Và chúng ta gọi hàm này ở một bảng có hai sẽ tạo ra một nút mới. Và ở đây sẽ nói bây giờ chúng ta đang ở tuyên bố ILD này ở đây, Nunatak tiếp theo bằng ba tám.

772
00:01:46,080 --> 00:02:02,940
Vì vậy, Newlander tiếp theo tương đương với sự căm ghét. Và sau đó là câu hỏi tiếp theo. Vì vậy chúng ta sẽ ngắt kết nối liên kết này, OK, từ đây đến đây. Vì vậy, chúng ta sẽ ngắt kết nối liên kết này từ đây đến đây và chúng ta sẽ nói ở đây với nút tiếp theo này.

773
00:02:02,940 --> 00:02:11,520
Nhưng ở đây chúng ta có một liên kết khác, đại loại như thế này từ đây đến đây. Liên kết này đã tồn tại nhưng chúng tôi đã xóa liên kết này. Điều này có thể hơi phức tạp một chút.

774
00:02:11,520 --> 00:02:24,270
Đừng lo lắng. Sau đó chúng ta sẽ thiết lập những kỷ lục mới. Làm như vậy sẽ kết nối ghi chú này với câu chuyện này và sẽ di chuyển đuôi đến nút này và cũng hướng tới đơn vị.

775
00:02:24,630 --> 00:02:37,050
Và nó trông hơi điên rồ một chút. Đừng lo lắng về điều đó. Nó sẽ được đại diện một cái gì đó như thế này. Hãy cố gắng giải quyết vấn đề này, sau đó sẽ hợp lý hơn nếu chúng ta gọi phương pháp này được thêm vào là ba.

776
00:02:37,290 --> 00:02:50,700
Và hãy tạo một nút mới ở đây. Vì vậy, bạn biết đấy, hãy chấm lớp tiếp theo để ghét điều này. Tiếp theo tất cả đều chỉ ra sự căm ghét này. Được rồi, tiếp theo chúng ta đến New Node. Vì vậy chúng ta sẽ ngắt kết nối liên kết này, đại loại như thế này.

777
00:02:51,000 --> 00:03:02,100
Chúng tôi có một mối liên kết, đại loại như thế này từ bàn tới sự căm ghét. Vì vậy, chúng ta sẽ ngắt kết nối cái này và chúng ta sẽ kết nối với nút này. OK, vậy thì nó thực sự gần với nút mới.

778
00:03:02,100 --> 00:03:13,800
Chúng ta sẽ chuyển điểm này tới ghi chú này. Chúng ta sẽ chuyển đến nút này và sau đó chúng ta sẽ thấy đầu khá gần với nút mới và nó sẽ được thể hiện, đại loại như thế này.

779
00:03:14,880 --> 00:03:27,600
Chúng ta đã hiểu chính sự hiểu biết của lời giải thích này. Hãy thử nhìn vào mã này ở đây. Ở đây chúng tôi có mũi tên với cùng dòng này có thể khiến bạn bối rối, nhưng đừng lo lắng về điều đó.

780
00:03:28,050 --> 00:03:43,070
Hãy thử viết ra mảnh giấy này để bạn sẽ thấy nó hoạt động như thế nào. Phương pháp này sẽ mất thời gian không đổi và độ phức tạp không gian không đổi vì chúng tôi đang thực hiện các thao tác trong thời gian không đổi và chúng tôi không sử dụng bất kỳ phần bổ sung nào.

781
00:03:43,120 --> 00:03:51,600
Chúng tôi đã hiểu điều này với những lời giải thích. Nếu bạn có bất kỳ vấn đề nào khi
hiểu lời giải thích này, hãy cho chúng tôi biết mã nguồn được đề cập đến video này. 

@@@



782
00:00:00,870 --> 00:00:11,130
Và rất nhiều chàng trai sẽ quay lại video này trong video này. Chúng ta sẽ nói về SARS và nỗi kinh hoàng rải rác ở Sakala tồn tại trong video này. Chúng tôi sẽ thực hiện nước sốt cà chua này và những kẻ khủng bố.

783
00:00:12,390 --> 00:00:22,620
Và hãy nói về phương pháp nước sốt. Phương thức này lấy một dữ liệu tham số làm đầu vào. Sau đó, chúng tôi sẽ bổ nhiệm người quản lý khu vực dầu mỏ của Heracles và sau đó chúng tôi sẽ đảm nhận vai trò quản lý chung.

784
00:00:22,620 --> 00:00:32,820
Không, nếu hồ chứa đạt kỷ lục mới cho Data Zero, thì chúng tôi đang khởi tạo chỉ mục. Sau đó, chúng tôi đang khởi tạo một con trỏ hiện tại tới ghi chú phía trên tiếp theo.

785
00:00:33,210 --> 00:00:45,060
Sau đó, chúng tôi đang đưa ra lời đảm bảo về Wildfowl liên quan đến sự căm ghét. Chúng tôi sẽ kiểm tra các bản ghi hiện tại với dữ liệu. Nếu nó liên quan đến một chỉ mục thì chúng ta sẽ tăng chỉ số đó và chuyển dòng điện sang con trỏ tiếp theo.

786
00:00:45,660 --> 00:01:00,870
Sau khi thực hiện việc này một thời gian, nếu điều kiện này không bao giờ liên quan đến thì nó sẽ trả về âm một. Bây giờ hãy xem nó thực sự hoạt động như thế nào. Chúng tôi gọi hàm này để kéo dài hadnot và phát triển là một hàm không bằng ba.

787
00:01:01,140 --> 00:01:10,380
Vì vậy, chúng ta sẽ chuyển sang nút tiếp theo và một trong số này, không phải hai, không bằng ba. Vì vậy, hãy chuyển sang nút tiếp theo bằng con trỏ hiện tại và phát triển nút này.

788
00:01:10,380 --> 00:01:30,690
Số ba bằng bốn số ba đã có trên chỉ mục của nút này vì chỉ số này ở mức tốt nhất của bạn. Vậy chỉ số của nút này là 0 một hai. Vậy nó sẽ quay về nếu ta gọi hàm này bằng năm thì nó sẽ trả về trừ một, trừ một vì giá trị nút năm không tồn tại trong danh sách liên kết này.

789
00:01:30,690 --> 00:01:40,980
Vì vậy, nó sẽ trả về trừ đi những gì chúng ta đã hiểu về phương pháp tìm kiếm. Phương pháp này sẽ khiến Spiga có độ phức tạp về thời gian cho trường hợp xấu nhất và Spiga sẽ có độ phức tạp về một không gian.

790
00:01:41,430 --> 00:01:49,310
Mã nguồn được đính kèm với video này. Kiểm tra xem. Bây giờ hãy nói về phương pháp khủng bố. Đây là một phương pháp khủng bố. Phương pháp này không có tham số ở đây.

791
00:01:49,630 --> 00:02:01,470
Bây giờ bạn phải có khả năng liệt kê và tồn tại bằng văn bản này. Rồi in ở đây sẽ in ra chưa có nhà phát triển. Vì vậy, hãy in một cái sau đó ban đầu đã được trỏ đến báo cáo tiếp theo chưa có.

792
00:02:01,740 --> 00:02:15,180
Và đây không phải là để đánh. Vì vậy, hãy in để sau đó chuyển sang nút tiếp theo. Và đây không phải là nút ghét, vì vậy hãy phát triển nút này. Không phải cả ba rồi sẽ trỏ đến nút này và chúng ta cũng thấy tướng Hayden này.

793
00:02:15,840 --> 00:02:34,710
Điều này sẽ dừng lại. Đây là những gì chúng ta có thể Devers phân lớp dài nhất? Chúng tôi đã hiểu điều này với những lời giải thích. Vấn đề này sẽ đưa Spiga về mặt thời gian, độ phức tạp, bất cứ điều gì mà nhà ngôn ngữ học từ trái sang phải muốn, và nó sẽ đòi hỏi độ phức tạp không gian không đổi.

794
00:02:35,430 --> 00:02:45,240
Vì vậy, thời điểm đó, karpinsky là do độ phức tạp trong không gian là lớn nhất. Đây là cách tôi thực hiện khủng bố. Chập chững, mã nguồn được đính kèm vào video này.

795
00:02:45,240 --> 00:02:53,220
Kiểm tra xem có bất kỳ câu hỏi nào có vấn đề không, hiểu điều này kèm theo lời giải thích.
Hãy để chúng tôi cảm ơn vì đã xem video này. Tôi sẽ gặp bạn trong video tiếp theo. 

@@@



796
00:00:00,840 --> 00:00:15,890
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về cách chèn vào vòng tròn, ít nhất là trong video này. Chúng tôi sẽ triển khai hai phương pháp thêm ghét và thêm chỉ mục cho Sakala và nhà ngôn ngữ học.

797
00:00:16,500 --> 00:00:27,510
Đầu tiên, hãy nói về phương pháp ghét được thêm vào. Sau đó tất cả đều nói về phương pháp chỉ mục được thêm vào. Đây là mã cho phương thức ghét được thêm vào. Phương thức này nhận tham số.

798
00:00:27,960 --> 00:00:37,080
Sau đó, ngay bên trong đây, chúng ta đang tạo một nút mới chứa dữ liệu. Sau đó, chúng tôi đang kiểm tra xem trang web có bằng kỹ thuật số hay không, sau đó chúng tôi sẽ khởi tạo cho đến khi được trỏ đến nút mới.

799
00:00:37,470 --> 00:00:51,650
Sau đó Heytesbury đi theo đuôi cho đến khi có lời kêu gọi ghét tiếp theo nếu không mới, không gần lắm để nói, cho đến khi mục tiêu tiếp theo là nút mới 960 mục tiêu ghét nó Marigold's đối với các gốc tự do sơ sinh đến kích thước trẻ sơ sinh, blah blah.

800
00:00:52,110 --> 00:01:06,720
Đây là mã. Bây giờ hãy xem nó thực sự hoạt động như thế nào. Nếu chúng ta gọi phương pháp này là thêm sự ghét bỏ ban đầu, chúng ta có con trỏ đầu và đuôi ngôn ngữ học này đang trỏ để tải xuống lại ở đây.

801
00:01:07,050 --> 00:01:21,240
Mã này sẽ được áp dụng vì chu kỳ tới GIRoA. Ban đầu ở đây chúng ta đã tạo một nút với dữ liệu một và sau đó chúng ta sẽ khởi tạo Hadil của bạn trỏ tới nút này và sau đó nó báo rằng anh ta đã làm rất gần để nói.

802
00:01:21,570 --> 00:01:46,890
Anh ấy đã bán lẻ Pericles và xử lý những thứ hỗn hợp tương đương với sự căm ghét. Vì vậy chúng ta thấy một vòng tròn ở đây. Đây được gọi là nhà ngôn ngữ học vòng tròn. Bây giờ chúng ta vì phương pháp này lại có dữ liệu nên chúng ta sẽ tạo một nút mới ở đây với dữ liệu để sau đó chúng ta phải áp dụng ở đây, chúng ta áp dụng câu lệnh này ở đây mới chứ không phải đuôi STR thông thường.

803
00:01:47,140 --> 00:02:07,140
Vậy đây là một nốt mới tương đương với đuôi. Được rồi, sau đó bang hội tiếp theo bằng nút tiếp theo bằng nút mới và ở đây 960 đứng đầu. Đây là tiếp theo. Tiếp theo là thụ động ghét và bị ghét tương đương với nút mới.

804
00:02:07,860 --> 00:02:17,370
Ở đây chúng ta đã kết nối nút đầu và nút đuôi. Sau đó chúng ta sẽ làm gì. Chúng ta sẽ tiến tới trẻ sơ sinh. Vì vậy chúng ta sẽ tiến về phía trước. Trỏ tới nút này.

805
00:02:17,850 --> 00:02:25,800
Điều này có vẻ hơi phức tạp một chút. Đừng lo lắng. Hãy thử viết mọi thứ ra một tờ giấy, sau đó nó sẽ có ý nghĩa. Và liên kết này đại diện cho một cái gì đó như thế này.

806
00:02:26,430 --> 00:02:41,040
Có thể gọi lại hàm này với dữ liệu ba. Hãy tạo một nút có ba dữ liệu. Bây giờ hãy tạo một nút có dữ liệu ba. Và ở đây chúng ta có prev và next bây giờ chúng ta có trống rỗng có nghĩa là không có gì bây giờ.

807
00:02:41,280 --> 00:03:01,860
Vì vậy, hãy áp dụng tuyên bố này ở đây. Perry, Pericles theo đuôi. Vì vậy, chúng tôi sẽ áp dụng điều này cho đến nút Coldstone tiếp theo. Vì vậy, điều này vẫn cho đến khi tiếp theo tương đương với nút mới và nút mới, nhưng tiếp theo tương đương với sự ghét bỏ.

808
00:03:02,160 --> 00:03:13,700
Vì vậy, chúng ta sẽ kết nối với điều này. Vì vậy, chúng tôi đã kết nối cuộc gọi tiếp theo của cuộc gọi Pravy không ghét và ghét này tới nút này và chúng tôi sẽ chuyển nó trỏ đến ghi chú này.

809
00:03:14,280 --> 00:03:32,100
Sau đó, danh sách liên kết sẽ được trình bày, đại loại như thế này. Đây là cách hoạt động của phương pháp căm ghét bổ sung này. Phương pháp này sẽ phát huy hiệu quả về mặt thời gian cũng như độ phức tạp về không gian vì chúng ta đang thêm một nút vào điểm ghét tại một thời điểm.

810
00:03:32,520 --> 00:03:44,270
Vì vậy, nó sẽ mất thời gian không đổi và độ phức tạp không gian không đổi. Bây giờ hãy nói về phương pháp chỉ mục được thêm vào. Đây là phương pháp chỉ mục được thêm vào. Phương thức này lấy hai tham số là chỉ mục và dữ liệu ở đây.

811
00:03:44,370 --> 00:03:56,970
Việc kiểm tra chỉ mục nhỏ hơn 0 hoặc các chỉ mục lớn hơn kích thước sẽ tồn tại bằng câu lệnh bằng văn bản này. Sau đó, chúng tôi đang kiểm tra xem chỉ số có bằng với đường hay không và sẽ gọi hàm này với dữ liệu được thêm vào dữ liệu ghét.

812
00:03:57,570 --> 00:04:07,860
LCP Nếu chúng tôi tìm thấy kích thước chỉ mục thì chúng tôi gọi phương thức này được thêm vào. Nếu không, chúng tôi sẽ áp dụng tuyên bố này và sẽ tăng trang web. Danh sách kinh khủng.

813
00:04:08,400 --> 00:04:17,850
Nếu chúng ta gọi phương thức này được thêm vào chỉ mục bằng một và ba, thì chúng ta phải thêm nút ba này vào chỉ mục một. Vì vậy, trung lập vì ở giữa hai nút này.

814
00:04:18,330 --> 00:04:27,570
Vì vậy, hãy tạo một nút có ba nút và ở đây hãy áp dụng công thức này. Vì vậy, chúng tôi đã tạo một nút mới và Prevnar, đây là một lưu ý tích cực. Chúng tôi không xuất hiện ở đây.

815
00:04:27,570 --> 00:04:40,290
Việc thực hiện K.A. phương thức, mã nguồn được đính kèm với video này, với mã nguồn nơi chúng tôi triển khai phương pháp này. Sau đó, những gì chúng tôi sắp làm, chúng tôi sẽ nói rằng nút mới EcoStar tiếp theo.

816
00:04:40,470 --> 00:04:52,470
Vì vậy, riêng tư không phải là tiếp theo bằng ghi chú này. Chúng tôi muốn kết nối điểm này với nút này, sau đó nút mới không đi đến vỉa hè. Vì vậy, chúng tôi đã kết nối với cái này, không phải với nút này.

817
00:04:53,080 --> 00:05:07,880
Được rồi, vậy thì tất nhiên tiếp theo bạn cần có DOT, tiếp theo chúng ta sẽ kết nối với nút này. Và điều đó làm cho nó rất gần với trẻ sơ sinh. Chúng tôi sẽ kết nối liên kết này với ghi chú này và đây là cách nó hoạt động.

818
00:05:08,460 --> 00:05:16,550
Nhà ngôn ngữ học sẽ được đại diện, đại loại như thế này, và đây là cách nó hoạt động. Phương pháp này sẽ đề cập đến độ phức tạp về thời gian trong trường hợp xấu nhất.

819
00:05:16,560 --> 00:05:26,660
Chúng tôi đã xác định nó trước đó và nó sẽ có độ phức tạp không gian không đổi. Chúng ta đã hiểu chính lời giải thích này. Nếu bạn gặp vấn đề, hãy hiểu điều này kèm theo lời giải thích.

820
00:05:26,670 --> 00:05:36,630
Hãy cho chúng tôi biết nếu bạn gặp khó khăn trong việc hiểu phương pháp, chỉnh sửa và chỉ mục
đã chỉnh sửa, sau đó thử viết mọi thứ lên một tờ giấy. Thế thì tất cả đều có ý nghĩa. 

@@@



821
00:00:00,390 --> 00:00:15,780
Này các bạn quay lại với video này trong video này chúng ta sẽ nói về incircle, ít nhất là trong video này chúng ta sẽ thực hiện 2 phương pháp xóa ở chỉ mục và xóa toàn bộ danh sách đối với danh sách khoanh tròn.

822
00:00:16,410 --> 00:00:44,450
Đầu tiên, hãy nói về việc xem xét được lập chỉ mục và chúng ta sẽ nói về việc xóa và liệt kê điều này mỗi giờ. Xóa tại phương thức chỉ mục. Phương thức này lấy một chỉ mục tham số bên trong đây hoặc kiểm tra xem chỉ số có nhỏ hơn 0 hay chỉ số lớn hơn hoặc bằng kích thước hay không, sau đó sẽ bị ảnh hưởng bởi câu lệnh viết này ebc thấy chỉ số bằng 0 thì sẽ chuyển sang nút tiếp theo.

823
00:00:44,700 --> 00:00:58,590
Họ sẽ nói tiếp theo là ghét. Tôi ghét điều đó vì phải nói với bạn rằng chúng tôi sẽ tìm ra nút trước đó vì chúng tôi cần phương thức này lấy nút một và hiển thị ở đây phương thức chúng tôi có ở mã nguồn cho điều này.

824
00:00:58,620 --> 00:01:12,420
Chúng ta có thể kiểm tra xem chúng ta đã triển khai phương pháp này ở đâu. Sau đó, ở đây, mục tiêu tiếp theo là ngăn chặn điều đó tiếp theo hoặc tiếp theo. Nếu không phải dấu chấm, dấu chấm tiếp theo sẽ không rỗng.

825
00:01:12,930 --> 00:01:26,550
Sau đó, chúng ta sẽ nói không phải cái tiếp theo, mà tiếp theo là Pericles ipsi ưu việt để chỉ số trừ một cái đuôi bằng prev not và kích thước trừ âm. Ở đây chúng ta có câu lệnh if này.

826
00:01:27,150 --> 00:01:45,410
Chúng tôi có thể loại bỏ tuyên bố này cho danh sách vòng tròn. Đừng lo lắng. Chúng ta có thể sử dụng tuyên bố này. Bây giờ hãy xem điều này thực sự hoạt động như thế nào. Nếu chúng ta gọi hàm này với chỉ số 0, điều đó có nghĩa là chúng ta phải loại bỏ nút đầu tiên có chỉ số 0.

827
00:01:45,450 --> 00:01:58,920
Đây là nút đầu tiên ở đây. Chúng ta sẽ làm gì? Chúng ta sẽ chuyển sự căm ghét sang nút này, được rồi, đồng bộ hóa chỉ mục về 0. Sau đó chúng ta sẽ xem cho đến mục tiêu tiếp theo để ghét.

828
00:01:59,250 --> 00:02:10,590
Vì vậy, cho đến khi đạt được mục tiêu tiếp theo, chúng ta sẽ ngắt kết nối mục tiêu này và chúng ta sẽ kết nối với nút này. Vì đây là sự căm ghét mới của chúng ta nên nó gần như sắp bị giết.

829
00:02:10,920 --> 00:02:29,490
Vì vậy, chúng ta sẽ ngắt kết nối cái này và chúng ta sẽ kết nối nó với liên kết này, sẽ có được một cái gì đó như thế này. Bây giờ chúng ta thấy rằng không có gì trỏ đến nút này. Vì vậy nút này sẽ được người thu gom rác thu thập và người thu gom rác sẽ loại bỏ nút này.

830
00:02:29,730 --> 00:02:47,000
Vì vậy, nhà ngôn ngữ học của chúng tôi sẽ được đại diện. Một cái gì đó như thế này chúng tôi đã hiểu để hiểu rõ hơn. Hãy lấy một ví dụ khác. Nếu chúng ta nói xóa ở vị trí thứ hai đối với danh sách liên kết này, thì trong trường hợp này, chúng ta phải xóa nút này, được chứ?

831
00:02:47,330 --> 00:03:06,560
Bạn không muốn. Chỉ số của nút này là hai cho rối loạn chức năng. Chúng tôi thấy rằng tuyên bố này là sai. Bây giờ câu lệnh này sẽ được thực thi. Cho nên trước hết là quyết định cuối cùng, quyết định vĩnh viễn sẽ không phải là một sinh vật, không phải là khóa học tiếp theo để ngăn chặn cái tiếp theo.

832
00:03:06,900 --> 00:03:19,780
Vì vậy, không phải dấu tiếp theo bằng dấu chấm tiếp theo. Vì vậy nó sẽ trỏ đến nút này. Được rồi, chúng ta sẽ kiểm tra, nếu không thì lần tiếp theo. Sau này không bằng bây giờ.

833
00:03:19,800 --> 00:03:31,920
Chúng tôi thấy có thai chấm tiếp theo chấm tiếp theo là không đi xét xử. Trong trường hợp này, nút ghét không ghét không phải là một danh từ. Không phải vì vậy chúng ta sẽ nói nút đầu chấm Pericles để xoay.

834
00:03:32,160 --> 00:03:46,890
Vì vậy, chúng tôi sẽ kết nối liên kết này với nút này và chúng tôi sẽ xóa liên kết này vì chúng tôi đã kết nối bản tóm tắt với nút này. Có trang này tên là Index Minus One.

835
00:03:46,980 --> 00:04:00,600
Vì vậy, nó sẽ di chuyển hàng ngày đến khoảng thời gian này và sẽ giảm kích thước của danh sách liên kết này. Và bây giờ chúng ta thấy rằng không có gì trỏ đến nút này. Được rồi, vậy nên nút này sẽ vẫn được thu thập.

836
00:04:00,600 --> 00:04:11,130
Trình thu thập và thu gom rác sẽ xóa ghi chú này khỏi RAM chứ không hiển thị danh sách liên kết. Một cái gì đó như thế này. Chúng tôi đã hiểu nó hoạt động như thế nào.

837
00:04:11,490 --> 00:04:24,030
Bây giờ, hãy lấy một ví dụ khác để hiểu rõ hơn. Giả sử chúng ta đang đưa ra danh sách liên kết này và chúng ta gọi hàm này với chỉ mục một trong trường hợp này để loại bỏ nút này cho chuyến đi đầu tiên nhằm tìm ra ghi chú trước đó.

838
00:04:24,030 --> 00:04:41,450
Điều này ở nút trước của bạn, không phải nút trước, nút tiếp theo rồi nút trước, hai lệnh gọi tiếp theo tới nút trước, không phải nút tiếp theo hoặc nút tiếp theo. Vì vậy, chúng ta sẽ bỏ qua nút này và chúng ta sẽ kết nối với nút này và sau đó chúng ta sẽ thấy ở đây PEB, không phải DOT bên cạnh không phải là Goldstar.

839
00:04:41,480 --> 00:04:57,060
Bây giờ chúng ta thấy nút này không phải bây giờ, không phải nút này vì mặt đường. Vì vậy, chúng ta sẽ kết nối nút này với nút này, OK, và đây là điều kiện. Nó đã mặc định rồi.

840
00:04:57,420 --> 00:05:13,310
Vì vậy câu lệnh này sẽ chỉ được thực thi và sau đó là we. Trang web. Bây giờ chúng ta thấy rằng không có gì chỉ ra điều này, không phải tất cả những điều này không được thu thập bởi người thu gom rác và người thu gom rác sẽ thực hiện việc này không tự động từ bộ nhớ máy tính mà nhà ngôn ngữ học sẽ đại diện giống như thế này.

841
00:05:13,820 --> 00:05:27,260
Sau đó, một nhà ngôn ngữ học sẽ được đại diện, đại loại như thế này. Hoặc chúng ta đã hiểu phương pháp này tại file index. Phương pháp này sẽ khiến Spiga có độ phức tạp về thời gian và độ phức tạp về không gian không đổi.

842
00:05:28,160 --> 00:05:42,500
Bây giờ hãy nói về phương pháp xóa danh sách nhập. Đây là phương pháp xóa danh sách thiên thần của bạn. Trước tiên, bạn sẽ kiểm tra xem nó có nói không, này, chúng ta phải biết liệu việc này có được thực hiện hay không cho đến khi mục tiêu tiếp theo là phải biết.

843
00:05:42,740 --> 00:06:01,950
Và sau đó chúng ta sẽ khởi tạo con trỏ hiện tại thành ghét và chúng ta sẽ ngắt kết nối liên kết. Liên kết tiếp theo lại là Node. Và ở đây chúng tôi cũng đã ngắt kết nối điều này bị ngăn cản bởi tuyên bố này và ghi chú tiếp theo dành cho người thuê nhà của chúng tôi.

844
00:06:02,270 --> 00:06:26,540
Được rồi, vậy là chúng đã bị ngắt kết nối. Bây giờ chúng ta sẽ ngắt kết nối đầu cho đến con trỏ. Vì vậy, hãy loại bỏ một con trỏ đuôi ẩn và ngắt kết nối chúng và trỏ đuôi Hayden vào để đưa vào và chúng ta thấy rằng không có gì trỏ đến taylored này vì nút này bị ngắt kết nối và con trỏ tiếp theo cho nút này bị ngắt kết nối.

845
00:06:26,750 --> 00:06:37,100
Vì vậy, không có gì trỏ đến nút này. Vì vậy, ghi chú này sẽ được trình thu gom rác tự động xóa khỏi REM. Sau đó chúng ta có nút này. Không có gì trỏ đến nút này.

846
00:06:37,220 --> 00:06:46,940
Vì vậy ghi chú này sẽ bị xóa. Bộ sưu tập Reagonomics thì nút này không có gì trỏ đến ghi chú này. Vì vậy ghi chú này sẽ bị người thu gom rác xóa khỏi bộ nhớ máy tính.

847
00:06:47,450 --> 00:06:58,340
Vấn đề này sẽ giảm đi vì độ phức tạp về thời gian, vì bạn phải ngắt kết nối. Con trỏ tiếp theo là không và giải pháp sẽ giảm do độ phức tạp của một không gian.

848
00:06:59,290 --> 00:07:07,500
Chúng tôi đã hiểu điều này sẽ chuyển đổi. Mã nguồn được đính kèm với video này. Kiểm tra xem.
Nếu chúng tôi gặp khó khăn trong việc hiểu chính lời giải thích này, hãy cho chúng tôi biết. 

@@@



849
00:00:00,690 --> 00:00:11,850
Này các bạn, chào mừng đến với video này. Bây giờ chúng ta sẽ giải một danh sách liên kết cổ điển gọi bài toán, bạn có một sở thích duy nhất và bạn phải đảo ngược nó.

850
00:00:12,090 --> 00:00:22,430
Bạn phải giải quyết vấn đề này một cách lặp đi lặp lại và đệ quy. Chúng tôi đã giải quyết được vấn đề này. Thật đáng kinh ngạc, chúng tôi có một liên kết video trong phần mô tả. Kiểm tra xem.

851
00:00:22,650 --> 00:00:40,480
Bây giờ chúng ta sẽ giải quyết vấn đề này một cách đệ quy. Điều này sẽ hơi quan trọng để hiểu khi bạn giải quyết vấn đề này. Ví dụ, sử dụng đệ quy, nếu bạn được cung cấp danh sách liên kết này, thì bạn phải đảo ngược nó.

852
00:00:41,580 --> 00:00:53,490
Vì vậy, nút này trở thành nút đầu của danh sách liên kết đảo ngược của chúng tôi. Được rồi, đầu tiên là bốn, rồi ba, rồi hai, rồi một. Vậy thì bây giờ. Vì vậy chúng ta phải trả lại danh sách liên kết này.

853
00:00:54,360 --> 00:01:09,510
Vì vậy, đối với đầu vào đã cho này, sẽ trả về danh sách liên kết này, nếu bạn muốn. Với danh sách liên kết này, trước tiên chúng ta phải đảo ngược nó. Đây không phải là năm và đây hiện là phần đầu của danh sách liên kết đã sửa đổi.

854
00:01:09,900 --> 00:01:26,010
Rồi bốn, rồi ba, rồi hai, rồi một. Vậy thì bây giờ. OK, vì vậy chúng ta phải trả lại danh sách liên kết này nếu bây giờ chúng ta được cung cấp danh sách liên kết này, hãy xem cách chúng ta có thể giải quyết vấn đề này theo cách đệ quy cho dễ hiểu.

855
00:01:26,010 --> 00:01:41,670
Giả sử chúng ta được cung cấp danh sách này. OK, đầu tiên chúng ta sẽ khai báo hai điểm phía trước và NextEd sẽ trỏ đến đầu danh sách đã cho của chúng ta. Bây giờ cho lệnh gọi hàm đệ quy đầu tiên.

856
00:01:42,000 --> 00:01:56,270
Đầu tiên, chúng ta sẽ chuyển cái này chỉ vào cái này, chứ không phải cái này sẽ dẫn đến cái này. Và sau đó chúng ta sẽ kết nối nút này với nút hiện tại. Được rồi, đây là lệnh gọi hàm đệ quy đầu tiên.

857
00:01:56,610 --> 00:02:16,520
Bây giờ đây là phần đầu của lệnh gọi hàm mới. Bây giờ đây là phần đầu danh sách của chúng ta cho lệnh gọi hàm đệ quy tiếp theo. Được rồi, đây là đầu của chúng ta. Và sau đó chúng ta có ghi chú tiếp theo chỉ vào phần tiếp theo của đầu và những gì chúng ta sẽ làm.

858
00:02:16,520 --> 00:02:28,140
Những gì chúng ta sắp ngắt kết nối là chúng ta sẽ kết nối nó với nút hiện tại. Được rồi, nút này sẽ là nút đầu tiên cho lệnh gọi hàm đệ quy tiếp theo. Được rồi.

859
00:02:28,530 --> 00:02:38,460
Bây giờ, một lần nữa, chúng ta sẽ ngắt kết nối này. Bây giờ chúng ta sẽ kết nối nó với nút đó. Sau đó, điều này sẽ được đại diện như thế này. Bây giờ chúng ta có nút này.

860
00:02:38,620 --> 00:02:54,060
Đây là phần đầu cho lệnh gọi hàm đệ quy tiếp theo của chúng ta. Được rồi, đây là cái đầu. Vì vậy, những gì chúng tôi đã làm vào lúc này, chúng tôi đã thực hiện lệnh gọi hàm đệ quy và chúng tôi đã tìm ra trường hợp tốt nhất của mình.

861
00:02:54,060 --> 00:03:09,870
Đây là trường hợp tốt nhất của chúng tôi. Không sao đâu. Và ở đây là hàm đệ quy được gọi là chúng tôi đang ngắt kết nối nút đầu khỏi danh sách liên kết. Vì vậy, ở đây chúng ta đã ngắt kết nối một, sau đó chúng ta ngắt kết nối hai.

862
00:03:10,080 --> 00:03:29,340
Khi chúng tôi ngắt kết nối nút này, điều đó có nghĩa là chúng tôi cũng đã ngắt kết nối ở đây. Được rồi, khi chúng tôi ngắt kết nối Nút ba này khỏi danh sách liên kết, thì chúng tôi đang ngắt kết nối nút này và ghi chú này, như sẽ được gọi trong bộ nhớ máy tính.

863
00:03:29,580 --> 00:03:40,890
Chúng tôi có cùng một nút. Chúng ta không có bốn cách gọi hàm đệ quy khác nhau. Chúng tôi chỉ thay đổi con trỏ cho lệnh gọi hàm đệ quy.

864
00:03:41,190 --> 00:03:54,750
Được rồi, ở đây chúng ta có nút này để các điểm đó biết bây giờ chúng ta sẽ làm gì. Chúng tôi sẽ trả lại nút này làm nút đầu vì đây sẽ là nút đầu cho nhà ngôn ngữ học đã sửa đổi của chúng tôi.

865
00:03:55,110 --> 00:04:09,570
Và con trỏ đầu này đang trỏ đến nút này để sau đó chúng ta có con trỏ nút tiếp theo này và con trỏ này trỏ đến nút này. Hiện tại, chúng ta sẽ ngắt kết nối con trỏ này và sẽ kết nối nó với nút ba này, chúng ta có thể làm điều đó như thế nào.

866
00:04:09,570 --> 00:04:22,140
Chúng ta có thể làm điều đó bằng cách sử dụng công thức nút tiếp theo để thực hiện lệnh gọi ghét. Và chúng ta đã có cái này không phải cho con trỏ này đang trỏ tới, không phải cho trong bộ nhớ máy tính.

867
00:04:22,170 --> 00:04:34,920
Phải. Nếu chúng ta trả lại nút này, thì những gì chúng ta sẽ có sẽ có tất cả nút mà chúng ta đã kết nối với nút này, vì chúng ta không phải lo lắng về những gì chúng ta đang làm ở trên cùng.

868
00:04:36,210 --> 00:04:50,970
Chúng ta không phải lo lắng về những gì chúng ta đang làm trong hàm đệ quy. Gọi vẫn con trỏ này ở đây, chúng ta đã tạo một con trỏ mới, phần đầu mới, con trỏ này đáp ứng với nút trong bộ nhớ máy tính.

869
00:04:50,970 --> 00:04:59,610
Phải. Nếu chúng ta có thứ gì đó được kết nối với ghi chú này thì chúng ta sẽ có tất cả nút được kết nối với nút này. Vì vậy, ở đây chúng tôi đang ngắt kết nối ghi chú này khỏi nút này.

870
00:05:00,000 --> 00:05:12,340
Bây giờ, bộ nhớ kém được ghi vào bộ nhớ máy tính. Nốt này là ba, đây không phải ba mà nối với nốt bốn này. Và ở đây con trỏ đầu này chỉ vào nốt số ba.

871
00:05:12,660 --> 00:05:23,350
Bây giờ ở đây này. McFarland cũng đang chỉ vào ghi chú thứ ba này. Nếu chúng ta nói nốt hỗn hợp tạo ra âm thanh nổi thì nốt này sẽ kết nối với nốt này.

872
00:05:23,580 --> 00:05:37,710
Điều đó có nghĩa là chúng tôi cũng đang thêm ghi chú này vào ghi chú thứ ba này, bởi vì tất cả các ghi chú đều giống nhau trong bộ nhớ máy tính. Chúng ta không phải lo lắng về những gì họ đang làm trong lệnh gọi hàm đệ quy trước đó.

873
00:05:38,100 --> 00:05:49,810
OK, về cơ bản nó có nghĩa là cái này không được kết nối với ghi chú này đến ngay tại đây, nếu chúng ta nói tiếp theo và tiếp theo sẽ đi qua, bây giờ chúng ta đang kết nối nút này với nút này.

874
00:05:50,710 --> 00:06:08,110
Được rồi, những gì chúng ta đang làm, chúng ta chỉ thêm cái này chứ không phải cái này vào nút này bằng liên kết hoặc bằng con trỏ. Vậy điều này có nghĩa là gì? Điều đó có nghĩa là chúng ta đang thêm con trỏ của nút vào nút một, được chứ?

875
00:06:08,280 --> 00:06:20,730
Về cơ bản, điều đó có nghĩa là chúng ta đang thêm con trỏ của cái này, không phải hai, không phải một, bởi vì tất cả các nút đều nằm trong bộ nhớ máy tính. Bây giờ phần đầu mới của chúng tôi vẫn đang trỏ đến nút này.

876
00:06:20,730 --> 00:06:33,710
Nó sẽ trả về ghi chú này để lấy tất cả các nút được kết nối với ghi chú này. Và ở đây chúng ta thấy nút ba không phải nút một được kết nối với nút bốn riêng biệt này và mạng này.

877
00:06:33,900 --> 00:06:51,270
Sau đó chúng ta sẽ có Renquist đảo ngược. Điều này sẽ có một chút quan trọng để hiểu vấn đề này. Hãy khéo léo để hiểu một khi bạn đã hiểu được khái niệm, một con trỏ mà bạn sẽ có thể hiểu được vấn đề này một cách dễ dàng.

878
00:06:51,750 --> 00:07:12,060
Nếu bạn nhìn vào bức ảnh này và những gì tôi đã nói thì. Sẽ có lý nếu đây là đoạn mã để giải quyết vấn đề này trước tiên. Chúng tôi đang kiểm tra xem liên kết đã cho có bỏ sót hay không và bây giờ sẽ trả lại liên kết ngay bây giờ nếu chúng tôi thấy lần tải tiếp theo của chúng tôi.

879
00:07:12,900 --> 00:07:30,950
Nút hiện tại bây giờ sẽ trả về phần đầu. Điều đó có nghĩa là nút hiện tại và nút đó sẽ không phải là phần đầu của chúng tôi. Và ở đây chúng ta chỉ đang thao tác với con trỏ và ở đây chúng ta đang ngắt kết nối Hadnot cho ngăn xếp cuộc gọi đệ quy của nó.

880
00:07:31,380 --> 00:07:44,870
Vậy thì đây là cái đầu mới của chúng ta. Đơn vị mới này sẽ được chỉ định ngay tại đây và đơn vị này sẽ giữ nguyên cho tất cả hàm đệ quy có tên Stack. Và ở đây chúng ta chỉ đảo ngược nút và sẽ trả về lần truy cập mới.

881
00:07:45,390 --> 00:07:56,820
Nó sẽ trỏ đến nút cho mọi lứa tuổi. Và nếu chúng ta có nút đó thì sẽ nhận được tất cả các nút được kết nối với ghi chú này và đây là cách chúng ta có thể giải quyết vấn đề này.

882
00:07:57,150 --> 00:08:11,430
Giải pháp sẽ giúp Spiga phát triển trong thời gian phức tạp. Giải pháp sẽ nhắn tin vì độ phức tạp về thời gian và do độ phức tạp về không gian hoặc đó là số lượng nút trong danh sách liên kết nhất định.

883
00:08:11,460 --> 00:08:25,980
Được rồi các bạn đã hiểu vấn đề này ở mức độ rất cao. Nếu bạn không hiểu rõ, nếu bạn không hiểu lời giải thích nhanh chóng, hãy thử xem qua mã giả, với các ví dụ của riêng bạn, thì nó sẽ có ý nghĩa.

884
00:08:26,100 --> 00:08:38,790
Nếu bạn vẫn hiểu thì hãy nhìn vào bức ảnh này, bạn sẽ thấy nó có ý nghĩa. Tôi có một video khác về vấn đề này. Mình sẽ link video đó ở phần mô tả nó có thể hết video đó.

885
00:08:39,300 --> 00:08:49,980
Tôi hy vọng đó là liên kết video trong phần mô tả. Khi đó bạn sẽ có thể hiểu rõ vấn
đề này. Cảm ơn bạn đã xem video này và tôi sẽ gặp bạn trong video tiếp theo. 

@@@



886
00:00:01,620 --> 00:00:28,020
Bây giờ chúng ta sẽ giải một bài toán cổ điển dài nhất, gọi nó là danh sách liên kết ngược có vấn đề, bạn được cung cấp một nhà ngôn ngữ học duy nhất và bạn phải đảo ngược nó. Nếu họ giải quyết vấn đề này một cách lặp đi lặp lại và đệ quy trong video này thì chúng ta sẽ giải quyết vấn đề này một cách lặp đi lặp lại và tôi sẽ tạo một video khác để chúng ta giải quyết vấn đề này theo cách đệ quy.

887
00:00:29,700 --> 00:00:45,320
Ví dụ, nếu bạn được giao cho nhà ngôn ngữ học này, chúng ta phải đảo ngược nó. Nếu chúng ta đảo ngược nó không chỉ cho đầu của chúng ta, rồi ba, rồi hai, rồi một, rồi cái này không trỏ đến tải xuống.

888
00:00:45,540 --> 00:00:59,130
Được rồi. Và đây là sự căm ghét của chúng tôi. Vì vậy, chúng tôi phải trả lại nhà ngôn ngữ học này, nếu bạn muốn, đưa ra danh sách liên kết này, thì bạn phải đảo ngược nó. Nếu chúng ta đảo ngược nó, năm sẽ trở thành sự căm ghét của chúng ta.

889
00:01:00,260 --> 00:01:16,570
Rồi bốn, rồi ba, rồi hai, rồi một, rồi bây giờ. Được rồi, vậy nếu đảo ngược danh sách dài này, chúng ta sẽ có được danh sách liên kết này. Vì vậy, chúng tôi phải trả lại danh sách liên kết này ngay bây giờ để có thể giải quyết vấn đề này một cách lặp đi lặp lại.

890
00:01:17,810 --> 00:01:33,170
Không, hãy để tôi đi qua trực giác. Bây giờ hãy để tôi chỉ cho bạn cách chúng ta có thể giải quyết vấn đề này. Để dễ hiểu, giả sử chúng ta được đưa cho danh sách này, đây là Hadland của chúng ta.

891
00:01:33,380 --> 00:01:45,440
OK, chúng ta sẽ khai báo người bổ nhiệm hiện tại. Điều đó sẽ chỉ vào Hayden. Bây giờ chúng ta sẽ khai báo hai con trỏ trỏ đến tải xuống PRIV và thứ 10.

892
00:01:46,620 --> 00:02:08,360
Đầu tiên, chúng ta sẽ di chuyển con trỏ 10 này sang dòng tiếp theo, vì vậy con trỏ 10 sẽ trỏ đến ghi chú này. OK, bây giờ chúng ta sẽ ngắt kết nối liên kết này và chúng ta sẽ kết nối liên kết này với liên kết này ngay bây giờ, không phải nơi mọi người trỏ đến.

893
00:02:09,610 --> 00:02:24,000
Được rồi, sau đó chúng ta sẽ di chuyển ba con trỏ đến hiện tại và hiện tại ở vị trí thứ 10. Bây giờ chúng ta sẽ chuyển nhiệt độ sang dòng điện tiếp theo, vì vậy điểm tạm thời ở đây.

894
00:02:24,620 --> 00:02:38,450
Bây giờ chúng ta sẽ ngắt kết nối liên kết này và chúng ta sẽ kết nối nó. Ba con trỏ trỏ. OK, vậy chúng ta kết nối cái này với nút này. Bây giờ chúng ta sẽ di chuyển con trỏ đến hiện tại.

895
00:02:39,400 --> 00:02:57,690
Và con trỏ hiện tại tới temp. Được rồi, bây giờ chúng ta hãy chuyển điểm này sang ghi chú tiếp theo, con trỏ hiện tại của cô ấy trỏ tới sau đó hãy ngắt kết nối liên kết này và kết nối điểm con trỏ.

896
00:02:58,450 --> 00:03:21,150
Vì thế. Bây giờ chúng ta kết nối ở đây, chúng ta sẽ di chuyển ba con trỏ tới dòng điện và dòng điện sang nhiệt độ. Bây giờ chúng ta hãy chuyển sang điểm nhịp độ hiện tại tiếp theo ở đây. Bây giờ, hãy ngắt kết nối liên kết này và kết nối với điểm giữa mà nó trỏ tới.

897
00:03:22,470 --> 00:03:40,900
Bây giờ hãy để tôi chỉ ra hiện tại và hiện tại theo nhiệt độ. Được rồi, khi bạn thấy con trỏ hiện tại đang trỏ đến một nội dung không còn cũ nữa và sẽ quay trở lại, thì con trỏ hạnh phúc đang trỏ.

898
00:03:41,980 --> 00:03:56,820
Chúng ta thấy rằng đây chính là phần đầu của Reversed Lindqvist. Bạn sẽ trả lại cái đầu này. Điều đó có nghĩa là chúng ta đang quay trở lại với luật pháp đảo ngược, liên kết ngược được liệt kê từ ba đến một.

899
00:03:57,130 --> 00:04:09,940
Vì vậy, chúng tôi đang trả lại người theo chủ nghĩa pháp lý này và đây là cách chúng tôi có thể giải quyết vấn đề này để hiểu rõ hơn. Hãy lấy một ví dụ khác. Bây giờ, giả sử rằng chúng ta được cung cấp danh sách dài này.

900
00:04:10,750 --> 00:04:25,440
Đây là nút đầu của chúng ta, được chứ? Và chúng ta sẽ khai báo một dòng con trỏ mới trỏ tới hadnot này. Sau đó, chúng tôi sẽ khai báo 2.0, mở ra phản hồi cho Norrland và thứ 10 rằng nó cũng trỏ đến tải xuống.

901
00:04:26,870 --> 00:04:53,870
Bây giờ mục tiêu của chúng ta là di chuyển con trỏ thứ mười tới nút tiếp theo. Con trỏ hiện tại của cô ấy đang trỏ. Vì vậy, chúng ta sẽ chuyển tạm thời sang đây, không phải sang. Bây giờ, chúng ta sẽ ngắt kết nối liên kết này và sẽ kết nối nó với điểm không trỏ đến trong trường hợp này, nhưng Con trỏ đang trỏ đến một điểm không được kết nối tốt với quá trình tải xuống.

902
00:04:54,080 --> 00:05:11,960
Bây giờ chúng ta sẽ di chuyển con trỏ đến hiện tại và hiện tại đến thứ mười. Được rồi, hãy chuyển nhiệt độ sang dòng điện tiếp theo. Vì vậy, điểm nhiệt độ thấp ở đây. Bây giờ, hãy ngắt kết nối liên kết này và hãy kết nối với con trỏ nút đang trỏ.

903
00:05:12,140 --> 00:05:28,190
OK, bây giờ chúng ta hãy chuyển sang con trỏ hiện tại và hiện tại tới temp. Bây giờ hãy di chuyển điểm tạm thời tới nút tiếp theo nơi con trỏ hiện tại của chúng ta đang trỏ. Bây giờ chúng ta hãy ngắt kết nối liên kết này và hãy kết nối với con trỏ nút đang trỏ.

904
00:05:28,370 --> 00:05:39,830
OK, bây giờ hãy chuyển sang nhiệt độ hiện tại và hiện tại. Bây giờ hãy chuyển sang nút tiếp theo và ngắt kết nối. Điều đó được kết nối với nút. Nửa chừng nó đang chỉ.

905
00:05:39,980 --> 00:05:52,770
Bây giờ hãy chuyển sang hiện tại và hiện tại sang nhiệt độ. Bây giờ chúng ta hãy chuyển sang dòng điện tiếp theo. Vì vậy, nó sẽ trỏ đến nút bây giờ này và chúng ta sẽ ngắt kết nối liên kết được kết nối với nút này.

906
00:05:52,910 --> 00:06:10,180
Bây giờ hãy di chuyển con trỏ tới nút này và dòng điện trỏ tới ghi chú này. Chúng ta thấy con trỏ hiện tại đang trỏ để thông báo nó. Khi chúng ta thấy con trỏ hiện tại đang trỏ tới con trỏ khác, nó sẽ trả về con trỏ hoặc con trỏ nút đang trỏ vào.

907
00:06:10,610 --> 00:06:29,570
Chúng tôi thấy đây là đầu mối liên kết Rivers của chúng tôi. Liên kết ngược liệt kê năm, bốn, ba, hai, một. Hiện nay. ĐƯỢC RỒI. Và đây là cách chúng ta có thể giải quyết vấn đề này. Giải pháp sẽ phát huy được độ phức tạp về mặt thời gian khi đó là số lượng không có trong danh sách nhất định.

908
00:06:29,570 --> 00:06:42,500
Và tất cả đều có độ phức tạp không gian không đổi. Vì chúng tôi chỉ sử dụng một số con trỏ nên chúng tôi không sử dụng bất kỳ phần bổ sung nào để giải quyết vấn đề này và đây là cách chúng tôi có thể giải quyết vấn đề này một cách lặp đi lặp lại.

909
00:06:42,770 --> 00:06:54,320
Bây giờ hãy để tôi đi qua mã giả để hiểu rõ hơn. Được rồi, ở đây chúng ta có mã giả trước tiên, hãy xem lại mã giả của chúng ta, sau đó chúng ta sẽ xem nó hoạt động như thế nào.

910
00:06:55,200 --> 00:07:07,500
Đầu tiên, tất cả hàm, đảo ngược văn bản trước một danh sách nhất định, sau đó sẽ khai báo ba con trỏ gồm dòng điện và nhiệt độ. Sau đó, chúng ta sẽ chạy một chương trình trực tiếp liên quan đến bây giờ và ở đây.

911
00:07:07,500 --> 00:07:21,150
Chúng tôi đang thao tác con trỏ. Chúng tôi đang ngắt kết nối, chúng tôi kết nối và xóa các con trỏ đang di chuyển. OK, ở cuối ba con trỏ này sẽ trỏ đến đầu bên phải dài nhất được đảo ngược cho lần lặp đầu tiên.

912
00:07:21,150 --> 00:07:34,170
Nếu chúng ta cho một nhà ngôn ngữ học một, hai, ba, bốn. Bây giờ, trong lần lặp đầu tiên, danh sách liên kết đó sẽ được trình bày như thế này. Sau đó, trong lần lặp thứ hai của Wellinghoff này, danh sách liên kết sẽ được trình bày như thế này.

913
00:07:34,560 --> 00:07:48,480
Sau đó, ở thế hệ thứ ba, danh sách liên kết sẽ được biểu diễn như thế này và ở lần lặp thứ tư, danh sách liên kết sẽ được biểu diễn như thế này. Và đây là người đứng đầu nhà ngôn ngữ học đã được sửa đổi của chúng tôi.

914
00:07:48,660 --> 00:08:02,100
Vì vậy, tất cả danh sách liên kết này ở đây bạn có thể thấy từ ba đến một và bây giờ là danh sách liên kết đã được sửa đổi của chúng tôi. Được rồi, tôi sẽ không đi qua từng dòng mã giả này.

915
00:08:03,090 --> 00:08:16,830
Nếu tôi đi qua từng dòng mã giả bạn sẽ cảm thấy nhàm chán. Tôi không muốn điều đó để hiểu rõ hơn. Hãy nhìn vào bức ảnh này. Chỉ khi đó bạn mới có thể hiểu được vấn đề này một cách dễ dàng.

916
00:08:17,160 --> 00:08:29,850
Giải pháp chỉ cần thực hiện vì về mặt thời gian, độ phức tạp là số lượng nút trong danh sách liên kết nhất định và
tất cả đều có độ phức tạp không gian không đổi. Được rồi các bạn, đây là giải pháp của tôi cho vấn đề này. 

@@@



917
00:00:00,480 --> 00:00:11,340
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng ta sẽ nói về thế nào là dính. Stick là cấu trúc dữ liệu được sử dụng để lưu trữ một tập hợp các đối tượng.

918
00:00:12,090 --> 00:00:30,870
Nó giống như một chồng thư được xếp chồng lên nhau, đại loại như thế này. Chúng tôi có sáu đĩa của bạn, một đĩa, trên cùng của đĩa kia. Họ nói rằng chuyến bay hàng đầu, nếu bạn muốn đặt máu mới, thì bạn phải đặt cam kết lên trên cùng của đống này.

919
00:00:31,690 --> 00:00:45,870
Bạn sẽ muốn đặt một chiếc đĩa xuống đáy thì hãy nhanh tay thực hiện. Chúng tôi phải loại bỏ tất cả các tấm. Sau đó, bạn phải đặt tấm xuống phía dưới. Chúng ta có thể thực hiện hai thao tác.

920
00:00:46,350 --> 00:00:58,830
Chúng ta có thể đổ máu mới lên trên hoặc có thể tháo tấm trên cùng. Và nguyên tắc này được gọi là Last In, First Out, mục cuối cùng. Đó là món đồ đầu tiên được ra ngoài.

921
00:00:59,100 --> 00:01:18,750
Vì vậy, trong đống này, chúng ta thấy rằng chúng ta có sáu tấm. Chúng tôi phải loại bỏ tất cả các tấm. Chúng ta chỉ có thể tháo tấm từ trên xuống một lần nữa nếu chúng ta loại bỏ tất cả các tấm khỏi đống này, chỉ khi đó chúng ta mới có thể đặt một cam kết mới vào phía dưới.

922
00:01:19,540 --> 00:01:33,840
Được rồi, đây là một ví dụ về cấu trúc tiêu chuẩn và nguyên tắc của cấu trúc tiêu chuẩn là cấp độ vào sau, ra trước. Nếu chúng ta thêm một tấm mới ngay ở đây, nó được gọi là Last In.

923
00:01:33,990 --> 00:01:45,090
Và nếu chúng ta muốn lấy một cái đĩa ra khỏi đống này thì bạn phải lấy cái đĩa ra khỏi đầu. Và đó được gọi là đầu tiên. Vì vậy nó được gọi là vào sau, ra trước.

924
00:01:45,600 --> 00:01:56,700
Bây giờ chúng ta hãy nói về nguyên tắc của Leifur. Việc đặt một phần tử lên trên cùng của ngăn xếp được gọi là thao tác đẩy. Việc loại bỏ một mục khỏi đầu ngăn xếp được gọi là thao tác bật lên.

925
00:01:57,300 --> 00:02:08,600
Vì vậy, đây là cây gậy của chúng ta, chúng ta nói ở đây, đẩy và hãy đẩy nó một cái. Bây giờ trên ngăn xếp, chúng ta chỉ có một phần tử. Có một cái bây giờ chúng tôi có ngăn xếp này ở đây.

926
00:02:08,610 --> 00:02:19,040
Được rồi, hãy đẩy hai cái vào ngăn xếp này. Bây giờ chúng ta có ngăn xếp này và chúng ta chỉ có một phần tử được gọi là phương thức pop. Pop sẽ xóa phần tử ở trên cùng.

927
00:02:19,230 --> 00:02:30,120
Vì vậy, nếu chúng ta loại bỏ phần tử ở trên cùng thì chúng ta chỉ còn lại một phần tử. Nếu chúng ta đẩy một phần tử khác vào ngăn xếp này thì chúng ta phải loại bỏ phần tử đó một lần nữa.

928
00:02:30,120 --> 00:02:41,120
Nếu chúng ta đẩy ba và chúng ta đã thêm ba. Vậy chúng ta có ba phần tử trên ngăn xếp này, ABC phồng. Nó sẽ loại bỏ phần tử trên cùng, sau đó chỉ bầu Willmot một và hai.

929
00:02:41,310 --> 00:02:52,080
Vì vậy, chúng tôi đang đặt một mục lên trên cùng của ngăn xếp bằng thao tác đẩy này và xóa một mục khỏi đầu ngăn xếp bằng thao tác bật lên này. Và điều này được gọi là hoạt động đẩy và bật.

930
00:02:52,230 --> 00:03:04,170
Đây là các thao tác phổ biến trong một ngăn xếp mà chúng ta có thể gặp và đây được gọi là nguyên tắc vào sau, ra trước. Vì thế bằng thao tác đẩy này ta thấy bị mất vào và do các thao tác này kéo ra.

931
00:03:04,230 --> 00:03:16,500
Cái này được gọi là Leifur Nguyên tắc Up Stick. Bây giờ hãy nói về hoạt động trong Steck. Chúng ta có năm thao tác phổ biến trong thao tác đẩy ngăn xếp. Bằng thao tác đẩy này, chúng ta có thể thêm một phần tử vào đầu phần tử đó.

932
00:03:16,500 --> 00:03:28,050
Dính vào hoạt động này. Chúng ta có thể loại bỏ một phần tử khỏi đầu Aztek trống. Thao tác này sẽ kiểm tra xem ngăn xếp trống có bị kéo hay không, nó sẽ lấy.

933
00:03:28,050 --> 00:03:40,390
Nếu ngăn xếp đầy và đạt đỉnh, nó sẽ lấy giá trị của phần tử trên cùng mà không cần xóa nó. Ngoài ra còn có một thao tác khác được gọi là xóa ngăn xếp và thao tác đó sẽ được triển khai ngay trong phần này.

934
00:03:40,410 --> 00:03:59,160
Đừng lo lắng về điều đó. Và cuộc chiến này với các thao tác phổ biến mà nó có thể thực hiện trên một ngăn xếp mà chúng tôi có ở đây. Vì vậy, hãy đẩy vào ngăn xếp. Vì vậy, chúng tôi đã đẩy một phần tử vào ngăn xếp và đó là nếu chúng tôi nói POF, nó sẽ được thực hiện và nó sẽ loại bỏ phần tử trên cùng và đó là bốn và ba phần tử liên quan đang thực hiện thao tác này.

935
00:03:59,640 --> 00:04:11,750
Bây giờ trong ngăn xếp, nếu chúng ta thực hiện các thao tác này hoặc chúng ta gọi phương thức này là trống, phi tôn giáo sai vì ngăn xếp không trống, APC đã đầy và chúng ta thấy rằng bản nhạc này không đầy.

936
00:04:11,840 --> 00:04:28,140
Chúng tôi coi cạnh của ngăn xếp là vì kiểm tra này chưa đầy. Chúng ta có thể thêm một phần tử nữa vào ngăn xếp này. Vì vậy, nó sẽ trả về false vì ngăn xếp không đầy và các thao tác pig, các thao tác này sẽ giữ lại phần tử trên cùng và nó sẽ không loại bỏ phần tử trên cùng.

937
00:04:28,360 --> 00:04:36,570
OK, và đây là thao tác hiện tại mà nó có thể đáp ứng nếu một thao tác khác được gọi là ngăn xếp và nó sẽ xóa ngăn xếp khỏi bộ nhớ máy tính.

938
00:04:36,600 --> 00:04:45,510
OK, và bạn sẽ thấy cách chúng ta có thể triển khai điều đó ngay trong phần này. Bây giờ hãy nói về ứng dụng của cây gậy. Chúng tôi sử dụng một ngăn xếp trong trình biên dịch, trình biên dịch.

939
00:04:45,510 --> 00:04:59,610
Đó là ngăn xếp để tính giá trị của các biểu thức như hai cộng bốn chia năm nhân bảy trừ chín. Và đó là chèn dấu ngoặc đơn này bằng cách chuyển đổi phần đùn thành tiền tố.

940
00:04:59,720 --> 00:05:12,930
Phần tái bút của chúng tôi để tính toán biểu thức đó, chúng tôi phải sử dụng một cây gậy và thêu lại trình duyệt ghi lại tất cả những gì bạn nhận ra rằng bạn đã truy cập trước đó trong một ngăn xếp.

941
00:05:13,170 --> 00:05:25,760
Mỗi lần bạn truy cập một trang mới, nó sẽ được thêm vào đầu ngăn xếp. Khi bạn nhấn nút, URL hiện tại sẽ bị xóa khỏi ngăn xếp và Eurail trước đó sẽ được truy cập.

942
00:05:27,510 --> 00:05:42,470
Đây là một ví dụ về việc ghi ngược đường viền của chúng tôi và đây là nút quay lại. OK, và giả sử chúng ta đã truy cập năm trang web này, đầu tiên là Facebook, sau đó là liên kết, sau đó là bạn, sau đó là Google và chúng ta thấy ở đây là Google, được chứ?

943
00:05:42,750 --> 00:05:56,160
Và điều này sẽ được thể hiện trong Steck, giống như Facebook năm đầu tiên, sau đó liên kết Udemy, rồi Google. Nếu chúng tôi nhấn mạnh vào lời cầu xin thứ lỗi này, thì nó sẽ xóa trang web này khỏi Steck và nó sẽ chuyển sang bạn quyết định.

944
00:05:56,430 --> 00:06:12,090
Nếu chúng ta nhấp vào nút quay lại này một lần nữa, nó sẽ xóa mục này khỏi Steck và nó sẽ chuyển đến liên kết trang này. Nếu chúng ta nhấp vào backburn một lần nữa thì nó sẽ chuyển sang Facebook dot com lần nữa và nhấp lại vào nút quay lại.

945
00:06:12,090 --> 00:06:25,550
Sau đó nó sẽ chuyển sang tab trống. Được rồi, đây là cách Steck hoạt động. Đây là một ví dụ thực
tế của Steck. Việc ghi ngược này được thực hiện bằng cách sử dụng đã hiểu khái niệm về Steck. 

@@@



946
00:00:00,600 --> 00:00:18,810
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về tùy chọn triển khai Steck. Chúng ta có thể triển khai từng bước trong đây là một mảng hoặc sử dụng danh sách cho mọi triển khai mà chúng ta có ưu và nhược điểm là dễ thực hiện.

947
00:00:18,810 --> 00:00:36,120
Và nhược điểm là chỗ xảy ra lỗi đã được sửa. Vậy là hiền nhân của Steck sẽ được sửa chữa. Và đó có thể là một vấn đề đối với một số Kasit và đối với quá trình triển khai ngôn ngữ học mà trang web có thể bị thay đổi.

948
00:00:36,480 --> 00:00:48,970
Đây là một trang web có thể thay đổi. Chúng tôi có thể thay đổi kích thước trong thời gian chạy và Korn cho rằng việc triển khai Mordred hơi khó khăn một chút, nhưng đối với việc triển khai của chúng tôi thì cực kỳ dễ dàng.

949
00:00:49,770 --> 00:00:58,050
Bây giờ chúng ta hãy xem các hoạt động phổ biến mà chúng ta có thể đáp ứng để thực hiện và thực hiện theo chủ nghĩa pháp lý. Để thực hiện. Chúng ta có thể thực hiện phương pháp này ở đây.

950
00:00:58,170 --> 00:01:10,650
Đỉnh POF đẩy trống, Espoo và Delyth Steck và triển khai đầy đủ. Chúng tôi không biết trang web. Được rồi, vì vậy chúng tôi không thể triển khai phương pháp này để triển khai cho nhà ngôn ngữ học.

951
00:01:10,880 --> 00:01:26,940
Điều thú vị là chúng ta có Push-Pull Peak trống và phương pháp Delyth Stack ngay trong phần này và chúng ta sẽ xem cách chúng ta có thể triển khai STAC bằng cách sử dụng khu vực và
sẽ triển khai tất cả phương thức đó, đồng thời chúng ta sẽ xem cách chúng ta có thể triển khai STAC bằng cách sử dụng nhà ngôn ngữ học và sẽ thực hiện tất cả các phương pháp. 

@@@



952
00:00:00,480 --> 00:00:14,280
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ thấy việc triển khai STAC gặp lỗi và chúng ta sẽ triển khai Steck từ đầu bằng cách sử dụng Ouray để triển khai.

953
00:00:14,470 --> 00:00:27,060
Ưu điểm là dễ thực hiện. Và nó được sửa như thế nào? Saidi's, chúng ta có thể thay đổi địa điểm. Bây giờ chúng ta hãy xem một số thao tác sẽ được thực hiện trong video này.

954
00:00:27,840 --> 00:00:45,240
Trong video này sẽ thực hiện 2 thao tác này là tạo thao tác đẩy Steck và thao tác bật. Đây là mã để triển khai Steck bằng mọi lớp Urabe, Streck là một mảng.

955
00:00:45,830 --> 00:01:01,310
Và ở đây chúng tôi gặp phải lỗi này và chúng tôi gặp rắc rối khủng khiếp. Steck Và chúng tôi có ở đây bảy phương pháp. Great Steck Push-Pull Peak trống, là ngăn xếp nhỏ và sẽ triển khai ba phương pháp này trong video này.

956
00:01:01,550 --> 00:01:13,400
Bây giờ hãy nói về việc tạo phương thức Steck. Ở đây chúng tôi đã tạo ra Tegmental. Phương pháp này lấy một địa điểm tham số bên trong, chúng tôi đang tạo một khu vực mới với địa điểm nhất định và loại khu vực mà anh ấy sẽ quản lý.

957
00:01:13,550 --> 00:01:30,860
Sử dụng biến này, chúng tôi sẽ theo dõi phần tử khó khăn trong ngăn xếp của mình. Vì bạn đang triển khai STAC bằng cách sử dụng mọi phương thức của bạn vì phương pháp này có năm, nên họ đang tạo một mảng số nguyên mới LENTE năm và chúng tôi có số chỉ mục cho mỗi ô cho lần bán đầu tiên.

958
00:01:30,860 --> 00:01:46,190
Số chỉ mục bằng 0 đối với Kinsale trong số này là một, v.v. Chúng tôi đang sử dụng ngôn ngữ lập trình bằng không trong suốt bài diễn thuyết. Khi bạn tạo một mảng số nguyên trong Java, giá trị mặc định cho tất cả việc bán mảng là 0.

959
00:01:46,310 --> 00:02:00,860
Chúng tôi không hiển thị cho bạn số không. Chỉ vì sự hiểu biết. Chúng tôi giả định rằng mảng hiện trống và phần trên của nông nghiệp trừ đi một. Việc sử dụng mảng này sẽ theo dõi phần tử hàng đầu trong ngăn xếp của chúng ta và ngăn xếp sẽ được biểu diễn.

960
00:02:00,860 --> 00:02:10,850
Một cái gì đó như thế này. Ngăn xếp trống. Đây chỉ là một hình ảnh trực quan của một ngăn xếp. Nhưng trong nội bộ chúng tôi đang sử dụng mảng để biểu diễn một ngăn xếp. Bây giờ hãy xem phương pháp đẩy.

961
00:02:11,060 --> 00:02:23,280
Đây là phương pháp đẩy của chúng tôi. Phương pháp này lấy một dhara nổi bật bên trong đây. Chúng tôi đang kiểm tra xem độ dài của mảng trừ chỉ được đưa lên ngăn xếp, sau đó sẽ in tràn ngăn xếp sau đó.

962
00:02:23,510 --> 00:02:43,670
Điều đó có nghĩa là ngăn xếp đã đầy. Chúng ta không thể chèn thêm bất kỳ phần tử nào vào ngăn xếp nếu không phải tất cả. Chèn dữ liệu vào chỉ mục. Phần trên cùng của mảng cộng với một phần lỗi trên cùng hiện tại là trừ một và ban đầu nó sẽ chèn lần bán hàng đầu tiên, sau đó loại bỏ phần trên cùng của thanh sang phần tử tiếp theo.

963
00:02:43,670 --> 00:02:58,970
Và chúng tôi đang in ở đây. Chèn nó ngay bây giờ. Hãy xem nó hoạt động như thế nào. Bây giờ nếu chúng ta gọi phương thức này là push bằng một thì điều gì sẽ xảy ra? Chúng tôi sẽ chèn cái này vào khu vực này và chèn vào phần lỗi được chọn đầu tiên này.

964
00:02:58,970 --> 00:03:11,960
Cộng một là 0 phần trăm trên cùng của mảng, trừ một. Vì vậy, chúng tôi sẽ chèn dữ liệu vào ô này. Và trong ngăn xếp, nó sẽ được biểu diễn giống như thế này và nó sẽ chèn ngay vào đây.

965
00:03:12,050 --> 00:03:29,990
Và giá trị của kiểu mảng này sẽ được thay đổi thành 0. Bây giờ, nếu chúng ta gọi lại phương thức này, đẩy bằng hai, thì điều gì sẽ xảy ra? Chúng ta sẽ chèn dữ liệu này vào đợt bán chỉ số một này và chúng ta có thể lấy chỉ mục của đợt giảm giá này bằng cách nói DUBOV ba cộng một.

966
00:03:30,170 --> 00:03:43,910
Vậy không cộng một là một. Vì vậy, hãy chèn vào đây và vào ngăn xếp nữa. Và chúng tôi chỉ cho bạn thấy hình ảnh trực quan của ngăn xếp và ngăn xếp sẽ được trình bày, đại loại như thế này, và phát triển nó một chút.

967
00:03:43,910 --> 00:04:03,620
Mười ăn một, có thể gọi lại phương thức này với ba, sau đó nó sẽ được chèn vào đây và nó sẽ được biểu thị giống như thế này trong Stack và nó sẽ tăng lên hai nếu chúng ta gọi lại vấn đề này, nhấn cho, sẽ chèn vào đây và vẫn sẽ được đại diện.

968
00:04:03,620 --> 00:04:12,020
Một cái gì đó như thế này. Phần tử trên cùng là bốn và giá trị của biến này là ba. Vậy bạn đang làm gì ở đây hoặc tăng cường phát triển? Biến này là thời gian.

969
00:04:12,050 --> 00:04:23,180
Tại sao? Chúng tôi muốn truy cập phần tử hàng đầu trong khu vực này. Chúng tôi thấy yếu tố hàng đầu trong phần bổ sung này. Phần tử trên cùng là phần tử thứ tư này. Và với số chỉ mục này, chúng ta có thể lấy được phần tử đứng đầu.

970
00:04:23,180 --> 00:04:42,230
Và trong ngăn xếp chúng ta thấy đây là phần tử trên cùng, được chứ? Và đó là lý do tại sao chúng tôi sử dụng biến này để theo dõi phần tử hàng đầu của mình. Vì bạn đang sử dụng triển khai Stack nhiều, nên nếu bạn gọi phương thức này bằng năm thì năm sẽ được chèn ngay tại đây, cũng ở đây để trình bày.

971
00:04:42,410 --> 00:04:52,850
Và giá trị này sẽ chỉ thú vị bây giờ. Chúng tôi thấy thứ hai của chúng tôi đầy đủ. Nếu chúng ta gọi lại, nhấn sáu, thì nó sẽ đưa ra lỗi tràn ngăn xếp này.

972
00:04:53,150 --> 00:05:07,640
Nó sẽ không được chèn vào ngăn xếp của chúng ta vì ngăn xếp đã đầy. Đây là cách hoạt động của Bush này hoạt động và đây là cách chúng ta có thể triển khai phương thức đẩy. Bây giờ hãy nói về phương thức pop với phương thức pop đều loại bỏ và trả về phần tử trên cùng.

973
00:05:07,910 --> 00:05:18,920
Bây giờ hãy xem làm thế nào chúng ta có thể làm điều đó. Đây là phương pháp của bạn. Phương pháp này không có tham số. Và ở đây, chúng tôi đang giải quyết những trở ngại hàng đầu đối với việc quản lý sẽ in ra lỗi tràn ngăn xếp có nghĩa là hoặc ngăn xếp trống.

974
00:05:19,190 --> 00:05:35,290
Phần thưởng của những người theo chủ nghĩa kinh nghiệm là trừ một. Điều đó có nghĩa là cổ phần của chúng tôi trống rỗng. Sau đó, chúng tôi đang lưu trữ giá trị cao nhất cho biến tạm thời này và chúng tôi đang in giá trị của biến số 10 rồi chúng tôi sẽ thiết lập giá trị đó.

975
00:05:35,780 --> 00:05:46,570
Hai phần trăm 0 chỉ tạo ra một khu vực, một khu vực số nguyên trong Java, mặc định là 0 trong 13 năm và đang giảm vị trí của các biến đầu ngăn xếp.

976
00:05:47,000 --> 00:05:56,510
Vì vậy, nó sẽ bật ra phần tử trên cùng. Sau đó, phần tử hàng đầu tiếp theo của chúng ta sẽ là phần tử trước đó. Được rồi, đó là lý do chúng tôi đang giảm kích thước của biến này.

977
00:05:56,690 --> 00:06:11,690
Bây giờ, nếu chúng ta gọi đây là pof, thì chuyện gì sẽ xảy ra? Nó sẽ loại bỏ phần tử thứ năm này và chúng ta có thể truy cập phần tử này của số chỉ mục này. Vì vậy, nó sẽ loại bỏ phần tử này và nó sẽ trả về phần tử số năm và phần tử số năm cũng sẽ bị xóa khỏi ngăn xếp của chúng ta.

978
00:06:11,870 --> 00:06:20,340
Vì ở đây chúng tôi chỉ hiển thị cho bạn biểu diễn ngăn xếp nên thực sự làm việc với mảng này và các cạnh của biến này sẽ giảm xuống còn ba.

979
00:06:20,450 --> 00:06:32,600
Vì vậy, ngăn xếp của chúng ta sẽ được biểu diễn giống như thế này và sẽ được biểu diễn giống như thế này. Nếu chúng ta gọi lại phương thức này là Pop, nó sẽ trả về nếu chúng ta gọi lại phương thức này là POF thì điều gì sẽ xảy ra?

980
00:06:32,600 --> 00:06:48,280
Nó sẽ trả về và loại bỏ phần tử bốn này khỏi ngăn xếp của chúng ta và được đặt thành 0 và nó sẽ trả về bốn và bốn sẽ bị xóa khỏi ngăn xếp của chúng ta và vị trí của biến này sẽ được thay đổi thành phần tử trên cùng của chúng ta là ba.

981
00:06:48,290 --> 00:07:03,920
Và với biến này chúng ta có thể truy cập phần tử trên cùng. Và đây là lý do tại sao chúng ta sử dụng top của mọi biến. Được rồi. Đây là tất cả về hoạt động đẩy và bật này, chúng tôi đã hiểu hoạt động đẩy, hoạt động bật và tạo hoạt động ngăn xếp.

982
00:07:04,250 --> 00:07:21,470
Hoạt động ngăn xếp này sẽ có độ phức tạp một lần lớn hơn và chúng ta sẽ đạt được độ phức tạp một không gian vì chúng ta đang tạo mảng cùng một lúc. Và biến này, thao tác Đẩy hoạt động này cũng sẽ lớn hơn về độ phức tạp về thời gian và không gian.

983
00:07:22,190 --> 00:07:33,650
Hoạt động pop này cũng mất nhiều thời gian và độ phức tạp về không gian. Chúng tôi đã hiểu mọi lời giải thích trong video này. Chúng tôi đã giải thích hoạt động đẩy và bật ngăn xếp tuyệt vời.

984
00:07:34,100 --> 00:07:44,750
Trong video tiếp theo, chúng ta sẽ nói về hoạt động lớn, hoạt động trống,
hoạt động đầy đủ và hoạt động ngăn xếp, xem trong video tiếp theo. 

@@@



985
00:00:00,480 --> 00:00:09,630
Rất nhiều chàng trai sẽ quay lại video này trong video này. Chúng ta sẽ nói về điều này trong video này, chúng ta sẽ nói về điều này trong giai đoạn hoạt động cao điểm.

986
00:00:10,170 --> 00:00:19,860
Hoạt động có hoạt động đầy đủ và hoạt động son môi không? Trong video trước chúng ta đã nói về ba thao tác tạo ra thao tác đẩy và bật Streck.

987
00:00:20,370 --> 00:00:34,050
Bây giờ, hãy nói về điều này cho các hoạt động. Đầu tiên hãy nói về hoạt động đỉnh điểm ngay trong video này. Chúng ta sẽ xem điều này để biết phương pháp. Bây giờ hãy nói về hoạt động cao điểm cho hoạt động cao điểm.

988
00:00:34,050 --> 00:00:47,750
Phương pháp này không có tham số bên trong hoặc kiểm tra. Rõ ràng là nó thuộc về quản lý. Sau đó chúng ta sẽ in ở đây, xếp chồng trống. Nếu không thì chúng ta đang in phần trên cùng của ngăn xếp.

989
00:00:47,760 --> 00:01:09,560
Nếu chúng ta gọi phương thức này và nếu được cung cấp vùng này dưới dạng một cây gậy và anh ta gói vùng của Arrigo vào và vùng này sẽ được biểu diễn giống như thế này, vì chúng ta đang triển khai STAC bằng cách sử dụng mọi phương thức mà chúng ta gọi, phương thức này sẽ trả về năm vì năm là yếu tố khó khăn trong cuộc tấn công này và đây là hoạt động cao điểm.

990
00:01:09,570 --> 00:01:18,570
Nó khá đơn giản. Và hoạt động này sẽ mất thời gian và làm tăng độ phức tạp của một không gian. Chúng tôi đã hiểu hoạt động cao điểm. Bây giờ hãy nói về phần còn lại của hoạt động.

991
00:01:18,810 --> 00:01:28,410
Đây là một hoạt động lớn. Hoạt động này sẽ trở lại với những nỗ lực của chúng tôi. Nếu ngăn xếp trống thì nó sẽ trả về. Đúng, nếu cảnh cáo không trống, nó sẽ trả về sai.

992
00:01:28,410 --> 00:01:48,120
Nếu chúng ta gọi phương thức này là trống đối với ngăn xếp đã cho này thì nó sẽ trả về false vì ngăn xếp không trống. Và đối với phương pháp này là đầy đủ. Kiểm tra xem mọi lentachus bom mìn, khi nó được nạp vào ngăn xếp, thì chúng tôi sẽ quay trở lại, nếu chưa sai đối với phương pháp khuôn mẫu đã cho này, nó sẽ quay trở lại.

993
00:01:48,120 --> 00:02:06,270
Đúng, bởi vì kích thước của ngăn xếp này đã đầy nên nó sẽ trả về true. Sau đó, chúng ta có ngăn xếp phương thức này và ở đây chúng ta đã quen với nó và rõ ràng là bạn phải theo dõi nó bởi vì phương thức này bây giờ sẽ được đặt thành rất kiêu ngạo, bị xóa khỏi bộ nhớ máy tính của chúng ta và ngăn xếp cũng sẽ bị xóa.

994
00:02:06,270 --> 00:02:15,960
Đây chỉ là một đại diện cho lỗi của chúng tôi. Vì vậy, ngăn xếp của chúng tôi sẽ bị xóa khỏi bộ nhớ máy tính và tất cả văn bản hoạt động. Chúng tôi đi theo sự phức tạp về thời gian và không gian.

995
00:02:15,960 --> 00:02:27,810
Hoạt động này chiếm một lần độ phức tạp của khuôn mặt. Hoạt động này cũng chiếm độ phức tạp về thời gian và không gian. Hoạt động này cũng chiếm độ phức tạp về thời gian và không gian.

996
00:02:27,930 --> 00:02:41,000
Chúng ta đã hiểu chính lời giải thích này. Tôi kiểm tra mã nguồn bằng Java để triển khai STAC. Sử dụng mọi tập tin
nguồn duy nhất. Bạn có một phương trình trong đó là phép cộng hoặc có vấn đề để hiểu lời giải thích tốt hơn này. 

@@@



997
00:00:00,570 --> 00:00:13,810
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ thấy cách triển khai Steck lâu nhất khi bạn triển khai sáu phương pháp này cho việc triển khai của các nhà ngôn ngữ học.

998
00:00:13,830 --> 00:00:24,520
Trong video này, chúng ta sẽ xem cách họ triển khai ba phương pháp này. Trong video tiếp theo, chúng ta sẽ xem cách họ triển khai ba phương pháp này. Bây giờ, hãy nói về điểm số, sự thúc đẩy công nghệ và hoạt động phổ biến.

999
00:00:25,230 --> 00:00:36,900
Hãy bắt đầu với các hoạt động công nghệ tuyệt vời. Đây là mã của chúng tôi để triển khai STAC bằng cách sử dụng nhà ngôn ngữ học. Đầu tiên, chúng ta có nút lớp này. Đây là nút của chúng tôi.

1000
00:00:37,140 --> 00:00:49,640
Nút này chứa hai thuộc tính, dữ liệu và con trỏ tiếp theo mà chúng ta có. Bạn biết đấy, đây là nút đầu cho danh sách liên kết của chúng tôi. Khi bạn đang gọi phương thức này hoặc khởi tạo con trỏ Hajja now.

1001
00:00:49,740 --> 00:01:02,340
Vì vậy, nhà ngôn ngữ học ban đầu của chúng tôi bây giờ và đây là nút đầu của chúng tôi. ĐƯỢC RỒI. Sẽ rất khó khăn cho ngăn xếp của chúng tôi và ngăn xếp sẽ được đại diện. Một cái gì đó như thế này. Bây giờ ngăn xếp trống vì danh sách trống.

1002
00:01:02,370 --> 00:01:25,110
Bây giờ hãy nói về hoạt động đẩy. Đây là phương pháp đẩy. Được rồi, phương pháp này lấy một dữ liệu tham số bên trong Iraq, tuyển dụng một nút mới. Và sau đó chúng ta sẽ kiểm tra xem điều đó có đúng hay không ngay bây giờ để đi đến nút mới, nếu không phải là NENO thì hãy chuyển đến đầu và ahady đến đơn vị, có thể gọi phương thức này với dữ liệu một sau đó sẽ tạo một nút mới.

1003
00:01:25,350 --> 00:01:38,040
Vì người đứng đầu danh sách ban đầu không chuyển hướng đầu của chúng ta sang điều mới này, nên nhà ngôn ngữ học sẽ được thể hiện như thế này. Và đây là chồng Lenthall của chúng tôi.

1004
00:01:38,250 --> 00:01:52,930
Và ở đây chúng ta có một phần tử trong ngăn xếp và đây sẽ là phần tử hàng đầu của chúng ta. Có thể gọi phương thức này để đẩy nó đến nút, tạo một nút mới với dữ liệu tới và ở đây nó sẽ áp dụng câu lệnh ELT này vì hiện tại không có.

1005
00:01:53,040 --> 00:02:08,060
Vì vậy, ở đây chúng ta sẽ nói phần tiếp theo để trải qua nó. Vì vậy, tiếp theo là sự căm ghét và Hayday Gholston. Vì vậy, nó chỉ ra điều này không chỉ được biểu diễn, những thứ như thế này và ngăn xếp của chúng ta sẽ được biểu diễn, đại loại như thế này.

1006
00:02:08,730 --> 00:02:21,430
Đây chỉ là hình ảnh minh họa trực quan của Stack và đây là Hadnot của chúng tôi, OK, và đây là phần trên cùng của ngăn xếp của chúng tôi. Tôi gọi phương thức này là đẩy bằng ba, sau đó sẽ tạo một nút mới có ba nút.

1007
00:02:22,050 --> 00:02:31,080
Và ở đây chúng tôi sẽ gửi thông tin tiếp theo để đi qua Hatswell được kết nối với nút này và sẽ di chuyển nó trỏ đến nút này. Sau đó tất cả người Anh sẽ được đại diện, đại loại như thế này.

1008
00:02:31,080 --> 00:02:50,310
Và đây là đại diện cho ngăn xếp của chúng tôi. Và họ nói, được rồi, đây là phương pháp đẩy của chúng tôi hoạt động và đây là công nghệ. Đây là một nhà ngôn ngữ học. Nhưng chúng tôi coi đây là một cuộc kiểm tra vì chúng tôi đang chèn dữ liệu của mình lên phía trước và nhà ngôn ngữ học này được thể hiện giống như thế này.

1009
00:02:50,460 --> 00:03:02,830
Và trong kịch bản chúng ta có ba. Phần tử trên cùng bây giờ, nếu chúng ta thực hiện các thao tác chốt ở đây, các thao tác sẽ giữ lại giá trị từ đầu thanh của chúng ta. Ví dụ: nếu đơn giản làm lại dữ liệu có tiêu đề, thì nó sẽ trả về giá trị này.

1010
00:03:03,300 --> 00:03:12,660
Đừng lo lắng về điều đó. Nó sẽ giải thích từng chi tiết. Bây giờ hãy nói về hoạt động pop. Các phương tiện truyền thông tin tức hoạt động tại studio không có tham số nào trong quá trình kiểm tra của bạn.

1011
00:03:12,660 --> 00:03:30,660
Nếu nó biết, bạn sẽ nói Streck để trống nút đầu nhà phát triển in của ELT và chuyển qua đây tới nút tiếp theo. OK, nếu chúng ta gọi phương thức pop, điều gì sẽ xảy ra nên nó sẽ in giá trị ba một và trả về giá trị hoặc chỉ in giá trị mà chúng ta có thể đạt tới và giá trị.

1012
00:03:30,780 --> 00:03:38,280
Những gì chúng tôi chỉ in giá trị ở đây. Đừng lo lắng về điều đó. Nếu bạn muốn trả về giá trị, bạn có thể trả về giá trị. Nhưng chúng tôi chỉ đang in ở đây.

1013
00:03:38,340 --> 00:03:47,580
Ở đây chúng ta sẽ in giá trị của phần đầu của chúng ta, không phải bằng đầu của bạn, không phải tất cả. In ba. Vì vậy, phương pháp này sẽ in ba và chúng ta sẽ chuyển sang nút tiếp theo.

1014
00:03:47,730 --> 00:03:57,560
Vì vậy, nếu chúng ta chuyển sang nút tiếp theo, thì chúng ta sẽ thấy không có gì trỏ đến nút này. Vì vậy, ghi chú này sẽ bị xóa bởi rác được thu thập từ bộ nhớ máy tính của chúng tôi, từ biểu diễn ngăn xếp của chúng tôi.

1015
00:03:57,690 --> 00:04:14,490
Cây giá trị này sẽ bị loại bỏ. OK, danh sách liên kết của chúng tôi sẽ được trình bày. Một cái gì đó như thế này, nếu chúng ta gọi lại vấn đề này, trong trường hợp này, phần đầu mà chúng ta thấy ở đầu ngăn xếp của chúng ta là to và chúng ta sẽ in giá trị của nút hỗ trợ này là hai.

1016
00:04:14,940 --> 00:04:28,320
Vì vậy, nó cũng sẽ in ở đây và nó sẽ chuyển sang nút tiếp theo. Và không có gì chỉ ra điều này. Không phải vậy, ký tự rác sẽ tự động xóa ghi chú này khỏi RAM và ghi chú này sẽ bị xóa khỏi biểu diễn ngăn xếp của chúng tôi.

1017
00:04:28,500 --> 00:04:36,500
Đây chỉ là một đại diện của nhà ngôn ngữ học của chúng tôi. Được rồi, vậy Stegall của chúng ta đã đại diện cho một cái gì đó như thế này. Đây là nhà ngôn ngữ học của chúng tôi và đây là đại diện của chúng tôi.

1018
00:04:36,660 --> 00:04:49,440
Đây là cách chúng ta có thể triển khai Stack bằng cách sử dụng nhà ngôn ngữ học. Nó không khó lắm nhưng nếu bạn hiểu khái niệm, hình phạt này thì chỉ cần thực hiện vì độ phức tạp về thời gian và không gian.

1019
00:04:49,740 --> 00:05:02,320
Và hoạt động này cũng thể hiện sự phức tạp về thời gian và không gian. Chúng ta sẽ hiểu lời
giải thích này trong video tiếp theo mà chúng ta sẽ nói đến. Trống rỗng và được kiểm tra. 

@@@



1020
00:00:00,360 --> 00:00:09,810
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về cách triển khai STAC bằng cách sử dụng nhà ngôn ngữ học và đây là phần thứ hai trong video này.

1021
00:00:09,840 --> 00:00:22,860
Chúng ta sẽ thực hiện ba phương pháp này. Nó trắng tay. Trước tiên hãy nói về đỉnh cao, sau đó chúng ta sẽ nói về nó. Sau đó chúng ta sẽ nói về việc bắt đầu ngay bây giờ, hãy bắt đầu với phương pháp chọn này.

1022
00:00:23,610 --> 00:00:32,700
Vì vậy, trong video này, chúng ta sẽ xem ba phương pháp này. Hãy nói về phương pháp đỉnh cao. Giả sử chúng ta được cung cấp danh sách liên kết này và danh sách liên kết này được thể hiện dưới dạng như thế này.

1023
00:00:33,210 --> 00:00:44,460
Đây là phần tử trên cùng, được chứ? Phương pháp này không có tham số bên trong ở đây hoặc kiểm tra xem nếu bạn thực hiện ngay bây giờ, ngăn xếp bản in có trống không. Nếu không, sẽ in giá trị từ ghi chú của chúng tôi.

1024
00:00:45,030 --> 00:00:55,590
Nếu chúng ta gọi phương thức này, phương thức này sẽ in từ hadnot của chúng ta vì tiêu đề dành cho chúng ta thấy trong ngăn xếp của mình phần tử trên cùng là bốn. Vì vậy, nó in bốn.

1025
00:00:56,280 --> 00:01:21,390
Nếu chúng ta được cung cấp ngăn xếp này và danh sách liên kết này cũng như trực quan hóa danh sách liên kết này tại ngăn xếp, đại loại như thế này, chúng ta gọi phương thức này cho ngăn xếp này, khi đó nó sẽ trả về số ba vì nút trên cao hoặc biến đó rất khó vì giá trị lịch sử của chúng tôi và điều đó có nghĩa là trên đỉnh SEC của chúng tôi, chúng tôi có ba bản in ba.

1026
00:01:22,130 --> 00:01:31,470
Chúng tôi đã hiểu phương pháp đỉnh cao. Phương pháp này sẽ giúp Spiga giải quyết được độ phức tạp về thời gian và không gian. Điều đó có nghĩa là phương pháp này hoạt động trong thời gian không đổi và độ phức tạp không gian không đổi.

1027
00:01:31,770 --> 00:01:55,420
Bây giờ chúng ta hãy nói về trống rỗng. Giải pháp được thực hiện. Phương thức này không có tham số nào trong quá trình kiểm tra của bạn đối với một vùng nếu không phải tất cả sẽ trả về false cho ngăn xếp đã cho này, chúng tôi gọi phương thức này là trống rỗng, tôn giáo là sai vì hiện tại phương thức này không thực hiện vì độ phức tạp về thời gian và không gian là siêu cao dễ.

1028
00:01:55,760 --> 00:02:07,190
Được rồi, bây giờ hãy nói về phương pháp cuối cùng. Hãy cùng kiểm tra điều siêu thú vị này tại đây. Chúng tôi vừa thấy bạn có Sternhell. Vì vậy, thật tốt khi biết toàn bộ liên kết sẽ bị xóa.

1029
00:02:07,210 --> 00:02:19,560
Điều đó có nghĩa là Steckel sẽ bị xóa nếu chúng ta loại bỏ con trỏ này khỏi this. Không có điểm nào để đầu này để bây giờ ghi nhận mà có nghĩa là không có gì cả. Và bây giờ chúng ta thấy rằng không có gì trỏ đến nút này.

1030
00:02:19,560 --> 00:02:28,620
Vì vậy, tỏi để loại bỏ điều này không phải từ REM. Và rồi nút này chúng ta thấy không có gì khác trỏ tới nút này. Vì vậy, điều này sẽ được loại bỏ bởi người thu gom rác.

1031
00:02:28,620 --> 00:02:38,820
Và sau đó ghi chú này không có gì khác chỉ vào điều này, không phải ghi chú này sẽ bị người thu gom rác xóa. Vì vậy, ngăn xếp này cũng sẽ bị xóa vì bản nhạc này là hình ảnh trực quan của tất cả các nhà ngôn ngữ học.

1032
00:02:39,090 --> 00:02:51,270
Vì chúng tôi đang triển khai Steck không phải là nhà ngôn ngữ học nên phương pháp này sẽ khiến Spiga trở nên phức tạp về thời gian và không gian. Chúng tôi đã hiểu chính biểu hiện này. Tôi báo mã nguồn cho mã nguồn trong mã nguồn.

1033
00:02:51,270 --> 00:03:00,210
Chúng tôi đã thực hiện tất cả các phương pháp của chúng tôi. Nếu chúng tôi gặp khó khăn khi hiểu điều
này, hãy giải thích và cho chúng tôi biết. Cảm ơn đã xem. Tôi sẽ gặp bạn trong video tiếp theo. 

@@@



1034
00:00:00,360 --> 00:00:20,270
Bạn được cung cấp một chuỗi chỉ chứa các ký tự, dấu ngoặc này, bạn có phiền nếu chuỗi đầu vào hợp lệ và dữ liệu nhập vào hợp lệ hay không, nếu dấu ngoặc mở phải được đóng bằng cùng loại dấu ngoặc và dấu ngoặc mở phải được đóng theo đúng thứ tự ?

1035
00:00:20,490 --> 00:00:33,900
Không phải một chuỗi trống cũng được coi là hợp lệ. Nếu chúng ta nhập tổ hợp dấu ngoặc này thì chương trình sẽ trả về. Đúng, bởi vì đây là một điểm hợp lệ, phải không?

1036
00:00:34,200 --> 00:00:48,510
Nếu chúng ta có sự kết hợp của các dấu ngoặc này thì chúng ta nên quay lại. Đúng, vì đây là sự kết hợp hợp lệ. Nếu chúng ta có thông tin nhập như thế này thì chúng ta sẽ trả về false vì đây là định dạng không hợp lệ.

1037
00:00:48,730 --> 00:01:00,180
Bây giờ hãy xem giải pháp của tôi bằng mã giả. Được rồi. Bây giờ hãy xem giải pháp của tôi trông như thế nào. Để dễ hiểu, hãy giả sử đây là chuỗi đầu vào của chúng tôi.

1038
00:01:00,360 --> 00:01:12,930
Đầu tiên mình sẽ lặp qua chuỗi này từ trái sang phải ở đây chúng ta sẽ có một bảng băm ánh xạ dấu ngoặc đóng tới dấu ngoặc mở tương ứng.

1039
00:01:13,170 --> 00:01:27,490
Và chúng tôi cũng có một ngăn xếp ở đây và ở đây. Tôi có thuật toán cho giải pháp. Bây giờ hãy xem thuật toán này hoạt động như thế nào. Được rồi, ở đây dành cho AI từ 0 đến một đầu vào trừ một.

1040
00:01:28,110 --> 00:01:46,500
Vậy với chuỗi này, bạn làm việc từ 0 đến 3, phải không? Bởi vì đầu vào này là bốn bốn. Một là ba. Đối với lần lặp lại đầu tiên của tình yêu này, giá trị của I bằng 0 đối với giá trị, tức là gần bằng 0.

1041
00:01:46,620 --> 00:02:01,470
Nó trỏ đến dấu ngoặc này trong chuỗi. Phải. Và ở đây chúng tôi có điều kiện. Nếu Hasdrubal không chứa khóa đầu vào, tôi sẽ trỏ đến ký tự đầu tiên này trong chuỗi này và có dấu ngoặc này.

1042
00:02:01,920 --> 00:02:14,920
Ký tự này có phải là ASCII không. Không, nó không tồn tại. Khi đó điều kiện này sẽ sai. Được rồi, bạn nhấn vào đây để kiểm tra ký tự này.

1043
00:02:14,970 --> 00:02:29,140
Được rồi, chúng ta có nhân vật này cho phiên bản AI tiếp theo. Giá trị sẽ là một. Khi ta có bằng 1 thì nó sẽ trỏ đến dấu ngoặc này trong chuỗi có ý chí chứa key import AI.

1044
00:02:29,220 --> 00:02:42,360
Và điều đó có nghĩa là nhân vật này thực hiện dấu ngoặc mở đầu này ngay trong đầu chúng ta. Tobolowsky Không, nó không tồn tại. Sau đó nó sẽ đẩy vào ngăn xếp cho lần lặp tiếp theo.

1045
00:02:42,360 --> 00:02:54,440
Giá trị của tôi cũng sẽ như vậy. Vì vậy, trong thời gian này nó trỏ đến dấu ngoặc này. Dấu ngoặc đóng này có một bảng chứa dấu ngoặc này. Có khung này. Nó chỉ có mức độ ổn định thôi.

1046
00:02:54,720 --> 00:03:10,740
Vâng, nó có. Vì vậy, nó bật ra bất cứ thứ gì chúng ta có trong ngăn xếp và nó được lưu trữ trong biến, bật hàm pop này, xóa phần tử khỏi ngăn xếp khỏi ngăn xếp của chúng ta và nó trả về giá trị đó.

1047
00:03:11,100 --> 00:03:23,360
Và ở đây chúng ta gọi dấu ngoặc này và bạn sẽ lấy hiện trong trường hợp này, dấu ngoặc này không bằng bảng băm. Không nhận được đầu vào. Charite tôi nhập nó.

1048
00:03:23,370 --> 00:03:36,540
Tôi chính là khung này mà chúng ta có trong bảng nhà và giá trị so với khung này. Chúng tôi có khung mở đầu này. Vì vậy, dấu ngoặc này và dấu ngoặc này khớp nhau nên nó sẽ không trả về sai.

1049
00:03:36,750 --> 00:03:53,130
Bây giờ ở lần lặp tiếp theo, giá trị của I sẽ là ba và nó trỏ đến dấu ngoặc cộng này và dấu ngoặc này. Nó chỉ có bảng. Vì vậy, nó sẽ bật ra dấu ngoặc này từ ngăn xếp này và nó sẽ được lưu trữ trong biến này.

1050
00:03:53,430 --> 00:04:09,000
Bây giờ chúng ta đã thực sự gần với khung này và ở đây chúng ta sẽ lấy không pop không bằng phải lấy đầu vào từ thiện. Vì vậy, nó sẽ trỏ đến đầu vào này và bất cứ thứ gì chúng ta có, nó đều phải chống lại điều này.

1051
00:04:09,300 --> 00:04:22,650
Chúng tôi có ở đây khung này. Phải. Và dấu ngoặc này và dấu pop bằng nhau. Vì vậy, nó sai thì nó sẽ không quay trở lại. Và bây giờ quá trình lặp lại kết thúc và chúng ta có ngăn xếp trống của bạn.

1052
00:04:22,860 --> 00:04:35,250
Nếu chúng ta có ngăn xếp trống sau tất cả các lần lặp, điều đó có nghĩa đây là dấu ngoặc đơn hợp lệ. Vì vậy, chúng ta sẽ trả về giá trị trống tiêu chuẩn. Nếu chúng ta có một ngăn xếp trống thì nó sẽ trả về.

1053
00:04:35,250 --> 00:04:59,340
ĐÚNG VẬY. Vì vậy, đối với hàm này, nó sẽ trả về đúng cho chuỗi đầu vào này. Điều này sẽ trở lại đúng. Được rồi. Bởi vì chúng tôi có ngăn xếp trống ở cuối và giải pháp có độ phức tạp về thời gian lớn hơn vì bạn phải truy cập vào ký tự trên màn hình sau khi giải pháp chiếm độ phức tạp về không gian.

1054
00:04:59,990 --> 00:05:13,310
Cuối cùng, cô ấy là độ dài của chuỗi đã cho trong trường hợp xấu nhất mà chúng ta có thể có trong một số phần
tử trong ngăn xếp của mình. Cho nên không gian phức tạp vì trong vọng niệm, khái niệm này không rõ ràng. 

@@@



1055
00:00:00,450 --> 00:00:09,960
Này, bạn muốn vài người hay quay lại video này trong video này, chúng ta sẽ nói về chuỗi vấn đề ghi âm cuộc phỏng vấn. Đây là một vấn đề công nghệ.

1056
00:00:10,380 --> 00:00:20,940
Trong vấn đề này, bạn được cung cấp một chuỗi. Chuỗi được mã hóa chuỗi. Bạn phải giải mã chuỗi đó. Làm thế nào nó nên được gọi là chuỗi? Ở đây chúng tôi có ba.

1057
00:00:20,940 --> 00:00:33,720
Vậy thì chúng ta phải lặp lại điều này ở đây ba lần. Bạn sẽ lặp lại điều này ba lần. Không nhận được ba A.. Sau đó, chúng tôi phải và sau đó là khung dự định của bạn.

1058
00:00:33,720 --> 00:00:47,310
Chúng ta có B C ở đây. Chúng tôi phải lặp lại Besi hai lần. Nếu chúng ta lặp lại nó hai lần thì chuỗi sẽ được biểu diễn như thế này. Đây là chuỗi được mã hóa của chúng tôi và nó sẽ giải mã chuỗi này.

1059
00:00:47,310 --> 00:01:01,530
Vì vậy, chúng tôi nhận được những chuỗi này. Vì vậy, đối với đầu vào này, chúng ta phải trả về các chuỗi này. Ví dụ: nếu bạn được cung cấp các chuỗi này, trước tiên chúng tôi phải giải mã chuỗi được mã hóa quyết định của quận.

1060
00:01:01,530 --> 00:01:15,810
Việc đầu tiên phải làm là gì? Chúng ta phải lặp lại điều này hai lần. Chúng tôi lặp lại điều này trên toàn thành phố. Chúng ta có một cái gì đó giống như chữ C kép này và ở bên trái của Toussie, chúng ta có một chữ C nên hãy chèn vào đây.

1061
00:01:16,650 --> 00:01:29,490
Bây giờ chúng ta phải lặp lại S.E.C. Ba lần. Nếu chúng ta lặp lại S.E.C. Ba lần thì chuỗi sẽ được biểu diễn, đại loại như thế này. Vậy đây là chuỗi được mã hóa và đây là chuỗi được giải mã.

1062
00:01:29,730 --> 00:01:42,690
Đối với chuỗi được mã hóa đã cho này, chúng ta phải trả về chuỗi đã giải mã này. Ví dụ, nếu được cho chuỗi này, chúng ta phải giải mã chuỗi này. Chuyến đi đầu tiên đến chúng tôi có ABC.

1063
00:01:43,110 --> 00:01:55,310
Không có recist lồng nhau nên chúng ta không phải lo lắng về điều đó ở đây. Chúng ta phải lặp lại ABC đến ITP, đến ABC đến tối nay, rồi chúng ta có ABC, ABC, rồi chúng ta có ba KDDI.

1064
00:01:56,250 --> 00:02:11,130
Vì vậy chúng ta phải lặp lại Sidhe ba lần. Vì vậy, Thành phố, thành phố, thành phố. Sau đó chúng ta có chuỗi EAF này. Vì vậy, hãy chèn F vào đây để đây là toàn bộ chuỗi được mã hóa và đây là chuỗi được giải mã của bạn.

1065
00:02:11,340 --> 00:02:24,480
Bạn được cấp lại chuỗi này để trả về chuỗi này. Chúng ta đã hiểu được cách giải mã chuỗi đã cho trong bài toán này. Bạn có thể cho rằng chuỗi đã cho là không hợp lệ.

1066
00:02:25,350 --> 00:02:38,850
Bây giờ cách chúng ta có thể tiếp cận vấn đề này khi bạn gặp phải vấn đề trong ngoặc đơn mà chúng ta thường sử dụng là kiểm tra. Vâng, đây là một bài toán để giải quyết bài toán này chúng ta phải sử dụng để xếp chồng.

1067
00:02:39,600 --> 00:03:02,520
Một cái được gọi là chống dính và một cái khác được gọi là xếp chồng chuỗi. Hãy xem làm thế nào có thể giải quyết vấn đề này bằng cách sử dụng hai ngăn xếp. Cả hai đã được cấp những chuỗi này và chúng tôi vẫn chưa dính vào, không có chuỗi và chuỗi dính, và chúng tôi cần khởi động lại trình tạo chuỗi và nó biến một biến và lặp qua chuỗi từ trái sang phải.

1068
00:03:02,890 --> 00:03:21,320
Ký tự đầu tiên trong chuỗi là một cái cây. Cây này nằm trong một sợi dây. Cho nên một ba nhẫn, ba là một nhân vật. Cuối cùng khi nó làm được điều đó, nó sẽ thích thú tìm hiểu xem điều đó làm được điều đó, nếu đúng như vậy, nếu đúng như vậy thì nó lớn hơn chín.

1069
00:03:21,680 --> 00:03:33,390
Được rồi, vì ở đây chúng ta chỉ có một số, ba. Vì vậy, hãy chèn ba vào số của chúng tôi. Và hãy chuyển sang nhân vật tiếp theo. Ký tự tiếp theo là dấu ngoặc mở.

1070
00:03:33,630 --> 00:03:46,290
Khi bạn tìm thấy nó mở ngoặc, điều chúng ta sắp làm là chèn bất cứ thứ gì chúng ta có trong biến trình tạo của mình vào ngăn xếp chuỗi. Chúng tôi có chuỗi trống của chúng tôi.

1071
00:03:46,290 --> 00:03:56,310
Vì vậy, chúng tôi đã chèn ngành vào đây và tất cả đều đặt trình tạo chuỗi thành chuỗi trống, trình tạo chuỗi đã có chuỗi trống. Vì vậy, không cần phải làm gì ở đây.

1072
00:03:57,600 --> 00:04:09,960
Bây giờ, chúng ta hãy chuyển sang ký tự tiếp theo, ký tự tiếp theo là bất cứ khi nào anh ấy tìm thấy một ký tự bằng tiếng Anh, tất cả đều như vậy, chúng ta sẽ làm gì? Chúng ta sẽ chèn ký tự đó vào Sting Builder.

1073
00:04:10,080 --> 00:04:27,150
Sau đó, hãy chuyển sang ký tự tiếp theo, ký tự tiếp theo mà chúng ta thấy dấu ngoặc đóng bất cứ khi nào chúng ta tìm thấy dấu ngoặc đóng sẽ bật ra phần tử trên cùng từ ngăn xếp chuỗi, trong trường hợp này là trong chuỗi và đoạn văn, tất cả được gán cho biến tạm thời mà chúng ta có ở đây trong sợi dây.

1074
00:04:27,150 --> 00:04:36,300
Vì vậy, hãy coi chuỗi trống này là chính xác. Giả sử biến này chuyển sang biến thứ 10 vì biến tạm thời này đã là chuỗi trống. Vì vậy, không cần phải làm gì ở đây.

1075
00:04:36,390 --> 00:04:47,040
Bây giờ, điều tiếp theo chúng ta sẽ làm, chúng ta sẽ lấy ra phần tử hàng đầu từ trong nước, và đó là ba. Bây giờ, hãy lặp lại những gì chúng ta có ở Steam Builder hai lần.

1076
00:04:47,040 --> 00:05:06,630
Nếu chúng ta lặp lại nó ba lần bằng cách sử dụng Loof và chúng ta sẽ chèn nó vào biến tạm thời của mình và chúng ta sẽ sử dụng nó. Được rồi, vậy nếu chúng ta lặp lại nó ba lần và nó xảy ra ba, tám lần cho đến biến thời gian này, thì chúng ta sẽ nhận được kết quả như thế này, khi đó chúng ta sẽ thay đổi trình tạo chuỗi bằng biến tạm thời.

1077
00:05:06,810 --> 00:05:19,100
Vì vậy, trình xây dựng ghi lại mọi người và bản ghi tạm thời thành chuỗi trống và tạm thời sẽ được đặt lại thành chuỗi trống vì chúng ta sẽ sử dụng biến tạm thời này trong mỗi câu lệnh.

1078
00:05:19,140 --> 00:05:30,210
Vì vậy, biến tạm thời này là biến tạm thời sẽ mất giá trị khi chúng ta chuyển sang lần lặp tiếp theo. Chúng ta sẽ xem khi nào chúng ta sẽ xem qua mã giả của mình. Sau đó, nhân vật tiếp theo của chúng tôi.

1079
00:05:30,420 --> 00:05:40,920
Ký tự tiếp theo là một chữ số. Vì vậy, hãy chèn hai vào trong nước của chúng tôi. Sau đó hãy chuyển sang nhân vật tiếp theo. Ký tự tiếp theo là dấu ngoặc mở. Bất cứ khi nào chúng tôi tìm thấy dấu ngoặc mở.

1080
00:05:41,100 --> 00:05:53,220
Bạn định làm gì? Chúng ta sẽ chèn bất cứ thứ gì chúng ta có ở biến Steenbergen vào chuỗi. Vì vậy, chúng tôi sẽ chèn một chuỗi chuỗi dài hai giờ và sẽ đứng yên.

1081
00:05:53,220 --> 00:06:05,360
Chúng ta cần làm trống chuỗi. Bây giờ chúng ta hãy chuyển sang nhân vật tiếp theo. Ký tự tiếp theo là bảng chữ cái tiếng Anh. Vì vậy, hãy chèn B vào trình tạo chuỗi của chúng ta và chúng ta sẽ trở thành Torstein Builder.

1082
00:06:05,520 --> 00:06:16,350
Ký tự tiếp theo là C, C, C là bảng chữ cái tiếng Anh. Vì vậy, hãy chèn C vào công cụ xây dựng quý giá của chúng ta. Bây giờ hãy chuyển sang nhân vật tiếp theo. Ký tự tiếp theo là dấu ngoặc đóng.

1083
00:06:16,490 --> 00:06:28,830
Bất cứ điều gì anh ấy tìm thấy, đóng khung. Những gì chúng ta sắp làm, chúng ta sẽ lấy ra phần tử trên cùng từ ngăn xếp chuỗi trong trường hợp này với giá rẻ. Và chúng ta sẽ gán yếu tố làm tê liệt này cho biến thứ mười.

1084
00:06:29,130 --> 00:06:41,040
Sau đó, điều tiếp theo, chúng ta sẽ điền phần tử trên cùng từ lớp chống dính trong trường hợp thứ hai này. Và chúng ta sẽ lặp lại bất cứ điều gì chúng ta có khi bắt đầu biến Veldon hai lần bằng Aluf.

1085
00:06:41,250 --> 00:06:56,610
Và chúng tôi sẽ bổ nhiệm Besi bằng cách lặp lại hai lần với vị trí tạm thời có sẵn này. Vì thế nó sẽ được thể hiện như thế này, bận rộn, bận rộn. Bây giờ chúng ta sẽ thay đổi hoặc thay đổi biến đơn này bằng cách sử dụng biến tạm thời này.

1086
00:06:56,700 --> 00:07:09,120
Vì vậy, chúng ta sẽ duyệt qua Bekesi và sẽ mất giá trị này cho biến tạm thời vì đây là biến tạm thời vì bạn đang sử dụng biến này trong một câu lệnh.

1087
00:07:09,510 --> 00:07:18,270
Khi chúng tôi thực hiện xong các bước lặp hiện tại, chúng tôi sẽ mất giá trị. Được rồi, Tempy sẽ trống rỗng. Sau đó, ở lần lặp tiếp theo, chúng ta sẽ vượt ra khỏi ranh giới ban đầu.

1088
00:07:18,390 --> 00:07:32,010
Vậy là chúng ta đã hoàn tất. Bây giờ chúng ta sẽ làm gì? Chúng tôi sẽ chuyển đổi hoặc trình tạo chuỗi thành chuỗi và sẽ quay lại lần này. Câu trả lời của chúng ta cho chuỗi đã cho này là chuỗi Sepehr, với chuỗi trả về này, chuỗi này.

1089
00:07:32,400 --> 00:07:43,620
Bây giờ, hãy lấy một ví dụ khác để hiểu rõ hơn. Bây giờ, giả sử chúng ta được cấp chuỗi này. Chúng tôi phải kiểm tra và ở đây chúng tôi có hai biến, trình tạo chuỗi và tạm thời.

1090
00:07:43,620 --> 00:07:53,250
Vì vậy, hãy lặp qua chuỗi từ trái sang phải. Đầu tiên, chúng ta có ký tự ba ba chữ số. Vì vậy, hãy chèn ba cái vào chảo chống dính của chúng ta. Đây là một chữ số.

1091
00:07:53,730 --> 00:08:04,380
Nếu chúng ta có mức thâm hụt lớn hơn chín, chúng ta sẽ chạy đủ để có được số và số trong một chiếc chảo chống dính nhất định vì ba, một chữ số.

1092
00:08:04,470 --> 00:08:19,950
Vậy chúng ta hãy theo hướng không dính trong ba, sau đó chúng ta hãy chuyển sang anh chàng tiếp theo để nhân vật tiếp theo là mở dấu ngoặc mỗi khi anh ta tìm thấy dấu ngoặc mở. Những gì chúng tôi sẽ làm là chèn B hai séc trượt tuyết và nó sẽ nằm khi chúng tôi thực hiện chuỗi trống.

1093
00:08:20,070 --> 00:08:30,060
Vì vậy, hãy chèn chuỗi trống vào đây vì chúng ta có chuỗi trống và tất cả được đặt theo thuật ngữ của chúng ta, vì chúng ta có khi đi qua MDT, không cần phải làm gì ở đây.

1094
00:08:30,270 --> 00:08:39,120
Bây giờ chúng ta hãy đi đến nhân vật tiếp theo. Ký tự tiếp theo là a là bảng chữ cái tiếng Anh. Vì vậy, hãy chèn trình tạo Torstein, sau đó chuyển sang ký tự tiếp theo.

1095
00:08:39,120 --> 00:08:48,030
Ký tự tiếp theo là hai, hai là sa mạc. Vì vậy, hãy chèn hai cái vào thanh nom của chúng ta. Không, hãy chuyển sang nhân vật tiếp theo. Ký tự tiếp theo là dấu ngoặc mở.

1096
00:08:48,270 --> 00:09:02,500
Khi tìm thấy dấu ngoặc mở, chúng ta sẽ làm gì? Chúng ta sẽ chèn bất cứ thứ gì chúng ta có vào chuỗi STAC. Vì vậy, hãy chèn cái này vào màn hình này và chúng ta hãy ngồi khi chúng ta thực hiện chuỗi trống.

1097
00:09:02,760 --> 00:09:11,700
Bây giờ chúng ta chuyển sang nhân vật tiếp theo, mùa nhân vật tiếp theo. Hãy thêm see vào trình tạo hơi nước của chúng ta, sau đó là ký tự tiếp theo. Ký tự tiếp theo gây ra dấu ngoặc.

1098
00:09:11,850 --> 00:09:26,000
Khả năng chiến thắng được tìm thấy trong khung kết thúc. Những gì sẽ làm sẽ loại bỏ phần tử trên cùng khỏi ngăn xếp chuỗi và nó sẽ gán phần tử đó cho biến thứ 10. Vì vậy, hãy lấy không khí này ra khỏi ngăn xếp chuỗi này và gửi nó đến biến tạm thời này.

1099
00:09:26,130 --> 00:09:40,140
Điều tiếp theo chúng ta phải làm, chúng ta phải điền phần tử trên cùng từ lớp chống dính, và điều đó đúng. Vì vậy, hãy bật ra và lặp lại bất cứ điều gì chúng ta có tại Stringbean hai lần bằng cách sử dụng Aluf.

1100
00:09:40,140 --> 00:09:51,300
Nếu chúng ta lặp lại hai lần, chúng ta sẽ nhận được CESI và hãy thêm Sissi vào biến tạm thời này. Vậy là S.E.C. Bây giờ hãy đặt biến thời gian này cho trình tạo chuỗi.

1101
00:09:51,480 --> 00:10:03,270
Vậy String Builder bằng hai giây.E.C. Và vì đây là biến tạm thời nên mất giá trị này. Bây giờ hãy chuyển sang nhân vật tiếp theo. Ký tự tiếp theo là dấu ngoặc đóng.

1102
00:10:03,570 --> 00:10:13,570
Khi dấu ngoặc đóng loại bỏ phần tử trên cùng khỏi ngăn xếp bắt đầu và gán giá trị đó cho biến số 10, chúng ta có một chuỗi trống. Vậy hãy đặt thứ này vào.

1103
00:10:13,590 --> 00:10:23,730
Hãy gửi nó tới biến tạm thời, biến tạm thời đã có trong chuỗi. Vì vậy, không cần phải làm gì ở đây. Rồi điều tiếp theo lên đến cấp cao nhất từ ​​trong nước có ba.

1104
00:10:24,120 --> 00:10:35,370
Và hãy nhắc lại, những gì chúng ta có sẵn có sẵn ba lần. Nếu lặp lại ba lần, chúng ta sẽ nhận được SC, SC và hãy thêm danh tiếng đó cho biến tiêu chuẩn này.

1105
00:10:35,580 --> 00:10:51,410
Vì vậy, chúng tôi nhận được s.E.C SC, SC và hãy đặt biến thời gian này thành vẫn có sẵn để chúng tôi có được hơi nước. Đối với SC SC, vì temp là một biến tạm thời nên nó sẽ mất biến temp phát triển trong lần lặp tiếp theo.

1106
00:10:51,600 --> 00:11:03,830
Bây giờ hãy chuyển sang ký tự tiếp theo và chúng ta thấy rằng chúng ta đã vượt ra ngoài ranh giới chuỗi. Vì vậy, chúng tôi đã hoàn thành bây giờ. Chúng ta sẽ làm gì? Chúng tôi sẽ chuyển đổi trình tạo chuỗi này thành chuỗi và chúng tôi sẽ trả về quyết định chuỗi này.

1107
00:11:03,870 --> 00:11:23,670
Chúng ta có thể giải quyết vấn đề này. Giải pháp chỉ đạt được hiệu quả lớn hơn về thời gian, độ phức tạp, đồng bộ, bất kể chuỗi đã cho từ trái sang phải một lần. Và tất cả diễn ra phức tạp về mặt không gian vì bạn phải xây dựng để ngăn xếp num stack vẫn dính.

1108
00:11:23,670 --> 00:11:38,910
Ngoài ra còn có trình tạo chuỗi và biến tạm thời. Trên thực tế đối với đứa trẻ đầu tiên, nó có thể phức tạp hơn về thời gian ở nước ngoài. Trên thực tế, đối với đứa trẻ đầu tiên, độ phức tạp của không gian có thể là bốn và tương đương với Big Ofin vì bốn là một hằng số.

1109
00:11:39,000 --> 00:11:54,930
Chúng ta có thể bỏ qua hằng số về độ phức tạp. Phân tích nó. Bây giờ chúng ta hãy xem mã giả năm nay để tòa án giải quyết vấn đề này. Ta có hàm này gọi là xâu chuỗi, lấy chuỗi trong tạo lại để xếp naoum stack và vẫn xếp chồng mới cắt một chuỗi tạo biến.

1110
00:11:55,200 --> 00:12:07,410
Sau đó, chúng tôi đang tính toán độ dài của chuỗi đã cho. Sau đó, chúng tôi đang chạy một chút để tôi từ số 0 cho vay trừ một bên trong bạn. Chúng tôi đang lấy ký tự hiện tại và chúng tôi đang lấy ký tự hiện tại Indesit.

1111
00:12:07,680 --> 00:12:24,480
Sau đó, chúng tôi nhận được số bằng cách trừ giá trị ASCII dựa trên, chặn giá trị ASCII bằng 0 khỏi chữ số hiện tại của chúng tôi, sau đó chúng tôi đang chạy. Aluf, nếu số của chúng ta lớn hơn mười thì chúng ta phải lấy số đó và hoặc chèn số đó vào số.

1112
00:12:24,480 --> 00:12:37,980
Lấy ký tự hiện tại của bạn là dấu ngoặc mở. Sau đó, chúng ta sẽ chuyển đổi trình tạo chuỗi. Hấp dẫn. Và chúng tôi sẽ chèn nó vào phần kiểm tra chuỗi của mình và chúng tôi sẽ đặt trình tạo chuỗi thành chuỗi trống.

1113
00:12:38,250 --> 00:12:49,800
Khó nắm bắt. Nếu chúng ta thấy ký tự hiện tại của mình đang đóng dấu ngoặc thì chúng ta sẽ điền phần tử trên cùng từ NUM cổ phần của mình và sau đó chúng ta sẽ điền phần tử trên cùng từ chuỗi của mình và chúng ta sẽ tạo một trình tạo hơi nước mới.

1114
00:12:49,920 --> 00:13:02,220
Và ở đây temp là trình tạo chuỗi tạm thời. Và chúng tôi đang chạy theo niềm đam mê của mình để lặp lại trình tạo chuỗi, lặp lại nhiều lần và chúng tôi đang lập kỷ lục Stingley lên hàng chục.

1115
00:13:02,550 --> 00:13:11,340
Nếu không, chúng tôi đã tìm thấy ký tự hiện tại của mình trong bảng chữ cái tiếng Anh. Chúng ta sẽ chỉ định nhân vật đó vào trình tạo chuỗi. Cuối cùng. Nó sẽ chuyển đổi trình tạo chuỗi của chúng tôi.

1116
00:13:11,640 --> 00:13:25,560
Trong trường hợp này, nó phải là trình tạo chuỗi chứ không chỉ là trình tạo chuỗi của chúng tôi thành chuỗi và sẽ trả về chuỗi đó. Và đây là cách nó hoạt động. Giải pháp sẽ giúp Spiga vượt qua độ phức tạp về thời gian và chúng ta sẽ vượt qua độ phức tạp của không gian.

1117
00:13:25,740 --> 00:13:36,360
Trong trường hợp xấu nhất, Spiga có thể có độ phức tạp không gian nước ngoài tương đương với mức độ phức tạp trong khu vực này. Tôi vẫn ở trong cánh cửa này, vẫn bám vào sợi dây đã định.

1118
00:13:36,360 --> 00:13:50,370
Và ở đây chúng tôi có một trình tạo giao diện và chúng tôi có khung hình đầu tiên biến thứ mười của bạn hay không? Vì vậy, hãy chèn báo chí sau đó chúng tôi có dấu ngoặc mở đầu, chỉ bạn có dấu ngoặc mở sẽ chèn bất cứ thứ gì chúng tôi có tương tự như ngăn xếp bắt đầu của chúng tôi.

1119
00:13:50,370 --> 00:14:08,970
Chúng tôi có sản phẩm nào. Vì vậy, hãy chèn cái trống của bạn và hãy đặt Bellata trống và cái đó đã trống. Nhân vật độc ác liên bang đối với người xây dựng nhóm khung kết thúc và khung kết thúc sẽ hỗ trợ việc ngồi ở 10 timbrell có thể ghi hàng đầu đã trống.

1120
00:14:09,240 --> 00:14:18,460
Bây giờ, hãy lấy phần tử hàng đầu từ Nomsa ra. Đó là sự thật. Và hãy lặp lại nó cho đúng. Nếu chúng ta lặp lại điều đó tối nay, nếu chúng ta cộng nó vào các biến số của nhóm, chúng ta sẽ đạt gần 80.

1121
00:14:18,720 --> 00:14:30,660
Và đó là những gì chúng tôi đang làm. Sử dụng phần dự phòng này, chúng ta sẽ đặt nhiệt độ này cho máy tạo hơi nước này, được chứ? Và đó là những gì chúng tôi đang làm ở đây. Và nó sẽ mất biến đã phát triển khi bạn chuyển sang lần lặp tiếp theo.

1122
00:14:30,960 --> 00:14:46,470
Vì bạn đang khai báo biến này bên trong câu lệnh nâng cao này, nên chúng tôi mong muốn Siletz đối với các con số của chúng tôi. Sau đó, chúng tôi sẽ mở dấu ngoặc khi tìm thấy dấu ngoặc mở hoặc các chữ cái chuyển đổi và sẽ thêm nó vào ngăn xếp hiện có của chúng tôi.

1123
00:14:46,800 --> 00:15:00,390
Vậy đó là bên trong đây. Và hãy thêm nó vào chuỗi trống. Sau đó, chúng ta có C, vậy hãy thêm C vào trình tạo chuỗi của chúng ta. Sau đó chúng ta có một dấu ngoặc đóng. Khi bạn có dấu ngoặc đóng sẽ bật ra một vài Steck thú vị và sẽ thêm nó vào biến nhóm của chúng tôi.

1124
00:15:00,540 --> 00:15:14,070
Vì vậy, hãy cộng E và A ở đây và đó là những gì chúng ta đang làm ở đây, sẽ làm nổi bật phần tử trên cùng và chúng ta sẽ thêm phần tử đó vào biến số 10. Sau đó, chúng ta sẽ lấy ra phần tử hàng đầu từ trong nước và chúng ta sẽ lặp lại C hai lần, C hai lần.

1125
00:15:14,070 --> 00:15:28,440
Và nếu chúng ta thêm điều đó vào nhiệt độ của mình, chúng ta sẽ nhận được điều đang xảy ra ở đây. Được rồi, sử dụng câu lệnh này, Tim, điều đã xảy ra là B và sau đó chúng ta sẽ đặt các nhiệt độ này thành biến B để chúng ta nhận được s.E.C.

1126
00:15:28,710 --> 00:15:40,500
Và chúng ta mất giá trị của biến thời gian này. Vì vậy, hãy loại bỏ nó trong lần lặp tiếp theo sẽ di chuyển ra ngoài ranh giới chuỗi. Vậy là chúng ta đã hoàn tất và sau đó chúng ta sẽ chuyển tòa nhà này thành chuỗi và nó sẽ trả về chuỗi.

1127
00:15:40,650 --> 00:15:50,250
Vì vậy, đối với đầu vào đã cho này, chúng ta phải trả về chuỗi này. Đây là cách chúng ta có thể giải
quyết vấn đề này nếu chúng ta hiểu rõ video này. Giải thích về mã nguồn được đính kèm với video này. 

@@@



1128
00:00:00,660 --> 00:00:15,090
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng ta sẽ nói về cấu trúc dữ liệu hàng đợi. Hàng đợi là cấu trúc dữ liệu trừu tượng tương tự như ngăn xếp và giống như hàng đợi ngăn xếp mở ở cuối.

1129
00:00:15,540 --> 00:00:30,710
Một đầu là tất cả các nhà nghiên cứu thường sử dụng để tìm kiếm dữ liệu và đầu còn lại được sử dụng để loại bỏ dữ liệu. Việc chèn dữ liệu vào hàng đợi được gọi là in queue và xóa dữ liệu khỏi hàng đợi được gọi là dequeue.

1130
00:00:31,110 --> 00:00:47,610
Ở đây chúng tôi có một số người đang đứng xếp hàng. Giả sử họ đang xếp hàng và muốn đặt vé. Người đầu tiên đến hàng này trước sẽ nhận được vé trước.

1131
00:00:47,820 --> 00:01:02,360
Đầu tiên người này sẽ lấy vé, sau đó người này sẽ lấy vé rồi người này sẽ lấy vé, v.v. Nếu chúng ta muốn thêm một người mới thì người đó phải đứng ở cuối dòng này.

1132
00:01:02,370 --> 00:01:13,590
Vì vậy, ngay tại đây và ở đây, chúng ta thấy người đầu tiên sẽ nhận được vé. Vì vậy, hàng đợi vào trước ra trước và cấu trúc dữ liệu hoạt động theo nguyên tắc vào trước ra trước.

1133
00:01:13,800 --> 00:01:24,810
Người nào đến trước sẽ được ra trước. OK ở dòng này chúng ta thấy người này đến trước nên người này sẽ lấy vé trước từ quầy bán vé.

1134
00:01:24,960 --> 00:01:43,530
Vì vậy đây được gọi là nguyên tắc FIPA. Vào trước, ra trước. Việc chèn dữ liệu được gọi vào hàng đợi và việc xóa mảng được gọi là dequeue. Nếu muốn thêm người mới vào hàng này thì người đó phải đứng cuối và người đứng trước sẽ nhận được vé.

1135
00:01:43,950 --> 00:01:56,580
Đây được gọi là Nguyên tắc FEBA và đây là toàn bộ khái niệm về cấu trúc dữ liệu hàng đợi. Bây giờ hãy nói về hoạt động trong hàng đợi. Đang xếp hàng. Thao tác này sẽ thêm một phần tử vào cuối hàng đợi.

1136
00:01:56,760 --> 00:02:12,520
Dequeue bạn xóa một phần tử khỏi phía trước hàng đợi trống. Nó sẽ kiểm tra xem anh ta có trống trong spool không. Nó sẽ kiểm tra xem hàng đợi đã đầy chưa. Nó sẽ lấy giá trị của phần tử từ phía trước mà không cần loại bỏ nó.

1137
00:02:13,110 --> 00:02:29,910
Và đây là những hoạt động phổ biến trong hàng đợi. Có thể làm nước hoa. Điều đó thật đơn giản với hàng đợi này và chúng tôi đã chèn nó vào dễ thương này bằng cách sử dụng cái này để chế nhạo nó, nó sẽ loại bỏ phần tử khỏi phía trước và nó sẽ giữ lại phần tử đó.

1138
00:02:30,210 --> 00:02:41,220
Nếu chúng tôi thực hiện thao tác này, nó sẽ kiểm tra. Nếu hàng đợi trống thì sẽ quay về hàng đợi không trống thì sẽ quay lại. Sai đầy trong cái này get nó sẽ trả về.

1139
00:02:41,490 --> 00:02:53,520
Đúng trong hàng đợi đã đầy. Nếu hàng đợi không đầy, thao tác này sẽ trả về sai. Thao tác này sẽ trả về phần tử từ phía trước mà không loại bỏ phần tử phía trước.

1140
00:02:54,270 --> 00:03:09,970
Bây giờ hãy nói về ứng dụng của hàng đợi. Chúng tôi sử dụng Q để lập lịch cho CPU khi dữ liệu được truyền không đồng bộ giữa hai tiến trình, Q được sử dụng để đồng bộ hóa.

1141
00:03:09,980 --> 00:03:26,350
Ví dụ: tôi có bốn ống, tệp, Faleiro, v.v. để xử lý sự gián đoạn trong hệ thống thời gian thực. Chúng tôi sử dụng Q trong hệ thống điện thoại của trung tâm cuộc gọi, sử dụng tín hiệu để giữ mọi người gọi cho họ theo thứ tự.

1142
00:03:27,270 --> 00:03:44,120
Đây là ứng dụng của Q. Chúng tôi đã hiểu cấu trúc dữ liệu Q là gì, cách thức hoạt động, thao tác nào chúng tôi có thể
thực hiện bằng cách sử dụng tín hiệu và ứng dụng tín hiệu từ video tiếp theo mà chúng tôi sẽ bắt đầu triển khai. 

@@@



1143
00:00:00,870 --> 00:00:12,510
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về các tùy chọn triển khai Kuis. Chúng ta có thể triển khai tính dễ thương bằng cách sử dụng Arry và chúng ta có thể triển khai tính dễ thương bằng cách sử dụng nhà ngôn ngữ học để triển khai.

1144
00:00:12,540 --> 00:00:22,980
Chúng ta có hai loại tín hiệu, tín hiệu tuyến tính và tín hiệu vòng tròn để các nhà ngôn ngữ học thực hiện. Chúng tôi chỉ có một loại kỹ năng tuyến tính. Q Được rồi. Và trong phần này của bài diễn văn Alsi tuyến tính.

1145
00:00:22,980 --> 00:00:33,790
Q Và Zaghloul khó hiểu mảng và tuyến tính. Q không được liên kết trong quá trình triển khai tuyến tính của Arry.
Chúng ta có thể gặp phải một số vấn đề và vấn đề đó chúng ta có thể khắc phục bằng cách sử dụng Sakaki. 

@@@



1146
00:00:01,140 --> 00:00:10,560
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về việc sử dụng tín hiệu tuyến tính. Chúng ta sẽ triển khai việc sử dụng arem trong video này.

1147
00:00:10,590 --> 00:00:20,400
Chúng tôi sẽ thực hiện bảy phương pháp này, tạo hàng đợi, bao gồm cả đỉnh của bạn là trống và xóa hàng đợi. Bây giờ, hãy bắt đầu với việc tạo hàng đợi.

1148
00:00:20,640 --> 00:00:33,480
Đây là hàng đợi tuyến tính của chúng tôi đã có trong lớp của bạn. Ở đây chúng ta có mảng để thay đổi phía trước và phía sau phía trước hàng đợi của chúng ta. Rehrmann Sự kết thúc của hàng đợi của chúng tôi tạo ra hàng đợi trong hàng đợi.

1149
00:00:33,510 --> 00:00:43,250
Đỉnh trống là ý chí và hàng đợi xóa. Bây giờ hãy bắt đầu với phương thức tạo hàng đợi. Điều này sẽ tạo ra phương thức xếp hàng. Phương pháp này lấy một trang tham số ở đây.

1150
00:00:43,250 --> 00:01:04,380
Chúng tôi đang tạo mảng và chúng tôi đang khởi tạo từ tỷ lệ đó đến trình quản lý. Nếu chúng ta gọi phương thức này bằng 5 thì chúng ta đang tạo một mảng. Mảng này sẽ hoạt động giống như một cấu trúc Cloudera và chúng tôi có biến này ở phía trước và phía sau các điểm trừ một và chúng không tồn tại trên chỉ số 0 của chúng tôi.

1151
00:01:04,920 --> 00:01:15,840
Chúng tôi sẽ xóa các phân đoạn trống của Cilacap trong Java. Ngôn ngữ lập trình chỉ tạo một mảng số nguyên. Khu vực này được lấp đầy bằng số không. Chúng tôi đang đại diện cho trống rỗng.

1152
00:01:16,020 --> 00:01:29,580
Bạn có thể coi như chúng ta có số 0 trong một ô trống để đặt lại ô sẽ sử dụng khái niệm số 0, tất cả được đặt thành 0. Nhưng chúng tôi không cho bạn thấy rằng khi bạn có ô trống, bạn có thể coi chúng tôi có số 0.

1153
00:01:29,820 --> 00:01:40,140
Và hãy nói về phương pháp thu nhập. Phương thức này nhận giá trị tham số. Sau đó vào bên trong này, kiểm tra xem hàng đợi đã đầy chưa, sau đó chúng ta sẽ in tràn hàng đợi.

1154
00:01:40,350 --> 00:01:51,360
Nếu thực sự đi đến âm một, điều đó có nghĩa là nếu hàng đợi trống, chúng ta sẽ xếp về 0 và vết máu hiếm sẽ chuyển sang hàng tiếp theo và sẽ chèn giá trị của chúng ta vào khu vực của chúng ta.

1155
00:01:51,360 --> 00:02:08,340
Được rồi, nếu không, nếu chúng ta có một số phần tử trong hàng đợi thì chúng ta sẽ chuyển sang phần tử tiếp theo và sẽ chèn phần tử hiện tại vào hàng đợi của mình. Nếu chúng ta gọi phương thức này và hàng đợi, cutin sẽ chèn dữ liệu vào ô đầu tiên của chúng ta và chúng ta sẽ chuyển sang ô tiếp theo và O'Rear sang ô tiếp theo.

1156
00:02:08,460 --> 00:02:21,480
Bạn gọi lại phương thức này và hàng đợi với hai mươi sẽ chèn hai mươi hai ô này vào đây và sẽ chuyển sang ô tiếp theo. OK, đầu tiên chúng ta sẽ di chuyển đến đây rồi chèn nó vào.

1157
00:02:21,480 --> 00:02:33,510
Chúng tôi gọi lại phương pháp này. Chúng tôi sẽ di chuyển đến đó ở đây và chèn vào đây mười ba. Nếu chúng ta gọi lại phương thức này bằng fording sẽ di chuyển o'rear và sẽ chèn ngoại.

1158
00:02:33,510 --> 00:02:48,810
Vì chúng ta có một số phần tử trong hàng đợi nên nếu chúng ta gọi lại phương thức này thì chúng ta sẽ chuyển sang phương thức tiếp theo và sẽ chèn 50. Nếu chúng ta gọi một phương thức khác có 60, thì nó sẽ đưa ra lỗi tràn tín hiệu vì hàng đợi đã đầy .

1159
00:02:49,200 --> 00:03:01,950
Joe Incubated hoạt động. Phương pháp này sẽ yêu cầu người nói nói một lần và do độ phức tạp của một không gian, tài liệu riêng biệt sẽ chiếm độ phức tạp một lần.

1160
00:03:02,250 --> 00:03:14,340
Nhưng thứ tự của tổ hợp không gian đang tạo ra một mảng có kích thước trong. Bây giờ chúng ta hãy nói về hoạt động phân rã bằng 0 dequeue. Phương thức này không nhận tham số mà chúng ta đang sử dụng nếu thực sự gần bằng âm một.

1161
00:03:14,550 --> 00:03:26,570
Điều đó có nghĩa là nếu hàng đợi trống, điều đó có nghĩa là nó sẽ trống. Nó sẽ in lỗi tràn hàng đợi. Nếu không, chúng ta sẽ in giá trị từ phía trước và đặt Frontyard Zero.

1162
00:03:26,820 --> 00:03:37,320
Khi anh ấy nói phía trước số 0, điều đó có nghĩa là chúng ta sẽ nói giá trị đó là giá trị mặc định và chúng ta sẽ chuyển sang giá trị tiếp theo nếu chúng ta thấy phía trước lớn hơn hiếm.

1163
00:03:37,320 --> 00:03:52,680
Trong trường hợp đó, nếu chúng ta xóa giá trị năm mươi thì tất cả sẽ di chuyển về phía sau và phía trước về điểm trừ đó. Nếu chúng ta gọi phương thức này là Q, nó sẽ trả về chuỗi giá trị và nó cho biết số 0 tương đối này và mặt trước sẽ chuyển đến đây.

1164
00:03:52,890 --> 00:04:07,980
Được rồi, nó in số 10 khi quay lại bài viết này, chúng tôi có thể trả về, nhưng chúng tôi chỉ in giá trị và chúng tôi đã đặt nó được phát triển bằng 0 và chỉ hiển thị cho bạn số 0 vì giá trị mặc định mà chúng tôi tạo mảng số nguyên trong Java.

1165
00:04:08,340 --> 00:04:21,630
Sau đó, nếu chúng ta gọi lại vấn đề này là Q print 20 và bạn xóa quản trị viên này, nó sẽ bằng 0 và nó sẽ được chuyển đến ô này. Vì vậy, nó sẽ được đại diện như thế này.

1166
00:04:21,630 --> 00:04:32,010
Và đây là cách tài liệu này hoạt động. Phương pháp này chụp ảnh một lần và do độ phức tạp của một không gian. Và hãy nói về hoạt động. Điều này khá đơn giản.

1167
00:04:32,700 --> 00:04:41,400
Đó là không có tham số. Chúng ta đang lấy nó bằng hai trừ một. Nếu khóa trống thì chúng tôi sẽ in sử dụng trống hoặc in giá trị từ phía trước.

1168
00:04:41,760 --> 00:04:51,140
Chúng tôi gọi phương pháp này là giả mạo. Nó sẽ in ngày hôm nay. Nó sẽ không loại bỏ bất cứ điều gì. Nó sẽ vừa được trả về từ trên cùng hoặc nó sẽ in giá trị mà chúng ta vừa in ở đây khi trả về.

1169
00:04:51,240 --> 00:05:12,780
Vì vậy, đối với điều này. Q Nó sẽ in ba mươi. Hoạt động này sẽ mất một trong những độ phức tạp về thời gian và không gian. Bây giờ hãy nói về hoạt động. Bạn biết đấy, thao tác này không có tham số, kiểm tra hồ sơ điện thoại của bạn để theo dõi và nếu chúng tôi tìm thấy trong vài phút thì chúng tôi sẽ quay lại từ thời điểm này sau hai phút khi hàng đợi trống hoặc sai.

1170
00:05:13,190 --> 00:05:25,550
Ta thấy hàng đợi không trống, phía trước không trừ một. Vì vậy, chúng tôi gọi là trống rỗng. Nó sẽ trả về false vì hàng đợi không trống và thao tác này sẽ mất thời gian và làm tăng độ phức tạp về không gian.

1171
00:05:25,790 --> 00:05:36,170
Bây giờ hãy nói về hoạt động đầy đủ. Nếu chúng tôi tìm thấy quả mìn thực sự gần với quả mìn trên tàu Diligenta cho vụ giết người này, chúng tôi sẽ biết hắn đi đến đâu ở vùng đất dành cho người lớn trừ đi một.

1172
00:05:36,180 --> 00:05:45,970
Vì vậy, chúng tôi gọi phương pháp này. Nó sẽ quay lại làm những gì chúng ta có ở bên trái. Chúng ta thấy ở đây hai cái vẫn trống, Rouselle đầu tiên, nhưng đã sử dụng hai cái đầu tiên này.

1173
00:05:45,980 --> 00:05:58,430
Vậy nên chúng ta sẽ nói nhiều hơn. Bạn đang nói về điều gì? Quay tròn? OK, tất cả các phần tử từ hàng đợi này chỉ có chúng ta mới có thể bắt đầu chèn từ bên trái. Chúng tôi đã bị loại bỏ 14 và 30 khỏi.

1174
00:05:58,430 --> 00:06:13,730
Q Nếu chúng tôi chỉ có 15 thì chúng tôi cũng không thể chèn bất cứ thứ gì vào hàng đợi của mình. Đó là lý do tại sao chúng ta phải đưa ra Thông tư A. Chúng ta sẽ nói về điều đó trong video tiếp theo. Hoạt động này sẽ chiếm nhiều không gian hơn và độ phức tạp lớn hơn một lần.

1175
00:06:13,850 --> 00:06:27,830
Bây giờ hãy nói về sự hợp tác giữa thang máy và chúng ta chỉ đang thiết lập tập phim gốc Arietta. Bây giờ khu vực này sẽ bị xóa khỏi bộ nhớ máy tính. Vì vậy, nếu chúng ta gọi hàm này, hàm đó sẽ bị xóa và việc hợp tác bị trì hoãn.

1176
00:06:27,840 --> 00:06:38,810
Siêu đơn giản, bản gốc cho biết. Và thao tác này sẽ mất một lần và tăng độ phức tạp về không gian. Và đây là video giải thích cách triển khai tuyến tính.

1177
00:06:39,010 --> 00:06:51,800
Chúng tôi đã hiểu lời giải thích của video này. Tôi có nó có mã nguồn và mã nguồn. Chúng tôi có tất cả các phương pháp tuyến tính. Q Sử dụng mọi kiểm tra mã nguồn để triển khai tuyến tính hoàn chỉnh.

1178
00:06:51,800 --> 00:07:00,740
Q Sử dụng lỗi, chúng tôi hiểu điều này bằng cách giải thích. Bạn có một vấn đề. Nếu bạn có bất
kỳ câu hỏi nào, hãy cho chúng tôi biết. Cảm ơn đã xem. Tôi sẽ gặp bạn trong video tiếp theo. 

@@@



1179
00:00:00,650 --> 00:00:15,700
Chào mừng bạn quay trở lại với video này trong video này. Chúng tôi sẽ triển khai khu vực sử dụng Thông tư Quay. Chúng tôi sẽ triển khai phương pháp SEBEN này cho Thông tư Quay để tạo hàng đợi trong hàng đợi.

1180
00:00:15,740 --> 00:00:32,510
Đỉnh trống, Espoo và hàng đợi bị trì hoãn. Trong video trước, chúng ta đã thấy rằng khi triển khai hàng đợi tuyến tính là một khu vực, chúng ta gặp phải một vấn đề. Chúng tôi có ô chưa sử dụng nên chúng tôi không thể sử dụng và điều đó không hiệu quả lắm.

1181
00:00:32,720 --> 00:00:44,250
Và để giải quyết vấn đề đó chúng ta có thể sử dụng hàng đợi vòng tròn. Bây giờ hãy nói về hình tròn. Đầu tiên, chúng ta sẽ thấy phương thức này tạo hàng đợi. Sau đó chúng ta sẽ nói về tất cả các phương pháp.

1182
00:00:44,280 --> 00:00:58,300
Từng cái một. Đầu tiên, hãy nói lại về việc tạo hàng đợi cho lớp của chúng ta. Ở đây chúng ta có bảy phương pháp này và chúng ta có mọi mặt trước và mặt sau. Đây là phía của khu vực của chúng tôi.

1183
00:00:58,710 --> 00:01:14,250
Đây là phương pháp xếp hàng tuyệt vời của chúng tôi. Phương thức này lấy một tham số là độ dài và ở đây chúng ta đang tạo một diện tích của cạnh đã cho, sau đó chúng ta sẽ khởi tạo phía trước và phía sau để theo dõi bên trong bằng để cho mượn nó.

1184
00:01:14,610 --> 00:01:26,250
Chúng ta gọi phương thức này là sáu, sau đó chúng ta sẽ tạo một mảng có độ dài sáu. Đây là diện tích của LENTE 6 và diện tích này được thể hiện theo kiểu hình tròn, đại loại như thế này.

1185
00:01:26,250 --> 00:01:37,140
Chúng ta có chỉ số 0 một, hai, ba, bốn, năm. Ban đầu khu vực của chúng tôi trống và phía trước và phía sau đều chỉ đến âm một và các cạnh gần bằng sáu.

1186
00:01:37,890 --> 00:01:46,800
Bây giờ hãy xem cách chúng ta có thể chèn dữ liệu vào hàng đợi của mình. Bây giờ hãy nói về phương thức xếp hàng. Đây là sự gia tăng của chúng tôi. Phương thức này lấy một tham số ở đây.

1187
00:01:46,800 --> 00:01:56,700
Đầu tiên, chúng ta sẽ kiểm tra Isbel. Nếu hàng đợi được sắp xếp đầy đủ thì hàng đợi nhà xuất bản đã đầy. Sẽ thấy phương pháp này trong video này. Đừng lo lắng về điều đó thì chúng tôi có việc khác.

1188
00:01:57,180 --> 00:02:13,310
Nếu nguồn tài trợ dành cho Jérome bị trừ đi ở mặt trận đó và sau đó chúng tôi sẽ tính tỷ lệ lỗi cộng với một trang web mô hình, thì lỗi sẽ ghi lại giá trị. Nếu không khí của chúng ta đi ra ngoài ranh giới lỗi thì chúng ta sẽ chuyển sự nghiệp của mình đến ô đầu tiên đó.

1189
00:02:13,500 --> 00:02:28,110
Được rồi, bây giờ hãy xem nó hoạt động như thế nào. Nếu bây giờ chúng tôi gọi Cutin thì điều gì sẽ xảy ra với hàng đợi của bạn trống, vì vậy chúng tôi sẽ đặt trước số 0 và sau đó chúng tôi sẽ tính toán O'Rear.

1190
00:02:28,350 --> 00:02:40,800
Vậy mô đun 0 ở đây là 6, 6 của Saidi, Morila 6 là 0. Vì vậy, thực tế sẽ trỏ đến ô này. Và ở đây trong ô này chúng ta sẽ chèn giá trị của giá trị là 10.

1191
00:02:40,950 --> 00:02:51,150
Vì vậy, hãy bất an và hãy tiến về phía trước và phía sau vấn đề này. Vì vậy, bây giờ ACU của chúng tôi đã được đại diện, đại loại như thế này. Đây là phía trước và đây là phía sau. Chúng tôi chỉ có một phần tử trong hàng đợi của mình.

1192
00:02:51,390 --> 00:03:09,960
Chúng tôi gọi lại vào Quý 2 và bây giờ chúng tôi sẽ tính toán diện tích phía sau sẽ được đánh giá. Một điểm ở đây và chúng ta sẽ chèn vào đây hai mươi. Nếu chúng ta gọi lại vấn đề này bằng Tarty, chúng ta sẽ chuyển đến ô này và ở đây chúng ta sẽ chèn sự chậm trễ.

1193
00:03:11,070 --> 00:03:23,370
Chúng tôi gọi lại với bốn mươi, sau đó chúng tôi sẽ chuyển khu vực này sang khu vực này. Vì vậy, thực sự cộng một. Kích thước mô-đun sáu ở đây là sáu, vậy ba mô-đun, sáu ngang thành ba.

1194
00:03:23,880 --> 00:03:37,290
Vậy điểm thực ở đây và ở đây chúng ta sẽ chèn bốn mươi. Sau đó, chúng ta lại gọi vấn đề này là một điểm thực sự ở đây và ở đây. Chúng tôi sẽ chèn năm mươi tám để gọi phương thức này trong Q Sixty.

1195
00:03:37,890 --> 00:03:52,650
Sau đó chúng ta sẽ di chuyển đến đây, ở đây và chúng ta sẽ chèn vào đây sáu mươi. Đây là cách hoạt động gia tăng. Chúng tôi đã hiểu phương pháp mới này. Phương pháp này mất thời gian không đổi và độ phức tạp không gian không đổi.

1196
00:03:53,400 --> 00:04:08,130
Phương thức tạo hàng đợi này có độ phức tạp một lần và độ phức tạp lớn hơn trong không gian. Độ dài của mảng là bao nhiêu? Đây là một kuac hình tròn trong vòng tròn này.

1197
00:04:08,130 --> 00:04:22,760
Q được thể hiện như thế này trong một vòng tròn. Được rồi, chúng ta thấy điều này trong một vòng tròn 10, 20, 30, 40, 50 và 60. Đây là mặt trước của chúng ta và đây là khu vực của chúng ta. Bây giờ hãy nói về việc sử dụng phương pháp ở đây.

1198
00:04:22,770 --> 00:04:42,480
Chúng ta sẽ kiểm tra xem nó có trừ một không, sau đó chúng ta sẽ in hai. Nếu nó tiến đến âm một, điều đó có nghĩa là Q của chúng ta trống. Nếu tỷ lệ của chúng tôi không trừ một trăm và sai, nếu chúng tôi gọi phương thức này, phương thức này sẽ trả về sai vì đối với Q này, chúng tôi thấy các bản ghi lại hai năm, không phải là trừ một.

1199
00:04:42,810 --> 00:04:59,970
Vì vậy phương pháp này sẽ trả về sai. Bây giờ hãy nói về phương pháp Espoo. Đây là phương pháp Espoo. Phương thức này lấy một tham số. Bạn sẽ kiểm tra xem một cái có đi đến các cá nhân và một bản ghi lại có kích thước trừ một hay không, chúng tôi thấy các bản ghi lại có kích thước trừ một.

1200
00:04:59,970 --> 00:05:19,470
Có năm cỡ, sáu hoặc sáu phút khi là năm năm. Thế là tẩy chay trừ một. Vì vậy, trong trường hợp này sẽ trở lại. ĐÚNG VẬY. Và ở đây chúng ta có câu lệnh if này nếu phía trước bằng hai số thực cộng một thì sẽ trả về true và sẽ nhận được câu lệnh này sau khi thực hiện các thao tác dequeue.

1201
00:05:19,800 --> 00:05:33,830
Bây giờ hãy xem sự hợp tác để chúng ta có thể thực hiện các hoạt động dequeue cho CU này. Bạn nhớ lại phương pháp này thì nó sẽ trả về true vì hàng đợi này đã đầy và sẽ đến câu lệnh này sau trong video này.

1202
00:05:34,530 --> 00:05:46,170
Bây giờ, hãy nói về một tài liệu. Vấn đề này lấy một tham số bên trong đây, chúng tôi đang kiểm tra xem có trống không, hàm này có trả về true hay không. Điều đó có nghĩa là hàng đợi của chúng ta trống, hàng đợi in trống.

1203
00:05:46,180 --> 00:05:55,390
Nếu không, thì chúng ta sẽ lấy phần tử phía trước và chúng ta đang in phần tử đó và chúng ta sẽ lấy nó từ phía sau. Sau đó, chúng tôi đang ngồi phía trước ecoles để thực sự gần đến âm một.

1204
00:05:56,570 --> 00:06:15,430
Cũng từ cụm trước, cộng thêm một bên nữa. Được rồi, nếu chúng ta gọi phương thức này, phương thức này sẽ in ra 10 và chúng ta sẽ chuyển sang phần tử này, một, thay đổi giá trị của đơn vị đầu tiên này, thay đổi giá trị của lần bán đầu tiên hoặc chỉ giữ giá trị mà chúng ta coi là giá trị giá trị mặc định.

1205
00:06:15,430 --> 00:06:29,830
Zero cho ngôn ngữ lập trình Java. Nhưng chúng ta chỉ giữ giá trị và điểm chính diện cho phần tử này. Đây là cửa trước của bạn trong phân khúc của chúng tôi. Chúng ta thấy nó từ ghi chú này trỏ đến phần tử này và cái này ở đây.

1206
00:06:30,540 --> 00:06:41,650
Nếu chúng ta gọi lại phương thức này, nó sẽ quay trở lại và chuyển sang phương thức tiếp theo. Và sau đó chúng tôi gọi lại. Nó sẽ quay lại nước đi Freundel phía trước tới nước tiếp theo, sau đó chúng ta gọi lại.

1207
00:06:42,130 --> 00:07:04,000
Nó sẽ trả về 40 và chuyển sang phần tiếp theo. Có lẽ sẽ gọi lại. Nó sẽ trả về 50 và sau đó chuyển sang phần tiếp theo. Bây giờ chúng ta thấy phía sau và phía trước không trỏ đến cùng một phần tử và vòng tròn và phía trước của anh ta đang trỏ đến phần tử này và họ nói không, thao tác dequeue này hoạt động.

1208
00:07:04,000 --> 00:07:15,130
Phương pháp này sẽ đưa Spiga lên một lần và B, tăng độ phức tạp một không gian. Bây giờ, hãy quay trở lại với việc hợp nhất của chúng ta. Nếu chúng ta gọi phương pháp này là trực giác 70 thì điều gì sẽ xảy ra?

1209
00:07:15,460 --> 00:07:35,050
Hậu phương của chúng ta sẽ di chuyển đến ngưỡng cửa này và Hyrule trong bảy mươi như vậy ở vị trí 10. OK, sau đó nếu chúng ta gọi lại, thì nó sẽ thay thế sự biến động này bằng 80, bạn nhớ lại với 90, sau đó chúng ta sẽ di chuyển đến đây và tất cả sẽ như vậy được cập nhật với 90.

1210
00:07:35,420 --> 00:07:51,770
Nếu chúng ta gọi lại với 100 thì cái này sẽ được nâng cấp. Với 100, chúng ta gọi lại bằng 110. Khi đó giá trị này sẽ được cập nhật thành một trăm mười. OK, bây giờ chúng ta thấy rằng phản ứng với phần tử này và phản hồi với phần tử này.

1211
00:07:52,070 --> 00:08:07,260
Bây giờ hãy quay lại hoạt động Espoo của chúng ta. Năm nay có đầy đủ các hoạt động ở đây, chúng tôi thấy từ đi đến thực cộng một và chúng tôi thấy ở đây hàng đợi của chúng tôi trông như thế nào và điều kiện này đúng trong trường hợp này, từ trước ra sau cộng với một trước.

1212
00:08:07,400 --> 00:08:18,200
Chúng ta hãy đến một điểm cộng thực sự. Vậy có bốn bốn cộng một ở phía trước. Vì thế nó sẽ quay trở lại. ĐÚNG VẬY. Và đây là tuyên bố của chúng tôi đã hiểu tuyên bố này.

1213
00:08:18,800 --> 00:08:31,610
Chúng tôi gọi phương pháp này. Phương pháp này sẽ trở về số không. Đây là phương pháp hoạt động. Phương pháp này hoạt động trong thời gian không đổi, phương pháp này hoạt động trong thời gian không đổi và độ phức tạp không gian không đổi.

1214
00:08:32,240 --> 00:08:43,370
Bây giờ hãy nói về hoạt động của lợn. Nó cực kỳ đơn giản. Đầu tiên để kiểm tra xem xe của chúng tôi có trống hay hàng in có đơn vị trống hay chỉ in van từ phía trước và đây là 40 60 của chúng tôi.

1215
00:08:43,380 --> 00:08:55,790
Vì vậy, nó sẽ in 60. Chúng tôi gọi phương pháp này. Nó sẽ in 60 đơn vị trả về giá trị. Chúng tôi có thể trả lại giá trị là tốt. Nhưng chúng tôi chỉ đang in ở đây. Phương pháp này chỉ mất một lần và nhận được một độ phức tạp Espace.

1216
00:08:56,360 --> 00:09:08,810
Bây giờ hãy nói về một phương pháp mới ở đây. Bây giờ chúng tôi chỉ đang làm nông nghiệp, vì vậy khu vực của chúng tôi sẽ được thiết lập cho đến bây giờ và chúng tôi chỉ giao cho O'Rear và Prodigals quản lý một cấp trên.

1217
00:09:08,810 --> 00:09:19,410
Và mặt trước của chúng ta đều hướng tới quản lý và khu vực này sẽ bị xóa khỏi bộ nhớ máy tính của chúng ta, được chứ? Và toàn bộ khu vực này sẽ bị xóa trong hàng đợi vòng tròn của chúng tôi.

1218
00:09:19,430 --> 00:09:29,480
Đây là sự đại diện. Đây chỉ là một hình ảnh đại diện trực quan về khu vực của chúng tôi. Được rồi, khu vực này, vụ bắt giữ này được coi như một hàng đợi. Đây là cách phương pháp này hoạt động.

1219
00:09:29,780 --> 00:09:39,230
Và phương pháp này sẽ mất một lần và chúng ta tăng độ phức tạp lên một không gian. Những gì chúng ta đã hiểu cách giải thích về tốc độ này là chúng ta đã hiểu khái niệm về vòng tròn.

1220
00:09:39,230 --> 00:09:51,410
Q sử dụng hình tròn. Q Chúng tôi có thể sử dụng ô không sử dụng của mình, OK, chúng tôi không lãng phí bất kỳ
lời nói nào trong bộ nhớ máy tính. Chúng tôi đã hiểu phương pháp này. Chúng ta đã hiểu hình tròn là gì. 

@@@



1221
00:00:01,140 --> 00:00:22,700
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng ta sẽ triển khai tín hiệu tuyến tính bằng cách sử dụng nhà ngôn ngữ học trong video này. Chúng ta sẽ triển khai tín hiệu tuyến tính bằng cách sử dụng cấu trúc dữ liệu ngôn ngữ và thực hiện sáu phương pháp này, tạo tín hiệu trong đỉnh Q dequeue trống và xóa.

1222
00:00:22,830 --> 00:00:38,850
Q Bây giờ hãy tạo phương thức xếp hàng. Sau đó chúng ta sẽ nói về tất cả các phương pháp. Từng người một, đây là lớp học của chúng tôi. Lớp này chứa trên onload. Ghi chú này chứa hai thuộc tính, một giá trị và một con trỏ.

1223
00:00:38,850 --> 00:00:54,000
Tiếp theo ở đây chúng ta có mặt trước và mặt sau của Q và chúng ta có phương pháp thứ sáu của bạn. Bây giờ, hãy nói về việc tạo cho bạn cái này để tạo một phương thức mới. Phương pháp này không có tham số.

1224
00:00:54,270 --> 00:01:08,950
Và bên trong đây, chúng ta đang ngồi phía trước và phía sau về giá trị rỗng. Bây giờ, nếu chúng ta gọi phương thức này là tạo hàng đợi, thì chúng ta sẽ gán một con trỏ phía trước và một con trỏ thực cho nút null.

1225
00:01:08,970 --> 00:01:35,820
Được rồi, đây. Con trỏ phía trước và phía sau đang trỏ đến nút hiện tại. Bây giờ chúng ta hãy xem sự chuyển đổi này đã tăng dần theo phương pháp NQ của chúng ta. Phương thức này nhận giá trị tham số. Bên trong đây, chúng tôi đang tạo một nút mới, OK, và chúng tôi đang lấy nó từ tiêu chuẩn vàng và chúng tôi đang ngồi phía trước và phía sau các trường nút mới tổ chức lớp tiếp theo cho nút mới và bản ghi lại cho nút mới.

1226
00:01:36,240 --> 00:01:49,610
Nếu chúng ta gọi phương thức này bằng 10 thì chúng ta sẽ tạo một nút mới và sau đó chúng ta sẽ di chuyển về phía trước và phía sau nút này. Vì vậy, nhà ngôn ngữ học sẽ được đại diện, đại loại như thế này.

1227
00:01:49,860 --> 00:02:06,300
Đây là kuac của chúng tôi. Được rồi, nhà ngôn ngữ học này đang sử dụng cấu trúc dữ liệu gợi ý. Chúng tôi có mặt trước và chúng tôi có O'Rear. Có thể gọi lại phương thức này với 20. Sau đó, ở đây chúng ta đang tạo một nút mới có giá trị 20.

1228
00:02:06,960 --> 00:02:17,430
Và chúng ta sẽ làm gì? Chúng ta sẽ thấy ở Riyadh bên cạnh nút mới. Vì vậy, chúng ta sẽ kết nối điểm này với nút này và chúng ta sẽ di chuyển sớm hơn đến nút này.

1229
00:02:17,640 --> 00:02:29,070
Vì vậy, hàng đợi sẽ được thể hiện như thế này. Chúng tôi có giao diện người dùng. Chúng tôi có ở đây. Đây là mặt trước của bạn và đây là O'Rear. Bạn gọi lại vấn đề này, chúng tôi chậm trễ.

1230
00:02:29,280 --> 00:02:39,210
Sau đó, chúng ta sẽ tạo một nút mới và sau đó chúng ta sẽ gán điểm này cho ghi chú này bằng cách nói đã xóa đơn vị Mixteco tiếp theo, sau đó chúng ta sẽ chuyển khu vực sang nút này.

1231
00:02:39,570 --> 00:02:50,970
Sau đó, nhà ngôn ngữ học của chúng tôi sẽ được đại diện, đại loại như thế này. Đây là một nhà ngôn ngữ học. Nhà ngôn ngữ học này đang coi như một cấu trúc dữ liệu hàng đợi. Chúng tôi có mặt trước ở đây và chúng tôi có O'Rear.

1232
00:02:51,540 --> 00:03:08,200
Đây là cách phương pháp mới này hoạt động. Phương pháp này tốn nhiều thời gian và độ phức tạp về không gian. Phương pháp này tạo ra bạn. Nó cần nhiều thời gian hơn và lớn hơn về độ phức tạp của không gian.

1233
00:03:09,310 --> 00:03:20,440
Bây giờ hãy nói về phương pháp đỉnh cao. Phương pháp này không có tham số. Bạn đang lấy nó từ tiêu chuẩn vàng và chúng tôi đang in các ELT trống trong hàng đợi hoặc in giá trị từ phía trước của chúng tôi.

1234
00:03:21,380 --> 00:03:35,910
Được rồi, chúng tôi gọi phương pháp này là chọn. Nó sẽ in 10 từ phía trước. Được rồi. Và nó sẽ không làm gì cả. Nó sẽ chỉ in 10. Chúng ta có thể trả về giá trị 10 từ nút phía trước, nhưng chúng ta chỉ in giá trị.

1235
00:03:36,250 --> 00:03:48,070
Bạn có thể trả lại nó là tốt. Bây giờ hãy nói về các hoạt động trống rỗng. Thao tác này lấy một tham số bên trong việc kiểm tra Euphronios của bạn với Nalden khi trả về giá trị đúng hoặc trả về sai.

1236
00:03:48,070 --> 00:03:59,370
Nếu chúng ta gọi phương thức này dài nhất thì nó sẽ trả về false vì mặt trước không trỏ đến nút hiện tại. Và chúng ta nói đây không phải là hàng đợi trống.

1237
00:03:59,830 --> 00:04:15,700
Đó là cách nó được viết. SAI. Thao tác này mất một lần và nhận được một độ phức tạp về không gian. Hoạt động này, hoạt động này cũng chiếm nhiều thời gian hơn và độ phức tạp lớn hơn về không gian.

1238
00:04:16,630 --> 00:04:28,690
Bây giờ hãy nói về hoạt động dequeue. Thao tác này, phương thức này lấy một tham số bên trong. Bạn đang xem nó hợp pháp. Tất cả hàng đợi in đều trống, ELT, tất cả sẽ có giá trị từ phía trước.

1239
00:04:28,870 --> 00:04:43,290
Và sau đó chúng ta sẽ di chuyển về phía trước đến nút tiếp theo và chúng ta đang kiểm tra xem bây giờ nó đúng hay ở phía sau cho đến nay. Nếu chúng tôi tìm thấy Đường hầm điên cuồng, thì chúng tôi đang đặt con trỏ thực để tải xuống.

1240
00:04:43,300 --> 00:04:58,420
Chúng tôi gọi phương pháp này. Phương pháp này sẽ in và xóa giá trị khỏi phía trước của chúng tôi. OK là một danh sách liên kết và nó sẽ trả về Vollertsen này và nó sẽ xóa sổ ghi chép này và mặt trước này sẽ được chuyển đến nút này.

1241
00:04:58,660 --> 00:05:13,210
Sau đó, danh sách liên kết của chúng tôi sẽ được trình bày, đại loại như thế này. Và ở đây chúng tôi chỉ di chuyển tài liệu phía trước của bạn chứ không xóa tài liệu này. Không phải khi không tìm thấy bộ thu thập Garrick nào thì không có gì trỏ đến điều này, không phải nút này sẽ tự động bị bộ thu gom rác xóa khỏi RAM.

1242
00:05:13,390 --> 00:05:27,580
Vì vậy, liên kết sẽ được đại diện. Một cái gì đó như thế này. Nếu chúng ta gọi lại kim loại này, nó sẽ in ra 20 và nó sẽ di chuyển về phía trước nút này. Vậy nên liên kết của chúng ta cần được thể hiện, đại loại như thế này.

1243
00:05:27,580 --> 00:05:46,540
Và trình thu gom rác sẽ loại bỏ nút này khỏi RAM. Nếu chúng ta gọi lại phương thức này, phương thức này sẽ in TARDE và nó sẽ di chuyển về phía trước đến nút bây giờ. Vì Rod bằng Tranel, khu vực này sẽ được chuyển đến nút này cũng như nút này và cho phép nó được biểu diễn, đại loại như thế này.

1244
00:05:46,540 --> 00:05:53,690
Và không có gì khác chỉ vào điều này, không ghi chú này sẽ bị người thu gom rác loại bỏ. Vì vậy, nhà ngôn ngữ học của chúng tôi sẽ được đại diện như thế này.

1245
00:05:53,710 --> 00:06:04,600
Hàng đợi của bạn trống thế nào. Hoạt động này mất một lần và làm tăng độ phức tạp về không gian và đây đều là các công việc được ghi lại. Hy vọng đã hiểu phương pháp này hoạt động như thế nào.

1246
00:06:05,410 --> 00:06:19,090
Bây giờ hãy nói về phương pháp ở đây. Chúng ta chỉ ở phía trước và ngay bây giờ nó sẽ ở phía trước và phía sau là vô giá trị. Sau đó, nhà ngôn ngữ học này sẽ tự động bị người thu gom rác loại bỏ.

1247
00:06:19,090 --> 00:06:27,700
Đầu tiên nó sẽ loại bỏ nút này vì không có gì trỏ đến nút này, sau đó nút này không có gì được đổ vào nút này. Không phải là bộ thu gom rác trong nút này.

1248
00:06:28,060 --> 00:06:41,350
Không có gì trỏ đến nút này. Vì vậy ghi chú này sẽ bị xóa. Trình thu gom rác và chúng tôi thấy danh sách của mình trống và đây là trình thu gom rác sẽ xóa tín hiệu khỏi IREM.

1249
00:06:42,190 --> 00:06:59,500
Điều đó có nghĩa là danh sách liên kết của chúng tôi nếu tôi hiểu phương pháp này, thì phương pháp này sẽ sử dụng Spiga một lần và chọn ra một không gian phức tạp trong số
bạn đã hiểu chính lời giải thích này về việc chúng tôi đã hiểu cách triển khai tuyến tính dễ thương bằng cách sử dụng khóa học ngôn ngữ học Evony trong mọi tình huống . 

@@@



1250
00:00:00,750 --> 00:00:15,990
Này các bạn quay lại với video này nhé. Chúng ta sẽ nói về cấu trúc dữ liệu cây. Cây là cấu trúc dữ liệu phân cấp phi tuyến bao gồm các nút được kết nối bởi Isiah.

1251
00:00:17,980 --> 00:00:31,210
Đây là một ví dụ về cái cây mà chúng ta không có và chúng ta có con trái và con phải ở bên trái mà chúng ta không có, và nốt đó chứa một con trái và con phải khác.

1252
00:00:31,360 --> 00:00:45,940
Và vân vân. Đối với lưu ý này, chúng tôi chỉ có con đúng. Chúng tôi không còn con nào cho ghi chú này. Chúng ta có con trái, con phải cho ghi chú này. Chúng ta có con trái, con phải cho nốt này, cho nốt này, cho nốt này và cho nốt này.

1253
00:00:46,120 --> 00:01:00,500
Không có con trái và phải. Và ghi chú này được gọi là LoopNet. Và Tufnel được gọi là The Root Note. Và chúng ta sẽ nói về điều đó khi nói về ba thuật ngữ.

1254
00:01:00,700 --> 00:01:15,340
Đây là một ví dụ về lỗi cấu trúc dữ liệu cây. Ngăn xếp danh sách liên kết và Q là các cấu trúc dữ liệu tuyến tính lưu trữ dữ liệu một cách tuần tự để thực hiện bất kỳ thao tác nào trong cấu trúc dữ liệu tuyến tính.

1255
00:01:15,580 --> 00:01:32,050
Độ phức tạp về thời gian tăng lên khi kích thước dữ liệu tăng lên. Nhưng điều này không được chấp nhận trong thế giới tính toán ngày nay. Cấu trúc dữ liệu cây điểm sương cho phép truy cập dữ liệu nhanh hơn và dễ dàng hơn giống như cấu trúc phi tuyến tính.

1256
00:01:32,260 --> 00:01:50,860
Vì vậy, chúng tôi hiểu rằng đối với cấu trúc tuyến tính, chúng tôi có thể gặp vấn đề. Bất cứ khi nào kích thước tăng lên, độ phức tạp về thời gian của chúng tôi sẽ tăng lên đối với tất cả những gì chúng tôi cần để các cấu trúc phân tâm xuất hiện để giải quyết các vấn đề mà chúng tôi nên thực hiện với cấu trúc dữ liệu một cây.

1257
00:01:51,490 --> 00:02:03,880
Các cấu trúc dữ liệu chính khác nhau cho phép truy cập dữ liệu nhanh hơn và dễ dàng hơn vì đây không chỉ là cấu trúc dữ liệu mới mà còn là cấu trúc phi tuyến tính. Đây là một đại diện thực sự.

1258
00:02:03,970 --> 00:02:16,120
Chúng ta có thể tạo cây bằng cách sử dụng Legalist hoặc thêm cấu trúc vào nó và chúng ta sẽ thấy tất cả trong phần này. Đừng lo lắng về điều đó. Bây giờ hãy nói về các loại cây khác nhau.

1259
00:02:16,360 --> 00:02:29,590
Chúng tôi có nhiều loại cây khác nhau, nhưng trong khóa học này chúng tôi sẽ nói về, đặc biệt đối với năm loại cây này, cây nhị phân Star Street sẽ trồng cây Bintliff và thử.

1260
00:02:30,010 --> 00:02:46,090
Chúng ta sẽ nói về tất cả cấu trúc dữ liệu này trong khóa học này. Bây giờ chúng ta hãy nói về ứng dụng tạo ra một cấu trúc. Cấu trúc dữ liệu khát nhị phân được sử dụng để nhanh chóng kiểm tra xem một phần tử có ở trạng thái hay không.

1261
00:02:46,270 --> 00:03:03,040
Nếu là một loại cây được dùng để làm một đống ngắn. Một phiên bản sửa đổi của cây có tên Driss được sử dụng trong các rooter hiện đại để lưu trữ thông tin định tuyến. Cơ sở dữ liệu phổ biến nhất sử dụng cấu trúc dữ liệu cây.

1262
00:03:03,490 --> 00:03:22,840
Trình biên dịch sử dụng cây cú pháp để xác thực cú pháp của mọi chương trình bạn viết và có nhiều ứng dụng liên quan đến cấu trúc dữ liệu trong khóa
học này. Chúng ta sẽ nói chi tiết về cấu trúc tijeras trong video tiếp theo, chúng ta sẽ nói về các thuật ngữ cây, xem trong video tiếp theo. 

@@@



1263
00:00:00,420 --> 00:00:12,940
Trong video này, chúng ta sẽ nói về ba thuật ngữ. Đầu tiên, hãy nói về một nút trong nút chứa hai thuộc tính, dữ liệu và tham chiếu hoặc con trỏ.

1264
00:00:14,190 --> 00:00:28,810
Đây là một.. Ghi chú này chứa ba dữ liệu. Ở đây chúng ta có hai con trỏ và một dữ liệu. Đây là một nút có chiều dài gấp đôi. Để biểu diễn cây, chúng ta sử dụng mọi danh sách hoặc danh sách liên kết.

1265
00:00:29,340 --> 00:00:47,550
Giả sử đây là cấu trúc dữ liệu cây, cách biểu diễn cấu trúc dữ liệu cây này, đại loại như thế này. Chúng ta có 10 và chúng ta có con trái và con phải và bên trái khôi phục con đang hoạt động và ở bên phải hoặc xâu chuỗi các cạnh của con bên phải, đại loại như thế này.

1266
00:00:48,090 --> 00:01:03,210
Và đại diện cho số không không không hai không không không ba làm địa chỉ. Được rồi, và đây là cách biểu diễn cây. Và đây là một nút. Đây là một nút và đây là một nút.

1267
00:01:03,660 --> 00:01:18,450
Vậy ngành chúng ta thấy nút Tunisia 20 là nút và Tara phải không? Bây giờ hãy nói về root. Gốc là gì? Nút trên cùng tùy ý được gọi là root. Đây là gốc của cây này.

1268
00:01:19,080 --> 00:01:33,570
Đây là trên cùng, không phải trên cùng. Chú ý gọi là gốc chứ không phải là cây. Bây giờ chúng ta hãy nói chuyện. Mối liên kết giữa hai nút bất kỳ ở đây là gì?

1269
00:01:33,780 --> 00:01:50,790
Đây là một liên kết. Đây là một liên kết. Đây là một liên kết. Đây là một liên kết. Cái này. Cái này và cái này. Tất cả điều này được gọi là. Vì vậy, chúng ta thấy liên kết được gọi là liên kết này nằm giữa hai nút.

1270
00:01:51,390 --> 00:02:05,210
Vì vậy, liên kết này được gọi là bây giờ chúng ta hãy nói về trực tiếp. Những hạch bạch huyết không có con được gọi là hạch bạch huyết. Ở đây chúng ta thấy nút 40 này không có nút con nào.

1271
00:02:05,520 --> 00:02:19,740
Nếu không, nút này không có nút con. Vậy đây là hạch bạch huyết, hạch này và hạch này không có con. Vì vậy điều cần lưu ý này được gọi là hạch bạch huyết. Thuật ngữ tiếp theo là tổ tiên.

1272
00:02:20,190 --> 00:02:33,600
Tổ tiên là gì? Tổ tiên có nghĩa là cha mẹ, ông bà, ông cố, v.v. Vậy tổ tiên của nút này là gì? Bốn mươi tổ tiên của nút này, 40 là cha mẹ.

1273
00:02:33,600 --> 00:02:53,250
Đây là cha mẹ. Đây là ông bà. Đây là ông cố nội. Vậy tổ tiên của nút 40 này là tarde, 20 và 10. Bản thân nút này cũng là tổ tiên của chính nút đó, tổ tiên của nút đó.

1274
00:02:53,550 --> 00:03:03,330
Vậy tổ tiên của người này không phải bốn mươi là bốn mươi, ba mươi, hai mươi và mười. Vì vậy, bạn sáu mươi này không phải là tổ tiên của nút này. Bốn mươi. Tổ tiên của việc này.

1275
00:03:03,330 --> 00:03:14,070
Không phải vì điều này. Bốn mươi, ba, hai mươi và mười. Tổ tiên của nút này là gì. Sáu mươi. Tổ tiên của nút này. Sáu mươi không phải là sáu mươi mà là sáu mươi.

1276
00:03:14,070 --> 00:03:28,980
Cha mẹ hai mươi tuổi và ông bà lên mười. Vì vậy, câu trả lời không phải là mười sáu, sáu mươi, hai mươi và mười. Tổ tiên của nút này là gì. Năm mươi. Tổ tiên không năm mươi là năm mươi ba, hai mươi mười.

1277
00:03:29,610 --> 00:03:45,690
Chúng tôi đã hiểu tổ tiên là gì. Bây giờ hãy nói về thuật ngữ lần sau. Thuật ngữ tiếp theo là độ cao của một.. Bây giờ chúng ta hãy nói về độ cao lên chứ không phải độ cao lên ở độ dài của con đường từ phía bắc đến nốt sâu nhất là bao nhiêu.

1278
00:03:46,110 --> 00:03:59,490
Vậy chiều cao của cái này là bao nhiêu? Không phải nốt sâu nhất mà chúng ta thấy là năm mươi hay bốn mươi. Vậy độ cao của nốt nhạc này là một và hai. Chúng ta có hai con át ở giữa nốt này và nốt sâu nhất.

1279
00:03:59,490 --> 00:04:15,240
Vậy độ cao của nốt này, không phải hai mươi, mà là độ cao của nốt này là một, hai và ba. Vậy chiều cao của cái này là bao nhiêu? Độ cao của nốt này không phải là một, bởi vì nốt sâu nhất ở đây không phải là nốt tám mươi.

1280
00:04:15,540 --> 00:04:27,000
Vậy chiều cao của cái này không phải bảy mươi là một. Hãy nói về độ sâu của nốt nhạc? Độ sâu của lưu ý là độ dài của đường đi từ tuyến đường đến Dunnart. Vậy độ sâu của ghi chú này là gì?

1281
00:04:27,210 --> 00:04:48,790
Có phải đây là chúng ta có ở giữa lộ trình và nốt nhạc này là hai, nên một đầu đến cuối nên chiều sâu của nốt nhạc này. Sáu mươi là hai. Vậy độ sâu của ghi chú này là gì? Những hình ảnh chúng tôi có ở Beirut và theo ghi chú này là một, hai và ba, vì vậy độ sâu của cái này, không phải 50, là ba.

1282
00:04:49,030 --> 00:05:06,640
Độ sâu của ghi chú này là gì? Độ sâu của ghi chú này là một đầu đến độ sâu của nút gốc này là bao nhiêu? Và không có số 0 vì không có ranh giới giữa nốt gốc và nốt này, bởi vì đây là gốc của việc hiểu nó và đào sâu thêm một..

1283
00:05:06,850 --> 00:05:19,090
Và hãy nói về chiều cao của cây. Chiều cao của cây là gì, chiều cao của cây là bao nhiêu, chiều dài từ gốc đến nốt sâu nhất. Đây là gốc rễ của chúng tôi và đây là lưu ý sâu sắc nhất của chúng tôi.

1284
00:05:19,210 --> 00:05:34,090
Vậy chiều cao của cây này là một, hai và ba. Chúng ta có ba chữ S. Vậy chiều cao của cây này là cây. Bây giờ hãy nói về độ sâu của cây. Độ sâu của cây giống như độ sâu của rễ chứ không phải độ sâu của rễ.

1285
00:05:34,090 --> 00:05:50,020
Nút bằng 0 vì không có cạnh nào ở giữa nút gốc và nút 10 này vì đây là nút gốc. Vậy độ
sâu của cây này là bằng không. Chúng ta đã hiểu hai thuật ngữ trong video tiếp theo. 

@@@



1286
00:00:00,790 --> 00:00:19,630
Bạn đây rồi. Một số chàng trai sẽ quay lại video này trong video này. Chúng ta sẽ nói về ba thuật ngữ trong video này. Chúng ta sẽ nói về người tiền nhiệm và người kế nhiệm, người tiền nhiệm của A. là người đứng trước liền kề trong thân của cây nhị phân.

1287
00:00:20,920 --> 00:00:34,730
Và họ đã được quân đội trao cho cái này, phần cuối của tòa tháp. Vậy cây thông này là được, nên chúng ta có thể có được danh sách này bằng cách duyệt cây nhị phân này theo thứ tự.

1288
00:00:35,590 --> 00:00:45,860
Vì vậy, bây giờ chúng ta nói, tiền thân của nút chín này là gì? Vì vậy chúng ta phải tìm ra nó. Tiền thân của Nút chín này. Đầu tiên chúng ta phải tìm ra tòa tháp bên trong.

1289
00:00:45,880 --> 00:00:59,530
Vì vậy, đây là phần cuối của ô khủng bố theo thứ tự di chuyển qua nút ngay trước đó của số 9 được gọi là nút tiền thân. Vậy đối với nốt số 9 này thì số trước là số 4.

1290
00:00:59,580 --> 00:01:13,400
OK, vậy tiền thân của Nút chín này là dành cho nút ABC này. Nói xem, tiền thân của Nút sáu này là gì. Đầu tiên, hãy tìm số sáu trong tháp này.

1291
00:01:13,420 --> 00:01:29,330
Vì vậy, ở đây chúng ta tìm ra sáu và nút ngay trước của nút sáu là 12. Vậy tiền thân của nút sáu này là 12. Tiền thân của nút 10 này là gì?

1292
00:01:29,530 --> 00:01:49,300
Đầu tiên chúng ta cùng tìm hiểu 10 cái tên trong danh sách này nhé. Và đây, xem nào, đây là nó, 10. Nút ngay trước đó, lên 10 cũng là nút này. Vậy tiền thân của nút 10 này là không hiểu tiền thân của nút này là gì?

1293
00:01:49,870 --> 00:02:02,200
Bây giờ hãy nói về sự kế thừa của một nút. Bây giờ hãy nói về người kế nhiệm. Người kế vị. Nút là nút tiếp theo ngay lập tức theo thứ tự của cây nhị phân.

1294
00:02:02,530 --> 00:02:14,050
Vậy sự kế thừa của nút chín này là gì. Vì vậy, đây là Nút chín và nút tiếp theo ngay lập tức là hai. Vì vậy, người kế nhiệm của Nút chín này cũng là nút này.

1295
00:02:14,350 --> 00:02:28,300
Vậy cái kế thừa của nút này, không phải chín, bây giờ cái kế thừa của nút sáu này là gì? Đầu tiên, chúng ta hãy tìm ra sáu người trong tòa tháp này. Vì vậy, ở đây chúng ta tìm ra 6 và nút tiếp theo ngay lập tức là 13.

1296
00:02:28,510 --> 00:02:42,640
Vậy phần kế tiếp của nút sáu này là 13. Phần kế tiếp của nút ba này là gì? Đầu tiên chúng ta hãy tìm hiểu ba trong tòa tháp. Vì vậy, ở đây chúng tôi tìm ra ba.

1297
00:02:43,060 --> 00:02:58,600
Bây giờ, nút tiếp theo, nút tiếp theo ngay lập tức của ba trong quá trình truyền tải này là 14. Vậy nút
kế tiếp của nút ba này, đây không phải là 14. Chúng ta đã hiểu đâu là tiền thân và đâu là kế tiếp. 

@@@



1298
00:00:00,570 --> 00:00:12,600
Trong video này chúng ta sẽ nói về cây nhị phân là gì, cây nhị phân là một cấu trúc dữ liệu cây trong đó nút cha của nó có thể có tối đa hai con.

1299
00:00:13,380 --> 00:00:26,370
Đây là một ví dụ về cướp bóc. Nút này có hai con. Nút này có hai nút con, nút này, nút này. Và đối với điều này thì không, không có con nào trong định nghĩa nhị phân.

1300
00:00:26,580 --> 00:00:48,560
Chúng tôi thấy rằng nút cha có thể có tối đa hai nút con. Vậy theo định nghĩa thì có thể nói đây là cây nhị phân. Đây là cây nhị phân, nút này cũng sẽ có hai con, nút này có hai con, nút này có hai con, nút này không có con, nút này không có con.

1301
00:00:48,960 --> 00:01:01,410
Không bảy này không có con và không ba không có con. Vì vậy, nó tuân theo định nghĩa của cây nhị phân. Vậy đây cũng là cây nhị phân. Cây này cũng là cây nhị phân.

1302
00:01:01,800 --> 00:01:13,200
Nút này có hai con, nút này có hai con, nút này có ba con. Và tất cả các hạch bạch huyết mà chúng tôi thấy đều không có con. Đây không phải là bốn không có con.

1303
00:01:13,200 --> 00:01:26,640
Nút thứ năm này không có con, không có và không có con. Không phải vậy. Năm không có con. Vậy theo định nghĩa thì có thể nói đây là cây nhị phân. Đây là ví dụ về cây nhị phân.

1304
00:01:26,830 --> 00:01:37,800
Bây giờ chúng ta hãy xem thêm một số ví dụ. Đây là cây nhị phân ở bang này có hai cây con. Nút này có hai con. Nút này có hai con. Nút này không có con.

1305
00:01:37,800 --> 00:01:54,270
Nút này không có con. Nút này không có con. Nút này chỉ có một nút con. Và điều này không có con. Trong định nghĩa nhị phân. Thứ hai, chúng ta thấy rằng mỗi nút chỉ nên có tối đa hai nút con.

1306
00:01:54,810 --> 00:02:11,280
Cây này tuân theo các thuộc tính của cây nhị phân. Vậy đây là cây nhị phân hợp lệ. Đây cũng là cây nhị phân mà nút này có trên các nút con. Nút này có một nghìn tỷ, nút này có con, nút này không có con.

1307
00:02:11,820 --> 00:02:25,170
Vậy ở Notkin có nhiều nhất là hai con ở đây. Bạn thấy nút cây này có một nút con và nó không phải là không có nút con. Vậy đây là cây nhị phân. Đây cũng là một cây nhị phân.

1308
00:02:25,170 --> 00:02:35,760
Điều này được gọi là cây nhị phân lệch. Nút này có một nút con. Nút này, nút này có con và không có con. Vậy đây là cây nhị phân hợp lệ.

1309
00:02:37,200 --> 00:02:48,870
Đây cũng là cây nhị phân hợp lệ. Điều này được gọi là đúng. Cây nhị phân lệch. Chúng tôi có một triệu cho nút này không có ở trẻ em. Nút này có một nút con.

1310
00:02:48,870 --> 00:03:07,140
Nút này không có con. Vì vậy, đây cũng là một cây nhị phân hợp lệ. Như vậy chúng ta đã hiểu thế nào là cây nhị phân trong một cây, nếu thấy một nút chứa nhiều nhất hai nút con thì có thể thấy cây đó là cây nhị phân.

1311
00:03:07,560 --> 00:03:19,820
Chúng ta đã hiểu cây nhị phân là gì. Không, hãy xem nào. Một số ứng dụng là cây nhị phân. Banita được sử dụng để truy cập dữ liệu trong bộ định tuyến một cách dễ dàng và nhanh chóng.

1312
00:03:19,830 --> 00:03:44,660
Thuật toán. Chúng tôi sử dụng cây nhị phân để triển khai cấu trúc dữ liệu. Chúng tôi sử dụng cây nhị phân và trình biên dịch sử dụng cây nhị phân để xây dựng cây cú pháp.
Chúng ta có thể xác thực mã bằng cách sử dụng cây cú pháp và theo cú pháp, chúng ta sử dụng cây nhị phân để hiểu cây nhị phân là gì và các ứng dụng của nhị phân. 

@@@



1313
00:00:01,110 --> 00:00:13,770
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về các loại cây nhị phân khác nhau trong video này. Chúng ta sẽ nói về cây nhị phân đầy đủ, cây nhị phân hoàn hảo và cây nhị phân hoàn chỉnh.

1314
00:00:14,130 --> 00:00:28,040
Hãy bắt đầu với cây nhị phân đầy đủ. Cây nhị phân đầy đủ là gì? Cây nhị phân là cây nhị phân đầy đủ. Nếu mỗi nút có dero hoặc hai nút con thì đây là một nhóm cướp.

1315
00:00:28,080 --> 00:00:46,050
Hạt này có hai con. Nút này có hai con. Nút này có hai con. Nút này, nút này, nút này và ghi chú này không có con. Điều đó có nghĩa là nút đầy đủ bốn, sáu, bảy và ba này không có nút con nào.

1316
00:00:46,200 --> 00:00:57,060
Đây là cây nhị phân đầy đủ ở đây. Đây cũng là một cây đa đầy đủ. Nút này có hai con. Nút này có hai con và đây là các hạch bạch huyết.

1317
00:00:57,360 --> 00:01:10,740
Nút này không có nút con. Vậy đây là cây nhị phân cho cây này. Ta thấy cây này cũng là cây nhị phân đầy đủ. Nút này có hai con. Nút này có hai con.

1318
00:01:11,280 --> 00:01:25,260
Đối với nút này, hai, bốn và năm không có con nào. Vậy có thể nói đây là cây nhị phân đầy đủ. Đã hiểu thế nào là một thực thể toàn diện. Bây giờ hãy nói về sự hoàn hảo.

1319
00:01:25,260 --> 00:01:37,440
Một cây nhị phân. Cây nhị phân hoàn hảo là gì? Một hệ nhị phân. Đó là một cây nhị phân hoàn hảo trong đó tất cả các nút bên trong có hai nút con và tất cả các nút bạch huyết đều ở cùng cấp độ.

1320
00:01:38,340 --> 00:01:56,240
Đây là một ví dụ về cây nhị phân hoàn hảo. Người này không có hai đứa con và hai đứa này không có hạch bạch huyết của chúng tôi. Từ định nghĩa hạch ta biết hạch không có con và người ta nói cùng cấp này là sống không cùng cấp.

1321
00:01:56,370 --> 00:02:08,580
Vậy đây là cây nhị phân hoàn hảo ở đây. Đây cũng là một cây nhị phân hoàn hảo. Nút này chứa hai nút con. Nút này chứa hai nút con. Điều này không có hai đứa trẻ.

1322
00:02:08,850 --> 00:02:22,320
Và chúng tôi có bốn hạch bạch huyết của bạn. Hạch không có con và các hạch nằm ngang nhau. Chúng tôi thấy rằng họ ở cùng cấp độ. Vậy đây là cây nhị phân hoàn hảo.

1323
00:02:23,490 --> 00:02:32,460
Điều này cũng hoàn hảo. Bonaduce, nút này chứa hai đứa trẻ. Nút này chứa hai nút con. Nút này chứa hai nút con. Nút này chứa trẻ em.

1324
00:02:32,940 --> 00:02:43,890
Nút này chứa hai nút con. Đối với ghi chú này, nút này cũng chứa hai nút con. Và ghi chú này cũng có hai đứa trẻ. Và đây đều là các hạch bạch huyết.

1325
00:02:44,000 --> 00:03:00,930
Được rồi, các hạch 8, 9, 10, 11, 12, 13, 14 và 15 là các hạch bạch huyết và các hạch bạch huyết đều ở cùng cấp độ. Vậy đây là cây nhị phân hoàn hảo. Chúng ta đã hiểu cây nhị phân hoàn hảo là gì.

1326
00:03:01,740 --> 00:03:19,740
Không, hãy nói về cây nhị phân hoàn chỉnh. Cây nhị phân hoàn chỉnh là gì? Cây nhị phân là cây nhị phân hoàn chỉnh. Nếu tất cả các cấp độ được lấp đầy hoàn toàn, ngoại trừ cấp độ cuối cùng và cấp độ cuối cùng có tất cả các phím càng muộn càng tốt.

1327
00:03:20,370 --> 00:03:34,370
Đây là một ví dụ về cây nhị phân hoàn chỉnh. Đây cũng là một ví dụ về chứng hoảng loạn hoàn toàn. Và ở đây chúng ta thấy màn cuối cùng có tất cả các phím càng muộn càng tốt.

1328
00:03:34,380 --> 00:03:49,530
Chúng ta thấy đây là các hạch bạch huyết và đây là cấp độ cuối cùng. Cấp độ cuối cùng có tất cả các phím càng muộn càng tốt. Vậy đây là cây nhị phân hoàn chỉnh cho cây này.

1329
00:03:49,530 --> 00:04:07,470
Chúng ta thấy rằng mọi sự sống đều được lấp đầy hoàn toàn. OK, trường cấp độ này và cấp độ này cũng đã được điền. Nhưng ở đây chúng ta thấy màn chơi này không được lấp đầy hoàn toàn mà màn chơi này có tất cả các phím càng muộn càng tốt.

1330
00:04:07,470 --> 00:04:20,790
Vậy có thể nói đây là cây nhị phân hoàn chỉnh. Chúng ta đã hiểu cây nhị phân hoàn chỉnh trong video này
là gì. Chúng ta đã nói về cây nhị phân đầy đủ, cây nhị phân hoàn hảo và cây nhị phân hoàn chỉnh. 

@@@



1331
00:00:00,630 --> 00:00:10,450
Đây rồi các bạn. Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về cách triển khai cây nhị phân, cách biểu diễn cây nhị phân.

1332
00:00:11,580 --> 00:00:27,490
Đây là một ví dụ về cây nhị phân. Chúng ta có thể triển khai nhị phân bằng cách sử dụng cấu trúc dữ liệu mảng hoặc lindqvist. Trước tiên, hãy xem cách chúng ta có thể triển khai cây nhị phân là danh sách liên kết.

1333
00:00:28,410 --> 00:00:40,560
Giả sử đây là cây nhị phân đã cho và cây này chúng ta có thể tạo bằng cách sử dụng danh sách liên kết trong nút của danh sách DoubleLine. Ở đây chúng ta có agist của nút này không không không một.

1334
00:00:40,920 --> 00:00:57,810
Điều này không chứa ba thuộc tính cho con trỏ và con trỏ bên trái của Deira và con trỏ bên phải là bên trái. Con trỏ đang trỏ tới con Lepp. Con trỏ bên phải đang trỏ tới nút con bên phải và có các cạnh của nút này.

1335
00:00:58,170 --> 00:01:16,350
Và ở đây chúng ta có nút này, đây là nút gốc con bên trái, nút tuyến đường này và đây là địa chỉ của nút này. Và chú này chứa ba thuộc tính left và right con ở đây là chuỗi các cạnh của con và ở đây là một chuỗi con thẳng đứng.

1336
00:01:16,820 --> 00:01:30,730
Con này nói đúng đó con. Nút này không có con trái, không có con phải. Nút này cũng không có con, không có con đúng. Quyền kết thúc của nút tuyến đường này là không.

1337
00:01:30,840 --> 00:01:45,720
Đây là địa chỉ của nút con phù hợp trong việc khôi phục địa chỉ của nút này. Nút này có ba thuộc tính con trái và con phải và Adara. Và đây là địa chỉ của đứa trẻ ở đây nhìn chằm chằm vào đứa trẻ ngạc nhiên này không.

1338
00:01:45,720 --> 00:01:55,710
Không có con trái và con phải cho việc này, không phải hiện tại chúng ta không có con trái và con phải. Và đây là cách chúng ta có thể biểu diễn cây nhị phân bằng cách sử dụng pháp lý.

1339
00:01:56,580 --> 00:02:09,190
Đã hiểu cách chúng ta có thể triển khai cây nhị phân bằng cách sử dụng dài nhất trong phần thảo luận này. Chúng ta sẽ xem cách chúng ta có thể tạo cây nhị phân bằng cách sử dụng cấu trúc dữ liệu hợp pháp và tất cả đều thực hiện tất cả các hoạt động tiêu chuẩn.

1340
00:02:09,570 --> 00:02:28,070
Bây giờ hãy nói về cách chúng ta có thể triển khai cây nhị phân bằng cấu trúc dữ liệu của mình. Chúng tôi có mảng tám, và ở đây chúng tôi có chỉ mục số một, hai, ba, bốn, năm, sáu, bảy, ban đầu sẽ chọn mục từ chỉ mục trên theo lộ trình.

1341
00:02:28,130 --> 00:02:40,070
Vì vậy, đây là tuyến đường của chúng tôi. Không, hãy tạo nút gốc, nút gốc thứ hai. OK bây giờ bên trái ghi chú này sẽ chọn mảng công thức này tới X đây.

1342
00:02:40,070 --> 00:02:57,000
X có nghĩa là chỉ số hiện tại. Vậy là hai lần chỉ gần bằng hai. Vì vậy, nó sẽ thiết lập đứa trẻ. Bất kể chúng ta có gì ở chỉ số này, hãy đặt 20 sang một bên. Bây giờ, hãy tìm nó đúng.

1343
00:02:57,120 --> 00:03:09,820
Trẻ sẽ thấy đúng, trẻ dùng công thức này để diễn đạt một hoặc hai lần một cộng một bằng hai, ba. Vì vậy tất cả hãy chèn ngay vào đây những gì chúng ta có ở chỉ số 3.

1344
00:03:10,190 --> 00:03:23,450
Vì vậy, hãy chèn vào đây ngày hôm nay. Bây giờ là ghi chú 20. Hãy tìm đứa trẻ. Vì vậy, hai lần ba đến bốn. Vì vậy, hãy để đứa trẻ này, không phải hai mươi là bất cứ điều gì chúng ta có ở chỉ số bốn.

1345
00:03:23,660 --> 00:03:38,930
Vậy hãy chèn vào đây giếng số 40. Bây giờ, kết quả của việc này, không phải hai mươi, là khai thác một. Điều đó có nghĩa là bất kỳ giá trị nào chúng ta có ở chỉ số 5. Vì vậy bây giờ chúng ta hãy chèn năm mươi vào đây cho Nithari này.

1346
00:03:39,350 --> 00:04:00,340
Đứa bé là hai X, nghĩa là ba nhân hai. Có sáu. Vì vậy, bất kỳ giá trị nào chúng ta có ở chỉ số sáu, hãy chèn dưới dạng con của nút thứ ba mươi này. Vì vậy bây giờ chúng ta hãy chèn vào đây sáu mươi số con bên phải cứ hai X cộng một có chỉ số bảy, ba nhân hai cộng một bằng hai bảy.

1347
00:04:00,440 --> 00:04:11,110
Vì vậy, bất cứ điều gì chúng ta có ở chỉ số bảy sẽ chèn vào đây. Vì vậy, hãy chèn vào đây bảy mươi bây giờ hãy tìm nó. Hãy kết thúc nút này. Bốn mươi. Vậy là năm nay bốn mươi tuổi.

1348
00:04:11,120 --> 00:04:28,010
Vậy hai lần bằng tám. Nó nằm ngoài mọi ranh giới. Vì vậy, hãy chèn bây giờ dưới dạng trái và phải để thể hiện một là chín vì vậy nó sẽ chèn dưới dạng tiêu đề con bên phải bây giờ bên trái và bên phải bây giờ và bảy cho phần còn lại của nút.

1349
00:04:29,000 --> 00:04:53,660
Đây là cách chúng ta có thể xây dựng cây nhị phân bằng Herry. Đây là cách chúng ta có thể thực hiện nó một cách tự nhiên. Việc sử dụng mảng trong phần này của khóa học này sẽ triển khai cây nhị phân bằng cấu trúc dữ liệu ngôn ngữ cũng như sử dụng cấu trúc dữ liệu của chúng tôi và tất cả đều thực hiện tất cả các hoạt động tiêu chuẩn để triển khai theo chủ nghĩa pháp lý cũng như triển khai theo khu vực.

1350
00:04:53,930 --> 00:05:13,730
Trong phần còn lại của khóa học này, chúng ta sẽ nói về việc triển khai các nhà ngôn ngữ học chỉ trong phần này của khóa học này, chúng ta sẽ nói về việc triển khai các nhà ngôn ngữ học và việc triển khai ARRY việc triển khai danh sách liên kết hiệu quả hơn nhiều so với việc triển khai danh sách liên kết của chúng tôi. Chúng tôi sẽ sử dụng tùy chọn triển khai danh sách liên kết cho phần còn lại của khóa học này.

1351
00:05:14,270 --> 00:05:29,040
Nhưng đối với phần thảo luận này, tôi sẽ nói về việc triển khai Linklaters và cách triển khai của chúng tôi để bạn hiểu rõ hơn. Haviv hiểu
cách chúng tôi có thể triển khai cây nhị phân bằng cách sử dụng nhà ngôn ngữ học và cấu trúc dữ liệu của chúng tôi trong phần tiếp theo. 

@@@



1352
00:00:01,200 --> 00:00:18,030
Này, có chuyện gì vậy các bạn, mọi người quay lại với video này nhé, trong video này chúng ta sẽ thực hiện bằng cách trung hòa cấu trúc dữ liệu ngôn ngữ. Phần này của diễn ngôn sẽ thực hiện tạo cây nhị phân, chèn nguồn xóa, không xóa cây nhị phân.

1353
00:00:18,240 --> 00:00:28,820
Và phương pháp của Trevor trong Phương thức truyền tải sẽ duyệt cây nhị phân đó bằng cách sử dụng thuật toán truyền tải này để sắp xếp thứ tự bài đăng và thứ tự cấp độ của bạn.

1354
00:00:29,160 --> 00:00:41,760
Trong video này, chúng ta sẽ nói về hai phương pháp cây thỏ tuyệt vời này và chèn đầu tiên vào việc tạo cây nhị phân. Sau đó chúng ta sẽ xem cách chèn dữ liệu vào cây nhị phân.

1355
00:00:42,480 --> 00:01:00,810
Bây giờ hãy nói về cây nhị phân cret. Đây là nhà ngôn ngữ học đang học về cây nhị phân của lớp chúng tôi. Bên trong lớp này chúng ta có một node. Nút này có ba giá trị thuộc tính và hai con trỏ trái và phải ở đây hoặc khai báo gốc của cây nhị phân của chúng ta.

1356
00:01:01,230 --> 00:01:13,560
Và sau đó chúng ta có phương pháp này. Tạo cây nhị phân bên trong phương pháp này hoặc tìm hiểu cách đặt gốc để tải xuống. Vì vậy, root của chúng ta bây giờ là node. Đây là cây nhị phân và đây là nút gốc của chúng ta.

1357
00:01:13,560 --> 00:01:28,680
Bây giờ, hãy nhìn xem, ban đầu chúng ta có gốc này không phải là null. Bây giờ hãy nói về phương pháp chèn. Đây là phương pháp chèn. Phương thức này nhận giá trị tham số. Bên trong đây, chúng tôi đang tạo nút mới có giá trị và không kiểm tra.

1358
00:01:28,690 --> 00:01:52,820
Nếu chúng ta đang ngồi xuống, chúng ta đang thiết lập gốc của mình cho nút mới và chúng ta sẽ quay lại bằng câu lệnh bằng văn bản này hoặc chỉ tồn tại từ lệnh gọi hàm của chúng ta. Nếu hiện tại Rudy không đúng, nếu chúng ta có một số giá trị trong cây nhị phân thì chúng ta đang tạo một hàng đợi và sau đó chúng ta thêm các nút tuyến đường vào hàng đợi và khi đó chúng ta đang chạy một thế giới giá trị, không trống rỗng.

1359
00:01:52,980 --> 00:02:08,670
Chúng tôi sẽ bật ra phần tử trên cùng từ CU và chúng tôi đang kiểm tra xem loại bản ghi có biết vị trí của nút hiện tại nhất định chấm hình elip đến nút mới ở đây hay chỉ đặt ghi chú mới cho Lebanon của nút hiện tại của chúng tôi.

1360
00:02:08,670 --> 00:02:21,990
Nếu chúng ta nhìn thấy địa ngục chính trị hiện tại và chúng ta đang tồn tại từ tình yêu của mình bằng cách sử dụng tuyên bố này, nếu không kiểm tra xem nút hiện tại có cấp tiến Struhl hay đặt ghi chú mới cho đúng đứa trẻ.

1361
00:02:22,300 --> 00:02:34,740
Được rồi, và chúng ta đang nhận được tình yêu. Tại sao lại có tuyên bố phanh này nếu tình trạng này có liên quan đến. Nếu không, chúng ta sẽ thêm dòng Childersburg trái và phải vào.

1362
00:02:34,830 --> 00:02:49,560
Q Và chúng tôi đang thực hiện quá trình này cho đến khi đạt được điều kiện đúng này hoặc ngăn xếp của chúng tôi trống. Bây giờ hãy xem nó hoạt động như thế nào nếu chúng ta gọi phương thức này là chèn trong trường hợp này hay chúng ta sẽ tạo một nút mới mười.

1363
00:02:50,040 --> 00:03:01,950
Vì vậy, chúng tôi đang tạo một nút mới cho đến đây, tuyển dụng nút mới và không kiểm tra nút đó ngay từ đầu. Rudy bây giờ. Vì vậy, chúng ta sẽ thiết lập một tuyến đường đến nút này và chúng ta sẽ lấy nó từ lệnh gọi hàm của mình.

1364
00:03:02,100 --> 00:03:16,710
Vậy đây là lộ trình của chúng ta, phải không? Và con trái và con phải của nút này hiện được mặc định. Vì vậy, bây giờ chúng ta có nút gốc mười. Chúng tôi gọi phương thức này là chèn hai mươi, sau đó chúng tôi sẽ tạo một nút mới hai mươi.

1365
00:03:16,920 --> 00:03:27,900
Và chúng ta thấy Rudi không bằng bây giờ. Vì vậy, ở đây chúng tôi tạo một hàng đợi mới. Vì vậy, ở đây bạn tạo một hàng đợi. Và đây là hàng đợi của chúng tôi và chúng tôi sẽ thêm tuyến đường của mình chứ không phải vào hàng đợi.

1366
00:03:28,140 --> 00:03:40,830
Vì vậy, hãy thêm vào đây nút tuyến đường thứ mười. Bây giờ chúng ta thấy hàng đợi không trống, vì vậy chúng ta sẽ đưa phần tử cứng đó vào phía trước hàng đợi của mình. Vì vậy, ở đây lưu trữ nút 10.

1367
00:03:40,920 --> 00:03:53,130
Vì vậy, hãy bật ra ghi chú này và chúng tôi đưa ra ghi chú này. Bây giờ, chúng ta có các bản ghi hiện tại cho nút mười. Điều đó có nghĩa là nút gốc. Sau đó, chúng tôi sẽ kiểm tra xem hiện tại có theo thứ tự không.

1368
00:03:53,130 --> 00:04:05,660
Bây giờ chúng ta sẽ đặt ghi chú mới vào nút bên trái ở đây. Chúng tôi thấy rằng nút hiện tại là bây giờ. Vì vậy, hãy đặt nút 20 ở bên trái của ghi chú này.

1369
00:04:05,670 --> 00:04:17,160
Được rồi, vậy hãy đặt ở đây hai mươi. Vì vậy, chúng tôi đã chỉ định nút 20 đó làm phía bên trái của nút tuyến đường này và sau đó chúng tôi sẽ phá vỡ. Vậy vòng lặp này dừng ở đây.

1370
00:04:17,280 --> 00:04:29,820
Bây giờ chúng ta đã hoàn thành việc gọi hàm này. Bây giờ hãy gọi lại hàm này với giá trị tarde. Bây giờ điều gì sẽ xảy ra? Chúng tôi sẽ tạo một nút mới có giá trị tarty và chúng tôi thấy nút của Rudi không bằng giá trị hiện tại.

1371
00:04:29,910 --> 00:04:51,060
Vậy điều kiện này là sai. Sau đó, chúng ta sẽ khai báo Q và bên trong góc phần tư này tại nút gốc có 10. Vậy hãy thêm Hurtin' vào. Sau đó, chúng ta sẽ chạy Aluf, sau đó chúng ta sẽ quảng bá phần tử phía trước từ Q của chúng ta. Vì vậy, hãy hỗ trợ việc loại bỏ khỏi Q này. Và hãy kiểm tra nút hiện tại này có bằng hai hay không.

1372
00:04:51,060 --> 00:05:06,890
Không, không, bên trái không phải của nút. Chúng tôi xuất hiện từ nút Q của mình ở nút mười. Bây giờ chúng ta sẽ kiểm tra đồ thị của nút này. Người hay nói nhẹ câu này là, không, không, không, chúng ta hãy ghi chú cho đúng, bây giờ có đúng không, có danh dự hay không?

1373
00:05:06,910 --> 00:05:26,860
Vâng, đúng vậy. Vì vậy, hãy đặt ghi chú hiện tại cho con bên phải của điều này. Không phải vậy. Chúng ta hãy thêm vào đây bữa tiệc ghi chú đó, sau đó là cơ quan của chúng ta sẽ được đại diện, đại loại như thế này, và họ sẽ phá vỡ những thứ tự do bất cứ khi nào nó tìm thấy trạng thái ngắt này, khi đó chúng ta đã hoàn thành lệnh gọi hàm này.

1374
00:05:27,070 --> 00:05:36,330
Bây giờ, hãy gọi lại hàm này. Chúng tôi đã phát triển 40. Bây giờ chúng tôi sẽ làm gì? Chúng ta sẽ tạo một ghi chú mới có giá trị là bốn mươi. Khi đó ta thấy nốt gốc vẫn không rỗng.

1375
00:05:36,490 --> 00:05:49,900
Vì vậy, chúng ta sẽ khai báo Q và bên trong này. Q Chúng ta sẽ chèn nút gốc vào đó để đảm bảo rằng bây giờ chúng ta đang chạy tốt nếu Q không trống, do đó dòng điện hiện đang được cấu thành sẽ đi đến nút mười.

1376
00:05:50,170 --> 00:05:59,290
Bây giờ chúng ta sẽ lấy những thứ đó. Lưu ý nhỏ về nút hiện tại của chúng tôi là bây giờ. Không. Vậy giả sử điều kiện này, điều kiện này cũng sai. Vậy bạn sẽ làm gì?

1377
00:05:59,320 --> 00:06:10,210
Chúng ta sẽ thêm con hai mươi và con bên phải thứ ba vào Q, vì vậy Q sẽ được biểu diễn như thế này. Trong lần lặp tiếp theo, chúng ta sẽ điền vào nút thứ hai mươi.

1378
00:06:10,240 --> 00:06:25,210
Vì vậy, bây giờ đây là nút hiện tại của bạn, giả sử con nhỏ của nút thứ hai mươi này có giá trị rỗng không? Vâng, đúng vậy. Vì vậy, hãy chèn vào đây nút bốn mươi. Bây giờ chúng ta có Q3 dễ thương và ở đây chúng ta có tuyên bố nghỉ giải lao.

1379
00:06:25,330 --> 00:06:35,380
Vì vậy, hãy ngừng điều trị. Tất cả những điều này đã diễn ra được một thời gian kể từ khi chúng ta gọi hàm này, nên chúng ta đã hoàn thành lệnh gọi hàm này và Banerji của chúng ta được thể hiện, đại loại như thế này.

1380
00:06:35,500 --> 00:06:46,090
Sau khi thực hiện lệnh gọi hàm này, bất cứ khi nào chúng ta gọi lại nhạc cụ, tín hiệu sẽ được tạo. Vì vậy, bạn có thể coi Q trống. Bây giờ hãy gọi lại hàm với Valla 50.

1381
00:06:46,300 --> 00:07:01,600
Bây giờ, bạn định làm gì? Chúng ta sẽ tạo một nút mới năm mươi và sau đó chúng ta sẽ khai báo nút mới. Q Đây là cái mới của bạn. Q Và hãy chèn vào đây nút mười, vì vậy hãy chèn một điều chắc chắn thì chúng ta sẽ chạy giá trị này, sau đó chúng ta sẽ chạy trong năm nay.

1382
00:07:01,600 --> 00:07:12,910
Chúng tôi sẽ hỗ trợ nhóm nút này. Bây giờ, đây là nút hiện tại của chúng tôi. Hãy tuyên truyền và chúng ta thấy bên trái và bên phải lưu ý không phải bây giờ. Vì vậy, hãy thêm rẽ trái và rẽ phải vào đây.

1383
00:07:13,210 --> 00:07:24,850
Vì vậy, hai mươi sẽ được thêm vào đây và hôm nay sẽ được thêm vào đây. Mười đã được gỡ bỏ rồi. Được rồi, trong lần lặp tiếp theo, đi tới phần tử phía trước sẽ có 20.

1384
00:07:25,030 --> 00:07:46,900
Vì vậy, nút hiện tại của chúng tôi là 29. Ở phía bên trái của ghi chú này không phải là bây giờ mà là phía bên phải là bây giờ. Vì vậy, hãy chèn nút năm mươi vào đây. Vì vậy, bạn sẽ chèn nút đó vào năm mươi và nút này đã xuất hiện ở nút thứ hai mươi vì vậy hãy chèn năm mươi vào đây rồi sau đó hai người sẽ được biểu thị, đại loại như thế này.

1385
00:07:47,230 --> 00:08:01,810
Bây giờ hãy gọi lại vấn đề này là 60. Chúng ta sẽ tạo một nút mới có giá trị 60. Và ở đây, hãy thêm nút tuyến đường vào Q của chúng ta và sau đó chúng ta sẽ truyền phần tử này từ Q của mình. Vì vậy, hãy bật hệ thống ra ngay bây giờ.

1386
00:08:01,810 --> 00:08:17,320
Đây là nút hiện tại của chúng tôi. Bây giờ chúng ta thấy rằng bên trái và bên phải không phải là bây giờ. Vì vậy, hãy cộng trái và phải vào Q của chúng ta Vì vậy, 28 sẽ được thêm vào đây và 30 sẽ được thêm vào đây, vì vậy 20 sẽ được thêm vào đây và hôm nay sẽ được thêm vào đây trong lần lặp tiếp theo của điều này.

1387
00:08:17,320 --> 00:08:28,360
Chà, nếu chúng ta định hỗ trợ nút hai mươi này, thì nút hiện tại của chúng ta là nút hai mươi này và chúng ta thấy rằng kênh trái và phải, nút hai mươi này bây giờ không phải là nút.

1388
00:08:28,360 --> 00:08:36,780
Vậy bạn sẽ làm gì? Chúng tôi sẽ thêm kênh trái và phải vào hàng đợi này. Vậy hãy cộng 40 và để 50 còn lại. Bây giờ chúng ta sẽ làm gì?

1389
00:08:36,820 --> 00:08:53,350
Chúng tôi sẽ truyền bá nút này ba từ nút này. Q Không phải hôm nay là nút hiện tại của chúng tôi. Bây giờ, bạn định làm gì? Chúng ta sẽ kiểm tra phía bên trái của nút 30 này và bây giờ đã có để chúng ta có thể chèn nút sáu mươi, vì vậy hãy chèn nút sáu mươi, khi đó tiền của chúng ta sẽ được biểu thị, đại loại như thế này.

1390
00:08:53,560 --> 00:09:05,080
Bây giờ hãy gọi lại vấn đề này với giá trị bảy mươi. Bây giờ chúng ta sẽ làm gì? Chúng tôi sẽ thêm ghi chú vào đây. Q Vì vậy, mười nút sẽ được thêm vào đây và chúng tôi sẽ hỗ trợ nút mười này ngay bây giờ trong năm nay.

1391
00:09:05,500 --> 00:09:18,490
Hãy đặt nút này ở vị trí thứ mười và thêm kênh trái và phải vào nút này. Q Vậy là bây giờ chúng ta sẽ bật nút này. Hai mươi, vậy là hai mươi. Vì vậy, đây là nút hiện tại của bạn.

1392
00:09:18,520 --> 00:09:29,260
Chúng ta thấy bên trái và bên phải không phải là bây giờ. Vì vậy, hãy thêm Tokuzo trái và phải để thêm vào đây và năm mươi sẽ được thêm vào đây. Sau đó, chúng tôi sẽ hỗ trợ nút này ngay hôm nay.

1393
00:09:29,410 --> 00:09:39,400
Nút hiện tại của chúng tôi là nút thứ ba mươi chín này. Chúng tôi sẽ cố tình quyết định sáu mươi không phải là bây giờ mà là trái sang phía bên phải. Quyền là bây giờ. Vì vậy chúng ta có thể chèn vào đây nút bảy mươi.

1394
00:09:39,550 --> 00:09:54,610
Vì vậy, hãy chèn vào đây nút bảy mươi. Được rồi, hệ nhị phân của chúng ta sẽ được biểu diễn, đại loại như thế này. Vậy là chúng ta đã hoàn thành lệnh gọi hàm này và sau đó bạn có được cây nhị phân này và đây là những gì chúng ta có thể chèn giá trị vào cây nhị phân.

1395
00:09:54,790 --> 00:10:09,650
Nếu chúng ta gọi lại vấn đề này là tám mươi thì tám sẽ được thêm vào đây. Chúng tôi đã hiểu. Cách thức hoạt động của phương pháp này, phương pháp này sẽ khiến Bygrave mất thời gian, độ phức tạp và do độ phức tạp về không gian, nếu bạn không hiểu phương pháp này thực sự hoạt động như thế nào.

1396
00:10:09,830 --> 00:10:17,660
Hãy thử viết mọi thứ ra một tờ giấy, khi đó nó sẽ có ý nghĩa, thậm chí là một gợi ý. Nếu
bạn gặp khó khăn trong việc hiểu điều này với lời giải thích, hãy cho chúng tôi biết. 

@@@



1397
00:00:01,170 --> 00:00:10,910
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng ta sẽ nói về phương pháp này. Bây giờ hãy xem chúng ta có thể thực hiện phương pháp này như thế nào.

1398
00:00:11,400 --> 00:00:23,610
Việc chuyển đổi thuật toán của chúng tôi cho phương pháp tìm kiếm. Phương pháp này sẽ trở lại lỗi của chúng tôi. Nếu giá trị đã cho tồn tại trong cây nhị phân đó thì nó sẽ trở về ELT.

1399
00:00:23,610 --> 00:00:50,460
Nó sẽ sai. Phương thức này lấy một giá trị tham số liên quan đến việc chúng ta sắp in trống và chúng ta sẽ thoát bằng cách trả về false. Sau đó, chúng tôi khai báo Q và chúng tôi đang thêm gốc chứ không phải Q và chúng tôi đang chạy trực tiếp rồi lấy ra phần tử phía trước từ Q Và chúng tôi đang kiểm tra xem liệu chúng tôi có bỏ qua giá trị có đi đến giá trị đã cho hay không, sau đó sẽ quay lại .

1400
00:00:50,640 --> 00:01:08,040
Nếu không, chúng tôi sẽ kiểm tra xem nó có rỗng hay không hoặc chèn nó vào. Q Và sau đó chúng ta sẽ kiểm tra. Nếu người viết không biết rằng chúng ta sẽ làm như vậy thì chúng ta sẽ chèn đứa trẻ vào Q. Nếu chúng ta thấy điều kiện này không bao giờ đúng thì sẽ chỉ trả về sai.

1401
00:01:08,490 --> 00:01:22,830
Bây giờ hãy xem phương pháp này hoạt động như thế nào. Cả hai đang đưa ra cái này theo nghĩa đen. Và nếu chúng ta gọi chuỗi phương thức này thì điều gì sẽ xảy ra ở đây? Chúng ta sẽ khai báo Q vì nút gốc không rỗng và ở đây chúng ta sẽ chèn nút gốc.

1402
00:01:22,830 --> 00:01:34,110
Vì vậy, hãy chèn số 10 vào đây, sau đó chúng ta sẽ điền vào nút gốc. Vì vậy, hãy nói về nút mười này. Và bây giờ chúng tôi thấy đây là nút hiện tại của bạn và chúng tôi thấy nút hiện tại rất gần với giá trị.

1403
00:01:34,230 --> 00:01:46,090
Giá trị của nút này gọi tới giá trị đã cho. Điều kiện này đã đúng. Vì vậy, nó sẽ trả về true cho lệnh gọi hàm này. Bây giờ chúng ta sẽ trả về true nếu chúng ta gọi phương thức này với giá trị năm mươi.

1404
00:01:46,170 --> 00:01:56,970
Bây giờ hãy xem nó hoạt động như thế nào. Đầu tiên, chúng ta sẽ chèn nốt gốc vào Q, sau đó chúng ta sẽ làm gì? Chúng tôi sẽ đề xuất nút tuyến đường này. Sau đó, chúng tôi có dòng điện đi đến nút tuyến đường này.

1405
00:01:57,060 --> 00:02:07,620
Bây giờ chúng ta sẽ phát triển nút này, phát triển cái này của Noriko đến 50, vì vậy chúng ta sẽ đối xử với đứa trẻ như bây giờ thì không. Vì vậy, hãy thêm nó vào Q rằng tiêu đề là null.

1406
00:02:07,620 --> 00:02:17,130
Không phải vậy. Hãy thêm nó vào hàng đợi. Bây giờ hãy nói về phần tử phía trước là 20. Nút hiện tại của chúng tôi là 20 đang phát triển, bây giờ 20 bằng 15.

1407
00:02:17,430 --> 00:02:30,300
Vì vậy, giả sử bên trái làm bên trái và bây giờ thì không. Vì vậy, hãy thêm 40 vào Q hiện tại bên phải trống. Vì vậy, hãy thêm 50 vào Q của chúng ta. Bây giờ chúng ta sẽ phổ biến phần tử hàng đầu này muộn hơn.

1408
00:02:30,660 --> 00:02:38,980
Vì vậy, hãy hỗ trợ tiểu học này. Bây giờ đây là phần tử hiện tại của bạn và hãy lấy phần con bên trái và bên phải và chúng ta chọn phần tử con bây giờ không phải. Đó không phải là bây giờ.

1409
00:02:39,000 --> 00:02:55,100
Vì vậy, hãy cộng 60 và 70 vào Q, sáu sẽ được thêm vào đây và 70 sẽ được thêm vào đây. Bây giờ hãy nói về 40 này từ Q của chúng ta. Bây giờ đây là Nurhasyim hiện tại của chúng ta và chúng ta đã chọn Reitzell là bây giờ và nó không bằng 50, OK.

1410
00:02:55,260 --> 00:03:05,370
Ở đây chúng ta cũng nên kiểm tra mục tiêu giá trị bằng 50 và chúng ta nói rằng chúng không bằng nhau. Vì vậy chúng ta đã chèn 60 và 70 vào Q và phù hợp. Phần tử phía trước có 40.

1411
00:03:05,730 --> 00:03:13,040
Bây giờ đây là nút hiện tại của chúng tôi và chúng tôi thấy bên trái và bên phải hiện tại. Vì vậy không cần phải làm gì ở đây và giá trị không bằng 4 không bằng 50.

1412
00:03:13,080 --> 00:03:25,820
Và hãy nói về phần tử phía trước của Q Đó là 50. Đây là nút hiện tại của chúng ta và chúng ta thấy giá trị của cái này bằng 50. Vì vậy, chúng ta tìm ra giá trị 50 trong cây này.

1413
00:03:25,950 --> 00:03:38,610
Vì thế nó sẽ quay trở lại. ĐÚNG VẬY. Và chúng ta đã hoàn thành. Chúng tôi đang quay trở lại sử dụng tuyên bố bằng văn bản này. Đây là cách hoạt động tìm kiếm này hoạt động và chúng ta có thể tìm kiếm một giá trị nhất định trong cây nhị phân này.

1414
00:03:38,760 --> 00:03:53,530
Nếu giá trị không tồn tại trong cây nhị phân thì nó sẽ trả về hy vọng sai lầm. Chúng tôi đã hiểu phương pháp này thực sự hoạt động như thế nào. Phương pháp
này sẽ thành công trong độ phức tạp về thời gian và chúng ta sẽ thành công trong độ phức tạp của không gian hoặc chúng ta đã hiểu chính lời giải thích này. 

@@@



1415
00:00:00,660 --> 00:00:16,860
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ thực hiện phương pháp này, xóa chứ không phải tháo dỡ. Will nhận một giá trị cho trước và phương thức này sẽ xóa giá trị đó khỏi cây nhị phân.

1416
00:00:17,280 --> 00:00:31,820
Bây giờ hãy xem chúng ta có thể triển khai phương pháp này như thế nào. Đầu tiên, hãy nói về nút sâu nhất, nút sâu nhất là nút cuối cùng mà chúng ta duyệt qua cây nhị phân theo thứ tự cấp độ Tarasoff.

1417
00:00:31,860 --> 00:00:42,750
Nó sẽ đi qua Binit này theo thứ tự cấp độ. Hãy tìm ra nút cuối cùng. Vì vậy, trước hết, bất kể nút này là 10, rồi 20, rồi 30, rồi 40, 50, 60, 70.

1418
00:00:42,960 --> 00:00:57,630
Vì vậy, 70 là nút cuối cùng mà chúng tôi tìm thấy bằng cách duyệt qua Banita này theo thứ tự cấp độ. Vậy 70 là nút sâu nhất trong cây nhị phân này nếu chúng ta được cấp banditti này.

1419
00:00:57,810 --> 00:01:07,970
Hãy cùng tìm hiểu ghi chú cuối cùng mà chúng ta tìm thấy bằng cách duyệt cây nhị phân này theo thứ tự cấp độ. Đầu tiên là khủng bố, sau đó là 20 và 30, rồi 40, rồi 50 và 60.

1420
00:01:08,130 --> 00:01:20,630
Vì vậy, 60 là nốt cuối cùng mà chúng tôi tìm thấy khi đi ngang qua hành tinh này và cấp độ của đường đi này. Vậy 60 là nút sâu nhất từ ​​trước đến nay. Với nhóm nhị phân này, nút sâu nhất là gì?

1421
00:01:21,240 --> 00:01:36,930
Vì vậy, chúng ta hãy tìm ra ghi chú cuối cùng đó bằng cách duyệt qua nhị phân này để sử dụng 11 lần duyệt khác, trước hết, sau đó là 20 đến 30, rồi 40, 50, 60, 70, rồi 80. Vậy đây là phút cuối cùng chúng ta có được bằng cách duyệt qua nhị phân này mức độ hoặc bất cứ điều gì.

1422
00:01:36,930 --> 00:01:50,610
Vì thế. Vậy 80 là sâu nhất. Không phải vì hy vọng Banita này. Chúng ta đã hiểu điều gì sâu sắc nhất, không phải bây giờ chúng ta có thể giải quyết vấn đề này như thế nào. Giả sử chúng ta muốn xóa nút 10.

1423
00:01:51,060 --> 00:02:02,970
Nút này nếu chúng ta xóa nút này sẽ có được hai nhà ngôn ngữ học riêng biệt. Vì thế nó sẽ có được 2 nhà ngôn ngữ học riêng biệt này. Và việc hòa nhập hai nhà ngôn ngữ học không phải là điều dễ dàng.

1424
00:02:03,810 --> 00:02:22,730
Sẽ có một chút việc khó khăn mà bạn phải giải quyết, vậy làm sao có thể làm được? Một lưu ý cụ thể khi bạn nói chúng tôi phải làm chứ không phải trước tiên hãy tìm lưu ý sâu sắc nhất và sẽ cập nhật lưu ý rằng chúng tôi phải làm với giá trị phòng thủ.

1425
00:02:23,160 --> 00:02:36,490
Vì vậy trong trường hợp này sẽ cập nhật chuỗi giá trị với giá trị Diepsloot. Nốt sâu nhất trong phần này, Banita, là 70. Vì vậy, chúng tôi đã cập nhật giá trị của nút 10 này thành 70 và họ sẽ xóa nốt sâu nhất.

1426
00:02:36,910 --> 00:02:50,420
Bây giờ chúng ta thấy rằng chúng ta đã xóa nút 10 cho bức thư phù phiếm này. Bạn cũng muốn xóa nút 10. Sau đó bạn sẽ làm gì? Chúng tôi sẽ cập nhật Vallentine này với nút phòng thủ.

1427
00:02:50,670 --> 00:03:04,590
Vì vậy, mức phòng thủ là 60, vì vậy hãy cập nhật giá trị này lên 60 và sau đó loại bỏ nút sâu nhất. Vì vậy, chúng tôi đã xóa phần thâm hụt và chúng tôi cập nhật giá trị của tuyến đường của mình, không phải hoặc không mong muốn bằng giá trị của nút tốt nhất.

1428
00:03:04,980 --> 00:03:21,000
Chúng tôi đã lấy giá trị của not vì việc triển khai dễ dàng. Chúng ta có thể lấy giá trị của bất kỳ hạch bạch huyết nào cho sự phù phiếm này. Giả sử chúng ta muốn trì hoãn nút 10, thì chúng ta sẽ làm như vậy để tìm thấy nó.

1429
00:03:21,000 --> 00:03:31,290
Phòng thủ là phòng thủ không. Vì vậy, hãy cập nhật giá trị của nút này sau đó với giá trị của nút sâu nhất là 80, sau đó chỉ cần xóa nút phòng thủ.

1430
00:03:31,470 --> 00:03:44,580
Như vậy là chúng ta đã xóa nút gốc rồi, OK, thay vào đó chọn khoa chúng ta có thể chọn hạch nào thì chọn nút này, chúng ta chọn nút này hoặc chọn lại, đến nút này, điều đó hoàn toàn ổn.

1431
00:03:44,850 --> 00:03:58,770
Nhưng để dễ thực hiện, chúng tôi sẽ chọn nút đầu tiên. Bây giờ, giả sử bạn muốn xóa nút này 20. Bây giờ, giả sử bạn muốn cập nhật giá trị của this, không phải với nút này.

1432
00:03:59,610 --> 00:04:19,310
Cập nhật cái này với nút này hai mươi, thì có vấn đề. Điều này đối với các nút phụ thuộc vào nút này. Vì vậy, nếu chúng ta xóa ghi chú này thì sẽ có sự thu gọn trên hai nút này nếu nó không thay thế được sự phụ thuộc của việc bị hủy và điều đó sẽ khó khăn.

1433
00:04:20,130 --> 00:04:33,240
Đó là lý do tại sao chúng tôi chọn nút sâu nhất và chúng tôi chỉ cập nhật giá trị của nút sa mạc. Chúng tôi phát triển thoái vốn và cuối cùng sẽ loại bỏ hoặc xóa nút đó.

1434
00:04:33,600 --> 00:04:43,380
Giả sử chúng ta muốn xóa nút trễ. Vậy thì chúng ta sẽ làm gì đầu tiên? Chúng ta sẽ phát hiện ra rằng đây là biên bản bào chữa. Vì vậy, chúng tôi sẽ cập nhật giá trị của nút này.

1435
00:04:43,590 --> 00:04:53,380
Chúng tôi phát triển nút tốt nhất và cuối cùng chúng tôi sẽ xóa nút đó nên chúng tôi sẽ lấy nút thứ ba mươi. Đây là những gì chúng ta có thể xóa nó, không phải trong tình trạng khát nhị phân.

1436
00:04:53,760 --> 00:05:05,190
Vì vậy, trước tiên chúng ta đã xác định nút sa mạc của mình trong cây nhị phân này. Vậy thì bạn phải tìm ra liệu nó có phải như vậy không. Và sau đó chúng ta phải cập nhật giá trị của sa mạc chứ không phải bằng sự phát triển.

1437
00:05:05,250 --> 00:05:19,320
Sau đó chúng ta phải xóa nút phòng thủ. Có ba quá trình liên quan. Đầu tiên, tìm nút mong muốn, sau đó tìm nút phụ thuộc đó và sau đó xóa nút sâu nhất.

1438
00:05:19,950 --> 00:05:38,580
Được rồi, bây giờ hãy xem cách chúng ta có thể xóa một nút cụ thể trong cây nhị phân. Đây là mã giả để xóa một ghi chú cụ thể khỏi cây nhị phân. Đầu tiên chúng ta sẽ kiểm tra các cây in HOẶC trống và chúng ta chỉ tồn tại bằng câu lệnh bằng văn bản này.

1439
00:05:38,910 --> 00:05:50,490
Nếu không, chúng ta đang khai báo một Q và chúng ta đang chèn gốc không vào Q và chạy giá trị của phần tử phía trước xuất hiện từ Q. Và chúng ta đang kiểm tra giá trị hiện tại.

1440
00:05:50,670 --> 00:06:05,730
Nếu chúng tôi tìm thấy nút mong muốn thì chúng tôi sẽ cập nhật giá trị mà chúng tôi phát triển, nút tốt nhất mà chúng tôi có thể tìm thấy. Nếu nó không sử dụng phương pháp này, chúng ta sẽ xem cách chúng ta có thể tìm thấy ghi chú về điều đó vào lúc này và sau đó sẽ xóa nút sâu nhất và sẽ bị hỏng.

1441
00:06:06,360 --> 00:06:16,770
Sau đó chúng tôi sẽ kiểm tra. Nếu đứa trẻ không có, thì chúng ta sẽ thêm ghi chú đó vào Q. Nếu bây giờ không có Reitzell, thì chúng ta sẽ thêm ghi chú đó vào Q Và hãy xem nó hoạt động như thế nào.

1442
00:06:16,920 --> 00:06:29,700
Nếu chúng ta gọi phương thức này là xóa nút mười, sau đó tất cả đều khai báo một Q, thì chúng ta sẽ thêm nốt gốc vào Q của mình. Vì vậy, hãy thêm Hurtin' rồi đặt điều này không thể là chú thích cuối trang.

1443
00:06:29,880 --> 00:06:38,780
Đây là nút hiện tại của bạn và chúng tôi sẽ kiểm tra giá trị của nút hiện tại này. Với giá trị đã cho ta thấy giá trị 10 này bằng giá trị đã cho.

1444
00:06:39,150 --> 00:06:49,650
Bây giờ chúng ta sẽ làm, chúng ta sẽ tìm giá trị của nút đầu tiên. Cho nên đây là phòng thủ, không phải giá trị là tám mươi. Vì vậy, hãy cập nhật chuỗi giá trị này với giá trị 80 và sau đó chúng ta sẽ thực hiện điều đó.

1445
00:06:49,650 --> 00:06:59,280
Chúng tôi sẽ xóa ghi chú đầu tiên và bạn sẽ thấy phương pháp này trong video này. Đừng lo lắng về phương pháp này ngay bây giờ và sẽ xóa phòng thủ không sử dụng phương pháp này.

1446
00:06:59,460 --> 00:07:26,180
Vì vậy ghi chú này sẽ bị xóa và sẽ bị hỏng. Nhập một. Vì vậy, bạn bác bỏ quan điểm rằng đây là tất cả những gì chúng ta có thể xóa một ghi chú cụ thể khỏi cây nhị phân, sau đó Bunnett của chúng ta sẽ được biểu diễn, đại loại như thế này hoặc chúng ta đã hiểu cách xóa một nút cụ thể khỏi nó, nhưng chỉ có ba nút nếu chúng ta gọi đây là một lần nữa, trong thời gian này, chúng tôi muốn xóa nút 30 vòng đầu tiên ở gốc gốc.

1447
00:07:26,630 --> 00:07:38,120
Vì vậy gốc là tám mươi. Bây giờ, hãy cộng căn bậc ba không phải vào căn bậc ba của chúng ta, cũng không phải là 80. Sau đó, chúng ta sẽ lấy ra căn bậc ba này. Không phải vậy. Đây là nút hiện tại của bạn bật ra.

1448
00:07:38,570 --> 00:07:53,800
Sau đó, bạn sẽ kiểm tra giá trị với giá trị đã cho của chúng tôi. Nó không bằng 30. Vì vậy, hãy cộng let con vì little không bằng 20 và hãy cộng con bên phải reitzell không phải bây giờ có 30.

1449
00:07:53,810 --> 00:08:07,970
Hãy thêm vào đây nhà văn 30. Bây giờ chúng ta hãy bật ra phần tử phía trước 20. Bây giờ đây là hiện tại của chúng ta. Không, nhìn này, chúng ta nói 20 không phải là khởi đầu tốt. Vì vậy, hãy thêm đứa trẻ huyền thoại vào gợi ý của chúng ta.

1450
00:08:08,090 --> 00:08:22,250
Vì vậy, hãy cộng ở đây 40 và hãy cộng ở đây 50. Bây giờ, hãy đặt phần tử phía trước từ dấu hiệu của chúng ta. Có TARDE. Vì vậy, đây là nút hiện tại của chúng tôi. Bây giờ chúng ta thấy giá trị của Notari này bằng với giá trị đã cho.

1451
00:08:22,400 --> 00:08:32,630
Vì vậy bây giờ chúng ta phải tìm ra nút sâu nhất. Đây là nốt nhạc sâu sắc nhất mà chúng ta có thể tìm thấy. Và đây là nút và chúng ta có thể tìm ra nốt sâu nhất bằng phương pháp này.

1452
00:08:32,630 --> 00:08:45,010
Và chúng ta sẽ thấy trong video này chúng ta có thể tìm thấy nó nếu không. Và hôm nay chúng ta sẽ cập nhật giá trị này với giá trị 70. Vì vậy, hãy cập nhật mục tiêu giá trị này thành 70 và sau đó nó sẽ xóa nút sâu nhất bằng công thức này.

1453
00:08:45,230 --> 00:08:56,540
Vậy chúng ta hãy xóa nốt nhạc sâu nhất này đi sẽ thấy phương pháp này rồi nó sẽ hỏng. Sau đó Banita của chúng ta sẽ được đại diện, đại loại như thế này. Đây là tất cả những gì chúng ta có thể làm với một nút từ cây nhị phân.

1454
00:08:56,770 --> 00:09:10,760
Chúng ta đã hiểu cách xóa một nút khỏi cây nhị phân. Phương pháp này sẽ đưa Bygrave vào độ phức tạp về thời gian Axelle. Cây sẽ phức tạp hơn về mặt thời gian vì phải tìm ra nút mong muốn và nếu được xác định, hãy tìm nó.

1455
00:09:10,760 --> 00:09:21,860
Khi đó, hệ thống phòng thủ có thể phải xóa nút thâm hụt để cần một cây lớn hơn và độ phức tạp về thời gian tương đương với nút đó. Và tất cả đều diễn ra theo độ phức tạp về không gian của khối lập phương đó.

1456
00:09:22,040 --> 00:09:38,570
Bây giờ hãy xem làm thế nào chúng ta có thể tìm ra nút sâu nhất. Đây là phương pháp để tìm nút đầu tiên mà chúng tôi đang lấy hoặc in nó trống và chúng tôi đang thoát bằng câu lệnh bằng văn bản này đang khai báo một Q và chúng tôi đang thêm ghi chú gốc vào Q và hiện tại chúng tôi đang thiết lập các bản ghi Carino.

1457
00:09:38,660 --> 00:09:51,140
Và dòng điện này sẽ lưu trữ giá trị của nút tại đây. OK, chúng ta sẽ có nút 0 đô la, không phải nút hiện tại ở đây. Chúng tôi đang sử dụng Karnad ở đây, chúng tôi có giá trị không trống.

1458
00:09:51,170 --> 00:10:04,730
Chúng tôi đang bật ra phần tử phía trước từ CU. Sau đó chúng tôi đang kiểm tra xem người theo chủ nghĩa tự do có phải là Nelvis hay không. Chúng tôi đang thêm những người tự do vào Q Việc giữ lại quyền không phải bây giờ thì chúng tôi đang thêm kết quả vào hàng đợi ở cuối sẽ giữ lại nút hiện tại.

1459
00:10:04,730 --> 00:10:14,240
Nút hiện tại là nút sâu nhất hoặc lưu ý cuối cùng mà bạn có thể thấy nó đang vượt qua mức nới lỏng tiền tệ hoặc bất cứ điều gì. Vậy hãy xem liệu chúng ta có thể tìm thấy nó không.

1460
00:10:14,240 --> 00:10:26,300
Nút sâu nhất mà chúng tôi gọi là phương thức này trước tiên sẽ tạo một ý chí Q và A bên trong nút tới trường được chèn vào. Bây giờ hãy hỗ trợ Norten này từ Q Vì vậy, đây là nút hiện tại của bạn.

1461
00:10:26,430 --> 00:10:36,440
Bây giờ chúng ta thấy Latrelle không phải là null. Vì vậy, hãy thêm loài bò sát vào Q rồi vế phải. Phía bên phải không phải là bây giờ. Vì vậy, hãy thêm Reitzell vào Q ngay bây giờ, hãy hỗ trợ phần tử phía trước này.

1462
00:10:36,440 --> 00:10:45,740
Hai mươi bây giờ đây là hiện tại của bạn. Vậy nút hiện tại của bạn là 20. Nút bên trái không phải là bây giờ vì vậy hãy thêm vào đây không phải ghi chú không có giá trị rỗng đối với khu vực đó.

1463
00:10:45,740 --> 00:11:00,620
Phải. Nút 50 và nút đó khác với Q của chúng tôi, có ba lý do cần lưu ý. Bên trái không phải là lối thoát adare 60. Bên phải thì không. Bây giờ chúng ta hãy thêm vào đây bảy mươi, bây giờ hãy hỗ trợ ghi chú phía trước từ Q của chúng ta là bốn mươi.

1464
00:11:00,620 --> 00:11:14,030
Vậy hiện tại của chúng ta cũng không phải là 40. Bên trái là 80. Đó không phải là tuân theo Q và đúng đắn ngay bây giờ. Vì vậy, chúng ta có thể thêm nó vào Q, sau đó hãy bật ra phần tử hàng đầu này.

1465
00:11:14,030 --> 00:11:26,450
Năm mươi bây giờ đây là hiện tại của bạn và Lipton ngay bây giờ. Thế thì chủ nhân hiện tại của chúng ta là cực trái còn phải thì không. Họ cần phải được thực hiện ở đây sau đó. Bảy mươi, trái phải bây giờ nên phải làm ở đây.

1466
00:11:26,630 --> 00:11:37,220
Sau đó, chúng ta có 80, đây là nút hiện tại của bạn và bây giờ là bên trái và bên phải, vì vậy chúng ta đã hoàn tất và sẽ trả lại nút 80 này cho lệnh gọi hàm này khi nút bị chán.

1467
00:11:37,220 --> 00:11:50,840
Vậy là chúng ta có được nút phòng thủ từ tên cướp này. Đây là những gì chúng ta có thể tìm thấy ở nút đầu tiên, Metrolink này bởi vì độ phức tạp về thời gian và độ phức tạp của Bygrave trong không gian đối với mọi thứ, mọi ghi chú về sinh học nhất định của chúng ta.

1468
00:11:50,960 --> 00:12:02,390
Và tất cả đều có độ phức tạp về không gian để xây dựng cấu trúc dữ liệu khối. Chúng tôi đã hiểu phương pháp này. Bây giờ hãy xóa nút sâu nhất. Đây là phương pháp xóa nút sâu nhất.

1469
00:12:02,850 --> 00:12:16,880
Vẫn kiểm tra, bạn phải biết rằng họ đang in trống và quay lại, nếu không, chúng tôi đang tạo một hàng đợi và chúng tôi đang thêm ghi chú khó vào hàng đợi và chúng tôi vẫn chưa ngăn cản việc tiếp tục và chúng tôi đang khởi tạo Brebner và tiếp tục dỡ tải .

1470
00:12:17,040 --> 00:12:40,090
Sau đó, chúng tôi đang lấy Welches không trống rỗng. Chúng tôi đang nói không phải với hiện tại và hiện tại, không phải với Kudret Pop. Và phần chiếm, nếu còn lại, bây giờ là chúng tôi đang thiết lập Sternhell cấp tiến đó và đã tồn tại ELT nếu hiện tại, không phải Sternhell cấp tiến đó thì chúng tôi đang thiết lập phía bắc, đặt bên trái ghi chú hiện tại của chúng tôi đến bây giờ và chúng tôi sẽ thoát ra bằng văn bản này tuyên bố IFTTT.

1471
00:12:40,410 --> 00:12:49,950
Chúng tôi đang thêm Celle bên trái và bên phải vào hàng đợi. Hãy xem cách chúng ta có thể xóa ghi chú sâu nhất mà chúng ta gọi là phương pháp này. Sau đó, trước tiên chúng ta sẽ xây dựng một hàng đợi có cấu trúc.

1472
00:12:50,070 --> 00:13:03,330
Đầu tiên chúng ta sẽ chèn heatin. Vì vậy, hãy chắc chắn và ở đây Prevnar bằng với nút hiện tại. Vì vậy, trước tất cả các điểm tới nút. Ban đầu họ sẽ lấy phần tử phía trước ra khỏi hàng đợi.

1473
00:13:03,330 --> 00:13:17,340
Vì vậy, hãy bật ra. Và đây là ghi chú hiện tại của bạn. Bên trái và bên phải không phải là bây giờ. Vì vậy, hãy thêm vào đây trái và phải. Bây giờ là hai mươi ba mươi. Trong lần lặp tiếp theo của lần lặp này, chúng ta sẽ đặt quyền riêng tư cho nút này.

1474
00:13:17,610 --> 00:13:28,680
Vì vậy, hãy đặt cống hiến của chúng ta cho nút này, được chứ? Và chúng ta sẽ điền phần tử phía trước từ hàng đợi và chúng ta sẽ ngồi. Vì vậy, chúng ta sẽ thiết lập dòng điện thông qua nút này.

1475
00:13:28,890 --> 00:13:44,400
Bây giờ chúng ta thấy bên trái và bên phải của điều này, không phải hai mươi là không phải bây giờ. Vì vậy, hãy cộng ở đây 40 và cộng 50. Sau đó, trong lần lặp tiếp theo, chúng ta sẽ chuyển quyền riêng tư sang nút này và chúng ta sẽ điền phần tử đó từ CU, nghĩa là ba mươi.

1476
00:13:44,640 --> 00:13:54,930
Và chúng ta sẽ thiết lập dòng điện cho nút này. Hardy. Chúng ta thấy phần bên trái và bên phải của nút này không phải là null. Vì vậy, hãy chèn vào đây số sáu mươi và hãy chèn vào đây số bảy mươi.

1477
00:13:55,290 --> 00:14:07,980
Sau đó, trong lần lặp tiếp theo, chúng ta sẽ đặt thành nút này. Được rồi, vậy hãy thêm vào ghi chú này và ủng hộ mặt trước theo tín hiệu của chúng ta. Đó là bốn mươi. Vì vậy hiện tại sẽ trỏ đến nút này.

1478
00:14:08,310 --> 00:14:29,390
Chúng tôi thấy hạch bạch huyết của nút này bốn mươi. Và ở đây chúng ta thấy bức thư này. Không phải bốn mươi không phải là một bây giờ hãy kiểm tra lại lưu ý nhé. Lưu ý bên phải là bây giờ chúng ta đã tìm thấy nó bên phải không có dòng điện nào cấp tiến như vậy bây giờ và sau đó những gì chúng ta sắp làm chúng ta sẽ nói hiện tại bởi vì bây giờ chúng ta sẽ ngồi bên trái không phải bây giờ nên bên trái sẽ không kết nối với bây giờ.

1479
00:14:29,790 --> 00:14:40,710
Vì vậy, cái này sẽ bị ngắt kết nối và cái mới này sẽ bị người thu gom rác loại bỏ. Đây là người mà chúng tôi đã loại bỏ ở đây. Chúng tôi đang sử dụng câu lệnh bằng văn bản này để thoát khỏi lệnh gọi hàm của mình.

1480
00:14:40,710 --> 00:14:53,310
Và đây là cách chúng ta có thể xóa phần thoái vốn khỏi cây nhị phân nếu hiện tại chúng ta phát hiện ra nút bên trái. Nếu chúng ta thấy ở đây, nút của cái này, không phải là bốn mươi bây giờ, thì chúng ta sẽ làm gì?

1481
00:14:53,310 --> 00:15:06,240
Chúng tôi sẽ nói điều đó ngay bây giờ. Trong trường hợp đó, chúng tôi đã xóa ghi chú này, tất cả đều nói không làm đúng bằng hai bây giờ. Vì vậy ghi chú này sẽ bị xóa. Đây là những gì chúng ta có thể loại bỏ sâu nhất không phải từ cây nhị phân.

1482
00:15:06,240 --> 00:15:19,470
Chà, chúng tôi đã hiểu thao tác này xóa nút tốt nhất, văn bản thao tác này. Chúng ta đi theo độ phức tạp của thời gian và chúng ta đi lên ở
độ phức tạp của không gian. Chúng tôi đã hiểu điều này, một lời giải thích, nếu có, câu hỏi từ một vấn đề hiểu được lời giải thích này. 

@@@



1483
00:00:00,990 --> 00:00:12,510
Này các bạn quay lại với video này nhé. Chúng ta sẽ thực hiện xóa một phương pháp cây nhị phân. Phương pháp này sẽ xóa toàn bộ cây nhị phân.

1484
00:00:13,170 --> 00:00:26,920
Đây là phương pháp xóa cây nhị phân. Phương pháp này không có tham số chèn ở đây. Chúng tôi chỉ lập hồ sơ để biết bất cứ khi nào chúng tôi lập hồ sơ để biết toàn bộ sẽ bị người thu gom rác xóa.

1485
00:00:27,150 --> 00:00:41,920
Hãy xem bạn được cấp cây nhị phân này muộn đến mức nào nhé. Và đây là nút gốc của chúng tôi. Nếu chúng ta gọi phương thức này là xóa cây nhị phân thì tuyến đường này sẽ được đặt thành Knowland.

1486
00:00:41,940 --> 00:00:53,800
OK, vậy tuyến đường này sẽ được đặt thành nút rỗng. Bây giờ chúng ta thấy không có gì chỉ vào tuyến đường này. Nút 10. Vì vậy, nút này sẽ bị xóa khỏi bộ thu gom rác Rambhai.

1487
00:00:54,120 --> 00:01:04,410
Bây giờ không có gì trỏ đến nút này 20 và nút này ngày hôm nay. Vì vậy, nó cũng sẽ bị loại bỏ bởi người thu gom rác. Bây giờ chúng ta thấy không có gì khác trỏ tới nút 40 này.

1488
00:01:04,410 --> 00:01:13,680
Vì vậy, nó sẽ được loại bỏ bởi người thu gom rác. Không có gì chỉ ra điều này. Đáng chú ý, ghi chú này sẽ bị người thu gom rác loại bỏ. Không có gì chỉ vào điều này, không phải 60.

1489
00:01:13,710 --> 00:01:24,070
Vì vậy, ghi chú này cũng sẽ bị người thu gom rác xóa. Và sau đó là 70. Không có gì trỏ đến nút 70 này. Vì vậy, nút 78 này sẽ bị người thu gom rác loại bỏ.

1490
00:01:24,480 --> 00:01:41,100
Bây giờ chúng tôi thấy tính toàn vẹn của chúng tôi đã bị xóa. Đây là cách hoạt động của phương pháp cướp bóc Adelita này. Phương pháp này tất cả đều mất thời gian không đổi và không gian không đổi. Sự phức tạp của việc hiểu cách hoạt động của phương thức nhị phân đã xóa.

1491
00:01:41,600 --> 00:01:50,910
Tôi có mã nguồn Jike mã nguồn. Nếu bạn có bất kỳ gợi ý nào, nếu bạn gặp khó
khăn trong việc hiểu lời giải thích này của Aveda, hãy cho chúng tôi biết. 

@@@



1492
00:00:00,420 --> 00:00:17,010
Này, video này có một số chàng trai mà chúng ta sẽ nói về Binelli du jour, vì vậy đây không phải là video tiếng Hàn. Trong video này, chúng ta sẽ tìm hiểu một số vấn đề về thuật toán Seoul của chúng tôi và cách thức hoạt động của quá trình truyền tải.

1493
00:00:18,960 --> 00:00:36,780
Trong video này, chúng ta sẽ nói về tế bào khủng bố trước đồng euro trong tế bào khủng bố của bạn và đăng lên tế bào khủng bố, có nhiều cách để khủng bố một cây nhị phân, nhưng ba cách này là các thuật toán tế bào khủng bố chính và đây là những thuật toán thành thạo trước tiên thuật toán khủng bố.

1494
00:00:37,110 --> 00:00:55,230
Bây giờ, hãy xem nó thực sự hoạt động như thế nào. Video này là điều kiện tiên quyết cho ba video tiếp theo của phần này hướng tới tìm kiếm nhị phân để sử dụng ba thuật toán này bằng cách sử dụng đệ quy và lặp đi lặp lại cho phương pháp lặp lại.

1495
00:00:55,260 --> 00:01:07,050
Bạn phải sử dụng công nghệ trong video này. Chúng ta hãy xem các thủ thuật liên quan đến thuật toán truyền tải này. Đầu tiên, hãy nói về thuật toán duyệt thứ tự trước này.

1496
00:01:07,230 --> 00:01:21,560
Đầu tiên xử lý nút hiện tại, sau đó nó sẽ xử lý nốt bên trái, sau đó là nốt bên phải. Và điều này được áp dụng cho mọi nút đơn của cây nhị phân nhất định cho quá trình truyền tải đầu tiên ở bên trái.

1497
00:01:21,570 --> 00:01:33,000
Không phải khi bạn đã hoàn thành xong nút bên trái, quy trình, nút hiện tại, rồi đến nốt bên phải. Và chính sách này sẽ được áp dụng cho từng nút riêng lẻ cho chính chúng ta.

1498
00:01:33,000 --> 00:01:48,930
Đầu tiên là một quá trình, nút trái và sau đó là nút phải, sau đó là nút hiện tại. Và chính sách này được áp dụng cho mọi nút đơn lẻ. Bây giờ hãy xem cách chúng ta có thể phát triển cây nhị phân bằng cách sử dụng thứ tự đặt hàng trước và đăng chi tiết.

1499
00:01:49,080 --> 00:02:05,300
Đầu tiên, hãy nói về việc truyền tải theo thứ tự trước cho nút, bên trái và sau bên phải. Giả sử rằng cây nhị phân này và chúng ta phải duyệt cây nhị phân này bằng cách sử dụng khái niệm P hoặc phép duyệt.

1500
00:02:05,580 --> 00:02:18,570
Đây là nút hiện tại của chúng tôi. Được rồi, đây là Regenhard của chúng tôi. Đầu tiên chúng ta có nút đầu tiên ở đây để xử lý nút, nút hiện tại này, sau đó là trung úy của nút này được ghi chú trong ghi chú bên phải của nút này.

1501
00:02:18,780 --> 00:02:30,690
Đầu tiên, hãy xử lý ghi chú này. Đầu tiên chúng tôi xử lý nút này để chúng tôi nhận được giá trị của nút này chứ không phải một. Vậy là chúng ta đã hoàn thành xong nút hiện tại này. Bây giờ chúng ta hãy đi sang bên trái.

1502
00:02:30,990 --> 00:02:43,670
Chúng ta phải xử lý ghi chú bên trái. Sau đó, chúng ta phải xử lý nút bên phải đó và chúng ta có thể thực hiện việc này bằng cách sử dụng đệ quy hoặc chúng ta có thể thực hiện việc này bằng cách sử dụng loof. Bây giờ chúng ta hãy đi sang bên trái của nút này và đây là bên trái.

1503
00:02:43,720 --> 00:02:57,330
Không phải vậy nên chúng tôi đã chuyển đến nút. Vì vậy, hãy loại bỏ điều này khi chúng ta hoàn thành phần bên trái, sau đó sẽ quay lại nút này cho quá trình dẫn nút này, nút đó về đầu tiên.

1504
00:02:57,900 --> 00:03:12,590
Vì vậy, hãy thêm vào danh sách của chúng tôi. Chúng tôi đã xử lý nút này. Đây là nút hiện tại của chúng tôi. Bây giờ chúng ta hãy chuyển sang nút bên trái, sau đó chúng ta sẽ chuyển sang nút bên phải. Vậy đầu tiên chúng ta phải xử lý kết thúc quá trình phát triển của nút này là cho.

1505
00:03:13,080 --> 00:03:27,770
Vì vậy, chúng tôi đã chuyển đến node. Vì vậy, hãy loại bỏ phần còn lại ở đây. Hãy xử lý nút này cho. Vì vậy, nếu chúng tôi xử lý cái này, không phải cho nó, chúng tôi sẽ nhận được giá trị vì vậy hãy loại bỏ cái này ngay bây giờ.

1506
00:03:28,830 --> 00:03:40,800
Chúng ta phải chuyển đến trung úy này, cũng không phải trung úy này, cũng không phải thế này mà chúng ta chuyển sang trung úy. Chúng tôi sẽ loại bỏ phần bên trái này ở đây và ở đây.

1507
00:03:40,800 --> 00:03:53,010
Hãy xử lý ghi chú này để chúng tôi nhận được giá trị. Và hãy xóa ghi chú này đi, vì chúng ta đã xử lý ghi chú này nên hãy chuyển sang bên trái, Leptis ngay bây giờ. Vậy là chúng ta đã hoàn tất.

1508
00:03:53,370 --> 00:04:05,980
Chúng ta hãy đi bên phải và bên phải là chúng ta thấy ngay bây giờ. Vậy là chúng ta đã hoàn thành nốt đúng đó. Điều này sẽ được thực hiện bằng đệ quy hoặc sử dụng nó như là đệ quy tháng mười hai được gọi là ngăn xếp.

1509
00:04:06,030 --> 00:04:28,480
Chúng tôi có đường thẳng mới cho mọi hàm đệ quy. Cuộc gọi ở trạng thái đó sẽ có nút trái, phải và nút hiện tại cho mỗi nút. Khi chúng ta thực hiện xong tải ngoài cùng bên trái thì quay lại nút này và ở đây chúng ta thấy chúng ta có quyền đối với nút và ghi chú này không được xử lý và ở đây chúng ta thấy nó.

1510
00:04:28,500 --> 00:04:39,570
Chúng tôi có nút bên phải. Vậy chúng ta hãy đi tới nốt bên phải và tiến tới nốt bên phải và nốt bên phải là số chín. Vì vậy, hãy xử lý nút này. Vì vậy chúng ta đã chuyển sang nốt bên phải của nút này.

1511
00:04:39,570 --> 00:04:52,560
Vì vậy, hãy loại bỏ điều này ngay khỏi nút này. Và ở đây hãy xử lý nút chín này để nó xử lý. Chúng tôi nhận được giá trị này là chín. Hãy loại bỏ điều này. Bây giờ chúng ta hãy chuyển sang nút phân tích Leptis bên trái.

1512
00:04:52,710 --> 00:05:06,830
Vì vậy hãy loại bỏ bên trái và bên phải và bên phải không tốt cho nút này. Vậy là chúng ta đã hoàn thành phần bên trái của nút thứ hai này. Bây giờ chúng ta đi tới cây con bên phải và đây là cây con bên phải của chúng ta.

1513
00:05:07,080 --> 00:05:19,440
Vì vậy, vì chúng tôi đã chuyển sang bên phải nên chúng tôi sẽ xóa quyền từ đây. Vì vậy, ở đây chúng ta có nút số 5. Hãy xử lý nút này. Mọi quá trình đều không. Chúng tôi nhận được giá trị của năm.

1514
00:05:20,130 --> 00:05:30,840
Sau đó chúng ta hãy đi sang bên trái của ghi chú này. Đó là mười. Vì vậy, hãy loại bỏ phần bên trái này khỏi đây. Ở đây, hãy xử lý quá trình nút này. Lưu ý này, chúng ta có được chuỗi giá trị.

1515
00:05:31,740 --> 00:05:45,090
Hãy loại bỏ nó khỏi đây và đi sang trái và sang trái ngay bây giờ. Vậy là chúng ta làm đúng cũng không được. Vì vậy, hãy loại bỏ điều này. Vậy là chúng ta đã hoàn thành phần bên trái của nút số 5 này.

1516
00:05:45,240 --> 00:05:58,820
Bây giờ chúng ta hãy đi tới cây con bên phải bảy tỷ. Điều này thậm chí không phải vậy, hãy loại bỏ điều này khỏi đây kể từ khi chúng tôi chuyển sang bước đúng ba năm. Hãy xử lý ghi chú này để chúng ta có được sự đồng đều.

1517
00:05:59,190 --> 00:06:09,480
Vì vậy, hãy loại bỏ điều này ngay bây giờ. Chúng ta phải ghé thăm nút bên trái bây giờ cũng sẽ quay lại. Và ở đây ghi chú bên phải cũng không như vậy. Vì vậy, nó sẽ trở lại.

1518
00:06:09,840 --> 00:06:23,220
Tại thời điểm này, chúng ta thấy rằng chúng ta đã hoàn tất với nút gốc. Vậy là chúng ta đã hoàn thành phần bên trái. Chúng ta hãy đi đến cây con bên phải. Vì vậy, đây là nút bên phải của nút gốc này.

1519
00:06:23,400 --> 00:06:36,660
Vì vậy, hãy loại bỏ điều này ngay từ đây và ở đây. Bây giờ hãy xử lý nút ba này. Vì vậy, hãy thêm ba vào danh sách này. Chúng tôi xử lý nút ba này. Bây giờ, năm nay chúng ta hãy đi về bên trái.

1520
00:06:36,690 --> 00:06:48,450
Chúng ta đừng xử lý nút này và hãy xóa nó một cách bất hợp pháp ở đây. Chúng tôi xử lý ghi chú này. Chúng ta có sáu, sau đó hãy đi sang bên trái của nút này và nút bên trái bằng 0 và xử lý ghi chú này.

1521
00:06:48,450 --> 00:07:00,440
Chúng tôi nhận được mười hai. Vì vậy, hãy loại bỏ nút này. Vì bạn đã chuyển đến nút này nên ở bên trái của nút này là sáu. Vì vậy chúng ta cũng phải loại bỏ điều này. Và ở đây, chúng ta hãy đi sang bên trái.

1522
00:07:00,450 --> 00:07:09,570
Bây giờ còn bên trái nên chúng ta sẽ quay lại. Đúng là không làm ăn cũng sẽ trở lại. Và chúng ta đã hoàn thành xong phần môi của hai trong số nút sáu này. Không, hãy đi tới cây con bên phải.

1523
00:07:09,840 --> 00:07:22,140
Đây là cây con bên phải. Vì vậy, hãy loại bỏ giờ này vì chúng ta đã chuyển sang cây con bên phải và xử lý nút thứ mười ba này. Vì vậy, hãy thêm điều này vào danh sách của chúng tôi, Tartine.

1524
00:07:22,680 --> 00:07:32,700
Vì vậy, hãy loại bỏ trong sau đó hãy vào tù. Cũng sẽ trở về, đúng là không bằng tất cả trở về. Vậy là chúng ta đã hoàn thành phòng thí nghiệm của nút thứ ba này.

1525
00:07:32,970 --> 00:07:52,880
Bây giờ chúng ta đi tới cây con bên phải và đây là cây con bên phải của chúng ta. Và hãy xóa giờ này vì chúng ta đã chuyển sang bên phải lên đây, hãy xử lý nút bảy này, hãy thêm bảy ở đây và chúng ta đã hoàn thành nút hiện tại và hãy chuyển sang bên trái nút này và xóa nó.

1526
00:07:53,060 --> 00:08:06,680
Vì bạn di chuyển sang trái và hãy xử lý ghi chú này. Chúng ta có 14. Vậy hãy loại bỏ Leptis ngay bây giờ, tổng lợi nhuận ngay bây giờ. Vì thế nó cũng sẽ quay trở lại. Bây giờ chúng ta hãy đi sang bên phải của nút số bảy này.

1527
00:08:06,680 --> 00:08:19,460
Đó là 15 kể từ khi bạn chuyển đi. Phải. Vì vậy, hãy loại bỏ cái này ở đây. Hãy xử lý nút 15 này. Vì vậy, hãy thêm 15 vào danh sách này và Leptis ngay bây giờ. Vì vậy, hãy loại bỏ nó.

1528
00:08:19,460 --> 00:08:30,260
Đúng là không tốt bằng. Vì vậy, hãy loại bỏ nó. Đây là thời kỳ sử dụng kỹ thuật Tabassum của chúng tôi. Đầu tiên, chúng tôi xử lý nút hiện tại, sau đó chúng tôi xử lý nút bên trái, sau đó là nốt bên phải.

1529
00:08:30,470 --> 00:08:44,600
Và những chính sách này được áp dụng cho từng nút riêng lẻ. Và đây được gọi là Purita. Chúng ta có danh sách này một hai bốn tám chín năm, 10, 11, ba, sáu, 12, 13, bảy, 14, 15.

1530
00:08:44,900 --> 00:09:05,340
Đây là một cái gì đó như thế này. Một đến thì không cho. Rồi tám, rồi năm, rồi 11, rồi ba, rồi sáu, rồi 12, rồi nốt 13, rồi bảy, 14 rồi 15.

1531
00:09:05,410 --> 00:09:15,250
Và đây chính là hướng khủng bố. Vì vậy, chúng tôi hiểu rằng các kỹ thuật là thuần túy, tế bào khủng bố. Bây giờ hãy nói về các kỹ thuật của tế bào khủng bố.

1532
00:09:15,680 --> 00:09:26,550
Bây giờ chúng ta sẽ nói về tổ khủng bố. Công thức ở đây là đầu tiên của quy trình, phần môi, không phải hiện tại, sau đó là ghi chú phù hợp và các chính sách này sẽ được áp dụng cho mọi nút đơn lẻ.

1533
00:09:27,430 --> 00:09:50,700
Hãy xem xét cây nhị phân của tài liệu này. Có một nút gốc. Vì vậy trước khi xử lý, nút này sẽ xử lý lipner. Vì vậy, hãy di chuyển sang bên trái. Và ở đây trước khi xử lý là không được di chuyển sang trái cho và trước khi xử lý này chúng ta không sang trái và bên trái của nút này là nút số tám này, chúng ta sẽ trình bày nút số tám này.

1534
00:09:50,710 --> 00:10:04,540
Chúng ta đi sang bên trái và bên trái là nó sẽ quay lại thôi. Điều đó sẽ xử lý nút tám này. Vì vậy, hãy thêm nó vào danh sách. Vì vậy, một quá trình, nút này bây giờ hãy đi sang bên phải của tâm và bên phải là bây giờ.

1535
00:10:04,550 --> 00:10:15,190
Vì vậy, nó sẽ trở lại. Vậy là chúng ta đã hoàn tất. Hiện tại chúng tôi đã xử lý phần bên trái của ghi chú này. Hãy xử lý nút này. Vì vậy, hãy thêm vào đây vì vậy hãy loại bỏ cái này.

1536
00:10:15,190 --> 00:10:27,310
Và bây giờ chúng ta hãy đi đến nốt bên phải của nút này. Và có chín. Vì vậy, chúng tôi đã chuyển sang ghi chú bên phải. Bây giờ chúng ta hãy chuyển sang nút của nút số chín này. Và có bây giờ nó cũng sẽ quay trở lại.

1537
00:10:27,610 --> 00:10:37,830
Và sau đó chúng ta có nút này, hãy xử lý nút này thật ấn tượng, nút này, chúng ta có chín. Bây giờ chúng ta hãy đi tới nốt bên phải của nút này và có ngay bây giờ.

1538
00:10:37,960 --> 00:10:51,670
Vì vậy, hãy quay lại nút này và chúng ta đã hoàn thành LoopNet của nút thứ hai này. Vì vậy, bây giờ hãy xử lý nút này để xử lý nút này. Chúng ta cũng không đến bây giờ, hãy loại bỏ điều này ở đây và ngay bây giờ.

1539
00:10:51,700 --> 00:11:02,650
Hãy xử lý bên phải của nút này hai và bên phải của nút này là năm trước khi xử lý nút này năm. Hãy xử lý hạch bạch huyết và bên trái của nút này là mười.

1540
00:11:02,660 --> 00:11:12,670
Vì vậy, hãy loại bỏ điều này. Chúng ta sẽ di chuyển sang bên trái. Vì vậy chúng ta hãy loại bỏ chữ L này và trước khi xử lý nút này chúng ta hãy sang bên trái và bên trái bây giờ là hai sẽ quay trở lại.

1541
00:11:12,850 --> 00:11:24,730
Bây giờ hãy xử lý nút mười này. Vì vậy, hãy thêm 10 vào danh sách của chúng tôi sau đó chúng ta hãy đi đến nút bên phải và bên phải bây giờ. Vì vậy, hãy loại bỏ giờ này. Vậy là chúng ta đã hoàn thành Livnat của nút số 5 này.

1542
00:11:24,730 --> 00:11:43,250
Không, hãy xử lý nút này năm để bạn có được năm nút. Bây giờ chúng ta chuyển sang nốt bên phải của nút này, đó là 11. Và chúng ta bỏ nút R này đi và bỏ nốt R này đi và bây giờ đối với nút này trước khi xử lý thì nốt này sẽ sang bên trái và bên trái là bây giờ.

1543
00:11:43,270 --> 00:11:55,100
Vì vậy, nó sẽ trả về hãy xử lý nút 11 này để nó sẽ thêm 11 vào danh sách của chúng tôi. Sau đó chúng ta sang bên phải và nốt bên phải là null. Vì vậy, nó sẽ chỉ trở lại vào thời điểm này.

1544
00:11:55,120 --> 00:12:07,130
Chúng tôi thấy rằng chúng tôi đã hoàn thành nút trên đường bên trái. Bây giờ là lúc xử lý tuyến đường của chúng ta chứ không phải được xử lý. Điều này thông qua không phải chúng tôi nhận được một. Chúng tôi đã xử lý nút tuyến đường của mình.

1545
00:12:07,300 --> 00:12:23,950
Bây giờ chúng ta hãy đi đến nốt bên phải và nút bên phải. Vì vậy, hãy xóa R khỏi đây và đây trước khi xử lý ghi chú này. Hãy đi sang bên trái và nút bên trái của chúng ta là nút sáu này và trước khi xử lý nút sáu này.

1546
00:12:23,950 --> 00:12:34,390
Chúng ta hãy đi sang bên trái ở đây. Hãy loại bỏ điều này là tốt. Và ở đây chúng tôi đang xử lý nút này. Chúng ta hãy đi đến nút và hạch bạch huyết bây giờ là hai. Nó sẽ quay trở lại.

1547
00:12:34,390 --> 00:12:44,380
Sau đó, hãy xử lý việc này, không phải xử lý. Nếu chúng ta theo đuổi nút này, liệu chúng ta có bị lừa không? Bây giờ chúng ta đi tới đúng nốt số 12 này nhé, không có đáp án đâu, nó sẽ quay lại thôi.

1548
00:12:44,390 --> 00:12:56,390
Vậy là chúng ta đã hoàn tất việc đảm bảo an toàn cho Nút 6 này. Bây giờ, hãy đặt nó ở Nút sáu, nó chưa phải là sáu. Bây giờ chúng ta hãy chuyển sang nốt bên phải của nút sáu này và có 13.

1549
00:12:56,990 --> 00:13:06,900
Vì vậy, chúng ta hãy đi đến nốt bên phải của Nút sáu này. Và có sự khởi đầu. Và hôm nay chúng tôi đang xử lý nút này. Bây giờ chúng ta hãy đi sang bên trái để nó sẽ quay trở lại.

1550
00:13:07,430 --> 00:13:20,810
Bây giờ chúng ta đã vào nên hãy xử lý nút này 13, khu vực đó 13. Hãy loại bỏ nó và đi sang bên phải và bên phải là bây giờ. Vì vậy, nó sẽ trở lại. Vậy là chúng ta đã hoàn thành xong cây con bên trái của nút này là 3.

1551
00:13:21,020 --> 00:13:31,310
Bây giờ hãy xử lý nút ba này, nút này, chúng ta có quy trình ba năm, nút ba này. Vì vậy, chúng ta sẽ xóa và bây giờ hãy chuyển sang bên phải của node.

1552
00:13:31,490 --> 00:13:42,050
Và đây là nút bên phải của chúng tôi. Và ở đây chúng ta đang xử lý cái này, không đi tới nút bên trái và nút bên trái đây không phải là 14 sao? Và họ sẽ xử lý nút này cho.

1553
00:13:42,050 --> 00:13:50,560
Hãy đi sang bên trái, Leptis ngay. Vì vậy, hãy xử lý nút này và sau đó chúng ta nhận được 14. Bây giờ, hãy chuyển sang ghi chú bên phải. Và ngay bây giờ, nguồn tài trợ bổ sung đã có.

1554
00:13:50,600 --> 00:14:01,030
Vì thế nó sẽ quay trở lại. Vậy là chúng ta đã hoàn thành cuộc sống của Nút bảy này. Vì vậy bây giờ hãy xử lý nút bảy này để bạn có được nút bảy. Bây giờ chúng ta hãy sang bên phải số 7, đó là 15.

1555
00:14:01,310 --> 00:14:09,970
Vì vậy, chúng ta hãy đi đến ghi chú bên phải và nút bên phải này và hãy xử lý LoopNet của nút này. Và bây giờ có. Vì thế nó sẽ quay trở lại. Và hãy xử lý ghi chú này.

1556
00:14:10,250 --> 00:14:23,120
Sau đó chúng ta sẽ nhận được 15. Bây giờ hãy tiếp tục. Đúng nốt và đúng nốt là bây giờ. Vì vậy, hãy loại bỏ R và đây là cách chúng ta có thể duyệt cây nhị phân để đến Owasso.

1557
00:14:23,360 --> 00:14:33,650
Và đây là cách bạn biết, quá trình truyền tải giúp chúng tôi xử lý LoopNet. Sau đó, chúng tôi xử lý nút hiện tại, sau đó là ghi chú phù hợp và đây là cách nó hoạt động.

1558
00:14:33,740 --> 00:14:46,280
Bất kể cây nhị phân này sử dụng phương pháp truyền tải là gì. Sau đó, chúng tôi nhận được điều này. Chúng tôi đã hiểu khái niệm này. Nếu bạn không hiểu những lời giải thích này, tôi sẽ khuyến khích bạn xem qua nó bằng các ví dụ của riêng họ.

1559
00:14:46,460 --> 00:14:56,560
Bây giờ chúng ta hãy nói về việc đăng một bài đăng trên tháp. Vì vậy, chúng ta sẽ xử lý nút bên trái trước, sau đó là nốt bên phải, sau đó là nút hiện tại.

1560
00:14:56,900 --> 00:15:08,000
Hãy xem nó hoạt động như thế nào cho điều đó. Hãy lấy cái này làm ví dụ. Đây là nút gốc của chúng tôi. Vậy thì chúng ta phải xử lý không phải trước tiên. Phải. Và sau đó là nút hiện tại.

1561
00:15:08,120 --> 00:15:21,860
Vì vậy chúng ta hãy đi sang bên trái của nút một, nút môi nhỏ này của nút một này. Và bây giờ chúng ta hãy đi sang trái một lần nữa. Đây là bên trái của chúng ta, không phải của nút này bây giờ chúng ta hãy quay lại nút này và đây chúng ta hãy quay lại nút này một lần nữa.

1562
00:15:21,860 --> 00:15:38,920
Và chúng ta thấy chữ đó bây giờ cũng vậy chúng ta sẽ chỉ quay lại sau đó chúng ta đi tới nốt bên phải và nút bên phải cũng không bằng. Vậy chúng ta hãy quay trở lại. Và bây giờ chúng ta sẽ xử lý nút này để có được giá trị đó và chúng ta đã hoàn thành nút này.

1563
00:15:39,200 --> 00:15:49,700
Bây giờ chúng ta hãy chuyển sang nốt bên phải của nút bốn này và có chín. Và ở đây chúng ta hãy loại bỏ điều này để loại bỏ ghi chú bên phải. Và chúng ta hãy đi sang bên trái.

1564
00:15:49,700 --> 00:16:00,410
Leptis, bây giờ chúng ta hãy đi sang bên phải. Đúng là không tốt bằng. Và hãy xử lý nút này để chúng ta có được chín bằng cách xử lý nút này và chúng ta đã hoàn thành nút bên trái.

1565
00:16:00,410 --> 00:16:12,440
Và ngay bây giờ, hãy xử lý nút này để chúng ta nhận được giá trị và khái niệm này sẽ được áp dụng cho mọi nút đơn lẻ. Chúng tôi sẽ xóa nút này vì quá trình này, nút này.

1566
00:16:12,630 --> 00:16:23,390
Bây giờ chúng ta đi tới nút thứ hai này và ở đây chúng ta phải truy cập đúng nốt. Chúng tôi sẽ xử lý nút này. Vì vậy, đây là nút bên phải của chúng tôi. Và hãy loại bỏ R khỏi đây.

1567
00:16:23,750 --> 00:16:32,990
Chúng tôi sẽ xử lý nút này. Chúng ta hãy sang bên trái cái này, không phải năm và có mười ở đây. Tôi sẽ xóa L và ở đây trước khi xử lý ghi chú này, chúng ta hãy chuyển sang bên trái.

1568
00:16:32,990 --> 00:16:44,180
Bên trái là không không chúng ta hãy đi bên phải. Đúng là không tốt bằng. Vì vậy, chúng ta sẽ quay lại và bây giờ hãy xử lý việc này. Không phải mười nên chúng ta có được mười. Vậy là chúng ta đã hoàn thành xong phần bên trái của nút số 5 này.

1569
00:16:44,420 --> 00:16:53,900
Bây giờ chúng ta hãy đi tới cây con bên phải. Đây là quyền của chúng tôi về nút này năm. Hãy loại bỏ nó kể từ khi bạn chuyển sang ghi chú bên phải. Và ở đây chúng ta hãy đi sang bên trái.

1570
00:16:53,900 --> 00:17:09,200
Còn lại bây giờ là hai sẽ trở lại. Chúng ta hãy đi sang bên phải. Hiện tại cũng vậy. Bây giờ hãy xử lý nút này. Ngay cả khi điều này không xảy ra ngay cả khi chúng tôi nhận được nó, khi chúng tôi thấy rằng chúng tôi đã xử lý năm bên trái và bên phải của nút này, thì bây giờ đã đến lúc xử lý nút này.

1571
00:17:09,410 --> 00:17:20,030
Nếu một người không có điều này, chúng tôi nhận được năm. Tại thời điểm này, chúng tôi xử lý cây con trái và phải của nút này để xử lý nút này, xử lý nút này chứ không phải để truy cập.

1572
00:17:20,330 --> 00:17:31,940
Bây giờ, hãy loại bỏ điều này ở đây. Chúng tôi thấy rằng chúng tôi đã xử lý mọi tải ở phía bên trái của nút tuyến đường này. Bây giờ, chúng ta hãy đi đến ghi chú bên phải. Đây là cây bên phải của chúng tôi.

1573
00:17:32,390 --> 00:17:47,990
Và ở đây chúng ta hãy loại bỏ ở đây là ở bên trái. Và đây là ghi chú của chúng ta về nốt ba này, chúng ta hãy đi sang bên trái một lần nữa và đến từng trung úy của cái này, không phải sáu và không, chúng ta hãy đi sang bên trái một lần nữa.

1574
00:17:48,530 --> 00:18:02,010
Sau đó nó sẽ trở lại bây giờ. Thế thì chúng ta có ở đây nên chúng ta hãy sang bên phải bên phải cũng không được. Vì vậy, hãy xử lý nút này. Sau đó, chúng tôi nhận được trill. Vậy là chúng ta đã hoàn thành cây con bên trái của nút sáu này.

1575
00:18:02,030 --> 00:18:12,140
Bây giờ chúng ta hãy sang bên phải, bên phải của Nút sáu này. Vì vậy, hãy loại bỏ R khỏi đây và chuyển sang bên trái. Còn lại là bây giờ. Đúng là bây giờ. Vì vậy, hãy tiếp tục.

1576
00:18:12,140 --> 00:18:24,260
Không có sự trở lại. Vì vậy, chúng tôi nhận được Valot Harding và chúng tôi đã hoàn thành bên trái và bên phải của nút sáu này. Bây giờ hãy xử lý nút này để có được sáu nút và loại bỏ nó.

1577
00:18:24,830 --> 00:18:34,520
Bây giờ, chúng ta hãy đi sang bên phải của nút ba này và đây là bên phải của nút ba này trước khi xử lý. Cái này không. Chúng ta hãy đi sang bên trái. Bên trái là mười bốn.

1578
00:18:35,030 --> 00:18:45,890
Vì vậy, hãy xóa chữ L của bạn và trước nút thứ 4 này, hãy chuyển sang bên trái. Bên trái là bây giờ. Chúng ta hãy đi sang bên phải. Đúng là không tốt bằng. Và hãy xử lý điều này không thì chúng ta sẽ có được mười bốn.

1579
00:18:46,730 --> 00:18:58,340
Chúng tôi đã xử lý lipner. Bây giờ chúng ta hãy đi đến ghi chú bên phải. Vì vậy, hãy loại bỏ nút này. À bây giờ chúng ta hãy sang bên phải của doanh nghiệp số bảy và có mười lăm và đây chúng ta hãy sang bên trái.

1580
00:18:58,340 --> 00:19:08,630
Bên trái bây giờ chúng ta hãy đi bên phải. Hiện tại cũng vậy. Vì vậy, hãy xử lý điều này bây giờ chúng ta có mười lăm, bây giờ chúng ta đã hoàn thành bên trái và bên phải một cách tinh tế của nút bảy này.

1581
00:19:08,720 --> 00:19:19,610
Vì vậy, hãy xử lý nút này. Vì vậy, hãy xử lý cái này, thậm chí không xử lý cái này. Bây giờ chúng ta có bảy. Và ở đây cũng vậy khi di chuyển sang bên phải chúng ta phải bỏ nó đi.

1582
00:19:19,940 --> 00:19:30,620
Vì vậy, chúng tôi tiến hành điều này chứ không phải bảy bây giờ cho nút này, chúng tôi xử lý cây con bên trái và bên phải. Vì vậy, bây giờ hãy xử lý nút này để không có điểm 3 tại thời điểm này.

1583
00:19:30,620 --> 00:19:43,640
Chúng tôi thấy quá trình đó, tất cả nút trong phòng thí nghiệm và tất cả nút ở bên phải cho nút gốc. Đã đến lúc xử lý nút này. Nếu một người không có thì chúng tôi sẽ lấy một người và loại bỏ.

1584
00:19:43,940 --> 00:20:00,770
Vì vậy, chúng tôi nhận được danh sách này và đây là cách chúng tôi có thể duyệt qua một nhị phân bằng cách sử dụng truyền tải sau. Vì vậy, trong video này, chúng ta đã biết cách duyệt cây nhị phân bằng cách duyệt theo thứ tự trước trong bảng và đăng TOMMASEO trong phần này.

1585
00:20:01,010 --> 00:20:22,520
Chúng ta sẽ xem cách chúng ta có thể triển khai bảng tuần hoàn để lập bảng và đăng lên terrazzo một cách đệ quy và lặp đi lặp lại. Nếu chúng ta triển khai ba thuật toán truyền tải này bằng cách sử dụng đệ quy và khó hiểu, thì bạn sẽ dễ dàng giải quyết vấn đề theo cách đệ quy hoặc lặp lại.

1586
00:20:23,030 --> 00:20:35,210
Đầu tiên, tôi thực sự khuyên bạn nên hiểu thứ tự trước và đăng lên tháp. Vậy là khi các bạn đã hiểu rõ thứ tự và đăng lên tháp rồi thì chuyển sang video tiếp theo nhé.

1587
00:20:35,390 --> 00:20:58,100
Trong video tiếp theo, chúng ta đã thảo luận về quá trình truyền tải Puru, sau đó chúng ta sẽ nói về quá trình truyền tải, sau đó chúng ta sẽ nói về quá trình truyền tải sau đó và bạn sẽ thấy
cách chúng tôi có thể triển khai thứ tự trước theo thứ tự và đăng một quá trình truyền tải chi tiết những gì chúng tôi đã hiểu , khái niệm hay các thủ thuật về trật tự và hậu thế của Tyvaso. 

@@@



1588
00:00:00,990 --> 00:00:16,580
Này, có chuyện gì vậy các bạn, trong video này, chúng ta sẽ giải quyết một bài toán phỏng vấn viết mã, truyền tải thứ tự trước cây nhị phân. Với lộ trình của cây nhị phân trả về việc truyền tải thứ tự trước của các giá trị nút của nó.

1589
00:00:18,280 --> 00:00:30,400
Vì vậy chúng ta được cho một cây nhị phân và chúng ta phải duyệt cây nhị phân theo thứ tự. Hãy lấy một ví dụ. Đây là cây nhị phân và đây là nút gốc.

1590
00:00:30,430 --> 00:00:44,410
Chúng ta phải duyệt qua cây nhị phân này để Vì vậy, trước tiên chúng ta phải truy cập vào nút ngoài cùng bên trái. Vì vậy năm nay sẽ đọc node. Vì vậy, chúng tôi sẽ thêm cái này vào danh sách.

1591
00:00:44,800 --> 00:01:04,200
Vì vậy, đầu tiên, sau đó chúng ta sẽ đi sang bên trái. Đây là bên trái của nút này. Vì vậy, hãy thêm vào đây để quyết định nơi lipner của nút này bán nó tại nút này và xem chữ cái bây giờ khi bạn tìm thấy nút bên trái là bây giờ sẽ chuyển sang ghi chú bên phải.

1592
00:01:04,540 --> 00:01:21,550
Và ở đây bạn thấy nốt bên phải cũng là null. Khi bạn tìm thấy nút trái và nút phải là bây giờ sẽ truy cập vào nút bên phải gần nhất và nốt bên phải gần nhất cho nút này là ghi chú này.

1593
00:01:22,990 --> 00:01:40,630
Vì vậy, chúng tôi sẽ thêm năm vào danh sách của chúng tôi bây giờ. Hãy sang bên trái, không trái là rỗng và phải cũng không. Vậy bây giờ nút bên phải gần nhất của nút này là gì? Không phải năm và nút bên phải gần nhất, cái này có bị phá hủy không?

1594
00:01:41,140 --> 00:01:53,860
Hay nói cách khác, bạn có thể giả sử rằng khi anh ta tìm thấy nút trái và nút phải bây giờ dành cho một nút cụ thể, chúng ta sẽ quay lại. Cho đến nay nút này sẽ đi đến nút này.

1595
00:01:54,340 --> 00:02:06,640
Và đối với điều này, không phải ghi chú phù hợp đã được truy cập. Vậy chúng ta hãy quay trở lại. Sau đó chúng ta sẽ chuyển đến nút này và nghe nốt đúng, phải không? Vì vậy hãy thêm nút này để tranh thủ.

1596
00:02:06,790 --> 00:02:17,680
Và ở đây chúng ta đang thêm giá trị nút chứ không phải chính nút đó. Sau đó chúng ta hãy đi đến quyết định nút. Đừng như vậy, hãy thêm sáu vào danh sách của chúng tôi. Và nút bây giờ đã đúng.

1597
00:02:17,680 --> 00:02:35,080
Nút cũng không như vậy. Vì vậy, hãy đi tới nút này và cộng bảy. Và nút là bây giờ và nốt bên phải là bây giờ. Vì vậy, chúng tôi đã truy cập từng lô của cây nhị phân này bằng cách sử dụng phương pháp duyệt theo thứ tự trước cách thức hoạt động của chủ nghĩa khủng bố trong tương lai.

1598
00:02:35,290 --> 00:02:46,270
Đầu tiên chúng ta truy cập vào nốt ngoài cùng bên trái khi thấy hạch rỗng, sau đó mới truy cập vào nốt bên phải là đầu tiên chúng ta đã thăm hết hạch.

1599
00:02:46,280 --> 00:03:02,660
Sau đó khi tìm thấy Nalut, chúng ta chuyển sang nốt bên phải. Và đây là hướng của quá trình truyền tải Premotor trước tiên hãy truy cập vào nút này một, sau đó đến nút này hai, rồi bốn, rồi năm, rồi ba, rồi sáu, rồi bảy.

1600
00:03:03,040 --> 00:03:12,790
Vì vậy, đối với đầu vào đã cho này, chúng ta phải trả về danh sách này để hiểu rõ hơn. Bây giờ hãy lấy một ví dụ khác. Giả sử chúng ta được cấp cây nhị phân này.

1601
00:03:13,540 --> 00:03:28,000
Chúng ta phải duyệt cây nhị phân này theo thứ tự. Vì vậy, đầu tiên chúng ta sẽ truy cập vào nút ngoài cùng bên trái. Đây là nút tuyến đường của chúng tôi. Vì vậy, hãy thêm một cái vào danh sách của chúng tôi bây giờ. Chúng ta sang bên trái, không phải bên trái, phải không?

1602
00:03:28,420 --> 00:03:49,760
Và khi chúng ta làm xong nốt bên trái thì không những sau đó sẽ chuyển sang nốt bên phải. Và điều này đúng với mọi nút đơn lẻ. Vì vậy, hãy thêm vào danh sách của chúng tôi. Sau đó chúng ta hãy sang bên trái not và đây là left not for của chúng ta vì vậy hãy thêm vào danh sách của chúng ta và chúng ta thấy let not là không.

1603
00:03:49,830 --> 00:03:59,930
Chúng ta hãy đi đến ghi chú bên phải. Và hiện tại thì nó không được tốt như vậy. Vậy chúng ta hãy quay lại và thăm nút số 5 này. Vì vậy, hãy thêm năm vào danh sách của chúng ta rồi chuyển sang bên trái.

1604
00:03:59,930 --> 00:04:10,850
Không phải Lebanon là tám. Vậy hãy thêm tuổi vào danh sách của chúng ta nhé. Lebanon không đúng. Bây giờ là nút. Hãy quay lại và nốt bên phải của nút năm này là chín.

1605
00:04:11,060 --> 00:04:32,990
Vì vậy, hãy thêm chín vào danh sách của chúng tôi. Sau đó, hãy đi sang bên trái của nút chín này và đây là 11. Vậy hãy cộng 11 và bây giờ bên trái và bên phải của 11 sẽ là 11. Vậy chúng ta hãy quay lại và viết ghi chú của nút này là chẵn vậy chúng ta hãy cộng chẵn thì chúng ta có LoopNet của cái này, không phải mười một là mười hai.

1606
00:04:33,140 --> 00:04:48,990
Vì vậy, hãy thêm vào đây mười hai và bây giờ bên trái và bên phải của nút này là mười hai. Vậy hãy đi tới nốt bên phải của nút thứ mười một này và có mười ba. Vì vậy, hãy thêm 13 vào danh sách của chúng ta và bên trái và bên phải của cái này, không phải là 13 bây giờ.

1607
00:04:49,400 --> 00:05:07,790
Được rồi, hãy quay lại nút gốc. Vì chúng ta đã truy cập tất cả các nút trong ba nút này, nên một nút đã truy cập tất cả các nút trong cây con bên trái. Bây giờ hãy đi tới cây con bên phải và ở đây chúng ta có ba cây con.

1608
00:05:07,790 --> 00:05:19,520
Vì vậy, hãy thêm ba vào danh sách của chúng tôi. Sau đó chúng ta hãy đi sang bên trái và có sáu. Vậy hãy cộng vào đây, bây giờ là sáu trái và phải. Vậy chúng ta hãy chuyển sang nốt bên phải của nút ba này và có bảy.

1609
00:05:19,670 --> 00:05:46,730
Vậy hãy cộng ở đây bảy và bên trái và bên phải lên trên là bảy. Vậy là chúng ta đã hoàn tất. Chúng tôi đã truy cập tất cả các nút trong cây nhị phân này bằng cách sử dụng tháp trước. Vì vậy, hướng đi của chuyến đi này là chuyến thăm đầu tiên này một, rồi hai, rồi bốn năm tám chín mười một, mười một, mười hai, mười ba, rồi ba, sáu, bảy.

1610
00:05:46,860 --> 00:06:02,000
Vì vậy, đây là sự đảo ngược ưu tiên cho tòa tháp đầu tiên đó. Vì vậy, chúng ta có ba kiểu di chuyển trước khi di chuyển trong tháp. Vì vậy, định đề Owasso và trong video này chúng ta sẽ đề cập đến quá trình truyền chu kỳ.

1611
00:06:02,180 --> 00:06:17,000
Vì vậy nếu bạn được cho cây nhị phân này, chúng ta phải trả về danh sách này và đây là bảng tuần hoàn của cây nhị phân này. Bây giờ, làm thế nào chúng ta có thể giải quyết vấn đề này, chúng ta sẽ giải quyết vấn đề này một cách đệ quy và lặp đi lặp lại.

1612
00:06:17,210 --> 00:06:28,790
Đầu tiên, hãy xem chúng ta có thể giải quyết vấn đề này theo cách đệ quy ở độ tuổi này như thế nào. Thuật toán của chúng tôi để giải quyết vấn đề này. Và đây là hệ nhị phân đã cho của chúng tôi, chẳng hạn, trước tiên hãy xem lại thuật toán.

1613
00:06:29,360 --> 00:06:41,990
Đầu tiên, chúng ta có hàm này trong bảng tuần hoàn lấy gốc của một cây nhị phân nhất định. Sau đó chúng ta có danh sách. Danh sách này sẽ chứa câu trả lời của chúng tôi. Sau đó, chúng ta gọi hàm này là nỗ lực với gốc và danh sách.

1614
00:06:42,140 --> 00:06:54,920
Hàm này sẽ truy cập tất cả các nút trong quá trình duyệt thứ tự trước của hàm này, tất cả các máy chủ, tất cả các nút trong thứ tự trước và nó sẽ thêm tất cả giá trị nút vào biến danh sách ở cuối hoặc trả về danh sách.

1615
00:06:54,920 --> 00:07:17,150
Và đây là chức năng phòng thủ của chúng tôi. Hàm này có hai tham số là nút và danh sách. Chúng tôi kiểm tra thường xuyên để biết idjit. Nếu không không bằng bây giờ thì chúng ta sẽ cộng giá trị nút hiện tại và sau đó chúng ta đang gọi, chúng ta đang gọi hàm bảo vệ không còn ngày và danh sách, sau đó chúng ta sẽ gọi với quyền và danh sách đó.

1616
00:07:17,390 --> 00:07:29,660
Bây giờ hãy xem nó thực sự hoạt động như thế nào. Đây là nút gốc của chúng tôi. Vì vậy, trước tiên hãy truy cập nút ngoài cùng bên trái. Vì vậy, chúng tôi có nút này và ghi chú này không phải là bản tải xuống.

1617
00:07:29,810 --> 00:07:44,600
Vì vậy, chúng tôi sẽ thêm giá trị này vào danh sách. Vì vậy, hãy thêm một vào danh sách. Và đây là danh sách. Sau đó tôi sẽ để node. Đây là LoopNet của chúng tôi. Khi chúng tôi hoàn thành việc này, không chỉ sau đó chúng tôi sẽ chuyển sang nút bên phải.

1618
00:07:45,530 --> 00:08:01,160
Bây giờ, hãy thêm giá trị này vào danh sách vì nút này không liên quan. Vì vậy, hãy thêm vào danh sách. Vì vậy, hai cái sẽ được thêm vào đây, sau đó hãy gọi lại hàm phòng thủ này theo cách đệ quy để chúng ta chuyển sang nút này.

1619
00:08:01,250 --> 00:08:15,260
Vì vậy, hãy thêm giá trị nút này vào danh sách của chúng ta, vì đây không phải là nút. Vì vậy, hãy thêm vào đây sau đó. Bây giờ chúng tôi đã tải. Vì vậy, bây giờ, chỉ cần trả lại bản tuyên bố bằng văn bản này hoặc chỉ cần thoát ra sau đó.

1620
00:08:15,260 --> 00:08:26,990
Nút bên phải. Nút bên phải cũng không như vậy. Vậy là chúng ta đã hoàn tất. Đi thôi. Trong trường hợp này, chúng tôi gọi nút chức năng phòng thủ này là đúng. Trong trường hợp này, bạn đang gọi hàm này mà không có dấu chấm.

1621
00:08:26,990 --> 00:08:40,230
Phải. Đây là nút hiện tại của bạn và giá trị của nút này là năm và con số này không nhiều. Vì vậy, hãy thêm nó vào danh sách của chúng tôi sau đó. Chúng ta hãy đi sang bên trái. Chúng ta đang gọi hàm này mà không còn dấu chấm nào.

1622
00:08:41,390 --> 00:08:53,330
Vì vậy, Lipner là đây là ghi chú hiện tại của bạn và đây không phải là bản tải xuống, vì vậy hãy thêm giá trị này vào danh sách của chúng tôi, sau đó chúng tôi có cái này không có trong danh sách. Vì vậy, hợp pháp.

1623
00:08:53,510 --> 00:09:06,220
Và đối với lệnh gọi hàm này, chúng ta có kiến ​​thức này. Vì vậy, bây giờ chúng ta hãy đi đến ghi chú ARITE này. Và đối với một ghi chú đúng, chúng ta thấy rằng ghi chú này không phải là một ghi chú.

1624
00:09:06,230 --> 00:09:21,650
Vì vậy, hãy thêm chín vào danh sách của chúng ta và đi sang trái và sang trái, cũng không được quét và cái này nằm ở cái khác. Vì vậy, hãy thêm 10 vào danh sách của chúng tôi. Và chúng ta thấy rằng nốt của nốt này bây giờ ở nốt bên phải cũng không bằng.

1625
00:09:21,800 --> 00:09:33,500
Vì vậy, lệnh gọi hàm sẽ chỉnh sửa để tải xuống. Bây giờ chúng ta hãy đi đến ghi chú này. Và đây là 11. Và đây không phải là để tải xuống để thêm nó vào danh sách của chúng tôi 11. Sau đó, chúng ta hãy chuyển sang nút bên trái.

1626
00:09:33,510 --> 00:09:48,620
Và đây là Whipsnade 12 của chúng tôi và đây không phải là một cái khác. Vì vậy, hãy thêm giá trị này vào danh sách của chúng tôi. Ta thấy nốt trái và nốt phải của nốt này cũng chính là lời gọi hàm được chọn cho Knowland cho trái và phải của nút này.

1627
00:09:48,800 --> 00:10:01,680
Bây giờ chúng ta hãy đi sang bên phải và bên phải. Nút là 13 và 13 không phải là nút khác. Vì vậy, nó đã được thêm vào danh sách của chúng tôi. Ghi chú bên trái và bên phải của nút này là null nên hàm sẽ thoát.

1628
00:10:03,260 --> 00:10:24,000
Vì vậy, chúng tôi có một quy trình cho phép thoát khỏi nút này. Bây giờ chúng ta đi tới cây con bên phải và đây là cây con bên phải của chúng ta. Vì vậy, ở bên phải, chúng ta có nút thứ ba này, vì chúng ta đã hoàn thành việc chạm vào bên trái, không phải tất cả đều chuyển sang cây con bên phải trong trường hợp này hoặc gọi hàm này là DFS?

1629
00:10:24,030 --> 00:10:33,580
Không, đúng vậy. Vì vậy ghi chú này không phải là tất cả. Vì vậy, hãy thêm ba vào danh sách của chúng tôi. Bây giờ chúng ta hãy đi đến nút bên trái. Nút bên trái là sáu. Sáu không phải là khác.

1630
00:10:33,590 --> 00:10:45,410
Vì vậy, điều đó đã được thêm vào danh sách của chúng tôi. Và bên trái và bên phải của nút sáu này bây giờ nó cũng sẽ thoát khỏi lệnh gọi hàm cho bên trái và bên phải bây giờ chúng ta hãy chuyển sang ghi chú bên phải.

1631
00:10:45,410 --> 00:10:58,310
Đây là một lưu ý đúng đắn. Đây không phải là nhiều. Vì vậy, hãy thêm bảy vào danh sách của chúng tôi và lipner bây giờ cũng sẽ thoát ra bằng tuyên bố bằng văn bản này và ghi chú phù hợp cũng không được thỏa thuận bằng tuyên bố bằng văn bản.

1632
00:10:58,490 --> 00:11:12,470
Vậy là chúng ta đã hoàn thành lệnh gọi hàm đệ quy này và chúng ta đã truy cập tất cả các nút trong cây nhị phân này và chúng ta nhận được danh sách này và đây là giá trị nút cho việc truyền tải theo thứ tự trước và điều này nhằm trợ giúp cho tháp kia.

1633
00:11:12,470 --> 00:11:20,090
Vì vậy, nó hoạt động và đây là cách chúng ta có thể giải quyết vấn đề này một cách đệ quy. Đây không phải là một vấn đề khó khăn. Nếu chúng ta cố gắng làm điều đó trên ví dụ thì nó sẽ có ý nghĩa.

1634
00:11:20,630 --> 00:11:34,220
Tôi khuyến khích bạn xem qua mã giả này, sử dụng các ví dụ của bạn, cố gắng vẽ mọi thứ và cố gắng viết mọi lệnh gọi hàm đệ quy. Sau đó, bạn sẽ thấy nó thực sự hoạt động như thế nào.

1635
00:11:34,490 --> 00:11:47,150
Nếu đây là lần đầu tiên của bạn, thì tôi khuyên bạn nên xem qua nó bằng các ví dụ của riêng mình và cố gắng viết ra từng chức năng. Gọi một mảnh giấy mà bạn thấy có ý nghĩa.

1636
00:11:47,540 --> 00:12:02,960
Giải pháp sẽ phát triển hơn về độ phức tạp về thời gian. Số lượng nút trong cây đã cho là bao nhiêu? Và nó cũng đòi hỏi độ phức tạp về không gian lớn hơn đối với đệ quy được gọi là ngăn xếp đang gọi hàm này DFS theo cách đệ quy.

1637
00:12:03,230 --> 00:12:14,810
Nếu chúng ta đưa danh sách câu trả lời của mình vào các phân tích độ phức tạp, thì độ phức tạp giữa các không gian sẽ được tính đến. Và điều đó tương đương với biểu đồ mà chúng ta đã hiểu.

1638
00:12:14,980 --> 00:12:32,570
Kỹ thuật truyền tải piata đệ quy. Không, hãy xem chúng ta có thể giải quyết vấn đề này bằng cách lặp đi lặp lại như thế nào. Giả sử rằng chúng ta được cung cấp năng lượng não bộ này và đây là thuật toán cho cách tiếp cận tích hợp của bạn và đây là Steck của chúng tôi để giải quyết vấn đề chính bằng cách sử dụng sự thống nhất của phương pháp tiếp cận, chúng tôi phải sử dụng aztek.

1639
00:12:32,690 --> 00:12:42,470
Hãy xem chúng ta có thể giải quyết vấn đề này như thế nào. Trước đó, hãy xem lại thuật toán của chúng tôi. Đầu tiên, chúng ta có sản phẩm chức năng này lấy nút gốc của cây nhị phân nhất định.

1640
00:12:42,470 --> 00:12:52,430
Sau đó, chúng tôi có danh sách của mình và sau đó chúng tôi tạo một ngăn xếp và sau đó chúng tôi đang kiểm tra. Nếu nút hiện tại không thể biết thì chúng tôi sẽ thêm nút đó vào danh sách của mình.

1641
00:12:52,850 --> 00:13:10,520
Hãy coi đây là danh sách của chúng tôi và danh sách này tất cả và danh sách này đều lưu trữ các giá trị nút, sau đó kiểm tra lại nó. Ghi chú bên phải Pickerington hiện tại không có trong Nalden sẽ thêm ghi chú đó vào ngăn xếp của chúng tôi trong ngăn xếp cũng sẽ chỉ thêm nút bên phải.

1642
00:13:10,670 --> 00:13:21,890
Nếu nốt bên phải là của Noriko bây giờ thì chúng ta sẽ kiểm tra xem nút môi bây giờ có ở đó không và thẻ của nó không trống, sau đó sẽ bật ra nút trên cùng từ Steck.

1643
00:13:21,920 --> 00:13:36,190
Nếu không, thì chúng ta sẽ đặt cảnh báo chứ không phải vì nút hiện tại ở cuối sẽ trả về danh sách của chúng ta. Bây giờ hãy xem điều này thực sự hoạt động như thế nào. Vậy đây là nút gốc của chúng ta và nút này bây giờ không phải là nút đó sao?

1644
00:13:36,200 --> 00:13:47,160
Không phải vậy. Hãy thêm giá trị của điều này không. Một thì giả sử nốt đúng ta thấy nốt đúng là nốt ba và nốt đúng không tải xuống được.

1645
00:13:47,220 --> 00:14:04,230
Vì vậy, hãy thêm nút ba này vào ngăn xếp của chúng ta ở đây. Chúng tôi đang lưu trữ nút chứ không chỉ giá trị. OK, sau đó chúng ta sang nút bên trái gửi một lá thư không phải là cảnh báo sẽ chuyển sang nút bên trái và chúng ta thấy ghi chú này không phải là A..

1646
00:14:04,360 --> 00:14:24,230
Vì vậy, hãy thêm giá trị của ghi chú này vào danh sách của chúng tôi. Và người viết lá thư này mới 5 tuổi, và đó không phải là bây giờ. Vì vậy, hãy thêm năm nút này vào một ngăn xếp. Chúng ta đang bắt đầu ở đây, nút, không phải giá trị của một nút, OK, sau đó chúng ta hãy chuyển sang nút bên trái đã gửi thư, phải không bây giờ.

1647
00:14:24,780 --> 00:14:38,010
Vì vậy, đây là nút hiện tại của chúng tôi cho ghi chú này mà chúng tôi thấy rằng nút bên phải hiện tại, vì vậy nó sẽ không thêm quyền vào twistex nếu ghi chú bên phải không hợp lệ. Bây giờ chúng ta hãy đi sang bên trái và chúng ta thấy ở bên trái chúng ta cũng không còn nữa.

1648
00:14:38,190 --> 00:14:52,140
Nếu chúng tôi có kết quả cho nút hiện tại thì chúng tôi sẽ kiểm tra xem chúng tôi sẽ làm gì. Nếu ngăn xếp của chúng ta không trống thì chúng ta sẽ lấy ra phần tử trên cùng từ Ngăn xếp trong đứa trẻ đó hoặc chúng ta sẽ lấy ra phần tử thứ năm này từ ngăn xếp.

1649
00:14:52,320 --> 00:15:03,420
Và trước đó, vì chúng tôi đã truy cập nút này. Vì vậy, chúng tôi sẽ thêm ghi chú này vào danh sách của chúng tôi. Bây giờ hãy nói về nút thứ năm này trong ngăn xếp. Chúng tôi đã đề xuất nút năm.

1650
00:15:03,450 --> 00:15:18,620
Vì vậy, đây là nút hiện tại của chúng tôi. Và chúng ta nói rằng ghi chú này không phải là nút bây giờ vì nút này không phải là nút, sẽ thêm giá trị của ghi chú này vào danh sách của chúng ta. Sau đó cho đến nút bên phải trong ghi chú bên phải không phải là một phần bổ sung không có trong danh sách của chúng tôi.

1651
00:15:18,750 --> 00:15:29,210
Vì vậy, hãy cộng ở đây chín năm vào nút và bây giờ chúng ta hãy chuyển sang nút bên trái và chúng ta thấy ghi chú bên trái không phải là bản tải xuống. Kể từ đó, nút let không phải là nút khác.

1652
00:15:29,220 --> 00:15:37,650
Vì vậy, chúng ta hãy đi tới nút bên trái, phía nam Lebanon và chúng ta thấy nốt bên phải là một nút khác. Vì vậy, chúng tôi không ở đó, không du lịch. Vì vậy, chúng ta hãy đi đến hạch bạch huyết.

1653
00:15:37,650 --> 00:15:52,020
Chúng ta thấy nốt bên trái là bây giờ. Trước đó, chúng ta phải thêm Disvalue 8 vào danh sách của mình. Vì nút này không được phép ở bên trái nên chúng tôi có nút này. Bây giờ, nếu chúng tôi thấy kết quả là null, chúng tôi sẽ kiểm tra ngăn xếp.

1654
00:15:52,020 --> 00:16:03,120
Mỗi ngăn xếp không trống, sẽ trả về phần tử trên cùng và sẽ xóa phần tử đó. Vì vậy, nó sẽ bật ra Nút chín này và di chuyển đến nút này. Vì vậy hãy loại bỏ ghi chú này.

1655
00:16:03,420 --> 00:16:15,030
Và bây giờ chín là nút hiện tại của chúng tôi. Vì chín là không đủ nên không thêm chín vào danh sách của chúng ta và thấy rằng nốt chín không phải là để thêm phần tử vào ngăn xếp của chúng ta.

1656
00:16:15,210 --> 00:16:27,120
Bây giờ chúng ta thấy nút này không được đưa vào nên nó sẽ di chuyển đến nút đó. Đây là nút hiện tại của bạn vì ghi chú này không phải như vậy. Và cũng hãy thêm ghi chú này vào ngăn xếp của chúng ta và ở đây chúng ta thấy ghi chú phù hợp là Knowler.

1657
00:16:27,130 --> 00:16:39,420
Vì vậy, nó sẽ không thêm phần này vào ngăn xếp của chúng tôi và chúng tôi thấy rằng Lebanon là một nút. Nếu chúng tôi thấy không có Lebanon và ngăn xếp không trống, phần tử đó sẽ bật ra phần tử trên cùng từ Ngăn xếp và sẽ di chuyển đến nút.

1658
00:16:39,600 --> 00:16:51,540
Và trong trường hợp này, nó sẽ hỗ trợ nút thứ mười một từ ngăn xếp và sẽ di chuyển đến phần tử ghi chú này. Vì vậy, đây là nút hiện tại của chúng tôi, vì nút này không phải là kiến ​​thức sẽ thêm ghi chú này vào danh sách của chúng tôi.

1659
00:16:52,170 --> 00:17:05,570
Và đối với lưu ý này, chúng tôi thấy rằng từ phù hợp không phải là một cảnh báo. Vì vậy, hãy thêm nút bên phải, Taryn, vào ngăn xếp của chúng ta. Bây giờ chúng ta hãy đi đến nút bên trái. Vì bên trái không phải là một nút hiện tại truyền thống khác nên chúng ta thấy nút này không phải là nút khác.

1660
00:17:05,580 --> 00:17:21,840
Vậy hãy thêm nghiêng vào danh sách của chúng ta rồi hãy ghi chú đúng và ghi chú đúng bây giờ thì không nên sẽ không thêm một cuộc tấn công khủng bố nào nữa. Sau đó chúng ta sẽ di chuyển đến nút và bên trái not là một từ khác vì chữ cái là một cảnh báo và ngăn xếp không trống.

1661
00:17:21,840 --> 00:17:36,380
Vì vậy nó sẽ trả về phần tử trên cùng từ Stack và nó sẽ di chuyển đến nút trong lịch trình. Hãy truy cập vào nút này không phải là tareen và sẽ bật ra nút này cho nút này. Chúng tôi thấy nó không phải là không để thêm trái tim vào danh sách của chúng tôi ở đây.

1662
00:17:36,390 --> 00:17:45,750
Các bạn thấy ghi chú đúng là như vậy nên nó sẽ không thêm ghi chú đó vào ngăn xếp của chúng ta. Bây giờ chúng ta hãy đi đến nút bên trái và chúng ta thấy ghi chú bên trái rất nhiều và ngăn xếp của chúng ta không trống.

1663
00:17:45,750 --> 00:17:56,530
Vì vậy nó sẽ trả về phần tử trên cùng từ Stack và sẽ di chuyển đến nút đó. Vì vậy, hãy nói về ba và hãy đi tới nút này để biết điều này. Bây giờ chúng ta thấy nút bên phải không phải là nút tải xuống.

1664
00:17:56,550 --> 00:18:10,290
Vì vậy, hãy thêm nốt số bảy bên phải vào ngăn xếp của chúng ta và chúng ta sẽ thấy nút bên trái, phải không? Bây giờ, hãy chuyển sang nút bên trái. Vì bạn đã truy cập nút thứ ba này nên chúng tôi phải thêm ghi chú này vào danh sách của mình.

1665
00:18:10,470 --> 00:18:19,690
Bây giờ chúng ta thấy chữ cái không phải là null. Ngoài ra, hãy gọi nó. Nó không phải là nút hiện tại của bạn. Và lưu ý đúng đắn không chỉ là bổ sung thêm cây gậy khét tiếng này. Chúng tôi nói rằng ghi chú sáu này không được bao gồm.

1666
00:18:19,710 --> 00:18:29,880
Vì vậy, hãy thêm ghi chú này vào danh sách sáu của chúng tôi. Bây giờ chúng ta thấy nốt bên phải là của Knoller. Vì vậy, nó sẽ không thêm ghi chú này vào ngăn xếp của chúng ta và ghi chú bên trái bây giờ rất nhiều và ngăn xếp không trống.

1667
00:18:29,880 --> 00:18:41,820
Vì vậy, nó sẽ trả về phần tử trên cùng từ Stack và đó là bảy. Chúng tôi quảng bá nốt trên cùng từ Stack và nó sẽ chuyển sang nút bảy này. Phải. Và ở đây chúng tôi đã đến thăm nơi này không phải bảy.

1668
00:18:41,820 --> 00:18:54,150
Vì vậy, hãy thêm Nút bảy này vào danh sách và lưu ý đúng là bây giờ hai sẽ không thêm ngăn xếp khét tiếng này và nút hiện tại và ngăn xếp của chúng tôi trống, vì vậy nó sẽ không truy cập nút nữa.

1669
00:18:54,690 --> 00:19:13,890
Chúng tôi đã truy cập từng nốt của cây nhị phân này trong quá trình truyền tải và đây là thuật toán truyền tải người dùng và đây là cách nó hoạt động. Những gì chúng ta đã hiểu về khái niệm khủng bố thuần túy nên lặp đi lặp lại giải pháp mà người ta phải nói đến kịp thời.

1670
00:19:13,890 --> 00:19:23,990
Phức tạp cái gì. Đó là số lượng nút trong cây nhất định và văn bản giải pháp lớn hơn hai nút về độ phức tạp về không gian để xây dựng ngăn xếp và xây dựng danh sách của chúng tôi.

1671
00:19:24,320 --> 00:19:37,490
Vì vậy, độ phức tạp của không gian tổng thể sẽ lớn hơn theo thứ tự trong đó và đây là cách chúng ta có thể duyệt cây nhị phân theo thứ tự. Vậy đây là bảng tuần hoàn của cây nhị phân.

1672
00:19:38,030 --> 00:19:49,900
Để hiểu, để chìm đắm vào vấn đề này, bạn phải thử nó với một vài ví dụ. Sau đó, nó sẽ có ý nghĩa. Tôi thực sự khuyên bạn nên xem qua nó bằng các ví dụ của riêng bạn trong video này.

1673
00:19:49,970 --> 00:20:00,920
Chúng tôi đã giải quyết vấn đề này một cách đệ quy và lặp đi lặp lại, cho dù bạn đã hiểu khái niệm
này chưa. Nếu bạn có bất kỳ câu hỏi nào, nếu bạn có bất kỳ đề xuất nào, hãy cho chúng tôi biết. 

@@@



1674
00:00:01,590 --> 00:00:15,590
Rất nhiều chàng trai có mặt trong video này. Chúng ta sẽ giải quyết một vấn đề sáng tạo, cây nhị phân theo thứ tự truyền tải dựa trên gốc của cây nhị phân được trả về trong các giá trị nút quỹ đạo truyền tải.

1675
00:00:16,710 --> 00:00:45,090
Ví dụ, nếu bạn được cho cây nhị phân này, thì bạn phải duyệt cây nhị phân này theo thứ tự ở đây. Không có đầu tiên sẽ xử lý nút này tám, sau đó sẽ xử lý nút này cho nút chín này, rồi hai, rồi 10 năm 11 một 12, rồi nút này sáu.

1676
00:00:45,480 --> 00:01:13,810
Rồi nút này 13. Rồi nút này ba. Sau đó, nút này là 14. Rồi bảy, rồi 15. OK, và nút này được gọi trong Tháp. Vì vậy, trước tiên chúng ta phải xử lý điều đó, không đúng thì ghi chú đúng và các chính sách này sẽ được áp dụng cho từng nút nếu bạn chưa hiểu về tháp.

1677
00:01:13,820 --> 00:01:25,370
Vì vậy tôi rất khuyến khích bạn xem video đầu tiên trong phần này. Bây giờ hãy để tôi chỉ cho bạn cách chúng ta có thể giải quyết vấn đề này một cách đệ quy. Sau đó chúng ta sẽ xem làm thế nào chúng ta có thể giải quyết vấn đề này.

1678
00:01:25,490 --> 00:01:37,830
Lặp đi lặp lại sử dụng nó steck. Bây giờ hãy xem cách tiếp cận đệ quy. Đây là thuật toán đệ quy của chúng tôi để giải quyết vấn đề này. Đầu tiên, chúng ta hãy xem lại thuật toán này, sau đó chúng ta sẽ xem nó hoạt động như thế nào.

1679
00:01:38,420 --> 00:01:48,050
Đầu tiên, chúng ta có chức năng này đối với tế bào lấy gốc từ cơ thể con người. Và sau đó chúng tôi có danh sách của chúng tôi. Danh sách này, danh sách này sẽ chứa đựng câu trả lời của chúng ta.

1680
00:01:48,470 --> 00:01:58,760
Sau đó, chúng ta gọi hàm trợ giúp này bằng root và danh sách. Sau đó chúng tôi sẽ trả lại danh sách trong năm nay. Trợ giúp định nghĩa hàm. Phải mất hai tham số nút và danh sách.

1681
00:01:59,090 --> 00:02:14,460
Sau đó chúng tôi đang kiểm tra xem hồ sơ có biết không. Sau đó, theo tuyên bố ban đầu này, idjit, thì chúng tôi đang gọi điện. Chúng tôi không phản ánh và liệt kê đệ quy. Sau đó, chúng tôi sẽ thêm nút hiện tại của bạn vào danh sách và sau đó chúng tôi sẽ gọi điện.

1682
00:02:14,480 --> 00:02:27,800
Chúng tôi không biết điều đó đúng và danh sách. Bây giờ hãy để tôi chỉ cho bạn cách nó hoạt động ở đây. Hàm trợ giúp này sẽ gọi đệ quy và bạn biết rằng nó sẽ không hợp lệ.

1683
00:02:28,040 --> 00:02:39,130
Bây giờ hãy để tôi chỉ cho bạn cách nó hoạt động. Vì vậy, đầu tiên chúng ta có con nhện này ở bên trái của cái không phải gốc này. Chúng ta có nút hai ở bên trái cho đến nút bốn ở bên trái của bốn.

1684
00:02:39,140 --> 00:02:50,740
Chúng tôi không có tám. Và ở bên trái của Nút 8, chúng tôi hiện đã chọn cho chức năng này. Gọi cho nút này, OK, vì gần đây không có tự do.

1685
00:02:51,020 --> 00:03:00,500
Bây giờ hãy xử lý ghi chú này. Chúng tôi sẽ xử lý việc này không phải bằng danh sách câu lệnh này mà sẽ thêm vào đó. Vậy hãy thêm giá trị ghi chú này vào danh sách.

1686
00:03:00,860 --> 00:03:13,130
Bây giờ chúng ta hãy đi sang bên phải của cái này, không phải bên phải của nút này bây giờ. Vì vậy, lệnh gọi hàm sẽ nhận được bằng câu lệnh bằng văn bản này. Sau đó, hãy đi đến nút này và chúng ta sẽ xử lý nút này.

1687
00:03:13,280 --> 00:03:27,350
Và ở đây chúng ta sẽ thêm giá trị nút vào danh sách của mình. Bây giờ, chúng ta hãy đi sang bên phải của cái này, không phải bên phải của cái này, cũng không phải lúc này là chín giờ sáng. Chúng ta hãy đi sang bên trái, Leptis ngay bây giờ.

1688
00:03:27,530 --> 00:03:38,690
Bây giờ, hãy xử lý việc này không tính bằng phút. Chúng tôi đang thêm giá trị không vào danh sách. Vì vậy, hãy thêm chín vào danh sách này. Chúng ta hãy đi sang bên phải ngay bây giờ.

1689
00:03:39,020 --> 00:03:50,120
Vì vậy, nó sẽ chỉ xác định bằng văn bản ngay bên trái của ghi chú này về thời gian chờ đợi để xử lý ghi chú này. Vì vậy, hãy thêm ghi chú này vào danh sách.

1690
00:03:50,120 --> 00:03:59,200
Chúng ta hãy đi sang bên phải của ghi chú này. Ở bên phải, chúng ta có nốt này, năm ở bên trái của nốt này là năm. Chúng tôi có ghi chú này. Bật đèn lên. Bây giờ chúng tôi có mười.

1691
00:03:59,540 --> 00:04:09,230
Bây giờ, hãy xử lý lại ghi chú này. Hãy thêm giá trị vào đây. Bây giờ chúng ta hãy đi sang bên phải. Ngay bây giờ là để hoạt động. Sẽ chỉnh sửa. Sau đó hãy xử lý nút này năm.

1692
00:04:09,920 --> 00:04:21,190
Hãy thêm giá trị của năm vào danh sách. Bây giờ, chúng ta hãy sang bên phải của cái này, không tìm bên phải của nút 5 này là 11, mà hãy sang bên trái của 11.

1693
00:04:21,620 --> 00:04:36,770
Bây giờ có chức năng, gọi nó. Sau đó hãy xử lý việc này. Không, chúng ta có 11 và hãy đi sang bên phải ngay bây giờ. Vậy là chúng ta đã hoàn thành cây con bên trái của cái này, chưa phải cây con nào bây giờ.

1694
00:04:36,770 --> 00:04:46,570
Đã đến lúc xử lý ghi chú này. Chúng tôi xử lý ghi chú này. Chúng tôi nhận được giá trị một. Bây giờ chúng ta hãy đi sang bên phải của nút này, một là ba. Chúng ta hãy đi sang bên trái của ghi chú này.

1695
00:04:46,580 --> 00:04:57,310
Ba, tức là sáu. Bây giờ, hãy đi sang bên trái của nút thứ sáu này và có mười hai. Và bên trái của cái này, không phải mười hai, là bây giờ. Vì vậy, chức năng sẽ thoát.

1696
00:04:57,320 --> 00:05:17,900
Bây giờ, hãy thêm giá trị nút để thêm vào danh sách. Bây giờ chúng ta sang bên phải của cái này, không phải bên phải bây giờ nó sẽ già đi thì hãy xử lý Nút sáu này bây giờ chúng ta sang bên phải, bên phải là nút 13 này và chúng ta hãy sang bên trái của nút 13 này.

1697
00:05:17,900 --> 00:05:29,710
Đó là lúc này lệnh gọi hàm sẽ thoát. Bây giờ, hãy thêm giá trị ghi chú đó vào danh sách. Bắt đầu ngay bây giờ. Chúng ta hãy đi sang bên phải. Ngay bây giờ chức năng sẽ chỉnh sửa ở đây.

1698
00:05:30,320 --> 00:05:40,970
Bây giờ, hãy xử lý nút ba này ngay bây giờ. Chúng ta hãy sang bên phải cái này, không phải ba và cái kia là bảy. Bây giờ chúng ta hãy sang bên trái của cái này, không phải bảy. Đó là mười bốn.

1699
00:05:41,420 --> 00:05:53,480
Và chúng ta hãy sang bên trái của cái này, bây giờ không có bốn và sau đó chúng ta hãy thêm mười bốn nữa. Sau đó chúng ta sang bên phải của nút ngoại này mà biết gọi hàm thì nó sẽ thoát.

1700
00:05:53,780 --> 00:06:09,440
Bây giờ, hãy xử lý nút bảy này. Bây giờ chúng ta sang bên phải doanh nhân có 15 và chúng ta sang bên trái, đó bây giờ cũng là hàm Will Exit và chúng ta hãy thêm giá trị ghi chú này vào danh sách.

1701
00:06:10,220 --> 00:06:20,600
Và bây giờ chúng ta hãy sang bên phải và bên phải không phải là một cuộc điện thoại. Nó sẽ thoát ra. Vì vậy, chúng ta phải đảo ngược hệ nhị phân này bằng cách sử dụng kỹ thuật truyền tải theo thứ tự.

1702
00:06:21,250 --> 00:06:40,030
Chúng tôi đã hiểu điều đó theo thứ tự terrazzo. Đây là giải pháp đệ quy của chúng tôi và đây là cách nó hoạt động. Hãy hiểu biết. Tôi thực sự khuyến khích bạn xem xét các ví dụ của riêng mình và cố gắng viết mọi thứ lên một tờ giấy để xem mọi thứ hoạt động như thế nào.

1703
00:06:40,340 --> 00:06:53,840
Chúng tôi có rất nhiều lệnh gọi hàm đệ quy. Nếu bạn chưa quen với đệ quy thì tôi rất khuyến khích bạn viết ra tất cả hàm, mảnh giấy này để bạn có thể hiểu rõ hơn.

1704
00:06:54,470 --> 00:07:06,890
Giải pháp sẽ thành công trong thời gian phức tạp. Đó là số lượng nút chúng ta có trong cây nhất định và nó sẽ phát triển theo độ phức tạp về không gian. Đối với đệ quy được gọi là cây gậy.

1705
00:07:07,880 --> 00:07:18,490
Chúng tôi đã hiểu giải pháp đệ quy. Bây giờ hãy để tôi chỉ cho bạn cách chúng ta có thể giải quyết vấn đề này một cách lặp đi lặp lại. Đây là giải pháp lặp đi lặp lại của chúng tôi cho vấn đề này.

1706
00:07:18,650 --> 00:07:29,510
Thuật toán của bạn? Không, trước tiên hãy xem lại thuật toán, sau đó chúng ta sẽ xem nó hoạt động như thế nào. Đầu tiên chúng ta có hàm truyền tải theo thứ tự lấy gốc của một nhị phân nhất định.

1707
00:07:29,840 --> 00:07:45,230
Sau đó chúng ta có danh sách kết quả ở đây. Sau đó, chúng tôi đang tạo một ngăn xếp để giải quyết mọi vấn đề mà chúng tôi phải sử dụng. Aztek thì nút hiện tại của chúng ta là nút gốc. Vì vậy, đầu tiên nút hiện tại của chúng ta là root, sau đó là nút này.

1708
00:07:45,280 --> 00:08:02,660
Tại sao phải sống? Nếu nút hiện tại không bằng thì không có ngăn xếp cuối nào trống thì chúng ta sẽ kiểm tra. Nếu phần tử hiện tại không phải là bây giờ thì chúng ta sẽ đẩy phần tử đó vào ngăn xếp và sau đó chúng ta sẽ di chuyển sang trái và sau đó chúng ta sẽ lấy phần tử trên cùng ra khỏi Ngăn xếp.

1709
00:08:02,660 --> 00:08:15,980
Sau đó, chúng tôi sẽ thêm giá trị của tổng thể vào danh sách kết quả của mình. Sau đó chúng ta đang chuyển sang ghi chú bên phải ở cuối, danh sách kết quả đó không thể truy cập được. Bây giờ hãy để tôi chỉ cho bạn cách nó hoạt động.

1710
00:08:16,190 --> 00:08:26,990
Luật hiện hành của chúng tôi là một. Đầu tiên, chúng ta sẽ thêm nút, một nút để xếp chồng, sau đó chúng ta sẽ chuyển sang nút bên trái. Vậy là chúng ta đã hoàn thành xong nút này. Hãy chuyển sang nút bên trái.

1711
00:08:26,990 --> 00:08:41,240
Và đây là nút môi của chúng tôi. Chúng tôi thấy đây không phải là Egleston. Ngoài ra, chúng tôi sẽ thêm nút đó vào ngăn xếp của mình. Bây giờ chúng ta hãy đi sang bên trái của nút hai này và ở bên trái chúng ta thấy chúng ta có nút bốn này và đây không phải là nút bây giờ.

1712
00:08:41,390 --> 00:08:55,660
Vì vậy, hãy thêm nút pháp lý. Chúng tôi đang thêm nút vào ngăn xếp chứ không phải giá trị. OK, bây giờ chúng ta hãy đi sang bên trái của nút này và ở bên trái chúng ta có nút thứ tám này và bây giờ nó chưa tải.

1713
00:08:55,730 --> 00:09:09,080
Vì vậy, hãy thêm nó vào ngăn xếp của chúng tôi. Bây giờ, hãy đi sang bên trái của Nút 8 này và chúng ta thấy nó ở bên trái. Bây giờ chúng tôi có nó. Không phải khi bạn tìm thấy nút bây giờ ở bên trái sẽ bật ra phần tử trên cùng từ Ngăn xếp.

1714
00:09:09,350 --> 00:09:23,210
Và nếu chúng tôi đề xuất nút này từ ngăn xếp này, thì chúng tôi sẽ nhận được nút này chứ không phải tám. Được rồi, bây giờ nếu chúng ta cộng giá trị của nút, báo cáo từ Stack, giá trị đầu tiên là 8.

1715
00:09:23,360 --> 00:09:51,860
Bây giờ chúng ta sẽ di chuyển sang bên phải và ở bên phải, chúng ta thấy rằng bây giờ chúng ta sẽ nút. Vì vậy, chúng tôi đã xử lý nút này và hãy chuyển sang bên phải. Và chúng tôi cũng phải xóa cái này khỏi ngăn xếp của mình và chúng tôi thấy ở bên phải hiện tại chúng tôi có nó vì chúng tôi có quyền bây giờ không nên có một người thân sẽ không chạy và cái này sẽ chạy vì Ngăn xếp không trống và người thân này sẽ không chạy bởi vì nút hiện tại là nút bây giờ.

1716
00:09:51,950 --> 00:10:08,770
Vì vậy nó sẽ hỗ trợ phần tử từ Stack. Vì vậy, chúng tôi nhận được sự đồng ý và hãy thêm giá trị vào danh sách của chúng tôi. Và hãy bật ra, chúng ta đã xử lý nút hiện tại, bây giờ chúng ta hãy sang bên phải của Nút bốn này và ở bên phải chúng ta thấy nó.

1717
00:10:08,770 --> 00:10:18,400
Chúng tôi không có chín. Chín không phải là một bản tải xuống. Vì vậy, hãy thêm số chín này vào ngăn xếp của chúng ta. Sau đó, điều tôi sắp làm là tôi sẽ di chuyển sang bên trái của nút số 9 này.

1718
00:10:18,700 --> 00:10:30,850
ĐƯỢC RỒI. Và ở bên trái, chúng ta thấy nó tồn tại ở L.A. khi bạn tìm thấy ở nút hiện tại bên trái, sau đó chúng ta sẽ lấy ra phần tử trên cùng từ Ngăn xếp để nó sẽ bật ra chín phần tử này từ Ngăn xếp.

1719
00:10:31,180 --> 00:10:47,860
Sau đó, chúng ta sẽ thêm giá trị nút này vào danh sách của mình và xóa giá trị đó khỏi ngăn xếp và chuyển sang bên phải. Hiện tại cũng vậy. Sau đó, những gì tôi sẽ làm khi bạn tìm thấy ngay bây giờ sẽ bật ra phần tử hàng đầu từ Stack.

1720
00:10:48,070 --> 00:11:01,620
Vì vậy, hãy lấy phần tử này ra khỏi Ngăn xếp và thêm giá trị của phần tử đó vào danh sách. Vì vậy, chúng tôi đã xử lý nút thứ hai này. Bây giờ chúng ta sẽ di chuyển sang bên phải và bên phải của nút này là nút số 5.

1721
00:11:01,630 --> 00:11:11,770
Và ghi chú này không phải là bây giờ không. Vì vậy, hãy thêm cái này vào ngăn xếp của chúng ta. Bây giờ, chúng ta hãy đi sang bên trái của nút năm này ở bên trái của nút năm này, chúng ta có nút mười này.

1722
00:11:12,040 --> 00:11:30,760
Bây giờ, hãy thêm nút này vào ngăn xếp của chúng ta vì ghi chú này không phải là bản tải xuống. Vì vậy, chúng tôi sẽ thêm 10 vào tiền cược. Và bây giờ chúng ta hãy đi sang bên trái. Ở bên trái, chúng ta thấy rằng bây giờ khi anh ta tìm thấy nó sẽ bật ra phần tử trên cùng từ Ngăn xếp và nó sẽ thêm giá trị nút vào ngăn xếp của chúng ta.

1723
00:11:31,000 --> 00:11:43,900
Vì vậy, chúng tôi lấy ra nút mười từ Stack. Chúng tôi đến đây có mười và chúng tôi sẽ thêm Vallentine đó vào danh sách đó. Và sau đó chúng ta hãy đi sang bên phải của nút 10 ở bên phải này.

1724
00:11:43,900 --> 00:11:53,740
Bây giờ chúng ta đã biết khi nào bạn tìm thấy nút bây giờ ở bên phải để nó sẽ bật ra phần tử trên cùng từ Ngăn xếp. Vì vậy, hãy lấy phần tử này ra khỏi Ngăn xếp và thêm giá trị vào danh sách của chúng ta.

1725
00:11:54,040 --> 00:12:07,810
Vì vậy, chúng tôi đã xử lý nút này năm. Bây giờ chúng ta hãy sang bên phải của cái này, không phải năm và đó là 11. Bây giờ không phải là 11. Vì vậy, hãy thêm 11 vào ngăn xếp, khôi phục nút chứ không phải giá trị.

1726
00:12:07,810 --> 00:12:18,760
OK, ở bên trái số 11, chúng ta có bây giờ khi bạn thấy rằng left now sẽ bật ra phần tử trên cùng từ Stack và nó sẽ thêm giá trị của nút đó vào danh sách của chúng ta.

1727
00:12:18,970 --> 00:12:45,800
Vậy hãy cộng vào đây, 11 và 11 từ đây. Chúng tôi đã xử lý nút này ngay cả bây giờ. Chúng ta hãy sang bên phải cái này, không phải 11. Và chúng ta thấy ở bên phải chúng ta có bây giờ khi bạn tìm thấy bây giờ ở bên phải, chúng ta sẽ hỗ trợ phần tử từ Stack trong ngăn xếp không trống, vì vậy sẽ hỗ trợ nút một này và chúng ta sẽ thêm giá trị của nút đó vào danh sách của chúng tôi.

1728
00:12:45,910 --> 00:12:59,410
Vì vậy, ở đây chúng tôi thấy chúng tôi đã xử lý nút này. Bây giờ chúng ta hãy đi sang bên phải. Ở bên phải chúng ta có nút ba này. Hai không phải là một. Vì vậy, hãy thêm nó vào ngăn xếp của chúng ta và chuyển sang bên trái của nút thứ ba.

1729
00:12:59,740 --> 00:13:14,060
Và ở bên trái chúng ta thấy sáu. Sáu là không đủ để thêm sáu vào danh sách của chúng tôi. Bây giờ chúng ta hãy sang bên trái của số sáu và bên trái của số sáu, chúng ta có nút 12 này và hai nút bây giờ không nằm ngang.

1730
00:13:14,170 --> 00:13:27,190
Thêm nó vào ngăn xếp của chúng tôi. Bây giờ chúng ta hãy đi sang bên trái của số 12. Bây giờ chúng ta thấy bạn đã tìm ra phần tử trên cùng từ Stack. Vì vậy, nếu bạn muốn có được số 12 hợp lệ, hãy thêm 12 vào danh sách của chúng ta.

1731
00:13:28,650 --> 00:13:43,960
Vì vậy, chúng tôi đã xử lý cái này, không phải 12. Bây giờ chúng ta hãy chuyển sang bên phải ngay bây giờ để nó sẽ bật ra phần tử trên cùng từ Stack, vì vậy nó sẽ bật ra Nút sáu này. Và tôi sẽ thêm nó vào danh sách của chúng ta và theo dòng này ở đây, OK.

1732
00:13:44,280 --> 00:14:00,510
Đã đăng ký tại Green Dot. Chà, vậy là chúng ta đã xử lý được nút thứ sáu này. Bây giờ chúng ta hãy chuyển sang các nhà văn bên phải, 13, 13, 13 là không đủ để không thêm thứ ba vào ngăn xếp của chúng ta và bên trái của 13 là tải xuống.

1733
00:14:00,690 --> 00:14:13,180
Vì vậy, hãy lấy ra bốn phần tử hàng đầu từ Stack và chúng tôi sẽ thêm phần tử đó vào danh sách của mình. Vậy hãy cộng vào đây 13 và làm nổi bật cái này. Bắt đầu quá trình này, điều này không mệt mỏi.

1734
00:14:13,240 --> 00:14:25,960
Được rồi, bây giờ chúng ta hãy đi sang bên phải ngay bây giờ. Nếu chúng tôi tìm thấy đúng thì bây giờ sẽ bật ra phần tử trên cùng khỏi Ngăn xếp nếu Ngăn xếp không trống. Vì vậy, hãy nói về phần tử này từ Stack và hãy thêm nó vào danh sách này.

1735
00:14:26,260 --> 00:14:37,960
Và ở đây chúng tôi đang xử lý nút ba này. Bây giờ hãy loại bỏ nút này khỏi ngăn xếp và đi sang bên phải của nút thứ ba này và có bảy. Bảy thì không.

1736
00:14:37,990 --> 00:14:54,420
Bây giờ, hãy thêm bảy vào ngăn xếp của chúng ta và chuyển sang bên trái của số bảy. Và đó là 14 và 14 không phải là bây giờ sẽ thêm bốn vào ngăn xếp của chúng ta. Vì vậy, chúng ta sẽ cộng 4 và du lịch vào bên trái của 14.

1737
00:14:54,670 --> 00:15:03,850
Bây giờ chúng tôi có nút. Vì vậy, nó sẽ bật ra phần tử hàng đầu từ Stack và nó sẽ thêm phần tử đó vào danh sách này. Vì vậy, hãy thêm 14 vào danh sách này và hãy xuất hiện vào sáng nay.

1738
00:15:04,520 --> 00:15:15,880
Vì vậy, bạn xử lý nút 14 này. Bây giờ chúng ta hãy chuyển sang bên phải. Vì vậy hãy đặt phần tử trên cùng từ Stack. Vì vậy, chúng ta sẽ cộng bảy và hãy loại bỏ phần tử bảy này khỏi đây.

1739
00:15:16,090 --> 00:15:28,270
Vì vậy, chúng tôi đang xử lý nút này bảy. Và bây giờ chúng ta hãy đi sang bên phải của cái này, không phải bảy. Và đó là 15. 15 không phải là bây giờ. Vì vậy, hãy thêm 15 vào ngăn xếp của chúng ta và chuyển sang bên trái.

1740
00:15:28,660 --> 00:15:43,360
Ở bên trái, chúng tôi thấy hiện tại chúng tôi có nút. Vì vậy, chúng ta sẽ đặt phần tử trên cùng từ Ngăn xếp và có 15 để thêm 15 vào danh sách của chúng ta và hãy xóa phần tử đó khỏi ngăn xếp của chúng ta và xử lý nút 15 này.

1741
00:15:43,930 --> 00:16:00,160
Và bây giờ chúng ta có nút 15 này và ngăn xếp của chúng ta trống. Epiphone bên phải là null và Stack trống rỗng, thế giới ý chí này hiện đã ngừng thực thi Kynan.

1742
00:16:00,370 --> 00:16:09,520
Vì vậy, thật không tốt khi biết điều kiện này được cảm nhận ở đây và điều kiện này là sai ở đây. Vậy là cái Leubsdorf này ở đây và chúng ta đã hoàn thành và đây là cách nó hoạt động.

1743
00:16:09,520 --> 00:16:21,910
Và chúng ta đã hiểu điều đó mà không cần giải thích. Khái niệm là trước tiên bạn truy cập ghi chú ngoài cùng bên trái bằng cách thêm tất cả các ghi chú không phải từ gốc vào ghi chú ngoài cùng bên trái, không phải vào một ngăn xếp.

1744
00:16:22,120 --> 00:16:33,400
Chúng tôi chưa bao giờ tìm thấy bên trái. Thế bây giờ là sao đây. Tất cả nút trên cùng từ Ngăn xếp và tất cả đều thêm giá trị nút vào danh sách của chúng tôi và chúng tôi di chuyển sang bên phải nút bật ra của chúng tôi.

1745
00:16:33,400 --> 00:16:46,270
Và nếu bây giờ chúng ta tìm thấy nút bên phải thì phần tử trên cùng của Stack cũng sẽ bật ra. Nếu Steck không trống và đây là cách chúng ta có thể giải quyết vấn đề này thì giải pháp sẽ được đưa ra kịp thời.

1746
00:16:46,270 --> 00:17:00,320
Độ phức tạp là số nút chúng ta có trong một cây nhị phân nhất định và giải pháp sẽ diễn ra theo độ phức tạp về không gian để xây dựng ngăn xếp đó. Đây là cách chúng ta có thể giải quyết vấn đề này một cách lặp đi lặp lại.

1747
00:17:00,650 --> 00:17:16,900
Bạn đã hiểu lời giải thích giá trị trong video này chưa? Chúng ta đã thảo luận về giải pháp đệ quy và giải pháp trực quan. Chúng
tôi đã hiểu, nhưng nếu bạn không hiểu bất kỳ ví dụ nào trong số đó, tôi thực sự khuyến khích bạn xem xét các ví dụ của chính họ. 

@@@



1748
00:00:00,810 --> 00:00:13,920
Này, có chuyện gì vậy các bạn, ngay trong video này chúng ta sẽ giải một bài toán phỏng vấn viết mã, duyệt áp phích cây nhị phân, cho gốc của cây nhị phân, trả về việc duyệt thứ tự bài đăng lên.

1749
00:00:13,920 --> 00:00:28,110
Nó không phải là giá trị. Bây giờ hãy để tôi chỉ cho bạn cách chúng ta có thể giải quyết vấn đề này. Ví dụ: nếu bạn được cho cây nhị phân này, chúng ta phải duyệt cây nhị phân này theo thứ tự sau.

1750
00:00:28,740 --> 00:00:52,920
Ở đây chúng tôi không có. Đầu tiên, chúng ta phải xử lý Nút tám này, sau đó là nút chín này. Sau đó, nút này bốn. Sau đó, nút này 10, rồi 11, rồi năm, rồi bảy, rồi 12, rồi 13, rồi 10, rồi 14, 15.

1751
00:00:53,950 --> 00:01:07,980
Bảy, ba và một bây giờ trong video này, chúng ta sẽ giải quyết vấn đề này theo cách đệ quy và lặp đi lặp lại. Trước tiên, chúng ta sẽ xem cách chúng ta có thể giải quyết vấn đề này theo cách đệ quy.

1752
00:01:07,990 --> 00:01:23,670
Sau đó chúng ta sẽ nói về việc lặp đi lặp lại. Nếu bạn chưa hiểu thứ tự đầu tiên thì Tabassum bốn thì không. Chúng tôi có một chính sách ở đây. Infonet là bốn, phải không? Không dành cho hiện tại, không dành cho từng nút đơn lẻ.

1753
00:01:23,690 --> 00:01:33,910
Chính sách này sẽ được áp dụng cho nút này. Quá trình xem xét đầu tiên, bên trái, không phải bên phải, không phải nút hiện tại. Và chính sách này sẽ được áp dụng cho mọi nút đơn lẻ.

1754
00:01:34,090 --> 00:01:49,450
Nếu chúng tôi áp dụng chính sách này thì chúng tôi sẽ nhận được danh sách này. Nếu bạn không hiểu, tôi yêu cầu bạn xem video đầu tiên của phần này. Không, để tôi chỉ cho bạn cách chúng ta có thể giải quyết vấn đề này một cách đệ quy.

1755
00:01:50,290 --> 00:02:04,330
Đây là thuật toán đệ quy của chúng tôi để giải quyết vấn đề này. Trước tiên, chúng ta hãy xem lại thuật toán này, sau đó chúng ta sẽ xem nó hoạt động như thế nào để chúng ta có hàm này hoặc hàm này chiếm gốc của một cây nhị phân nhất định.

1756
00:02:04,330 --> 00:02:22,330
Sau đó chúng ta có danh sách này lưu trữ tất cả câu trả lời. Sau đó, chúng tôi gọi trình trợ giúp hàm này bằng nút gốc và liệt kê nút trả về danh sách. Hàm trợ giúp này sẽ duyệt qua cây thỏ và sẽ xây dựng danh sách bằng cách sử dụng các kỹ thuật khủng bố đặt hàng trước.

1757
00:02:22,690 --> 00:02:34,570
Và ở đây chúng ta có trình trợ giúp định nghĩa hàm này. Hàm này lấy nút và danh sách làm đầu vào. Và ở đây chúng ta sẽ lấy nút hiện tại bằng với bây giờ sau đó sẽ quay trở lại.

1758
00:02:35,670 --> 00:02:51,000
Họ đang gọi hàm theo cách đệ quy để danh sách khi nó gặp bây giờ không ở ngoài cùng bên trái, không phải bình thường, gọi nó bằng ghi chú bên phải và sau đó chúng tôi thêm giá trị hiện tại vào danh sách.

1759
00:02:51,510 --> 00:03:08,580
Bây giờ, hãy để tôi chỉ cho bạn cách nó thực sự hoạt động. Đầu tiên, chúng ta có Ehle nên chúng ta phải xử lý nút trước. Vì vậy, chúng ta hãy đi sang bên trái của nút này, người ta gọi đệ quy hàm trợ giúp này, OK, và phải di chuyển sang bên trái của nút này hai.

1760
00:03:09,000 --> 00:03:26,220
Vậy bên trái của nốt này là nút bốn của anh ấy và bên trái của nút bốn này là nút tám này. Và bên trái của nút thứ tám này là bây giờ khi anh ta tìm thấy một chút nút, liệu bây giờ nó có thực hiện lệnh gọi hàm đó bằng cách sử dụng câu lệnh viết này không?

1761
00:03:26,680 --> 00:03:38,340
Bây giờ chúng ta hãy đi sang bên phải. Ở bên phải chúng ta có nút hiện tại nơi anh ấy tìm thấy nút hiện tại sẽ quay trở lại. Điều đó có nghĩa là tất cả đều thoát ra thì toàn bộ quá trình này không thấy, chúng tôi xử lý nút này.

1762
00:03:38,340 --> 00:03:50,410
Giá trị nút của chúng tôi là tám. Vậy là chúng ta đã hoàn thành truyền thuyết về điều này, không phải bây giờ. Chúng ta hãy đi sang bên phải của nút này. Ở bên phải chúng ta có nút này. Vì vậy bây giờ chúng ta hãy đi sang bên trái.

1763
00:03:50,470 --> 00:04:02,690
Trái là bây giờ và phải là không được nhiều người biết đến. Hãy xử lý nút này để chúng ta có được nút chín. Bây giờ chúng ta đã hoàn thành xong phần bên trái và bên phải, không có cái nào trong số này, không phải bây giờ, hãy xử lý nút này.

1764
00:04:02,900 --> 00:04:15,530
Vì vậy hãy thêm giá trị cho Tonalist. Bây giờ, chúng ta đã hoàn thành phần nhỏ của nốt cần ghi chú này, hãy chuyển sang nốt bên phải và ở đây chúng ta có nốt số năm đúng này.

1765
00:04:15,970 --> 00:04:31,650
Bây giờ chúng ta hãy đi sang bên trái của cái này. Lưu ý năm. Và không, chúng ta hãy chuyển sang thuận tay trái ngay bây giờ và ngay bây giờ, hãy xử lý việc này. Bây giờ chúng ta nhận được 10, 20 được tìm thấy ở bên trái hoặc ngay bây giờ, lệnh gọi hàm sẽ là Edgett.

1766
00:04:32,400 --> 00:04:42,950
Chúng ta rẽ sang trái và đi sang bên phải. Phải. Vâng, chúng ta hãy đi sang bên trái. Trái bây giờ phải cũng không bằng. Hãy đặt ghi chú này để chúng tôi nhận được giá trị 11.

1767
00:04:44,140 --> 00:04:57,640
Sau đó, hãy xử lý cái này, không phải năm, hãy thêm vào đây, năm bây giờ chúng ta ở bên trái và sự an toàn bên phải của cái này là không xử lý nút này để bây giờ chúng ta xử lý bên trái của nút này.

1768
00:04:57,640 --> 00:05:06,400
Chúng ta hãy đi sang phía bên phải của nút này. Vì vậy chúng ta hãy đi tới cây con bên phải ở đây. Chúng tôi có nút ba này. Bây giờ chúng ta hãy đi sang bên trái. Ở bên trái, chúng ta có nút thứ sáu.

1769
00:05:06,400 --> 00:05:16,480
Chúng ta hãy đi sang bên trái. Ở bên trái của sáu, của nút này mười hai. Và chúng ta hãy đi sang bên trái của nút mười hai này. Đó là bây giờ. Vậy là nó đã làm đúng. Một cách gọi sai cũng không có giá trị.

1770
00:05:16,480 --> 00:05:31,480
Vì vậy, Edgett. Và sau đó chúng ta có dòng điện này, hãy xử lý ghi chú này. Chúng tôi nhận được giá trị mười hai. Bây giờ chúng ta hãy đi sang bên phải của nút thứ sáu này. Vì bạn đã xử lý việc đó nên hãy tiến tới nút thứ sáu này.

1771
00:05:31,480 --> 00:05:47,150
Chúng ta hãy đi tới bên phải, chúng ta có nút thứ mười ba này. Hãy đi sang bên trái của nút 13. Và ở bên phải của ghi chú này, chúng ta có 13. Vậy hãy cộng bây giờ chúng ta phải xử lý ghi chú này.

1772
00:05:47,320 --> 00:05:59,820
Hãy thêm vào toàn bộ danh sách của chúng tôi. Tại thời điểm này, chúng tôi thấy chúng tôi đã xử lý kiểu con trái và phải của nút này. Bây giờ hãy xử lý nút này để chúng ta nhận được giá trị sáu.

1773
00:06:00,520 --> 00:06:12,220
Bây giờ chúng ta hãy đi sang bên phải của nút thứ ba này. Nếu chúng ta di chuyển sang bên phải, chúng ta sẽ có nút thứ bảy. Bây giờ chúng ta hãy đi sang bên trái của doanh nghiệp số bảy. Chúng tôi nhận được nút này chuyển tiếp sang bên trái.

1774
00:06:12,220 --> 00:06:26,680
Bên trái bây giờ là bên phải. Bây giờ là vậy. Hãy xử lý nút này. Hãy thêm vào đây. Mười bốn bây giờ chúng ta hãy sang bên phải của nút này bảy có mười lăm. Chúng ta hãy đi sang bên trái của cái này, không phải mười lăm cái hiện có ở đó để loại bỏ cái này.

1775
00:06:26,980 --> 00:06:39,850
Và ở bên trái của mười lăm này chúng ta có bây giờ và bên phải chúng ta có bây giờ. Vì vậy bây giờ hãy xử lý ghi chú này để chúng ta có được 15. OK, bây giờ chúng ta đã xử lý bên trái và bên phải nút thứ bảy này.

1776
00:06:40,390 --> 00:06:50,200
Bây giờ hãy xử lý nút này để chúng ta có được nút thứ bảy. Bây giờ chúng ta thấy nó. Chúng ta đã xử lý cây con trái và phải của nút ba này và hãy xử lý nút này.

1777
00:06:50,440 --> 00:07:00,790
Bạn xử lý ghi chú này, chúng tôi nhận được ba. Bây giờ, tại thời điểm này, chúng ta đã hoàn thành việc thiết lập bên trái và bên phải trên nút tuyến đường. Bây giờ hãy xử lý việc này thậm chí không xử lý.

1778
00:07:00,880 --> 00:07:22,900
Chúng ta không có cái nào cả, được chứ? Và chúng ta đã xử lý xong tất cả các nút trong cây nhị phân này. Đây là cách chúng ta có thể giải quyết vấn đề này. Sử dụng đệ quy. Nếu bạn cần hiểu, hãy thử xem qua các ví dụ của riêng bạn và cố gắng viết nó từng lệnh gọi hàm đệ quy trên mảnh giấy này, khi đó nó sẽ có ý nghĩa.

1779
00:07:23,290 --> 00:07:36,390
Giải pháp này sẽ phức tạp hơn về mặt thời gian. Số lượng nút chúng ta có trong cây đã cho là bao nhiêu và nó sẽ tăng theo độ phức tạp về không gian đối với ngăn xếp cuộc gọi đệ quy.

1780
00:07:37,120 --> 00:07:47,770
Bây giờ hãy để tôi chỉ cho bạn cách chúng ta có thể giải quyết vấn đề này. Lặp đi lặp lại cho cách tiếp cận lặp đi lặp lại. Chúng ta phải sử dụng một ngăn xếp. Đây là thuật toán đệ quy của chúng tôi để giải quyết vấn đề này.

1781
00:07:49,030 --> 00:07:58,120
Đầu tiên, hãy xem lại thuật toán, sau đó chúng ta sẽ xem nó hoạt động như thế nào. Đầu tiên, chúng ta có chức năng duyệt thứ tự bài đăng này lấy gốc của một banditti nhất định.

1782
00:07:58,600 --> 00:08:12,820
Sau đó chúng tôi đã phát hành danh sách này. Câu trả lời của chúng ta là chúng ta đang khai báo một ngăn xếp. Sau đó, chúng ta sẽ kiểm tra xem liệu chúng ta có trả về danh sách trống hay không và sau đó chúng ta sẽ chèn nút gốc, nút gốc du lịch.

1783
00:08:12,820 --> 00:08:28,660
Vì vậy, chúng ta sẽ chèn gốc chứ không phải chèn một ngăn xếp. Sau đó chúng tôi sẽ kiểm tra. Nếu Ngăn xếp không trống thì chúng ta sẽ lấy phần tử từ trên xuống và sau đó chúng ta sẽ thêm giá trị vào danh sách đó từ cuối.

1784
00:08:29,440 --> 00:08:40,270
Và sau đó chúng ta sẽ kiểm tra xem bây giờ bên trái có ai khác không, sau đó chúng ta sẽ đẩy bên trái và bên phải sẽ không đẩy bên phải. Và sau đó chúng tôi sẽ trả lại danh sách.

1785
00:08:40,540 --> 00:09:03,250
Ý tưởng tổng thể ở đây là trước tiên chúng ta sẽ chèn phần gốc chứ không phải phần pháp lý. Sau đó chúng ta sẽ kiểm tra xem bên trái có trống không, sẽ chèn vào ngăn xếp. Và nếu bên phải không trống thì nó sẽ chèn vào ngăn xếp rồi kéo ra bên phải chèn bên trái và bên phải rồi ra bên phải sẽ chèn bên trái và bên phải.

1786
00:09:03,490 --> 00:09:19,660
Và chúng ta sẽ tiếp tục thực hiện quá trình này cho đến khi duyệt qua tất cả các nút trong một cây nhất định để đến mọi thứ chỉ đơn giản là truy cập vào các nút. Được rồi, bây giờ trước khi chúng ta bắt đầu giải quyết vấn đề này, hãy xem một mẫu ở đây.

1787
00:09:19,690 --> 00:09:56,590
Chúng tôi thấy điều đó ở phía dưới. Chúng ta có một và ở đây chúng ta có một cái vỗ nhẹ, rồi 15, 11, rồi mười, chín, tám. Sau đó bảy, sáu, năm, bốn, ba, hai, một, và chúng ta thấy một hướng ở đây, được rồi, và đây là thứ gì đó giống như tế bào khủng bố hoặc tế bào khủng bố khác, bất kể cái nào là cây nhị phân của con người từ phía bên trái hoặc thứ gì đó tương tự theo thứ tự, bất kể lý lẽ là gì, đại loại như thế này.

1788
00:09:57,950 --> 00:10:25,910
Đúng hướng này, OK, theo thứ tự trước. Và ở đây chúng ta thấy điều đó, ở đây bạn thấy rằng nếu chúng ta thêm một từ cuối, rất cuối, rồi ở cuối một, rồi ba, rồi bảy, rồi 15, rồi 14, rồi 13, sáu, đại loại như thế này ở cuối một, rồi ba, rồi bảy, rồi 15, v.v.

1789
00:10:26,210 --> 00:10:44,630
Sau đó, chúng tôi sẽ nhận được câu trả lời của mình trong quá trình truyền tải theo thứ tự bài viết. Và những gì chúng ta sẽ làm bằng cách sử dụng phương pháp lặp lại sẽ là tuyến đường trên ngăn xếp trước, sau đó là tuyến đường được đề xuất và sẽ chèn trái và phải và sẽ bật ra trên cùng.

1790
00:10:45,440 --> 00:10:56,990
Điều đó có nghĩa là bên phải, sau đó chúng ta sẽ chèn trái và phải và chúng ta sẽ làm ngược lại cho đến khi đi qua tất cả các nút và chúng ta sẽ thêm số 12 từ cuối.

1791
00:10:57,290 --> 00:11:10,910
Bây giờ hãy để tôi chỉ cho bạn cách chúng ta có thể giải quyết vấn đề này một cách lặp đi lặp lại. Và đây là trực giác cốt lõi. Bây giờ, trước tiên, điều tôi sắp làm là hỗ trợ nút này và tôi sẽ thêm nó vào danh sách từ cuối.

1792
00:11:11,050 --> 00:11:25,280
Được rồi, một. Vì vậy chúng ta phải xử lý cái này. Sau đó chúng ta sẽ làm gì? Chúng tôi sẽ thêm nút muộn và ghi chú phù hợp và chúng tôi đề xuất rằng không phải một nút từ Stack mà sẽ thêm hai và ba.

1793
00:11:25,650 --> 00:11:39,770
Chúng tôi đang thêm nút chứ không phải nút. Được rồi, vậy chúng ta sẽ làm gì? Chúng ta sẽ lấy ra nút thứ ba từ Stack. Được rồi, chúng ta sẽ lấy ra phần tử trên cùng từ Stack và đó là ba.

1794
00:11:39,950 --> 00:11:54,110
Vì vậy, hãy thêm nó vào danh sách theo thứ tự ngược lại. Được rồi, từ phải sang trái bây giờ, chúng ta sẽ loại bỏ nút ba này và cộng bên trái và bên phải vào ngăn xếp sáu.

1795
00:11:55,770 --> 00:12:09,780
Và bảy. Bây giờ, hãy lấy phần tử hàng đầu khỏi Stack, tức là 7, vì vậy hãy thêm nó vào danh sách của chúng ta. Và đối với ghi chú đó, số bảy, phần bên trái bây giờ không phải là để thêm vào ngăn xếp của chúng ta.

1796
00:12:10,860 --> 00:12:33,260
Fording, đây không phải là một giá trị, được rồi, và bây giờ không phải là giá trị đó, hãy cộng 15 vào Steck của chúng ta. Bây giờ chúng ta sẽ lấy ra phần tử trên cùng và đó là 15. Vì vậy, hãy lấy ra 15 và thêm 15 vào danh sách của chúng ta theo thứ tự ngược lại từ phải sang trái.

1797
00:12:33,620 --> 00:12:45,470
Vậy chúng ta đã xử lý một ba bảy 15 và bây giờ chúng ta thấy Leptis. Vậy tại sao không đẩy sang trái stack và chúng ta thấy ngay bây giờ như vậy sẽ không đẩy sang phải que đó.

1798
00:12:45,860 --> 00:13:05,700
Bây giờ, bạn định làm gì? Chúng ta sẽ lấy ra phần tử trên cùng của Stack, nếu trái và phải, cả bây giờ và Stack đều không trống. Vì vậy, hãy đặt phần tử hàng đầu đó từ Ngăn xếp 14 và thêm nó vào danh sách của chúng ta và hãy xem liệu ánh sáng của số 14 có bình thường không.

1799
00:13:05,720 --> 00:13:16,660
Và chúng ta thấy bây giờ không thêm cái này vào ngăn xếp và bên phải bây giờ cũng sẽ không thêm cái này vào ngăn xếp. Vì vậy, quá trình không 14 và chúng tôi chọn và đúng.

1800
00:13:16,670 --> 00:13:36,250
Bây giờ là bây giờ. Vì vậy, chúng tôi sẽ bật ra. Phần tử trên cùng của ngăn xếp trong ngăn xếp không trống và ngăn xếp của chúng ta không trống. Vì vậy, hãy bật ra yếu tố này. Nhưng nút từ ngăn xếp chúng ta nhận được sáu, hãy thêm sáu vào đây và xóa nó khỏi Ngăn xếp và bên trái của sáu là 12.

1801
00:13:36,440 --> 00:13:53,170
Vậy 12 không phải là bây giờ. Vì vậy, hãy cộng 12 du lịch và bên phải của sáu là 13. 13 không phải là rỗng để cộng 13 vào ngăn xếp của chúng ta. Bây giờ bạn định làm gì? Chúng ta sẽ bỏ qua phần tử trên cùng của Stack và đó là 13.

1802
00:13:53,300 --> 00:14:05,090
Vì vậy, hãy thêm nó vào danh sách của chúng ta theo thứ tự ngược lại từ phải sang trái. Vậy chúng ta có 13 bên trái của 13 là null và bên phải của 13 là bây giờ. Vì vậy, chúng ta không thể thêm trái và phải hoặc xếp chồng.

1803
00:14:05,750 --> 00:14:20,420
Nếu chúng tôi tìm thấy bên trái và bên phải thì bây giờ sẽ bật phần tử trên cùng từ ngăn xếp Stack IV không trống. Vì vậy, hãy bật ra mười hai. Anh ta sẽ bật ra số mười hai khi đó chúng ta nhận được giá trị mười hai và nốt trái và phải của nút mười hai này bây giờ là.

1804
00:14:20,430 --> 00:14:28,940
Vì vậy, chúng ta có thể thêm điều đó vào quá trình ngọt ngào của mình. Đây không phải là mười hai. Bây giờ bạn định làm gì? Chúng ta sẽ lấy ra phần tử trên cùng từ ngăn xếp trong lịch trình khoảng hai.

1805
00:14:29,180 --> 00:14:44,000
Vì vậy, hãy thêm vào để thêm vào danh sách của chúng tôi và hãy xóa hai. Và ở bên trái của hai chúng ta không có bốn thì không phải bây giờ. Vì vậy, hãy thêm vào cho du lịch và quyền cũng không được bao gồm.

1806
00:14:44,000 --> 00:15:00,530
Vì vậy, hãy thêm năm vào ngăn xếp đó. Bây giờ, bạn định làm gì? Chúng ta sẽ lấy ra phần tử hàng đầu từ Stack là 5. Vì vậy, hãy thêm năm vào danh sách của chúng ta theo thứ tự ngược lại và lấy năm và bên trái của năm là mười.

1807
00:15:00,530 --> 00:15:10,220
Hãy thêm hai vào ngăn xếp. Vì mười không phải là tải nên hãy thêm nút bên phải. Nút bên phải là 11. Bây giờ, chúng ta sẽ làm gì? Chúng ta sẽ lấy ra phần tử trên cùng từ Stack.

1808
00:15:10,280 --> 00:15:22,370
Vì vậy, chúng tôi sẽ bật ra ngay bây giờ. Chúng ta sẽ đến bên trái của số 11 là bây giờ và bên phải là bây giờ. Vì vậy, chúng ta có thể thêm hai ngăn xếp đó và xếp chồng Epiphone sang trái và phải.

1809
00:15:22,610 --> 00:15:35,450
Lệnh mở là bây giờ. Nó không trống rỗng. Hãy bật ra phần tử trên cùng. Đó là mười. Vì vậy, hãy thêm mười vào danh sách của chúng ta ở đây và hãy thêm khoảng mười từ Stack. Và chúng tôi thấy rằng chúng tôi cũng xử lý mười.

1810
00:15:35,810 --> 00:15:50,060
Bên trái và bên phải lên mười là bây giờ. Vì vậy, chúng tôi sẽ lấy phần tử trên cùng từ Ngăn xếp và với ngăn xếp này không trống. Vì vậy, hãy đặt phần tử này là số bốn và sẽ thêm vào danh sách của chúng ta và chúng ta thấy rằng phần tử bật ra bên trái và bên phải là tám và chín.

1811
00:15:50,060 --> 00:16:02,750
Vì vậy, hãy thêm chúng vào ngăn xếp. Vì bây giờ chúng không phải là tám và chín nên chúng ta sẽ bật phần tử trên cùng và đó là chín. Vì vậy hãy cộng thêm 9 vào danh sách và làm nổi bật ghi chú này.

1812
00:16:02,750 --> 00:16:12,290
Và chúng ta thấy một bên trái và bên phải là bây giờ. Vì vậy, chúng ta không thể thêm nút đó và xử lý nút này ở giữa bên trái và bên phải. Nút thứ chín này bây giờ chúng ta sẽ loại bỏ phần tử hàng đầu khỏi Stack.

1813
00:16:12,500 --> 00:16:28,130
Vì vậy, hãy bật ra phần tử số tám này và thêm nó vào danh sách của chúng ta. Vậy là chúng ta có được danh sách này còn bên trái và bên phải của phần tử này thì không. Taliban từ Stack cũng vậy, vì ngăn xếp đó trống rỗng nên chúng tôi không thể thoát ra được nữa.

1814
00:16:28,400 --> 00:16:42,500
Và chúng ta đã hoàn thành. Chúng tôi đang xử lý tất cả các nút. Chúng tôi đã xử lý tất cả các nút trong cây nhị phân nhất định bằng cách sử dụng các kỹ thuật khủng bố khác. Và chúng ta có được danh sách này và đây là cách chúng ta có thể giải quyết vấn đề này.

1815
00:16:42,710 --> 00:16:59,330
Những gì chúng ta đã hiểu, lời giải thích này, sẽ có giải pháp vì về độ phức tạp về thời gian, đó là số nút chúng ta có trong cây nhị phân đã cho và điều này sẽ diễn ra theo độ phức tạp về không gian để xây dựng ngăn xếp đó.

1816
00:16:59,630 --> 00:17:16,160
Trong video này, chúng tôi đã giải quyết vấn đề này một cách đệ quy và lặp đi lặp lại. Bạn đã hiểu cả hai cách tiếp cận chưa? Nếu bạn không hiểu bất kỳ điều gì trong số đó, tôi thực sự khuyến khích bạn xem xét các ví dụ của riêng mình và cố gắng viết mọi thứ ra một tờ giấy.

1817
00:17:16,310 --> 00:17:26,360
Sau đó bạn sẽ thấy nó hoạt động như thế nào. Bạn đã hiểu lời giải thích của video này chưa? Nếu
bạn có bất kỳ câu hỏi, gợi ý nào, hãy cho chúng tôi biết. Cảm ơn đã xem video này, Altium. 

@@@



1818
00:00:00,660 --> 00:00:15,060
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ giải quyết một vấn đề phỏng vấn mã hóa cấp độ cây nhị phân của quá trình truyền tải, dựa vào gốc của cây nhị phân, trả về cấp độ của các giá trị nút quỹ đạo truyền tải.

1819
00:00:15,840 --> 00:00:31,110
Ví dụ: nếu bạn được cấp cây nhị phân này, bạn phải duyệt cây nhị phân này theo thứ tự cấp độ. Điều đó có nghĩa là trước tiên bạn phải đi qua nút một này, sau đó là nút hai này, rồi ba, rồi bốn, năm, sáu, bảy.

1820
00:00:31,110 --> 00:00:45,350
Một cái gì đó như thế này một, hai, ba, rồi năm, sáu, bảy. Vì vậy, nếu bạn được cung cấp cây nhị phân này trong ngành, chúng tôi có ba cấp độ và chúng tôi phải trả về danh sách này ở cấp độ 0.

1821
00:00:45,360 --> 00:00:56,710
Chúng tôi chỉ có một nút ở cấp một. Chúng ta có hai, không phải hai và ba. Và ở cấp độ hai, chúng tôi có bốn nút. Vì vậy nếu chúng ta được cho cây nhị phân này thì chúng ta phải trả về danh sách này.

1822
00:00:57,390 --> 00:01:18,460
Ví dụ: nếu chúng ta được cung cấp cây nhị phân này trong hệ nhị phân này, chúng ta có bốn cấp độ, cấp 0, cấp một, cấp hai và cấp ba và sẽ hướng tới nút này ở cấp độ truyền tải, đầu tiên là một, sau đó là hai, rồi ba , rồi bốn, năm, sáu, bảy, rồi tám, chín, 10, 11, 12, 13, 14, 15.

1823
00:01:18,660 --> 00:01:30,180
Vì vậy, nếu chúng ta được cấp nhị phân này để hoạt động trong danh sách này ở cấp độ, chúng ta có một ghi chú ở cấp độ một, chúng ta có hai nút hai và ba. Ở cấp độ hai, chúng ta không có bốn, năm, sáu, bảy, tám.

1824
00:01:30,180 --> 00:01:40,800
Cấp ba, chúng ta có các nút tám, chín, 10, 11, 12, 13, 14 và 15. Trong video này, trước tiên chúng ta sẽ giải quyết vấn đề này theo cách đệ quy và lặp đi lặp lại.

1825
00:01:40,800 --> 00:01:55,700
Hãy xem làm thế nào chúng ta có thể giải quyết vấn đề này một cách đệ quy. Sau đó, chúng ta sẽ xem làm thế nào chúng ta có thể giải quyết vấn đề này một cách lặp đi lặp lại. Đầu tiên, hãy hiểu, giả sử chúng ta có cây nhị phân này, đây là cấp 0, đây là cấp một và đây là cấp hai.

1826
00:01:56,250 --> 00:02:05,850
Bây giờ chúng ta sẽ xây dựng một danh sách và bên trong danh sách đó sẽ lưu trữ một danh sách khác. Vì vậy, chúng ta hãy duyệt qua phương án thay thế đầu tiên Bonaduce này, đây không phải là một.

1827
00:02:06,150 --> 00:02:19,380
Và ở cấp độ này, chúng tôi chỉ có một nút. Vì vậy, chúng tôi sẽ xây dựng một danh sách bên trong danh sách này với chỉ số 0 bằng cách ánh xạ tới mức 0 này. Và hãy thêm điều này vào danh sách của chúng tôi.

1828
00:02:19,830 --> 00:02:32,810
Bây giờ chúng ta hãy đi sang bên trái. Ở bên trái, chúng ta có nút này để cho phép chúng ta xây dựng một danh sách mới ở chỉ mục một. Và hãy thêm giá trị vào danh sách của chúng tôi. Bây giờ chúng ta hãy đi sang bên trái và bên trái.

1829
00:02:32,820 --> 00:02:43,920
Chúng ta có nút này và hãy xây dựng một danh sách mới ở chỉ mục thứ hai. Và hãy thêm giá trị ghi chú này vào danh sách bên trái và bên phải của ghi chú này, vì hiện tại chúng tôi không có nút nào.

1830
00:02:43,920 --> 00:02:54,990
Nút bây giờ sẽ quay trở lại, sẽ không làm gì cả. Bây giờ chúng ta hãy sang bên phải của nút năm năm nằm ở cấp độ hai này. Vì vậy, hãy thêm nút năm này vào chỉ mục hai.

1831
00:02:55,560 --> 00:03:09,960
Vì vậy, năm sẽ được thêm vào đây. Rồi lưu ý này, nút này nằm ở cấp một hai. Hãy thêm ghi chú này vào chỉ mục một. Ba sẽ được thêm vào đây. Khi đó nút sáu sáu này nằm ở chỉ số hai.

1832
00:03:10,140 --> 00:03:25,970
Vì vậy, hãy thêm sáu vào danh sách chỉ mục của chúng ta để bảy nằm ở cấp độ hai. Vì vậy, hãy thêm bảy vào danh sách chỉ mục của chúng tôi. Bảy sẽ được thêm vào đây. Và đây là cách chúng ta có thể giải quyết vấn đề này một cách đệ quy để hiểu rõ hơn.

1833
00:03:25,980 --> 00:03:36,480
Hãy lấy một ví dụ khác. Giả sử chúng ta được cung cấp cây nhị phân này làm đầu vào, phải duyệt cây nhị phân này theo cấp độ khủng bố và trả về các giá trị nút theo cấp độ khủng bố.

1834
00:03:36,490 --> 00:03:45,450
Vì vậy, chúng tôi có bốn cấp độ, cấp 0, cấp một, cấp hai và cấp ba. Bây giờ hãy xây dựng một danh sách. Danh sách đó sẽ lưu trữ các giá trị nút trong tháp.

1835
00:03:45,450 --> 00:04:01,780
Vì vậy, trước tiên hãy duyệt qua ghi chú này của tuyến đường này và xử lý nút này. Nút này nằm ở chỉ số 0 tại Indexical. Chúng tôi sẽ tạo một danh sách mới và trong danh sách đó hoặc chèn một danh sách ở chỉ số 0 và chỉ mục đó ánh xạ tới số cấp đó.

1836
00:04:02,590 --> 00:04:15,660
Bây giờ, hãy thêm một vào chỉ số 0 này. Bây giờ chúng ta hãy đi sang bên trái. Ở bên trái, chúng ta có nút này, bây giờ hãy tạo một danh sách mới ở chỉ mục một và thêm giá trị các nút vào danh sách đó.

1837
00:04:15,870 --> 00:04:37,830
Vì vậy, hãy thêm giá trị nút vào danh sách này. Khi chúng tôi gặp nút này sẽ tìm ra số chỉ mục của chúng tôi, sau đó chúng tôi sẽ thêm các giá trị nút đó bằng cách lấy danh sách chỉ mục một và chúng tôi có thể quản lý chỉ mục bằng đệ quy có tên Stack và sẽ sớm đi qua mã giả trong hàm đệ quy của nó được gọi là Ngăn xếp.

1838
00:04:37,830 --> 00:04:50,970
Chúng tôi có một trạng thái mới trong trạng thái đó. Chúng ta sẽ có cuộc sống không có cách nào số cấp đó. Chúng tôi có thể chấp nhận bất kỳ danh sách nào trong danh sách này và chúng tôi có thể thêm giá trị nút vào danh sách đó.

1839
00:04:51,020 --> 00:05:00,660
OK, bây giờ chúng ta hãy sang bên trái và để bạn có nút này. Điều đó tốt. Một danh sách mới ở chỉ số hai. Và hãy thêm reliford này vào danh sách đó. Và chúng ta hãy đi sang bên trái một lần nữa.

1840
00:05:00,660 --> 00:05:14,670
Chúng tôi có Nút tám này. Bây giờ hãy tạo một danh sách mới ở chỉ mục thứ ba. Và hãy thêm ghi chú này, giá trị 8 vào danh sách bên trái. Bây giờ chúng tôi đã viết rất rõ ràng ở bên phải, chúng tôi có bây giờ sẽ quay lại và Mitt sẽ thoát ra, sẽ không làm gì cả.

1841
00:05:14,710 --> 00:05:26,070
Chúng ta hãy đi đến ghi chú bên phải. Ở bên phải, chúng ta có chín. Vì vậy, hãy thêm chín vào danh sách chỉ số ba. Vì vậy, hãy thêm chín ở đây và đi đến nút năm.

1842
00:05:26,850 --> 00:05:39,240
Năm nằm ở cấp độ hai. Và hãy thêm danh sách cấp độ vào nút năm. Vì vậy, năm sẽ được thêm vào đây. Sau đó chúng ta đi sang bên trái thì nằm ở cấp độ ba.

1843
00:05:39,240 --> 00:05:51,570
Vì vậy, hãy thêm mười vào danh sách này. Mười sẽ được thêm vào đây ở bên trái. Không phải tất cả chúng ta đều ở bên phải. Bây giờ chúng tôi đã chọn nút này, nút này nằm ở cấp độ ba.

1844
00:05:51,570 --> 00:06:02,190
Vì vậy, hãy thêm các giá trị ghi chú này vào chỉ mục ba. Bên trái và bên phải của nút 11 này bây giờ nó sẽ chỉ thoát ra vì nút đó sẽ không làm gì cả. Bây giờ, chúng ta đã hoàn thành phần bên trái của cái này.

1845
00:06:02,190 --> 00:06:14,850
Lưu ý một. Bây giờ chúng ta hãy đi tới cây con bên phải. Ở bên phải, chúng ta có nút ba này. Nút này nằm ở cấp một. Vì vậy, hãy thêm nút này vào chỉ mục một và chúng ta có thể lấy số chỉ mục.

1846
00:06:14,850 --> 00:06:28,010
Điều đó có nghĩa là cấp độ đệ quy gọi là stack cũng đã cũ. Chúng ta sẽ xem làm thế nào chúng ta có thể có được cái đó. Chúng ta xem xét mã giả của mình và thêm giá trị ba hai chỉ mục này vào danh sách chỉ mục một.

1847
00:06:28,410 --> 00:06:46,550
Vì vậy, ba sẽ được thêm vào đây, sau đó sáu sáu sẽ được thêm vào danh sách này, sau đó mười hai sẽ được thêm vào danh sách chỉ số ba này. Toàn bộ tạm thời sẽ được thêm vào danh sách chỉ số ba này, sau đó bảy bảy sẽ được thêm vào danh sách chỉ mục này để sau đó.

1848
00:06:47,470 --> 00:06:58,190
40 người sẽ được thêm vào danh sách ngành này, sau đó 15 người sẽ được thêm vào danh sách chỉ số ba này. Đây là cách chúng ta có thể giải quyết vấn đề này một cách đệ quy.

1849
00:06:58,430 --> 00:07:14,880
Chúng tôi đã hiểu sự xâm nhập. Bây giờ hãy xem cách chúng ta có thể triển khai giải pháp này bằng mã giả. Đây cũng là mã để giải quyết vấn đề này. Và để hiểu hoặc cho rằng chúng ta được cho cây nhị phân này, đầu tiên chúng ta có hàm này gọi là cấp độ hoặc tại hàm đó lấy gốc của cây nhị phân cho trước.

1850
00:07:15,120 --> 00:07:27,580
Sau đó, chúng ta tạo một danh sách rồi gọi trình trợ giúp cấp hàm với danh sách gốc và số 0. Số 0 này là số cấp độ. OK, sau đó khi trả về danh sách, hàm này sẽ tập trung kết quả của chúng ta.

1851
00:07:28,170 --> 00:07:37,980
Đây là trình trợ giúp cấp độ định nghĩa hàm của chúng tôi. Cái này có ba danh sách tham số, gốc và cấp độ. Nút kiểm tra ngay cả nút hiện tại của chúng tôi bây giờ sẽ quay trở lại.

1852
00:07:38,010 --> 00:07:54,120
Điều đó có nghĩa là chúng ta đang thoát khỏi hàm hiện tại được gọi bằng cách sử dụng câu lệnh bằng văn bản này. Nếu cấp độ lớn hơn bản ghi để liệt kê trang web đó thì chúng tôi sẽ tạo một cấp độ mới và chèn cấp độ đó vào danh sách của mình và chúng tôi có thể lấy số chỉ mục của danh sách đó theo số cấp độ.

1853
00:07:54,330 --> 00:08:04,740
Và chúng tôi đang quản lý số cấp độ, sử dụng lệnh gọi đệ quy này, sử dụng hàm đệ quy này, cấp độ cuộc gọi cộng một và danh sách kiểm tra và ở đây của bạn sẽ đạt được cấp độ.

1854
00:08:04,750 --> 00:08:20,430
Chúng tôi đang đạt được cấp độ hiện tại và chúng tôi đang thêm quyền không đúng cấp độ. Và sau đó chúng ta gọi hàm đệ quy trái và phải. Ban đầu, chúng ta có nút tuyến đường này và chúng ta sẽ thêm ghi chú gốc vào danh sách và chúng ta sẽ tạo danh sách đó ngay tại đây.

1855
00:08:20,430 --> 00:08:32,520
Cấp độ mới. Hãy thêm một danh sách mới ở đây và thêm nút một ở chỉ số 0. Sau đó chúng ta có nút này ở cấp một. Điều đó tốt. Một danh sách mới ở chỉ mục một.

1856
00:08:32,530 --> 00:08:52,650
Hãy vào bên trong nút này và chúng tôi đang chèn bằng cách sử dụng câu lệnh này và sau đó là nút này ở chỉ mục thứ hai, chúng tôi không có danh sách. Hãy đặt một danh sách mới và chèn giá trị này của nút này vào danh sách này, sau đó là nút số 5, tức là chèn số 5 vào danh sách này, rồi đến nút 3 này.

1857
00:08:52,650 --> 00:09:04,290
Hãy chèn cái này vào danh sách chỉ mục một, sau đó sáu sáu sẽ được thêm vào danh sách này, phụ lục hai, sau đó bảy bảy sẽ được thêm vào danh sách chỉ mục hai này.

1858
00:09:04,890 --> 00:09:16,920
Làm tốt. Đây là cách chúng ta có thể giải quyết vấn đề này vì chúng ta đã hiểu giải pháp này và đây là giải pháp đệ quy cho vấn đề này. Giải pháp sẽ bị tắt trong thời gian phức tạp.

1859
00:09:17,280 --> 00:09:36,180
Số lượng nút chúng ta có trong một cây đã cho là bao nhiêu? Và giải pháp sẽ tùy thuộc vào độ phức tạp của không gian để xây dựng danh sách đầu ra và đối với đệ quy được gọi là ngăn xếp và không gian bên ngoài, độ phức tạp lớn hơn ở chỗ số lượng nút chúng ta có trong cây đã cho.

1860
00:09:36,420 --> 00:09:49,710
Ngay cả trong sự hiểu biết. Tôi sẽ giới thiệu cho bạn những ví dụ của riêng bạn để hiểu nó sẽ có ý nghĩa. Bây giờ hãy xem liệu chúng ta có thể giải quyết vấn đề này một cách lặp đi lặp lại hay không ngay bây giờ chúng ta sẽ thực hiện cách tiếp cận tích hợp cho vấn đề này.

1861
00:09:50,070 --> 00:09:59,490
Điều đầu tiên cần hiểu, giả sử chúng ta có cây nhị phân này và chúng ta có một khối lập phương để giải bài toán này. Chúng ta phải sử dụng một khối lập phương hầu hết thời gian.

1862
00:09:59,490 --> 00:10:09,840
Khi bạn giải quyết một vấn đề quan trọng bằng cách sử dụng loof, chúng ta phải cân nhắc việc sử dụng ngăn xếp hoặc khối lập phương. Hãy xem chúng ta có thể giải quyết vấn đề này như thế nào. Đầu tiên, chúng ta có nút gốc này.

1863
00:10:10,050 --> 00:10:21,990
Hãy thêm phần này vào khối lập phương của chúng ta ngay bây giờ và bây giờ chúng ta sẽ tạo một danh sách mới. Đây là danh sách mới của chúng tôi và nó có số đếm bằng một nghĩa là ở cấp độ hiện tại, chúng tôi chỉ có một nút.

1864
00:10:22,590 --> 00:10:36,990
Và hãy tạo một danh sách mới ngay tại đây. Và hãy thêm một cái vào danh sách này và hãy hỗ trợ nút này. Hãy cộng trái và phải, không phải vào Q của chúng ta. Vì vậy, hai sẽ được thêm vào đây và ba sẽ được thêm vào đây.

1865
00:10:37,470 --> 00:10:49,830
Bây giờ hãy tính tất cả cơ hội để thêm hai nút vì ở cấp độ hiện tại, chúng tôi có hai nút. Bây giờ chúng ta sẽ làm gì? Chúng tôi sẽ quảng cáo nút này và chúng tôi sẽ có một danh sách mới và trong danh sách hãy chèn giá trị này, không phải giá trị hai.

1866
00:10:50,010 --> 00:10:59,430
Và sau đó chúng ta sẽ thêm nút trái và nút phải của nút thứ hai này vào hàng đợi của mình. Vì vậy, hãy thêm vào đây bốn và hãy thêm năm thuộc tính, nút ba.

1867
00:10:59,430 --> 00:11:12,930
Và hãy thêm ghi chú này vào danh sách của chúng tôi ngay tại đây. Sau đó, chúng ta sẽ cộng bên trái và bên phải, tất cả những điều này ghi chú số ba vào Q Vậy sáu và bảy bây giờ không thể đổi thành bốn vì bây giờ chúng ta có bốn.

1868
00:11:13,050 --> 00:11:24,630
Không có trong hàng đợi của chúng tôi vì bạn có bốn ghi chú ở cấp độ mới. Bây giờ chúng ta sẽ làm gì? Chúng tôi sẽ điền vào nút này và chúng tôi sẽ tạo một danh sách mới và chúng tôi sẽ thêm giá trị nút đó vào danh sách mới của mình.

1869
00:11:25,080 --> 00:11:44,910
Bên trái và bên phải bây giờ chúng ta cũng không thể thêm nhiều vào khối lập phương của mình. Sau đó là năm, hãy cộng giá trị của nút này vào năm Tonalist, rồi sáu. Hãy thêm phát triển nút này sáu bộ lạc bên trái và bên phải của ghi chú này, sáu nút hiện tại chúng tôi cũng không thể thêm kiến ​​thức vào khối của mình.

1870
00:11:45,890 --> 00:12:00,400
Họ có bảy cái hãy bật ra và thêm vào danh sách của chúng tôi và chúng tôi đã hoàn tất, và không có chỗ trống khi hàng đợi của bạn trống. Chúng tôi đã giải quyết xong vấn đề đó trong một năm nhất định để phải trả lại danh sách danh sách này.

1871
00:12:00,790 --> 00:12:11,680
Đây là mức độ không. Cái này dành cho cấp một, cái này dành cho cấp hai. Bây giờ chúng ta hãy xem thuật toán lặp để giải quyết vấn đề này. Được rồi. Đây là thuật toán lặp của bạn để giải quyết vấn đề này.

1872
00:12:11,680 --> 00:12:22,670
Đầu tiên của trật tự cấp độ rối loạn, rối loạn bắt nguồn từ việc đưa tiền vào danh sách, lấy Đường hầm Hoàng gia hoặc trả lại tiền trong danh sách. Sau đó, chúng tôi đang tạo một hàng đợi.

1873
00:12:22,690 --> 00:12:32,350
Đây là hàng đợi của bạn. Sau đó, chúng tôi sẽ thêm cái đầu tiên vào hàng đợi của mình. Đó là ở nút đầu tiên và danh sách của chúng tôi. Ban đầu chúng tôi tạo ra danh sách này. Hãy nói rằng đây là danh sách của chúng tôi.

1874
00:12:34,110 --> 00:12:44,760
Sau đó, trong khi giá trị không trống, bảo mật không trống, chúng ta có danh dự trong hàng đợi. Bây giờ chúng ta sẽ tạo một cấp độ mới có nghĩa là một danh sách mới cho danh sách của chúng ta.

1875
00:12:45,150 --> 00:12:55,690
Và chúng tôi sẽ lấy ghi chú này ra khỏi hàng đợi và thêm giá trị đó vào danh sách mới của chúng tôi. Và sau đó chúng ta sẽ thêm bên trái và bên phải của cái này, không phải một vào danh sách của chúng ta, hai và ba.

1876
00:12:56,310 --> 00:13:15,420
Ở đây chúng tôi đếm các vị trí bị điện giật. Đếm có nghĩa là ở cấp độ hiện tại chúng ta có bao nhiêu nốt nhạc. Được rồi, chúng ta đang chạy cái này, Aluf, sau đó chúng ta sẽ rút nút ra và thêm ghi chú đó vào danh sách hiện tại của mình và kiểm tra xem nút bạch huyết có rỗng hay không hoặc thêm vào hàng đợi.

1877
00:13:15,600 --> 00:13:30,120
Nếu người viết không phải thì chúng tôi sẽ thêm vào hàng đợi ở cuối hoặc thêm cấp độ vào danh sách của mình. Và đây là cấp độ mà chúng tôi đã thêm vào danh sách của mình. Bây giờ chúng tôi có trong hàng đợi hai nút ở đây không trống và chúng tôi phải nút và chúng tôi đã tạo một danh sách mới.

1878
00:13:30,420 --> 00:13:41,940
Đây là danh sách mới của chúng tôi, có hai danh sách. Điều đó có nghĩa là chúng ta phải không đạt đến trình độ hiện tại. Vì vậy, hãy đặt hai cái và thêm vào danh sách của chúng ta cũng như thêm bên trái và bên phải vào hàng đợi của chúng ta.

1879
00:13:42,210 --> 00:13:53,430
Vì vậy, chúng tôi đã thêm bốn và năm để làm việc. Bây giờ, hãy đặt nút này ở vị trí thứ ba. Hãy thêm giá trị vào danh sách của chúng ta rồi cộng bên trái và số ba vào khối lập phương của chúng ta, sáu và bảy.

1880
00:13:53,880 --> 00:14:10,500
Bây giờ chúng ta thấy điều đó trên tài khoản. Chúng tôi có bốn nút ở đây không trống. Bây giờ hãy tạo một cấp độ mới ở đây. Chúng tôi sẽ tạo một cấp độ mới và sau đó dòng ngược bằng 4 vì ở cấp độ đó, chúng tôi có bốn nút và họ đang lấy nút đầu tiên ra khỏi hàng đợi của chúng tôi.

1881
00:14:10,500 --> 00:14:22,850
Vì vậy, hãy thêm bốn vào danh sách của chúng tôi, sau đó là bên trái và bên phải. Vì vậy, chúng tôi không thể thêm số vào hàng đợi của mình. Sau đó, chúng ta có năm, hãy thêm năm vào hàng đợi của chúng ta và bây giờ là năm bên trái và bên phải.

1882
00:14:23,250 --> 00:14:36,420
Sau đó, hãy rút ra ghi chú này để thêm sáu vào một danh sách, rồi bảy, hãy đưa ra bảy và hãy thêm bảy vào danh sách của chúng ta. Và sau đó chúng tôi sẽ trả về danh sách danh sách này và đây là danh sách danh sách.

1883
00:14:36,560 --> 00:14:48,930
Được rồi, đây là cách chúng ta có thể giải quyết vấn đề này. Lặp đi lặp lại chúng tôi đã hiểu lời giải thích video này. Giải pháp sẽ diễn ra theo độ phức tạp về thời gian và là số lượng ghi chú chúng ta có trong cây nhị phân đã cho.

1884
00:14:49,260 --> 00:15:02,010
Và giải pháp chỉ đưa chúng ta đi lên vũ trụ. Độ phức tạp là số nút chúng ta có trong cây đã cho. Điều này phức tạp về mặt thời gian vì chúng tôi đang xây dựng hàng đợi và chúng tôi đang xây dựng danh sách kết quả của mình.

1885
00:15:02,640 --> 00:15:15,990
Độ phức tạp của không gian tổng thể thường lớn hơn vì hai là một hằng số. Các bạn, đây là giải pháp của tôi cho vấn đề này. Chúng tôi đã hiểu giải pháp đệ quy và lặp đi lặp lại cho vấn đề này.

1886
00:15:16,330 --> 00:15:28,460
Nếu có bất kỳ câu hỏi nào về việc bổ sung này, hãy cho chúng tôi biết. Tôi tin tưởng mã nguồn của video này. Hãy kiểm tra nó. Nếu
bạn có bất kỳ đề xuất nào hoặc nếu bạn có bất kỳ vấn đề nào trong việc hiểu lời giải thích của video này, hãy cho chúng tôi biết. 

@@@



1887
00:00:00,870 --> 00:00:15,820
Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ triển khai một cây nhị phân bằng cách sử dụng cấu trúc dữ liệu của chúng ta. Trong phần thảo luận này, chúng ta sẽ triển khai parfum điều khiển hoạt động này trong cây nhị phân.

1888
00:00:16,470 --> 00:00:30,300
Trong video này, chúng ta sẽ nói về vấn đề này khi vận hành, tạo cây nhị phân và chèn giá trị. Sau đó chúng ta sẽ nói về cây nhị phân bị trì hoãn ở nút bên trái và sau đó chúng ta sẽ nói về hoạt động của Trevor.

1889
00:00:31,020 --> 00:00:42,630
Và trong phương pháp khủng bố này, chúng tôi sẽ triển khai bốn loại tế bào khủng bố để giúp bạn. Đặt hàng, gửi đơn đặt hàng và đặt hàng. Bây giờ hãy nói về lưới, cây nhị phân và thao tác chèn.

1890
00:00:43,380 --> 00:00:58,620
Điều này bằng cách sử dụng yêu cầu của chúng tôi trong lớp này, chúng tôi có một mảng và chúng tôi có một biến chỉ mục được sử dụng lần cuối để triển khai. Bên của cây được cố định.

1891
00:00:59,130 --> 00:01:15,420
Chúng ta không thể có cơ hội ở phía bên đó của cây một khi chúng ta đã tạo ra cây. Phương pháp này đáng tin cậy có một trang web tham số ở đây. Bên trong đây chúng ta đang tạo một mảng mới bên trong splodge one.

1892
00:01:15,850 --> 00:01:27,100
Chúng tôi đang tạo một mảng các trang web vì chúng tôi sẽ không sử dụng ô đầu tiên. Sau đó, chúng tôi có chỉ mục được sử dụng cuối cùng này ban đầu bằng 0 và chúng tôi đang in ở đây.

1893
00:01:27,220 --> 00:01:37,790
Cây được tạo ra. Nếu chúng ta gọi phương thức này là tạo cây nhị phân bằng Serban, thì sẽ tạo một mảng lente tám trong đó chúng ta có chỉ số từ 0 đến 7.

1894
00:01:38,520 --> 00:01:59,250
Ban đầu, chúng ta có thể coi cây của mình là hiện tại vì R trống, sẽ không chèn bất kỳ giá trị nào vào chỉ mục đầu tiên mà chúng ta đang chọn. Chỉ mục được sử dụng cuối cùng bằng hai không không không là chỉ mục của ô này và sẽ không sử dụng ô này trong khi triển khai cây nhị phân.

1895
00:01:59,250 --> 00:02:16,870
Sử dụng Arry, chúng ta có thể coi null này là một trung tâm tuyển dụng trống. Bây giờ hãy xem phương pháp chèn. Trung gian này nhận giá trị tham số trong quá trình kiểm tra của bạn, nếu đúng, sẽ triển khai phương thức này trong tiện ích này.

1896
00:02:16,890 --> 00:02:29,280
Đừng lo lắng về điều đó. Nếu phương thức này quay trở lại cây in chồng như trước đây chúng tôi đã đề cập rằng để triển khai cấu trúc, cạnh của cây được cố định.

1897
00:02:29,850 --> 00:02:44,250
Chúng tôi không thể thay đổi trang web một khi chúng tôi đã tạo cây bằng cách thêm vào cấu trúc và sau đó nó sẽ quay trở lại đây. Nếu vùng chưa đầy thì chúng ta sẽ chèn giá trị vào chỉ mục được sử dụng cuối cùng cộng với một.

1898
00:02:44,430 --> 00:03:00,060
Vì vậy chúng ta sẽ chèn giá trị từ vị trí này. Điều đó có nghĩa là từ chỉ số này một rồi hoặc tăng chỉ số lên một. Bây giờ hãy xem cấu trúc dữ liệu cây được biểu diễn một cách logic như thế nào.

1899
00:03:00,660 --> 00:03:25,110
Và chúng ta sẽ sử dụng công thức này để xây dựng cấu trúc dữ liệu cây logic từ mảng này trong trường hợp không đủ năng lực. Tất cả chúng ta đều có lỗi, được chứ? Và về mặt logic, chúng ta sẽ có một biểu diễn cây bằng công thức này và sẽ chọn phần tử từ chỉ mục một làm nốt gốc, sau đó nó sẽ áp dụng hình elip cho công thức này và đúng.

1900
00:03:25,110 --> 00:03:37,400
Chillicothe's với công thức này ở đây. X là chỉ số hiện tại. Nếu chúng ta gọi phương thức này, hãy chèn mười rồi bạn chèn vào đây mười, khi đó trong biểu diễn logic sẽ có mười.

1901
00:03:37,890 --> 00:03:50,370
Mười là một gốc. Không ổn. Nếu chúng ta gọi phương thức này là 20 thì chúng ta sẽ áp dụng công thức này. Leyb Child Etrix ở đây chúng ta sẽ chèn giá trị 20 vào đây.

1902
00:03:50,370 --> 00:04:06,660
Vì vậy, tại chỉ số hai và trong biểu diễn logic, chúng ta sẽ thêm hai X vào đây. X là chỉ số của Perugino. Đó là một, vậy 2x là hai. Vì vậy nó sẽ lấy giá trị này và chèn giá trị đó vào con trái của cây nhị phân này.

1903
00:04:06,930 --> 00:04:21,840
Vì vậy, tất cả trong hai mươi như vậy đối với con bên trái, nếu chúng ta gọi lại hàm này với tarde sẽ chuyển sang điều này, đến việc bán hàng ở chỉ số ba và sau đó chúng ta sẽ chỉ định bên giá trị là kết quả của nút tuyến đường này mười.

1904
00:04:22,380 --> 00:04:34,280
Vì thế. Phải. Chillicothe dành cho mỗi hai chuyên gia ở đây X Chỉ số một, vậy Cành cây cộng một là ba. Vì vậy, chúng tôi sẽ chèn giá trị này vào nút con bên phải của nút gốc này.

1905
00:04:34,380 --> 00:04:44,400
Sau đó, về mặt logic, tên cướp sẽ được đại diện. Một cái gì đó như thế này. Nếu chúng ta gọi phương thức này bằng 40 thì chúng ta sẽ chèn 40 vào chỉ mục 4 và nút gốc này sẽ được xem xét.

1906
00:04:44,640 --> 00:04:57,330
Vậy con là Arijit X chỉ số lên hai mươi là hai, nên hai X là bốn nên sẽ chèn bốn mươi. Là con trái của nút này hai mươi. Vậy hãy cộng nó vào đây.

1907
00:04:57,480 --> 00:05:15,440
Nếu chúng ta gọi lại thì tất cả. Thay vì 50 ở đây và sẽ chèn 50 vào bên phải của nút gốc này vào tuyến đường hiện tại của chúng, và chúng ta có thể lấy chỉ số của phần tử này 50 bằng hai X cộng một, hai nhân hai cộng một là năm.

1908
00:05:15,670 --> 00:05:28,880
Có thể gọi lại phương thức này bằng 60, sẽ chèn 60 vào chỉ số sáu. Và chúng ta sẽ áp dụng đứa trẻ này của ba mươi ba X tức là sáu. Vì vậy, hãy chèn sáu năm.

1909
00:05:28,880 --> 00:05:41,330
Bên trái của nút này, chúng ta gọi lại bằng 70, sau đó chúng ta sẽ chèn 70 vào ngay đây và chúng ta sẽ áp dụng công thức này bằng cách xem xét nút gốc ngày nay.

1910
00:05:41,900 --> 00:05:56,090
Gốc hiện tại, không phải ba nhân hai cộng bảy mà thôi. Vậy hãy chèn vào đây 70. Vậy hãy chèn 70 của bạn và bên trái của 40 là X và đó là 8. Số tám đó nằm ngoài mọi ranh giới.

1911
00:05:56,090 --> 00:06:09,950
Người lính ba thì chúng ta có thể coi là vô giá trị. Và số bên phải bây giờ cũng là hai nhân bốn cộng một bằng hai chín. Đó là ranh giới khu vực của chúng tôi. Vì vậy, một lần nữa, hãy xem xét Lebanon ngay bây giờ là 40, 50, 60 và 70.

1912
00:06:10,100 --> 00:06:20,570
Khu vực này sẽ được lưu trữ trong bộ nhớ máy tính. Nhưng về mặt logic, cấu trúc dữ liệu cây đó sẽ được biểu diễn giống như thế này. Đây là sự biểu diễn logic của cấu trúc dữ liệu của chúng tôi.

1913
00:06:20,880 --> 00:06:35,900
Chúng ta đã hiểu cách thức hoạt động của phương thức chèn. Phương pháp này chiếm độ phức tạp một lần và do độ phức tạp một không gian, phương pháp krit này về bản chất sẽ chiếm độ phức tạp một lần và B tăng lên trong không gian.

1914
00:06:35,900 --> 00:06:53,420
Độ phức tạp là phía của mảng đó. Bây giờ hãy nói về phương pháp Espoo. Phương thức này sẽ trả về giá trị sai của chúng ta nếu thêm lente trừ một bằng với chỉ mục được sử dụng lần cuối và hai L2 sẽ củng cố nếu chúng ta gọi hàm này dành cho nhị phân đã cho này thì nó sẽ trả về.

1915
00:06:53,420 --> 00:07:03,690
Đúng, bởi vì trang web của lỗi của chúng tôi có đầy đủ sự hiểu biết giải thích dân sự này.
Ngay cả khi bạn hiểu lời giải thích bằng tiếng Thụy Điển này, hãy cho chúng tôi biết. 

@@@



1916
00:00:00,570 --> 00:00:12,660
Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ triển khai phương pháp này theo phương thức dịch vụ tìm kiếm và trước hết, hãy hiểu, giả sử chúng ta gặp phải lỗi này.

1917
00:00:12,930 --> 00:00:25,360
Đây được coi là cấu trúc dữ liệu cây vì bạn đang triển khai một cây đang được thêm vào cấu trúc. Đây là khu vực và đây là sự biểu diễn logic của khu vực này.

1918
00:00:25,800 --> 00:00:40,610
Làm thế nào một giá trị như vậy có thể có trong cấu trúc dữ liệu cây khi chúng ta triển khai cây có lỗi? Đây là thuật toán cho hoạt động tìm kiếm. Phương thức này lấy một giá trị tham số bên trong.

1919
00:00:40,620 --> 00:01:00,060
Ở đây chúng tôi đang chạy một vòng lặp từ chỉ mục này đến chỉ mục được sử dụng cuối cùng. Và ở đây chỉ số được sử dụng cuối cùng là số bảy. Ở đây chúng tôi đang tìm kiếm từ chỉ mục một đến chỉ mục được sử dụng cuối cùng, bắt đầu từ chỉ mục 0, số 0 là chỉ mục không được sử dụng đầu tiên.

1920
00:01:00,060 --> 00:01:09,990
Chúng tôi sẽ kiểm tra từ chỉ mục một. Nếu chúng ta gọi phương thức có giá trị 20 thì sao? Nó sẽ trở lại đầu tiên. Chúng ta thấy mười trong lần lặp lại tiếp theo của tình yêu này.

1921
00:01:09,990 --> 00:01:28,540
Chúng ta thấy mình có 20. Vì vậy, nó sẽ trả về chỉ số của giá trị 20. Đó là để. Vì vậy nó sẽ quay lại vì phương pháp này với 70 và đầu tiên sẽ kiểm tra với Tin Tin không bằng 70 vào năm 2020 không bằng 70 cả ngày hôm nay không bằng 70.

1922
00:01:28,840 --> 00:01:50,380
Khi đó 44 không bằng 70, 50 đến 70, 60 hoặc 70. Và chúng ta thấy 70 bằng 70. Vì vậy, nó sẽ giữ lại chỉ số bảy cho lệnh gọi hàm này. Nó sẽ giữ lại bảy vì chức năng này với 80 với 80 không tồn tại trong khu vực này.

1923
00:01:50,860 --> 00:02:13,750
Vậy bạn có thể nói 80 ​​không chỉ có ở cây nhị phân này. Vì vậy, chúng tôi sẽ chỉ trả lại trừ một. Đây là cách phương pháp này hoạt động. Phương
pháp này sẽ phát triển về độ phức tạp về thời gian và lớn hơn về độ phức tạp về không gian, nơi đó là số nút chúng ta có trong cây nhị phân. 

@@@



1924
00:00:00,840 --> 00:00:16,770
Ở đây rất nhiều bạn sẽ quay lại video này trong video này. Chúng tôi sẽ thực hiện thao tác này, xóa và không tháo dỡ. Tất cả đều cần một giá trị đầu vào và nó sẽ loại bỏ giá trị khỏi lettieri cây nhị phân vào đó.

1925
00:00:17,460 --> 00:00:31,040
Đây là loại mã để xóa một nút cụ thể khỏi cây nhị phân. Để dễ hiểu, giả sử chúng ta có diện tích này và mảng này được biểu diễn dưới dạng cây, đại loại như thế này.

1926
00:00:31,680 --> 00:00:43,890
Phương thức này nhận tham số. Bên trong đây, chúng ta đang tìm ra vị trí của giá trị đã cho. Nếu giá trị không tồn tại trong cây thì metatarsus này sẽ trả về âm một.

1927
00:00:44,370 --> 00:00:55,200
Chúng tôi đã thấy phương pháp này. Nếu vùng phương thức trừ đi một, điều đó có nghĩa là giá trị không tồn tại trong nhị phân đến giá trị in cũ không tồn tại và chúng tôi sẽ trả về.

1928
00:00:55,470 --> 00:01:11,240
Nếu không, chúng ta sẽ nhận được nốt nhạc sâu sắc nhất. Điều đó có nghĩa là phần tử cuối cùng của mảng và sẽ cập nhật giá trị ở vị trí mong muốn và sẽ di chuyển chỉ mục được sử dụng cuối cùng sang trái mà không sửa đổi giá trị.

1929
00:01:11,490 --> 00:01:20,760
Chúng tôi có thể sửa đổi giá trị hoặc chúng tôi có thể thay đổi giá trị thành giá trị mặc định hoặc chúng tôi có thể bỏ qua giá trị ở đây hoặc chỉ giữ giá trị. Hãy xem nó hoạt động như thế nào.

1930
00:01:21,150 --> 00:01:33,840
Nếu chúng ta gọi phương thức này là nút xóa bằng ba mươi thì trước tiên, bạn sẽ làm gì? Chúng ta sẽ tìm chỉ số của nó là ba mươi và đó là ba. Sau đó chúng ta sẽ tìm ra nút sâu nhất.

1931
00:01:33,840 --> 00:01:46,860
Điều đó có nghĩa là phần tử cuối cùng có lỗi là bảy mươi. Vì vậy, phần tử này và ở đây nút này và sau đó chúng ta sẽ cập nhật giá trị tarty với giá trị của nút tốt nhất.

1932
00:01:47,190 --> 00:02:01,340
Vì vậy, hãy bắt đầu với 70 và sau đó chúng ta sẽ bỏ qua chỉ mục được sử dụng cuối cùng. Vì vậy, chỉ mục cuối cùng sẽ di chuyển đến phần tử này nên chúng ta có thể coi 70 không tồn tại trong cây hoặc chỉ giữ nguyên giá trị.

1933
00:02:01,350 --> 00:02:12,480
Được rồi, chúng ta có nút đó từ chỉ mục đến chỉ số sáu để tôi sẽ được biểu diễn như thế này và cây logic sẽ được biểu diễn một cách logic, đại loại như thế này.

1934
00:02:12,780 --> 00:02:30,540
Bây giờ là nốt đúng của bảy mươi. Chúng tôi đã xóa nút 30 ngay tại đây. Hôm nay chúng tôi đã cập nhật giá trị của nút này lên 70. Nếu chúng ta gọi phương thức này là sáu mươi, thì đầu tiên chúng ta sẽ tìm chỉ số của nút này là sáu, tức là sáu.

1935
00:02:31,140 --> 00:02:45,390
Và sau đó chúng ta sẽ tìm thấy nút phòng thủ ở đó. Và đó chính là lưu ý rằng chúng ta sẽ bỏ qua phần cần thực hiện ở đây và cũng để phát triển 660 bằng cách sử dụng câu lệnh này và chúng ta sẽ di chuyển chỉ mục được sử dụng cuối cùng này sang ô trước đó.

1936
00:02:45,810 --> 00:02:58,680
Vì vậy, hãy giữ giá trị hiện tại. Và về mặt logic, chúng ta có thể coi như không có nút nào được gọi là sáu mươi. Vì vậy, nó sẽ được biểu diễn giống như thế này, và diện tích sẽ được biểu diễn, giống như thế này.

1937
00:02:58,830 --> 00:03:11,070
Đây chỉ là một đại diện hợp lý của khu vực này. Và chúng tôi đã bỏ qua hai mục này. Đây là phương pháp nút dẫn hoạt động ở đây. Chúng tôi đang lấy nút sâu nhất.

1938
00:03:11,250 --> 00:03:23,070
Chúng tôi cũng có thể lấy bất kỳ hạch bạch huyết nào. Nhưng để dễ thực hiện, chúng tôi đang lấy nút sâu nhất. Điều đó có nghĩa là phần tử cuối cùng từ khu vực của chúng tôi và cập nhật sa mạc có sẵn, không phải với nút sâu nhất.

1939
00:03:23,470 --> 00:03:36,330
Chúng tôi đã hiểu lời giải thích video này. Phương pháp này sẽ mất nhiều thời gian vì độ phức
tạp về thời gian và độ phức tạp không gian không đổi. Chúng tôi đã hiểu phương pháp này. 

@@@



1940
00:00:00,690 --> 00:00:12,760
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ thấy phương pháp xóa cây nhị phân này. Đây là phương pháp. Phương pháp này không có tham số bên trong ở đây hoặc chỉ ngồi ở thời điểm hiện tại.

1941
00:00:13,200 --> 00:00:28,820
Vì vậy, mũi tên sẽ vui mừng như thế nào khi anh ta nói bằng với bây giờ để dễ hiểu, hãy giả sử hoặc cho mảng này và điều này đang tạo ra như Tillett một cấu trúc và đây là biểu diễn logic của khu vực này.

1942
00:00:29,310 --> 00:00:51,960
Khu vực đang trỏ đến phần tử đầu tiên. Biến mảng đang trỏ đến phần tử đầu tiên của mảng và nó hoạt động giống như một con trỏ. Mũi tên đang trỏ đến phần tử đầu tiên khi chúng ta nói bằng với bây giờ, vùng sẽ không trỏ đến phần tử đầu tiên tại con trỏ và nó sẽ trỏ đến null.

1943
00:00:52,350 --> 00:01:04,290
Vì vậy, không có gì được trỏ đến ô đầu tiên. Vì vậy, mũi tên sẽ bị xóa. Vì mũi tên hoạt động theo kiểu liền kề nên toàn bộ khu vực sẽ bị người thu gom rác xóa.

1944
00:01:05,460 --> 00:01:17,210
Vì vậy liên kết đó sẽ bị xóa khỏi RAM và cả mũi tên liên quan nữa. Khi anh ấy nói, Eric, điều đó
hiện đúng và hoạt động này sẽ chiếm độ phức tạp một lần và nhận độ phức tạp một không gian. 

@@@



1945
00:00:00,690 --> 00:00:10,950
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ duyệt cây nhị phân bằng cách sử dụng phương pháp duyệt terrazzo theo thứ tự trước, cây nhị phân sử dụng phương pháp duyệt theo thứ tự trước.

1946
00:00:11,550 --> 00:00:27,030
Điều đầu tiên về sự hiểu biết, giả sử chúng ta được cấp cây nhị phân này trước tiên. Hãy xem ưu tiên hàng đầu là gì. EVERSOLE Đầu tiên, chúng ta sẽ ghé thăm không phải 10, rồi 20, rồi 40, 50, rồi 30, 60, rồi 70.

1947
00:00:27,760 --> 00:00:55,130
Đây được gọi là Turso. Bạn đang hiểu ưu tiên là gì? Sự tiếp nhận của chúng tôi trong video này, nơi bạn đã nói chi tiết về Phyu Order in order và post hoặc một tế bào khủng bố cũng như cách thức hoạt động của các thủ thuật, ngay cả khi chúng tôi hiểu rõ về video đó, mọi người đưa ra cây nhị phân này, chúng tôi phải trả lại cái này đầu tiên liệt kê 10, 20, sau đó là 40, 50, 30, 60, 70.

1948
00:00:55,830 --> 00:01:27,780
Bây giờ chúng ta hãy xem thuật toán. Đây là thuật toán duyệt theo thứ tự trước. Nó lấy chỉ mục chỉ mục là chỉ mục của phần tử đầu tiên và có một. Đây là NORCOM gốc và chỉ mục này lớn hơn chỉ mục được sử dụng lần cuối hoặc chỉ trả về giá trị đó hoặc tồn tại theo câu lệnh bằng văn bản này, thậm chí in đè giá trị từ chỉ mục hiện tại của chúng tôi và thu hồi khoảng thời gian hai lần chỉ mục và gọi đặt hàng trước hai lần chỉ số cộng một.

1949
00:01:28,050 --> 00:01:38,720
Nó giống như lit và đây giống như một quyền mà chúng tôi gọi nhà cung cấp phương pháp này với chỉ mục một. Đây là chỉ mục của ghi chú gốc. Đây là sự thô sơ của chúng tôi.

1950
00:01:38,850 --> 00:01:49,740
Vì vậy, hãy in chuỗi giá trị ngay bây giờ. Chúng ta hãy sang bên trái để kết xuất chỉ mục hai lần một là hai. Vậy giá trị đó là hai mươi. Hai mươi bên trái là hai nhân hai.

1951
00:01:49,740 --> 00:02:02,970
Đó là bốn và có bốn mươi tuổi in hai mươi thì sẽ in bốn mươi rồi hãy in bốn mươi vì hai nhân hai là bốn mươi rồi hai nhân hai cộng một có năm mươi.

1952
00:02:02,970 --> 00:02:19,870
Vì vậy, hãy in năm mươi rồi với ghi chú này hai nhân một cộng với Nghiên cứu lại, hãy in số lepidoptera là sáu mươi hai nhân ba sáu. Vậy là sáu mươi. Hãy in sáu mươi rồi hai nhân ba cộng một.

1953
00:02:19,870 --> 00:02:31,050
Đó là bảy ở chỉ số bảy, chúng ta có bảy mươi vì vậy hãy in bảy mươi. Vì vậy, bằng cách duyệt cây nhị phân này bằng cách duyệt theo thứ tự trước, chúng ta có được danh sách này và đây là cách thuật toán này hoạt động.

1954
00:02:31,370 --> 00:02:42,510
Chúng tôi đã hiểu thuật toán này hoạt động như thế nào. Nếu có thể hiểu được, tôi thực sự khuyến khích bạn cố gắng hiểu thuật toán này bằng cách lấy một số ví dụ.

1955
00:02:42,960 --> 00:02:55,530
Giải pháp này sẽ đưa Spiga về độ phức tạp về thời gian và cũng sẽ đưa Bygrave về độ phức tạp về không
gian cho phép đệ quy được gọi là ngăn xếp. Hoặc đó là số nút trong một cây nhị phân nhất định. 

@@@



1956
00:00:00,480 --> 00:00:09,540
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng ta sẽ nói về việc xào xạc cây nhị phân, nếu bạn không hiểu, sẽ được miễn trừ.

1957
00:00:09,720 --> 00:00:27,630
Vì vậy, trong phần này của khóa học này, chúng tôi có một video. Những gì chúng ta đã nói, đặt hàng trước theo thứ tự và đăng hoặc duyệt chi tiết trong Inanna traversal lần đầu tiên luôn truy cập không phải là 40, rồi 20, rồi 50, rồi 10, rồi 60, rồi 30, rồi 70.

1958
00:00:28,150 --> 00:00:39,150
Vì vậy, nếu chúng tôi cho phép nhị phân này hoạt động trong danh sách này và đây là danh sách chúng tôi có thể nhận được bằng cách truy tìm cây nhị phân sử dụng để bán. Bây giờ hãy xem thuật toán.

1959
00:00:39,390 --> 00:00:51,390
Đây là thuật toán truyền tải. Phương thức này lấy một chỉ mục tham số, nút được phê duyệt chỉ mục. Sau đó chúng tôi đang kiểm tra bên trong. Nếu chỉ mục lớn hơn chỉ mục được sử dụng lần cuối thì chúng tôi sẽ quay lại.

1960
00:00:51,630 --> 00:01:03,030
Nếu không, thì chúng ta gọi nó để lập chỉ mục khi chúng ta truy cập nút ngoài cùng bên trái hoặc in giá trị của nút ngoài cùng bên trái. Và sau đó chúng tôi đang gọi với chỉ số hai lần cộng một.

1961
00:01:03,030 --> 00:01:15,870
Đây là một cái gì đó giống như. Phải? Đây là một cái gì đó giống như lit. Và đây là một cái gì đó như thế. Phải. Đây là nút gốc của chúng tôi. Thế thì hai lần một là hai. Đó là 20 trong lệnh gọi hàm này.

1962
00:01:16,080 --> 00:01:28,680
Sau đó, một lần nữa, hai nhân hai là vì có 48 chỉ số trong đó chúng ta có 40. Bây giờ bên trái là toàn bộ quá trình. Ghi chú này, hãy xử lý bốn mươi, sau đó hãy in bốn mươi.

1963
00:01:28,680 --> 00:01:40,190
Ngay bây giờ nó sẽ quay trở lại. Bây giờ chúng tôi xử lý thư này không để ghi chú này. Vì vậy, hãy in hai mươi rồi sang bên phải. Phải. Năm mươi, hãy in năm mươi.

1964
00:01:40,500 --> 00:01:51,840
Bây giờ chúng ta thấy nó. Chúng tôi xử lý bên trái của ghi chú này mười. Bây giờ hãy xử lý cái này, không phải mười thì hãy đi ngay bây giờ. Hãy sang trái và bây giờ là bên trái nên hãy in sáu mươi.

1965
00:01:51,840 --> 00:01:59,610
Đúng là không tốt bằng. Bây giờ chúng ta hãy in ghi chú này ngày hôm nay. Vì quá trình của bạn đã để lại ghi chú về ghi chú này ngày hôm nay. Bây giờ chúng ta hãy sang bên phải và có bảy mươi.

1966
00:01:59,610 --> 00:02:08,670
Bây giờ, giả sử nó không phải là bảy mươi. Đây là những gì chúng ta có thể duyệt cây nhị phân bằng cách sử dụng tháp thứ tự. Vì vậy, đây chỉ là một biểu diễn logic của khu vực này.

1967
00:02:08,850 --> 00:02:23,490
Và chúng ta có thể xây dựng cái cây này bằng cách sử dụng con robot này và con bên phải và để nó khám phá chính nó. Và bằng cách lấy chỉ mục hợp lệ làm nút gốc, chúng tôi đã hiểu phương pháp này theo thứ tự truyền tải.

1968
00:02:23,790 --> 00:02:34,170
Chúng tôi đã hiểu phương pháp này. Phương pháp này sẽ giúp Spiga giảm độ phức tạp về thời
gian và sẽ đưa Spiga bay vào không gian. Phức tạp đã hiểu được lời giải thích này. 

@@@



1969
00:00:00,300 --> 00:00:10,430
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng tôi sẽ triển khai bài viết hoặc một bài dành cho những người nổi tiếng Berlusconi. Giả sử chúng ta được cấp cây nhị phân này.

1970
00:00:11,250 --> 00:00:24,550
Đầu tiên, hãy nói về bài đăng trên ô khủng bố trong bài là gì hoặc bài đăng của ô khủng bố sẽ xử lý nút này 40, rồi 50, rồi 20, rồi 60 và 70, rồi 30, rồi 10.

1971
00:00:25,200 --> 00:00:37,700
Khái niệm ở đây là sẽ xử lý nút hiện tại, xử lý apple, tất cả con trái và con phải, thậm chí hiểu được những gì trái ngược với ô khủng bố trong phần này.

1972
00:00:38,100 --> 00:00:48,690
Những gì chúng ta đã nói, hãy đặt hàng trước theo thứ tự và gửi thứ tự đến ô của chúng tôi một cách chi tiết. Bây giờ hãy xem thuật toán. Đây là thuật toán đi qua lớp bọc.

1973
00:00:49,260 --> 00:01:00,900
Phương thức này lấy chỉ mục của nút gốc tại đây, kiểm tra bên trong tại đây hoặc kiểm tra xem chỉ mục có lớn hơn vùng chỉ mục được sử dụng lần cuối hay không. Nó sẽ gọi với chỉ số hai lần.

1974
00:01:01,200 --> 00:01:16,860
Và để kết xuất chỉ mục một, cái này sẽ sáng và cái này ở ngay đây và đây. Nút phải Collinwood. Và bạn đang xử lý nút hiện tại khi chúng tôi đã xử lý tất cả phần con bên trái và bên phải thành một hạt A..

1975
00:01:17,560 --> 00:01:29,610
Vậy đầu tiên chúng ta có mười, sau đó hai lần chỉ số là hai vì hai số hạng trên hai của nó, sau đó hai lần hai là cho nên tất cả các lần truy cập vào ghi chú này và bên trái không phải là viết hết.

1976
00:01:29,610 --> 00:01:39,810
Đúng là bây giờ. Vì vậy bây giờ hãy xử lý nút này. Chúng ta nhận thức được bên trái và bên phải. Vì vậy, chúng tôi gọi phương thức này là đặt hàng bài với nút được phê duyệt chỉ mục, nó sẽ in đầu tiên.

1977
00:01:39,810 --> 00:01:52,350
Bốn mươi ba phần trăm bên trái của nút này là hai mươi. Bây giờ chúng ta sang bên phải và bên trái và bên phải là bây giờ. Vì vậy, hãy xử lý nút này. Hãy in quá trình 50 năm ở đầu bên trái và bên phải của cái này chứ không phải 20.

1978
00:01:52,350 --> 00:02:03,660
Vì vậy, hãy xử lý nút này. In ra 21 nút tính chỉ số cho mỗi nốt nhạc mà bạn tính chỉ số của từng nốt nhạc thì bạn sẽ chán.

1979
00:02:04,080 --> 00:02:16,740
Bạn có thể tính toán bằng cách sử dụng thuật toán này. Được rồi, việc lập chỉ mục cực kỳ đơn giản và hai lần chỉ số cộng một, chúng ta sẽ xử lý tất cả những điều này chứ không phải 10. Hãy đặt ghi chú đúng này vào đây.

1980
00:02:16,750 --> 00:02:27,030
Bây giờ chúng ta hãy đặt ghi chú này ở đây. Đây là bên trái và cho chúng tôi biết ngay bây giờ. Vì vậy, hãy xử lý sáu mươi. Hãy in sáu mươi. Hôm nay chúng ta đã hoàn thành xong phần việc còn lại của doanh nghiệp.

1981
00:02:27,060 --> 00:02:42,570
Chúng ta hãy đi sang bên phải. Trái bây giờ phải bây giờ cũng là đến. Và bây giờ hãy in số bảy. Toàn bộ quá trình này trái và phải bây giờ chúng ta hãy đưa Dissinger xử lý trái và phải thiết lập ngay hôm nay vì điều này không nên chúng ta xử lý con trái và con phải.

1982
00:02:42,570 --> 00:03:02,900
Vì vậy hãy in số 10 hiện tại. Và để thực hiện được điều này, cách thức hoạt động tự động của bài đăng này, phương pháp này sẽ phát triển về độ phức tạp về thời gian và lớn hơn về độ phức tạp về không gian, bạn có thể tính chỉ số bằng cách sử dụng biểu mẫu này chỉ số Rotterdam hai lần chỉ số cộng một.

1983
00:03:03,110 --> 00:03:19,490
Điều đó cực kỳ đơn giản. Khi bạn xử lý trái và phải, nó sẽ xử lý ghi chú hiện tại. Và đây là những gì chúng ta có thể nhận được
danh sách này nếu hiểu lời giải thích này của Aveda, ngay cả khi bạn hiểu lời giải thích tốt hơn, hãy cho chúng tôi biết. 

@@@



1984
00:00:00,540 --> 00:00:08,970
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ thấy mức độ thân của cây nhị phân. Hãy xem làm thế nào chúng ta có thể làm điều đó.

1985
00:00:09,150 --> 00:00:25,990
Điều này sẽ cực kỳ đơn giản. Đầu tiên, giả sử đây là bạn được tặng một cái cây. Tế bào khủng bố trong tế bào khủng bố là gì? Cây nào cấp 1 trước cấp này 10, rồi 20, rồi 30, rồi 40, 50, 60, 70.

1986
00:00:26,340 --> 00:00:38,520
Vì vậy, đây là một cấp độ. Đây là một cấp độ. Và đây là cấp độ 10, 20, 30, 40, 50, 60, 70. Bây giờ chúng ta hãy xem thuật toán. Và đây là thuật toán siêu đơn giản.

1987
00:00:38,850 --> 00:00:51,410
Chúng tôi chỉ lặp lại từ chỉ mục này đến chỉ mục được sử dụng cuối cùng từ chỉ mục một đến chỉ mục bảy này. Nếu chúng ta gọi phương thức này thì thứ tự cấp độ sẽ đi từ chỉ mục này sang chỉ mục bảy.

1988
00:00:51,420 --> 00:01:08,960
Đầu tiên sẽ in ra 10, họ sẽ in 20, rồi 30, rồi 40, rồi 50, 60, rồi 70. Và đây là phép duyệt cấp bậc của cây nhị phân. Điều này cực kỳ đơn giản.

1989
00:01:09,150 --> 00:01:29,980
Như vậy chúng ta thấy mức độ ô khủng bố của cây nhị phân là cực kỳ đơn giản. Khi chúng tôi triển khai cây nhị phân bằng cách sử dụng mọi hoặc hiểu phương
pháp này, tất cả các phương pháp này đều diễn ra theo thời gian, độ phức tạp và độ phức tạp không gian không đổi mà chúng tôi đã hiểu mức độ truyền tải. 

@@@



1990
00:00:00,510 --> 00:00:20,700
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng ta sẽ nói về cấu trúc dữ liệu trạng thái nhị phân là gì. Bây giờ chúng ta hãy nói về cấu trúc dữ liệu khát nhị phân, khát nhị phân hay nói ngắn gọn hơn, BSG là một cây nhị phân trong đó tất cả các nút đều tuân theo hai thuộc tính.

1991
00:00:21,580 --> 00:00:38,010
Cây con bên trái phía trên A. có một bài học quan trọng đối với cây mẹ của nó, Norske. Và đúng thành phố L.A. có một chiếc chìa khóa lớn hơn cả thành phố mẹ của nó, Norske, đây là hai đặc tính của xã hội nhị phân.

1992
00:00:39,040 --> 00:00:53,470
Đây là một ví dụ về sự khát khao nhị phân đối với điều này, không phải giá trị của sự giải phóng. Là Leavesden và Tuyên ngôn Nhân quyền. Một cây lớn hơn nên đây không phải là cây có tính chất nhị khát.

1993
00:00:53,800 --> 00:01:14,160
Và hai nút này là các nút trực tiếp nên sẽ không áp dụng các thuộc tính cho Livnat. Đây là một ví dụ về tìm kiếm nhị phân. Đây là một điểm hợp lệ và về cơ bản tất cả các nút đều tuân theo các đặc tính của sastry nhị phân ngoại trừ hạch bạch huyết.

1994
00:01:14,940 --> 00:01:26,110
Đây không phải là lịch sử tìm kiếm nhị phân vì giá trị ở cây con bên trái lớn hơn giá trị. Ở bên phải, Sebti cũng lớn hơn. Vì vậy đây không phải là tìm kiếm nhị phân hợp lệ.

1995
00:01:26,920 --> 00:01:40,360
Bây giờ chúng ta hãy xem thêm một số ví dụ. Đây là một ví dụ về nhị phân t biết. Hãy xem liệu cây này có phải là một xã hội nhị phân hợp lệ hay không. Đầu tiên, đối với điều này, không phải giá trị đó.

1996
00:01:40,360 --> 00:01:54,250
Bên trái là ba ba sáu bốn bảy một và giá trị nhỏ hơn giá trị của nút gốc và giá trị ở cây bên phải lớn hơn 8, 10, 14 Tareen.

1997
00:01:54,430 --> 00:02:05,020
Vì vậy, đây không phải là nút này tuân theo các thuộc tính của khát vọng nhị phân vì nút này tồn tại theo lasdun của nó và cây con bên phải lớn hơn sáu cho bảy.

1998
00:02:05,020 --> 00:02:22,750
Và đối với nút này, cây con bên trái và bên phải lớn hơn và ba nút này là các nút trực tiếp. Sau đó, đối với nút này không có nút nào được chọn. Bên phải, không phải bên phải lớn hơn nút rõ ràng này.

1999
00:02:22,750 --> 00:02:36,400
Vì vậy ghi chú này tuân theo các thuộc tính của DST nhị phân. Bây giờ lưu ý này, không có nút bên phải. Hạch nhỏ hơn con vẹt này 14. Vậy đây là tính chất tất yếu và đây là Livnat.

2000
00:02:36,550 --> 00:02:54,550
Vì vậy, bạn có thể thấy đây là một mạch nhị phân hợp lệ từng được cung cấp nhị phân này, hãy yêu cầu thiểu số này là một nhị phân hợp lệ. Vậy là vẫn chưa có nốt trái, không phải mỗi nốt của cây nhị phân này và nốt phải đều lớn hơn nút cha.

2001
00:02:54,940 --> 00:03:05,500
Vì vậy, cái này lớn hơn nút một. Vì vậy, đây là theo các thuộc tính chính xác. Nút này cũng đang tìm các thuộc tính của sastry nhị phân, nút này, ghi chú này nữa, và đây là Livengood.

2002
00:03:06,610 --> 00:03:26,300
Vậy đây là một hệ nhị phân hợp lệ mà chúng ta có thể thấy. Chúng tôi được cấp cây nhị phân này, chúng tôi thấy không có nút con bên phải nào của bất kỳ nút nào và phía bên trái lớn hơn nút cha, hai lớn hơn một năm, ba lớn hơn hai cho nơi cư trú của anh ta.

2003
00:03:26,600 --> 00:03:37,640
Bốn lớn hơn ba. Vì vậy đây không phải là chuỗi tìm kiếm nhị phân hợp lệ. Đây là khát nhị phân không hợp lệ. Cây này không bị đổ. Các thuộc tính của tìm kiếm nhị phân cây đó.

2004
00:03:37,880 --> 00:03:51,890
Cây này không phải là một mạch nhị phân. Nếu bạn được cho cây nhị phân này trong nhị phân này, chúng ta thấy bên trái của nút này năm nhỏ hơn bên trái của nút này, không phải cho là nhỏ hơn bốn.

2005
00:03:51,890 --> 00:04:01,280
Và phía bên trái của nút này ba nhỏ hơn đó là hai. Và tay trái của cái này, không phải hai, nhỏ hơn hai. Và đây là Livnat. Vì vậy chúng ta có thể nói đây là một mạch nhị phân hợp lệ.

2006
00:04:02,720 --> 00:04:15,020
Bây giờ, hãy xem thêm một số ví dụ. Đó là cách mà đây là một phi hành gia người Anh hợp lệ, ghi chú này là thuộc tính của hệ nhị phân. Tất cả NFL ở bên trái ít hơn tất cả.

2007
00:04:15,020 --> 00:04:27,860
NFL về chủ đề phù hợp còn lớn hơn đối với điều này. Không phải tất cả NFL và đồng tính nữ cũng như tất cả NFL về đúng chủ đề đều lớn hơn. Vì vậy, đây là một trong những tính chất của, như bạn biết, đối với cái này, không phải sáu.

2008
00:04:28,570 --> 00:04:36,290
Không có ghi chú đúng. Và ghi chú nhỏ hơn nốt ở chủ đề bên trái nhỏ hơn và đối với cây con bên phải. Vì vậy, không cần phải làm gì ở bên phải.

2009
00:04:36,920 --> 00:04:52,070
Vì vậy không cần phải làm gì cho cây con phù hợp. Vậy có một kẻ đang điều hành tài sản của Bonynge. Sáu mươi mốt, bốn và chín là Livnat. Chúng ta cần áp dụng các thuộc tính của nhị phân trong lenard để bạn có thể nói đây là một hệ nhị phân hợp lệ.

2010
00:04:52,610 --> 00:05:04,340
Nếu chúng ta được cho cây nhị phân này và cây ở bên trái của số tám này nhỏ hơn Valinda cho đến lớn hơn. Vì vậy, điều này có nghĩa là Dự luật 187 vẫn được áp dụng cho nút này.

2011
00:05:04,520 --> 00:05:17,210
Chà, ở cây con bên trái nhỏ hơn một giá trị ở bên phải không lớn hơn giá trị chúng ta thấy ở đây. Hai là ít hơn ba. Vì vậy, ghi chú này không được theo dõi. Các thuộc tính của nhị phân cho biết đây không phải là nhị phân hợp lệ.

2012
00:05:17,210 --> 00:05:37,130
Sastry, chúng ta đã hiểu Sastry nhị phân là gì. Bây giờ, bạn có thể hỏi tại sao chúng ta cần Sastry nhị phân. Bây giờ hãy nói về hoạt động của Saaz. Trong một lĩnh vực mà nó phục vụ một phần tử trong một mảng, điều này xảy ra vì đối với những đứa trẻ tồi tệ nhất và đối với các nhà ngôn ngữ học, Spiga cũng sẽ gặp phải sự phức tạp về thời gian.

2013
00:05:37,760 --> 00:05:59,780
Khi nào là mạch nhị phân? Hoạt động tìm kiếm sẽ mất nhiều thời gian hơn, phức tạp hơn và thống kê nhị phân Idjwi này đã xuất hiện. Nếu chúng ta có một tập dữ liệu khổng lồ, nếu chúng ta sử dụng Arry hoặc nhà ngôn ngữ học, thì sẽ mất rất nhiều thời gian để tìm nguồn một phần tử trong mảng hoặc trong cấu trúc dữ liệu.

2014
00:06:00,320 --> 00:06:14,390
Nhưng nếu chúng ta lưu trữ tập dữ liệu lớn trong một xã hội nhị phân, thì chúng ta sẽ tìm ra phần tử sa mạc theo độ phức tạp thời gian logarit. Và nó nhanh hơn độ phức tạp thời gian tuyến tính.

2015
00:06:14,630 --> 00:06:24,830
Và đây là lý do tại sao chúng tôi sử dụng mạch nhị phân. Chúng ta đã hiểu thế nào là
cần thiết và tại sao chúng ta cần học vì sự cần thiết. Cảm ơn đã xem video này. 

@@@



2016
00:00:00,360 --> 00:00:12,810
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ triển khai điều này với Phương thức Tạo ranh giới, Erste và chèn bằng phương pháp này, chúng ta có thể tạo ra một xã hội nhị phân.

2017
00:00:12,810 --> 00:00:23,990
Và bằng cách sử dụng phương pháp chèn này, chúng ta có thể chèn dữ liệu vào một khát vọng nhị phân. Bây giờ, giả sử bạn có thể tạo hai phương thức này. Đây là lớp học. Lớp này có chứa một ghi chú.

2018
00:00:24,000 --> 00:00:39,210
Nút này có ba giá trị thuộc tính và để trỏ sang trái và phải ở đây chúng ta có một nút tuyến đường và đây là phương thức Tạo BSD của chúng ta. Phương thức này lấy tham số bên trong tuyến cài đặt của bạn tới Knowland.

2019
00:00:39,870 --> 00:00:52,170
Nếu chúng ta gọi phương thức này là tạo pastie thì chúng ta sẽ tạo nút bây giờ và tuyến đường sẽ trỏ đến nút bây giờ. Bây giờ hãy nói về phương pháp chèn. Đây là phương pháp chèn.

2020
00:00:52,170 --> 00:01:05,670
Phương thức này nhận tham số. Và bên trong đây chúng ta đang gọi phương thức chèn này với hai tham số root và develop. Và đây là phương thức chèn nút hiện tại và Avello.

2021
00:01:06,240 --> 00:01:37,780
Chúng tôi đang sử dụng ngôn ngữ lập trình của chúng tôi. Ở đây chúng tôi có một số tham số khác, OK, vì vậy bạn có thể sử dụng cùng một phương pháp trong quá trình kiểm tra xem Noriko hiện tại có đến Nalden hay trả về trẻ sơ sinh bằng cách tạo một nút có giá trị đã cho khác hay không, nếu bạn đang kiểm tra xem giếng của nút hiện tại có lớn hơn giá trị đã cho thì chúng ta sẽ gọi phương thức chèn theo cách đệ quy và tất cả việc chèn dữ liệu sang trái không và sẽ giữ lại nút hiện tại.

2022
00:01:38,380 --> 00:01:50,350
Nếu không, chúng ta sẽ gọi các thao tác chèn hoặc phương thức chèn với đúng lưu ý và chúng ta sẽ chèn nút đó vào đúng nút con và chúng ta sẽ trả về nút hiện tại.

2023
00:01:51,010 --> 00:02:05,810
Bây giờ hãy xem nó thực sự hoạt động như thế nào. Đầu tiên, nếu chúng ta gọi phương thức này bằng 8, thì chúng ta sẽ tạo một con trỏ trái và phải ban đầu của Nút 8, tất cả các điểm tới nút hiện tại ở đây bằng 4 null.

2024
00:02:06,250 --> 00:02:17,890
Và đây là nút gốc của chúng tôi. OK, vì vậy nếu chúng ta gọi phương thức này bên trong để đánh giá, thì chúng ta gọi phương thức này là chèn với nút tuyến đường ban đầu là bây giờ và xác thực.

2025
00:02:18,130 --> 00:02:35,980
Vì vậy, Kintyre bằng hai bây giờ sẽ trả về ghi chú mới này bằng cách tạo nút có giá trị đã cho. Vì vậy, đây là lộ trình của chúng tôi và chúng tôi gọi lại phương thức này bằng chèn ba, sau đó chúng tôi sẽ gọi phương thức chèn này bằng nút gốc và với giá trị đã cho.

2026
00:02:36,370 --> 00:02:54,130
Vì nút hiện tại không bằng nút hiện tại nên sẽ kiểm tra giá trị của nút hiện tại của chúng tôi. Nếu giá trị hiện tại có giá trị lớn hơn giá trị đã cho thì chúng ta sẽ gọi hàm này theo cách đệ quy và sẽ chèn giá trị của cây vào nút con bên trái của nút hiện tại.

2027
00:02:54,540 --> 00:03:05,870
Vì vậy, chúng ta sẽ gọi lại phương thức này với phần tử con và giá trị. Phía bên trái bây giờ chúng ta cũng sẽ gọi nó là chèn null và một cái cây. Vì vậy, trong trường hợp này, nó sẽ chỉ trả về ba.

2028
00:03:06,220 --> 00:03:15,910
Vì vậy, hãy tạo ở đây một nút mới ba. Và ghi chú này sẽ được hàm này trả về và sẽ chèn ghi chú này vào nút con bên trái của nút số tám này.

2029
00:03:16,090 --> 00:03:34,030
Vì vậy, ba sẽ được gắn vào con trỏ bên trái này. Vì vậy, hãy thêm vào đây ba và con trỏ trái và phải của ba theo mặc định là null. Vì vậy, hãy để nó trong bốn. Bây giờ tôi nhớ lại vấn đề này một lần nữa với chín.

2030
00:03:34,630 --> 00:03:45,790
Sau đó, chúng ta sẽ gọi phương thức chèn này với gốc tám và giá trị chín. Và ở đây nút hiện tại không bằng null và giá trị của nút hiện tại không lớn hơn giá trị bởi vì.

2031
00:03:45,970 --> 00:03:56,080
Bởi vì nó không lớn hơn chín. Vậy là nó sẽ chuyển sang câu lệnh của ELT này và cũng gọi phương thức này bằng root đúng không. Và đó là bây giờ và giá trị chín.

2032
00:03:56,230 --> 00:04:11,290
Vì vậy nó sẽ tạo một nút mới ở đây, số chín và số chín sẽ được gắn vào con trỏ bên phải của nút số tám này. Vì vậy, hãy thêm vào đây số chín và con bên trái và bên phải của số chín hiện được mặc định.

2033
00:04:12,010 --> 00:04:20,990
Bây giờ, hãy gọi lại vấn đề này bằng một. Bây giờ chúng ta sẽ gọi phương thức này với nút gốc thứ tám và có giá trị. Một ghi chú hiện tại không phải là Egleston.

2034
00:04:21,010 --> 00:04:32,620
Ngoài ra, nút hiện tại lớn hơn một. Tám lớn hơn một. Vì vậy, hãy gọi phương thức này một cách đệ quy, sau đó chúng ta sẽ gọi nó bằng ba và với giá trị một.

2035
00:04:33,160 --> 00:04:47,980
Và rồi chúng ta thấy ba lớn hơn một. Vì vậy, chúng ta sẽ gọi lại phương thức chèn này ở bên trái của nút ba này, bây giờ cũng có và một và điều đó sẽ tạo ra một nút có một và hai sẽ chứng thực nút đó cho đứa trẻ nhỏ này.

2036
00:04:48,100 --> 00:05:04,660
Vì vậy, hãy thêm vào đây một và bên trái và bên phải của một theo mặc định, hàm này sẽ trả về nút gốc. Được rồi, vậy hãy gọi phương thức này là sáu.

2037
00:05:04,660 --> 00:05:18,480
Sau đó, chúng ta sẽ gọi phương thức này với bộ định tuyến tám và với giá trị sáu. Vì vậy, kinder không phải là nút hiện tại bên ngoài. Giá trị đó lớn hơn giá trị vì nó lớn hơn sáu.

2038
00:05:18,520 --> 00:05:35,440
Vì vậy chúng ta hãy đi sang bên trái. Leptis ba, hãy gọi nó là ba và sáu. Khi đó ta thấy ba không lớn hơn sáu. Vì vậy, nó sẽ chuyển sang câu lệnh Elsas và ở đây sẽ tạo một nút mới có Giá trị sáu và sẽ chứng thực rằng Nút sáu là con phù hợp của Nút ba này.

2039
00:05:35,440 --> 00:05:54,820
Vì vậy, hãy thêm vào đây ba. Vậy hãy cộng vào đây sáu. Hiện tại, con trái và con phải của sáu người được mặc định. Vì vậy, hãy thêm vào đây và thêm vào đây. Vậy là chúng ta đã hoàn thành câu lệnh bằng văn bản này đã có trong nút gốc và lặp lại nút cứng đó.

2040
00:05:55,270 --> 00:06:04,430
Nó sẽ lặp lại nút gốc và nó sẽ trả về nút gốc, OK, và ghi chú gốc sẽ được gắn vào con trỏ gốc này và có tám.

2041
00:06:05,110 --> 00:06:19,050
Bây giờ hãy gọi lại phương thức này với số 10 trong trường hợp này. Chúng tôi thấy. Giá trị hiện tại lớn hơn lỗi của nó, nó không lớn hơn 10 sẽ chuyển sang bên phải và họ sẽ gọi nó là chín và 10.

2042
00:06:19,360 --> 00:06:38,170
Và trong trường hợp này ta thấy giá trị của nút chín này không lớn hơn 10. Vì thế ta gọi nó là cách viết của Nút chín này và có giá trị là 10. Vậy giá trị 10 này sẽ được cộng vào bên phải của nút chín này .

2043
00:06:38,200 --> 00:06:56,900
Vậy hãy cộng vào đây, bây giờ là 10 trái và phải của 10. Vì vậy, hãy thêm vào đây ngay bây giờ và hãy thêm vào đây ngay bây giờ và nó chỉ hoạt động quay trở lại nút gốc và bộ định tuyến sẽ được trả về nút này bằng lệnh gọi hàm này và nó sẽ được gắn vào tuyến con trỏ này.

2044
00:06:57,640 --> 00:07:19,180
ĐƯỢC RỒI. Đây là nút gốc của chúng tôi và ghi chú này sẽ trả về ý tưởng về cách thức hoạt động của phương thức chèn này. Phương pháp này sẽ tốn thời gian, độ phức tạp,
độ phức tạp lớn trong và không gian vì trên thực tế, đệ quy được gọi là ngăn xếp lưới được hiểu rõ nhất và chèn phương thức tất cả các lần mã nguồn vào video này. 

@@@



2045
00:00:00,850 --> 00:00:12,070
Rất nhiều chàng trai sẽ quay lại video này trong video này. Chúng ta sẽ nói về hoạt động của Trevor trong một thảm họa nhỏ ở phần trước của khóa học này.

2046
00:00:12,250 --> 00:00:29,510
Chúng ta đã nói chi tiết về việc đặt hàng trước theo thứ tự và quá trình duyệt đơn hàng sau hoàn toàn giống nhau. Nếu bạn muốn học hát Banditti hoặc Bonaly khát nước, hãy vào phòng tắm đến phần đó.

2047
00:00:29,530 --> 00:00:43,000
Chúng ta đã nói chi tiết trong video này, chúng ta sẽ chỉ xem xét thuật toán truyền tải, đảo ngược mức độ ưu tiên terrazzo trong các giờ truyền tải và kiểm tra sau khác.

2048
00:00:43,420 --> 00:00:59,080
Bây giờ hãy nói về họ trước. Hãy nói về việc truyền tải đơn đặt hàng trước. Vấn đề này đi theo lộ trình của một luồng sao nhị phân nhất định và trong quá trình kiểm tra của bạn, nếu bạn chỉ đọc và đây là trường hợp cơ sở của chúng tôi và được in ra, hãy phát triển nút tuyến đường có sẵn.

2049
00:00:59,080 --> 00:01:11,400
Và sau đó chúng tôi gọi nó là con bên trái và sau đó chúng tôi gọi nó là con có kích thước phù hợp. Nếu bạn được cung cấp lịch sử của đất nước này và nếu bạn gọi phương thức này, thì bạn sẽ thực hiện tìm kiếm nhị phân này thông qua một cái gì đó như thế này.

2050
00:01:11,420 --> 00:01:23,650
Sơ cứu, rồi ba, rồi một, rồi sáu, rồi chín. Và đây chính là hướng khủng bố trước đồng euro. Vì vậy, tôi sẽ không xem qua mã nguồn.

2051
00:01:24,110 --> 00:01:41,450
Tôi thực sự khuyên bạn nên đi đến phần Bannerjee đó để xem cách truyền tải nguyên thủy hoạt động chi tiết về những gì bạn đã nói, cách tiếp cận đệ quy, cũng như cách tiếp cận lặp lại mà quá trình truyền tải giả định này thực hiện vì độ phức tạp về thời gian và vì độ phức tạp của nó.

2052
00:01:41,840 --> 00:01:54,780
Bây giờ chúng ta hãy xem hai thuật toán truyền tải tiếp theo để tới Eversole. Đây là thuật toán truyền tải theo thứ tự. Đây là một phương pháp khác. Phương pháp này lấy gốc của một đường tìm kiếm nhị phân nhất định và hệ tư tưởng của nó.

2053
00:01:54,920 --> 00:02:14,060
Nếu bạn nhớ lại, đúng, bây giờ chúng tôi đang quay lại, đây là Biscuit và họ gọi nó là ít tùy tiện hơn, sau đó mở nút hiện tại và sau đó chúng tôi gọi nó là cây con phù hợp để chúng tôi xử lý tất cả các môi và toàn bộ quá trình, nút hiện tại, toàn bộ quá trình, cây con bên phải.

2054
00:02:14,780 --> 00:02:29,450
Nếu bạn được cung cấp cây tìm kiếm nhị phân này và nếu chúng ta gọi vấn đề này theo thứ tự, thì bạn phải duyệt qua cây tìm kiếm nhị phân này, đầu tiên là một, sau đó là ba, rồi bốn, rồi sáu, rồi tám, chín.

2055
00:02:29,780 --> 00:02:42,170
Và đây là hướng đi, được chứ? Và đây là danh sách mà những kẻ khủng bố sẽ lấy trong hệ nhị phân 60 để duyệt những gì chúng tôi đã hiểu trong thuật toán duyệt của bạn.

2056
00:02:42,560 --> 00:02:52,820
Và thuật toán này sẽ loại bỏ độ phức tạp về thời gian, độ phức tạp và độ phức tạp của không gian. Bây giờ chúng ta hãy nói về bài đăng thuật toán truyền tải G tiếp theo hoặc quá trình truyền tải.

2057
00:02:53,270 --> 00:03:10,400
Đây là thuật toán đăng hoặc truyền tải. Chúng tôi gọi nó là nút gốc và đây là nút của bánh quy của bạn. Nếu chúng ta trả về cây con bên trái, luật sư quyền và nhà phát triển, nút hiện tại trước tiên xử lý tất cả máy tính xách tay, xử lý khu vực, tất cả đều ổn.

2058
00:03:10,790 --> 00:03:28,940
Sau đó, chúng tôi đang xử lý nút hiện tại chẳng hạn. Chúng tôi đang đưa ra hệ nhị phân này chắc chắn chúng tôi gọi phương pháp này. Sau đó chúng ta sẽ duyệt qua luồng tìm kiếm nhị phân này, đầu tiên là một, sau đó là bốn, rồi sáu và ba phủ nhận hơn tám.

2059
00:03:29,210 --> 00:03:38,520
Và đây là hướng đi. Và thuật toán này sẽ giúp Spiga vượt trội về độ phức tạp về thời gian và chúng ta sẽ vượt lên về độ phức tạp của không gian. Haviv hiểu bài viết là gì hay gì đó.

2060
00:03:38,560 --> 00:04:06,170
Vì vậy, bây giờ hãy nói về các thuật toán truyền tải cấp độ. Đây là cấp độ hoặc bất kỳ thuật toán truyền tải nào. Vấn đề này bắt nguồn từ vấn đề do Natsheh đưa ra trong năm nay nếu có điều kiện nếu bạn không trả lại bản ghi AQ và chúng tôi sẽ thêm giá trị đó vào hàng đợi và chạy một lúc nếu Welches không trống, chúng tôi sẽ loại bỏ phần tử đó từ Q tại đây , bật ra phần tử phía trước từ Q Và chúng tôi đang đưa phần tử đó và ghi chú.

2061
00:04:06,170 --> 00:04:37,190
Nếu đứa trẻ không có, hãy thêm nó vào. Q Và nếu quyền thiết lập ghi chú hiện tại của chúng tôi không bằng nhau, hãy thêm nó vào Q Ibargüen của chúng tôi. Tìm kiếm nhị phân này điển hình cho phương pháp này, sau đó chúng ta nên trả về danh sách này trong quá trình truyền tải, bất cứ điều gì có sẵn cho cấp độ này và cấp độ này, sau đó là cấp độ này của cấp độ này, tám đầu tiên, rồi ba, chín, rồi một, rồi sáu, sau đó bốn tám ba chín một sáu bốn.

2062
00:04:37,700 --> 00:04:47,330
Và đây là hướng mà chúng tôi đã hiểu mức độ của thuật toán là gì và thuật toán này sẽ phát triển theo thời gian, độ phức tạp và độ phức tạp của không gian.

2063
00:04:47,870 --> 00:05:00,050
Trong video này, chúng tôi chỉ xem xét các thuật toán rùa. Muốn hiểu hay muốn xem giải
thích chi tiết, muốn xem giải thích chi tiết, vui lòng tham khảo phần giải thích. 

@@@



2064
00:00:00,470 --> 00:00:12,740
Này các bạn quay lại với video này nhé. Chúng tôi sẽ thực hiện phương pháp dịch vụ này. Hãy xem chúng ta có thể thực hiện phương pháp này như thế nào. Họ nhìn thấy điều này thông qua phương pháp tống đạt của tòa án.

2065
00:00:13,190 --> 00:00:25,820
Phương thức này lấy một giá trị tham số bên trong đây. Chúng tôi đang gọi dịch vụ phương thức này với lộ trình và giá trị. Và ở đây chúng ta có phương thức phục vụ. Phương thức này lấy tham số ở đây, nút hiện tại và velho.

2066
00:00:26,570 --> 00:00:41,840
Nếu nút hiện tại bằng null thì không tìm thấy giá trị in đè và nó sẽ trả về ELT null. Nếu nút hiện tại không gần với giá trị thì sẽ in Valov được tìm thấy trong Besty và sẽ trả về nút hiện tại.

2067
00:00:42,440 --> 00:00:56,690
Nếu không, chúng tôi đang kiểm tra xem giếng của nút hiện tại có lớn hơn giá trị hay không. Họ sẽ gọi phương thức sers ở bên trái. Chắc chắn. Nếu không, chúng ta sẽ gọi phương thức bằng cây con bên phải.

2068
00:00:57,290 --> 00:01:11,260
Ví dụ: nếu bạn được cung cấp sastry nhị phân này, nếu chúng ta gọi phương thức này là sáu, trước tiên sẽ kiểm tra giá trị gốc nào tám bằng sáu sẽ kiểm tra tám bằng câu lệnh này.

2069
00:01:11,810 --> 00:01:21,320
Chính xác. Rất gần với giá trị mà chúng ta thấy sáu không bằng tám. Sau đó, chúng tôi đang kiểm tra xem nút khả dụng có lớn hơn giá trị đã cho hay không. Đúng vậy.

2070
00:01:21,680 --> 00:01:34,030
Sau đó chúng ta sẽ chuyển sang môi của ba người sẽ gọi bằng nút này. Trong trường hợp đó, chúng ta thấy rằng sáu không bằng ba và chúng ta thấy giá trị của nút hiện tại không lớn hơn giá trị đã cho.

2071
00:01:34,190 --> 00:01:44,440
Vì vậy chúng ta sẽ gọi nó bằng cây con bên phải. Trong trường hợp này, chúng tôi sẽ gọi bằng nút này. Bây giờ chúng ta thấy giá trị của nút hiện tại bằng giá trị đã cho.

2072
00:01:44,660 --> 00:02:00,620
Vì vậy, tất cả các bản in được tìm thấy trong Basti và sẽ trả về nút này sẽ được hiểu phương thức nguồn hoạt động như thế nào. Bạn thấy rằng để tìm kiếm giá trị này, chúng tôi so sánh giá trị này với chỉ ba nút.

2073
00:02:00,620 --> 00:02:19,250
Được rồi, tại sao không kiểm tra từng nút một? Nếu chúng ta gọi lại phương pháp này với số 14 thì điều gì sẽ xảy ra? Đầu tiên chúng ta sẽ gọi với nút gốc và nút ngoại và chúng ta thấy bốn không bằng tám và tám nhỏ hơn mười bốn để gọi với cây con bên phải này.

2074
00:02:19,700 --> 00:02:45,260
Không có bản ghi nào tới 14 cho tất cả cây con bên phải. Và sau đó chúng tôi tìm thấy ở đây mười bốn. Vì vậy, chúng tôi sẽ in Avello được tìm thấy ở Bisdee. Nếu chúng ta gọi phương thức này bằng Searsport, phương thức này sẽ gọi phương thức tìm kiếm này với nút hiện tại và ký tự Vello là nút gốc của chúng ta ban đầu và chúng ta thấy 8 không bằng lực sẽ gọi nó, hãy áp dụng vì giá trị nhỏ hơn 8.

2075
00:02:45,830 --> 00:02:58,460
Thế thì bạn thấy bốn không bằng ba. Vậy gọi với quyền TI, tức là sáu không phải là đi đến bốn sẽ gọi với hiện tại, sáu lớn hơn bốn và ở đây ta thấy bốn bằng bốn.

2076
00:02:58,460 --> 00:03:21,230
Vì vậy, nó sẽ in giá trị được tìm thấy trong Besty và chúng tôi thấy rằng chúng tôi so sánh với chuyển tiếp khi kiểm tra từng nút. Nếu chúng ta có một số lượng lớn các nút trong một hệ nhị phân nhất định, thì chúng ta không cần phải kiểm tra từng nút riêng lẻ để tìm ra giá trị trong xã hội nhị phân, để tìm ra giá trị trong xã hội nhị phân.

2077
00:03:21,800 --> 00:03:32,990
Nếu chúng ta gọi phương thức này là nguồn, chúng ta biết đó là điều sẽ xảy ra. Sẽ gọi phương pháp này là tám và hai mươi tám không bằng hai mươi và nó nhỏ hơn hai, hãy gọi như vậy.

2078
00:03:32,990 --> 00:03:47,150
Phải. Và ở đây chúng ta thấy Denise đang ở số 20, hãy gọi đúng như vậy. Tùy thuộc vào điều này liên quan đến mười bốn. Như vậy gọi là đúng. Iritis null bất cứ khi nào chúng tôi tìm thấy nút hiện tại vì không tìm thấy hiện tại và tất cả đều được ghi.

2079
00:03:47,150 --> 00:04:02,180
Bây giờ đây là cách nó hoạt động. Đây là một cái gì đó giống như sao nhị phân và tìm kiếm nhị phân hoạt động chính xác như thế này. Được rồi. Chúng tôi đã hiểu cách sử dụng tài nguyên Avella trong tìm kiếm nhị phân một cách hiệu quả.

2080
00:04:02,630 --> 00:04:16,370
Và đây là lý do tại sao tìm kiếm nhị phân bám sát vào hình ảnh. Chúng ta có thể tìm kiếm trong hệ nhị phân 60 với độ phức tạp thời gian logarit. Độ phức tạp về thời gian là tất cả các lần đăng nhập và độ phức tạp về không gian.

2081
00:04:16,370 --> 00:04:32,500
Hoặc đăng nhập vào đệ quy có tên là ngăn xếp. Được rồi, bây giờ chúng ta làm thế nào để có được độ phức tạp lần này. Chúng tôi chia nhỏ từng dòng. Chúng ta phải đến, chúng ta phải tính toán độ phức tạp về thời gian cho nguồn phương thức.

2082
00:04:32,840 --> 00:04:43,760
Đây là số nút mà chúng ta có trong lịch sử của Bernini nhất định ở đây đang gọi tìm kiếm nhị phân ở phần bên trái, nếu không muốn nói là bằng với phần bên phải.

2083
00:04:44,030 --> 00:04:59,920
Vậy đó là Esteve. T của chúng ta ở đây trở thành nhỏ với cây con bên trái hoặc bên phải sẽ không quay trở lại bên phải, cho đến cây con bên trái của bạn. Khi chúng tôi sang bên trái hoặc bên phải, nếu chúng tôi đăng ký lại trợ cấp ở đây.

2084
00:05:00,360 --> 00:05:16,110
Phương pháp, sau đó chúng tôi sẽ giải quyết vấn đề phức tạp về thời gian này hoặc đăng nhập và đăng nhập. Chúng tôi có một
phần trong khóa học này bắt đầu từ một số phần nhất định, vui lòng kiểm tra tìm kiếm nhị phân video trong Bannisters. 

@@@



2085
00:00:00,510 --> 00:00:09,930
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này chúng ta sẽ nói về Late Note. Vì vậy hãy thực hiện phương pháp này. Chúng ta đừng vì lịch sử ranh giới.

2086
00:00:10,560 --> 00:00:26,520
Trong phần trước của bài viết, chúng ta đã biết cách xóa một nút khỏi cây nhị phân. Nhưng đây là một xã hội nhị phân nơi chúng ta có giá trị trên cây con bên trái hoặc lasdun và giá trị của cây con bên phải đó lớn hơn nút cha.

2087
00:00:27,600 --> 00:00:40,380
Bây giờ hãy xem chúng ta có thể triển khai phương pháp này như thế nào. Đây là mã giả để xóa nút khỏi khát nhị phân. Chúng tôi đang gọi phương thức này bằng root và giá trị bên trong đây hoặc lấy hoặc in.

2088
00:00:40,380 --> 00:00:53,340
Không tìm thấy Reller và chúng tôi thực sự biết nếu giá trị của kẻ hủy hoại lớn hơn giá trị thì chúng tôi gọi nó là cây con bên trái. Nếu giá trị của nút gốc nhỏ hơn giá trị thì chúng ta gọi nó là cây con bên phải.

2089
00:00:53,940 --> 00:01:13,840
Nếu chúng tôi tìm ra giá trị trong nhị phân 60 thì chúng tôi phải xóa nút hiện tại. Trong trường hợp đó, chúng tôi sẽ kiểm tra xem liệu chúng tôi có con lipin phù hợp cho nút hiện tại mà chúng tôi phải xóa hay không, sau đó chúng tôi sẽ áp dụng công thức này cho trường hợp khác.

2090
00:01:13,860 --> 00:01:29,760
Nếu chúng ta thấy nút hiện tại chỉ còn lại nút con thì chúng ta sẽ áp dụng công thức này. Nếu nút hiện tại của chúng tôi từ chối giá trị rỗng, hãy áp dụng công thức này. Nếu chủ sở hữu hiện tại không phải là chủ sở hữu hiện tại thì chúng ta sẽ áp dụng công thức này để giải mã Sternhell và nó sẽ trả về root.

2091
00:01:30,000 --> 00:01:45,210
Đây là phương pháp tối thiểu. Phương thức này lấy gốc từ cây và phương thức này sẽ giữ lại nút tối thiểu trong cây hoặc nút có thể trong cây con. Để dễ hiểu, giả sử chúng ta có số nhị phân sáu mươi.

2092
00:01:45,780 --> 00:01:57,320
Đầu tiên, hãy xem trực giác chúng ta có thể làm được điều đó như thế nào. Cho đến khi chúng ta muốn xóa nút này vào lúc 3 giờ. Sau đó, chúng ta sẽ tìm giá trị nhỏ nhất ở phía bên phải của nút ba này và có bốn.

2093
00:01:57,510 --> 00:02:08,120
Vì vậy, chúng tôi sẽ lấy giá trị này và cập nhật giá trị của nút ba này với giá trị tối thiểu ở bên phải của Nút ba này. Và sau đó chúng ta sẽ làm gì, nó sẽ xóa ghi chú này, được chứ?

2094
00:02:08,670 --> 00:02:20,070
Và nó đã được đặt thành null. Và bây giờ chúng ta thấy rằng nút ba này đã bị xóa và chúng ta thấy rằng sastry nhị phân này là một nhị phân hợp lệ 60 sau khi xóa nút ba.

2095
00:02:20,790 --> 00:02:32,850
Chủ đề không dành cho nhỏ hơn chủ đề phù hợp không dành cho lớn hơn đây là cách chúng tôi sẽ xóa nó. Không phải từ một cơn khát nhị phân. Giả sử chúng ta muốn xóa nút tám.

2096
00:02:33,360 --> 00:02:57,570
Đây là một nút gốc. Sau đó chúng ta sẽ làm gì? Chúng ta sẽ tìm ra giá trị tối thiểu ở phía bên phải của nút tám này và có mười. Vì vậy, tốt hơn tôi nên đánh giá tám bằng mười, sau đó tôi sẽ xóa số 10 này và sẽ kết nối số này không phải với số này, không phải số 14, và chúng ta thấy rằng đây là một giá trị hợp lệ nhưng thật ngu ngốc khi để lộ trình này không phát triển.

2097
00:02:57,580 --> 00:03:09,010
Cây con bên phải thì lớn hơn giá trị trên mạng sống của chúng ta rồi. Bây giờ hãy xem cách chúng ta có thể xóa một nút cụ thể khỏi mạch nhị phân này bằng mã giả này.

2098
00:03:09,370 --> 00:03:20,650
Nếu chúng ta gọi phương thức này là xóa nút thứ ba thì chúng ta sẽ gọi phương thức này bằng gốc và cây giá trị. Bằng phương pháp này ở đây chúng tôi đang kiểm tra mọi tuyến đường Gholston không bằng null.

2099
00:03:21,250 --> 00:03:32,890
Và ở đây chúng ta sẽ kiểm tra điều này nếu điều kiện Tuyến 8 lớn hơn giá trị đã cho. Vì vậy chúng ta sẽ gọi nó là cây con. Bây giờ chúng ta sẽ gọi phương pháp này là Leptospira và quân đội.

2100
00:03:33,610 --> 00:03:45,490
Bây giờ chúng ta thấy ba bằng ba. Vì vậy bây giờ chúng ta đang ở mức báo cáo lợi nhuận này. Bây giờ chúng ta sẽ kiểm tra xem nút ba có trái và phải không? Vâng, nó có trái và phải.

2101
00:03:46,240 --> 00:04:00,610
Sau đó họ sẽ làm gì? Chúng ta sẽ tìm ra nút tối thiểu ở bên phải của nút này, số ba và chúng ta sẽ đặt biến số mười cho tuyến đường này. Giá trị tối thiểu trên cây con bên phải này là cách chúng ta có thể tìm thấy nó ở đây.

2102
00:04:00,610 --> 00:04:14,920
Sẽ gọi phương thức này tối thiểu với mười cho điều đó. Phải. Vì vậy chúng ta sẽ gọi phương thức này là temp đúng không. Phương thức này sẽ trả về nút bốn theo phương thức tối thiểu này, phương thức tối thiểu này sẽ ghi nút cho.

2103
00:04:15,310 --> 00:04:28,810
Vì vậy, chúng tôi sẽ cập nhật giá trị này của nút này bằng bốn. Vì vậy, hãy cập nhật điều này sẽ chờ điểm danh. Phương pháp này sẽ viết sự thật nên nó sẽ gửi địa chỉ nào đó đến đúng con này hoặc tới con trỏ bên phải.

2104
00:04:29,380 --> 00:04:44,920
Chúng ta sẽ gọi nó là sáu và bốn. Nếu gọi sáu và bốn thì ta thấy sáu lớn hơn bốn. Vì vậy chúng ta sẽ gọi nó là hãy để Leptis ghi chú này cho chính nó. Vì vậy, chúng tôi sẽ gọi nó và bây giờ chúng tôi thấy điều này một cách có chủ ý.

2105
00:04:44,920 --> 00:04:55,330
Vì vậy, nó sẽ đặt nút này là null vì đây là nút gốc bởi gốc này bằng hai. Bây giờ khai báo thì mình sẽ trả về root. Đây là gốc hiện tại của chúng tôi.

2106
00:04:56,020 --> 00:05:10,050
Vì vậy gốc này sẽ được trả về hàm này. Gọi gốc. Điều này sẽ trả về mạng gốc. Gốc hiện tại là vì chúng ta đã có Sternhell nên null sẽ nói ở bên trái của nút sáu này.

2107
00:05:10,060 --> 00:05:28,750
Vì vậy, tất cả các bản ghi rototiller đã nói thành null cũng là đứa con nhỏ này không phải là null, sau đó lặp lại lệnh gọi hàm đệ quy trước đó, nó sẽ trả về nút sáu và nút sáu sẽ được gắn vào bên phải của hai nút hiện tại của chúng ta.

2108
00:05:28,750 --> 00:05:41,080
Đó là ghi chú này vì chúng tôi đã cập nhật giá trị của không hoặc bốn này. Vì vậy, nó sẽ có nút sáu này, sự trở lại của nút này không dành cho và đã có nút sáu này và đây là những gì chúng ta có thể làm.

2109
00:05:41,110 --> 00:06:00,910
Nó không dành cho ranh giới vẫn được hiểu. Ghi chú liên quan của chúng tôi từ sự chắc chắn nhị phân. Và chúng tôi lấy giá trị tối thiểu từ chủ đề bên phải của nút mong muốn và cập nhật giá trị bằng giá trị tối thiểu trên cây con bên phải và hoặc xóa giá trị tối thiểu khỏi cây đó.

2110
00:06:02,120 --> 00:06:14,380
Đây là những gì chúng ta có thể xóa ghi chú khỏi nhị phân 60. Bây giờ, giả sử chúng ta muốn xóa nút tám chín này. Chúng tôi gọi phương pháp này là chữ cái có số tám. Chúng tôi muốn xóa nút gốc.

2111
00:06:14,380 --> 00:06:30,850
Hãy làm được điều đó. Như vậy chúng ta đã tìm ra được nút cần xóa. Đó là nút gốc. Bây giờ, trực tiếp trên câu lệnh của ELT này, chúng ta thấy bộ định tuyến có bên trái và bên phải.

2112
00:06:31,930 --> 00:06:40,870
Vì vậy, chúng ta sẽ thực hiện việc đặt 10 vì tuyến đường này sẽ đưa họ đến nút tuyến đường này và sau đó chúng ta sẽ tìm ra điểm tối thiểu ở bên phải. Và có mười.

2113
00:06:41,140 --> 00:06:51,750
Vì vậy, hãy cập nhật giá trị tám bằng mười. Bây giờ chúng ta sẽ làm gì? Chúng ta sẽ đặt bên phải của nút này mười. Vậy con bên phải của nút 10 này là gì?

2114
00:06:52,290 --> 00:07:03,870
Chúng ta không biết, phải không? Vì vậy, chúng ta phải thiết lập đúng nút con cho một nút mong muốn. Các ranh giới Erste phải tuân theo các tính chất của lịch sử ranh giới. Sau khi xóa một nút mong muốn.

2115
00:07:03,870 --> 00:07:13,700
Cây phải tuân theo các thuộc tính của một phép thuật nhị phân. Họ sẽ gọi nó là Roulet, phải không. Điều này không hợp lệ ở đây. Chúng ta phải xóa nút này, được chứ?

2116
00:07:14,310 --> 00:07:23,610
Nếu chúng ta gọi nó với mục đích, thì chúng ta lại đang ở trên trái đất này. Ở đây chúng tôi thấy nó. Chúng tôi không có đứa con nào còn lại. Vì vậy chúng ta có ở bên phải, Charles sẽ lập kỷ lục để làm điều đó.

2117
00:07:23,610 --> 00:07:33,810
Phải. Vì vậy, chúng ta sẽ thiết lập các bản ghi ở đây cho dấu chấm gốc. Phải. Vì vậy, đây là tuyến đường hiện tại của chúng tôi. Được rồi, chúng ta sẽ thiết lập các bản ghi ở đây để làm điều đó. Phải.

2118
00:07:33,840 --> 00:07:48,230
Vì vậy, chúng ta sẽ chuyển tuyến đường này sang tuyến đường tiếp theo bên phải. Chúng ta sẽ di chuyển tuyến đường đến bên phải đứa trẻ và ở cuối đây là tuyến đường. Vì vậy nó sẽ trả về tuyến đường mang đến nút này và ghi chú này sẽ quay lại tuyến đường này.

2119
00:07:48,230 --> 00:08:12,040
Đúng rồi. Tức là ở bên phải của nút này 10. Vậy tại liên kết này tới nút này. OK, nút này cho nên chúng ta có tại liên kết đến nút 14 này. Như vậy trong hàm đệ quy trước gọi all tại đúng điểm, trỏ đến nút 14 này bằng cách bỏ qua nút 10 này.

2120
00:08:12,570 --> 00:08:28,570
Được rồi. Và đây là tất cả những gì chúng ta có thể làm. Nút này và trong lệnh gọi hàm đệ quy trước đó sẽ trả về nút tuyến đường này. Đây là cách chúng ta có thể xóa một nút sa mạc khỏi các ranh giới vẫn đang duy trì các thuộc tính của niềm hy vọng khao khát nhị phân.

2121
00:08:28,580 --> 00:08:37,480
Chúng tôi đã hiểu phương pháp này thực sự hoạt động như thế nào. Chúng tôi đã hiểu lời giải
thích này. Bạn có vấn đề khi hiểu điều này kèm theo lời giải thích, hãy cho chúng tôi biết. 

@@@



2122
00:00:00,530 --> 00:00:16,490
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về hoạt động tìm kiếm nhị phân. Mời các bạn xem mạch nhị phân này và đây chính là thuật toán xóa mạch nhị phân có liên quan sâu sắc.

2123
00:00:16,640 --> 00:00:34,090
Hoặc nếu chúng ta gọi phương thức này thì tuyến đường này sẽ được đặt thành hiện tại. OK, vậy hãy ngắt kết nối bộ quy tắc con trỏ gốc này để tải xuống. Bây giờ, trình thu gom rác sẽ tự động xóa nút này vì không có gì trỏ đến Nút 8 này.

2124
00:00:34,760 --> 00:00:43,220
Vì vậy nút này sẽ bị người thu gom rác loại bỏ. Bây giờ chúng ta thấy không có gì chỉ vào tuyến đường này. Không phải vậy học sinh sẽ bị người thu gom rác loại bỏ sau đó.

2125
00:00:44,210 --> 00:00:57,680
Chúng tôi thấy rằng không có gì trỏ đến Nút ba này và nút 10 này, vì vậy nút ba và 10 này sẽ bị bộ thu gom rác loại bỏ. Sau đó, chúng ta thấy rằng không có gì trỏ đến cái này, không phải cái nào, vì vậy cái này sẽ bị người thu gom rác loại bỏ.

2126
00:00:59,030 --> 00:01:07,190
Không có gì khác chỉ vào ghi chú này. Không có gì được chỉ vào ghi chú này là tốt. Vì vậy ghi chú thứ sáu này và ghi chú thứ 14 này sẽ bị người thu gom rác loại bỏ.

2127
00:01:07,200 --> 00:01:18,800
Rồi chú này cho chú này, bảy là không chuyển. Nó không phản hồi với ghi chú này cho bảy và 13. Vì vậy, ghi chú cho bảy 13 sẽ bị người thu gom rác xóa.

2128
00:01:19,670 --> 00:01:32,870
Vì vậy, thảm họa liên hành tinh của chúng ta là tập phim mới nhất được tái hiện lại. Đây là cách hoạt động tinh vi
này hoạt động. Hoạt động này sẽ diễn ra đúng thời gian, độ phức tạp và lớn hơn về độ phức tạp của không gian. 

@@@



2129
00:00:00,540 --> 00:00:17,160
Này các bạn quay lại với video này nhé, chúng ta sẽ nói về cấu trúc dữ liệu nhị phân nếu Heave là một cây nhị phân hoàn chỉnh thỏa mãn thuộc tính heap, nếu cấu trúc đó còn gọi là nhị phân.

2130
00:00:18,150 --> 00:00:33,490
Bây giờ, hãy xem ở đây, giá trị thuộc tính của bất kỳ nút nào đã cho phải nhỏ hơn giá trị của các nút con của nó. Và đây được gọi là ý nghĩa và giá trị của bất kỳ nút nào đã cho phải lớn hơn giá trị của các nút con của nó.

2131
00:00:33,720 --> 00:00:57,640
Và đây được gọi là Max. Nếu chúng ta có hai loại cừu, một loại là Minifie và loại còn lại rất to lớn. HEVE nhị phân là một cây hoàn chỉnh. Điều đó có nghĩa là tất cả các cấp độ đều được lấp đầy hoàn toàn, ngoại trừ cấp độ cuối cùng và cấp độ cuối cùng có tất cả các khóa càng muộn càng tốt.

2132
00:00:58,450 --> 00:01:16,280
Chúng ta đã hiểu cấu trúc dữ liệu là gì. Bây giờ chúng ta hãy xem một số ví dụ. Đây là định nghĩa của ý nghĩa và đây là định nghĩa của Max. Nếu đây là một ví dụ về ý nghĩa thì giá trị của bất kỳ nút nào đã cho phải nhỏ hơn giá trị của các nút con của nó.

2133
00:01:17,280 --> 00:01:30,420
Vì vậy giá trị của Nút 8 này nhỏ hơn giá trị của tất cả các Nút con. Và giá trị của nút này nhỏ hơn giá trị của nút con của nút này, nhỏ hơn giá trị của nút con của nó.

2134
00:01:30,960 --> 00:01:53,940
Đối với điều này không phát triển nút này ít hơn nó. Trẻ em và đây được gọi là hạch bạch huyết, trong đó 565, 16, 50 và 60. Đây đều là các hạch bạch huyết. Đây được gọi là M.F. và đây là một ví dụ về giá trị lớn của bất kỳ nút đã cho nào phải lớn hơn giá trị của các nút con của nó.

2135
00:01:54,480 --> 00:02:07,020
Sự tồn tại của nút này lớn hơn các nút con của nút này lớn hơn giá trị của các nút con của nó. Kinh doanh lớn hơn trẻ em. Và phát triển nút 22 này lớn hơn giá trị của nút con của nó.

2136
00:02:07,830 --> 00:02:26,580
Và đây là những nút sống. Vì vậy có thể nói đây là một Haviv lớn được hiểu rõ. Ý nghĩa là gì và khối lượng là gì. Bây giờ hãy nói về ứng dụng nhị phân HIF nhị phân được sử dụng khi triển khai hàng đợi ưu tiên.

2137
00:02:27,150 --> 00:02:42,000
Thuật toán Dextrous sử dụng HIF nhị phân và thuật toán anh sử dụng nhị phân. Nếu đây là thuật
toán sắp xếp, sẽ nói về thuật toán sắp xếp trong phần thuật toán sắp xếp của khóa học này. 

@@@



2138
00:00:00,660 --> 00:00:11,440
Trong video này, chúng ta sẽ nói về tùy chọn triển khai chính nhị phân, chúng ta có thể triển khai nhị phân nếu có lỗi hoặc chúng ta có thể triển khai nhị phân bằng cách sử dụng nhà ngôn ngữ học.

2139
00:00:12,180 --> 00:00:29,470
Chúng tôi có sáu thao tác tiêu chuẩn này mà chúng tôi sẽ thực hiện ở dạng nhị phân nếu trang web trích xuất đỉnh cao sáng tạo, chèn và xóa. Nếu không có vấn đề gì khi chúng tôi triển khai HIF nhị phân thì có lỗi.

2140
00:00:30,300 --> 00:00:47,190
Nhưng có một vấn đề khi triển khai nhị phân bằng cách sử dụng cấu trúc dữ liệu ngôn ngữ cho cấu trúc dữ liệu ngôn ngữ. Hoạt động trích xuất này tạo ra một vấn đề. Hoạt động trích xuất này sẽ thực hiện Swadling, độ phức tạp về thời gian tuyến tính.

2141
00:00:47,730 --> 00:01:03,950
Nhưng để triển khai, thao tác trích xuất này sẽ có độ phức tạp theo thời gian logarit nên chúng tôi sẽ chọn triển khai nhị phân được Ả Rập hóa nếu chỉ điều này sẽ không bao giờ sử dụng việc triển khai nhị phân của các nhà ngôn ngữ học.

2142
00:01:03,960 --> 00:01:22,350
Nếu chúng ta có hai loại ý nghĩa của heap. Và Max, nếu đây là một ví dụ về McNiff và đây là một ví dụ lớn, nếu chúng ta trích xuất Nút 8 này, thì điều gì sắp xảy ra sẽ loại bỏ nút này, OK, và chúng ta sẽ lấy nút đầu tiên đó.

2143
00:01:22,920 --> 00:01:39,930
Điều đó có nghĩa là phút cuối cùng chúng ta có được bằng cách duyệt HIF nhị phân bằng cách truyền tải thứ tự cấp độ. Và đây là lưu ý cuối cùng và chúng ta có thể cập nhật giá trị của lộ trình này chứ không phải với nút thoái vốn này và khi đó sẽ giảm tải thâm hụt.

2144
00:01:40,680 --> 00:01:51,840
Nếu chúng tôi thực hiện việc này bằng cấu trúc dữ liệu ngôn ngữ học, điều đó có nghĩa là nếu chúng tôi triển khai nhị phân bằng cấu trúc dữ liệu Linklaters thì thao tác trích xuất sẽ có độ phức tạp về thời gian tuyến tính.

2145
00:01:52,260 --> 00:02:13,590
Và đó không phải là điều chúng tôi muốn. Chúng tôi muốn trích xuất Haid không phải từ cây nhị phân theo độ phức tạp thời gian logarit khi chúng tôi triển khai Bintliff. Đó có phải là cấu trúc mà chúng ta có thể dễ dàng lấy phần tử cuối cùng bằng cách sử dụng một biến chỉ mục được sử dụng lần cuối hoặc thứ gì đó tương tự.

2146
00:02:13,830 --> 00:02:27,540
Nhưng đối với nhóm thực hiện ngôn ngữ học, hãy duyệt qua HIF nhị phân để lấy nút cuối cùng hoặc phần bảo vệ cho nút. Phải. Và đó là tất cả những gì chúng ta sẽ thấy trong phần này của khóa học này.

2147
00:02:28,050 --> 00:02:40,310
Khi bạn triển khai thao tác trích xuất, chúng tôi hiểu rằng chúng tôi nên chuyển đổi cách triển
khai được Ả Rập hóa thay vì cách triển khai tốt nhất và lâu dài nhất. Cảm ơn đã xem video này. 

@@@



2148
00:00:01,130 --> 00:00:21,700
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về cấu trúc dữ liệu nhị phân. Trong video này, chúng ta sẽ triển khai phương thức này vào phương thức sáng tạo và phương thức chèn quảng cáo này sẽ tạo cấu trúc Heffter và phương thức chèn này sẽ chèn dữ liệu vào đống nhị phân.

2149
00:00:21,950 --> 00:00:45,650
Bây giờ, hãy xem chúng ta có thể triển khai phương pháp thực sự này như thế nào. Đây là lớp HIF của chúng tôi sử dụng mảng bên trong chúng tôi có mảng và chúng tôi có một trang web có thể thay đổi. Phương pháp quảng cáo này sẽ lấy trang web làm đầu vào bên trong đây hoặc tạo HIF nhị phân có kích thước trang web Flach một và sau đó chúng tôi đặt kích thước biến này thành 0.

2150
00:00:46,990 --> 00:01:03,320
Nếu bạn gọi phương thức này là sáng tạo bằng bảy, chúng sẽ tạo một mảng có độ dài tám, có chỉ số từ 0 đến bảy và kích thước ban đầu bằng 0. Được rồi, tôi sẽ không sử dụng đợt bán hàng đầu tiên của chúng tôi để dễ thực hiện.

2151
00:01:04,000 --> 00:01:16,100
Chúng tôi không có yếu tố nào trong khu vực của mình nên chúng tôi có thể xem xét những yếu tố nặng ký của mình. Bây giờ phương pháp này chiếm độ phức tạp một lần và lớn hơn trong không gian. Độ phức tạp là độ dài của mảng đã cho.

2152
00:01:16,420 --> 00:01:29,260
Hoặc chúng ta có thể nói là bên hông của chúng ta. Bây giờ hãy nói về phương pháp chèn. Phương thức này lấy một giá trị tham số bên trong đây hoặc chèn giá trị đó để tạo cấu trúc đó, tăng trang web.

2153
00:01:29,440 --> 00:01:56,170
Và sau đó chúng tôi đang gọi phương pháp này. Nếu chúng tôi thấy chúng quá khó, chúng tôi quyết định, OK, điều đó có nghĩa là chỉ mục của dữ liệu được chèn hiện tại của chúng tôi. Indore, nếu chúng ta có ở đây, công thức này sẽ chuyển sang 2x của chúng ta nên họ nói với hai chuyên gia của chúng ta về giá trị ở chỉ mục một là nút gốc của chúng ta và ở đây X là số chỉ mục và chèn 10, 20, 30, 40, 50, 60 và 70.

2154
00:01:56,170 --> 00:02:07,420
Nhị phân bên trong 15 là nhị phân sẽ được biểu diễn, đại loại như thế này. Và đây là sự biểu diễn của vùng này trong bộ nhớ máy tính sẽ lưu trữ mảng một cách logic.

2155
00:02:07,420 --> 00:02:23,170
Mảng sẽ được biểu diễn dưới dạng nhị phân nếu có dạng như thế này. Đây là sự biểu diễn logic của cấu trúc dữ liệu nhị phân của chúng tôi. Phương pháp này sẽ nhắn tin vì độ phức tạp của nhật ký về thời gian và do độ phức tạp của nhật ký về không gian.

2156
00:02:23,440 --> 00:02:43,390
Bây giờ chúng ta hãy nói về phương pháp từ dưới lên trên và hãy xem phương thức chèn hoạt động như thế nào. Điều này khác. Nếu tôi ghi phương thức trên cùng, thì phương thức này sử dụng phương thức này lấy chỉ mục làm đầu vào và các chỉ mục theo nghĩa đen sẽ đi đến một rồi quay trở lại vì bạn chỉ có một nút hoặc chúng tôi không thể làm gì cả.

2157
00:02:43,630 --> 00:03:02,020
Sau đó, chúng tôi tìm thấy nó ở đây. Nút cha, nếu chúng ta thấy nút hiện được chèn là một danh sách, thì nút cha, hoán đổi chúng và sau đó chúng ta phải gọi hipwell từ dưới lên trên và phần tử hiện được chèn của chúng ta có được vị trí chính xác trong tệp nhị phân mà không phải lo lắng về điều đó.

2158
00:03:02,090 --> 00:03:13,060
Bây giờ chúng ta sẽ xem nó thực sự hoạt động như thế nào. Nếu chúng ta gọi phương thức này là chèn sáu, thì chúng ta sẽ chèn sáu ngay tại đây và sẽ mở rộng trang web và sẽ gọi phương thức Sleepify.

2159
00:03:13,330 --> 00:03:29,020
Và chúng ta sẽ gọi phương thức này với chỉ số là 6 đang bật và chúng ta thấy trong X bằng để trả lời rồi và chúng ta sẽ không làm gì cả. Sau đó, hãy gọi lại phương thức này với bốn để tất cả bên trong, bốn ở ngay đây và bốn sẽ được gán cho bên trái của nút sáu này.

2160
00:03:29,440 --> 00:03:47,350
Vậy bốn người sẽ được phân công ngay ở đây. Mũi tên sẽ được đại diện. Một cái gì đó như thế này có trong công thức này. Giá trị tại chỉ số trên không phải và các xúc tu bên trái đối với Twiggs và đó là điều cần làm nếu tôi chạm đáy khó khăn nếu chúng ta gọi phương thức này với chỉ số sau đó là hai.

2161
00:03:47,740 --> 00:04:05,170
Vì vậy, hãy tìm nó cha và chỉ số của cha mẹ là kết quả chúng ta nhận được bằng cách chia chỉ số của bốn cho hai. Bây giờ chúng ta sẽ so sánh giá trị nút hiện tại và giá trị nút cha và chúng ta thấy bốn nhỏ hơn sáu.

2162
00:04:05,500 --> 00:04:20,620
Vì vậy chúng ta sẽ trao đổi. Nếu chúng ta giải quyết vấn đề này bằng nút, thì bốn sẽ di chuyển với tốc độ sáu và sáu sẽ di chuyển ở vị trí bốn. Và trong khu vực của chúng tôi, chúng tôi sẽ hoán đổi giá trị này thành giá trị để bốn người sẽ chuyển đến đây và sáu người sẽ chuyển đến đây.

2163
00:04:20,800 --> 00:04:32,470
Và đây là cách biểu diễn mảng này dưới dạng nhị phân. Anh ta sẽ gọi lại phương thức này với cha, đó là chỉ mục cho lệnh gọi hàm đệ quy tiếp theo được lập chỉ mục cho một.

2164
00:04:32,470 --> 00:04:44,950
Vì vậy, nó sẽ quay trở lại hoặc nó sẽ chỉ được hỗ trợ bởi tuyên bố bằng văn bản này. Sau đó hãy gọi lại phương thức này với số 5. Vì vậy, hãy chèn vào đây năm. Đúng rồi, Citrix cộng một, hai nhân một cộng một là ba.

2165
00:04:44,950 --> 00:04:58,680
Vì vậy, hãy chèn như một đứa trẻ bên phải ngay tại đây. Bây giờ chúng ta hãy gọi đây là phương pháp biffy từ dưới lên trên với chỉ số ba. Và chúng ta thấy rằng nút cha nhỏ hơn nút hiện tại này.

2166
00:04:58,690 --> 00:05:10,930
Vì vậy, điều này là sai. Sẽ gọi với cha mẹ, cha mẹ là bốn và lập chỉ mục một. Vì vậy, nó sẽ chỉ được thực hiện bằng tuyên bố bằng văn bản này. Sau đó, chúng ta sẽ gọi lại điều này không liên tục bằng một.

2167
00:05:10,930 --> 00:05:28,180
Vậy hãy chèn vào bên trái của nút sáu ở ngay đây, hai nhân hai là bốn. Vì vậy chúng ta sẽ chèn vào đây một cái. Bây giờ, hãy gọi đáy này trên cùng với chỉ số for và chúng ta thấy rằng cha mẹ của một là sáu và sáu thì lớn hơn một.

2168
00:05:28,180 --> 00:05:45,940
Vì vậy, hãy hoán đổi chúng một cột ở đây và sáu sẽ di chuyển đến đây và ở đây sẽ giải quyết một trong sáu, sáu cột nữa ở đây và một sẽ chuyển đến đây để hàm đệ quy tiếp theo sẽ gọi với chỉ mục tới và chúng ta thấy phần tử cha là của chỉ mục.

2169
00:05:46,070 --> 00:06:02,120
Một, và chúng ta thấy cha mẹ lớn hơn hiện tại, không nên đổi chỗ nếu chúng ta đổi một lấy tất cả, chuyển đến đây và một sẽ chuyển đến đây và nó sẽ giải quyết được bốn và một một sẽ chuyển đến đây và bốn sẽ chuyển đến đây.

2170
00:06:02,240 --> 00:06:22,730
Và chúng ta đã hoàn thành chức năng này. Gọi rồi cuộn, gọi nó với chỉ mục của nút gốc. Đó là một. Vì vậy, chúng tôi sẽ chỉ hỗ trợ bằng tuyên bố bằng văn bản này. Bây giờ hãy gọi lại cuộc họp này với bảy, bảy sẽ được chèn vào do kết quả của nút này ở ngay đây và trong khu vực của bạn ngay tại đây.

2171
00:06:22,970 --> 00:06:34,070
Chỉ số của bốn là hai. Vậy hai X cộng một, hai nhân hai cộng một là năm. Vì vậy, điều đó cho biết lý do tại sao chúng tôi có bảy chữ cái được chèn vào đây. Phải. Kênh bảy.

2172
00:06:34,560 --> 00:06:50,240
Bây giờ hãy gọi đáy fi nặng là khó với chỉ số năm. Và chúng ta thấy số bảy ở đúng vị trí của nó. Nếu gọi đây là lỗi cực kỳ cồng kềnh thì chúng ta sẽ gọi với chỉ số của cái này chứ không phải cái kia là hai.

2173
00:06:50,450 --> 00:07:01,540
Và chúng ta thấy cha của cái này, không phải bốn là một trong chỉ số một và bốn ở vị trí hiện tại của nó. Cuộc gọi có tính năng nhổ bỏ chỉ mục cũng chỉ bị ảnh hưởng bởi tuyên bố bằng văn bản này.

2174
00:07:01,850 --> 00:07:12,830
Bây giờ chúng ta đã hoàn thành lệnh gọi này, hãy chèn số bảy. Bây giờ hãy gọi lại với hai. Vì vậy chúng ta sẽ chèn ngay vào đây để chỉ số của năm là ba nhân hai là sáu.

2175
00:07:13,010 --> 00:07:22,850
Vì vậy, sẽ chèn vào bên phải ở đây và hệ nhị phân của chúng ta sẽ được biểu diễn, đại loại như thế này. Bây giờ, hãy gọi nó ở đây nếu tôi muốn. Khó khăn với chỉ số sáu.

2176
00:07:23,210 --> 00:07:37,280
Vậy nút cha của nút thứ hai này không phải là nút thứ năm. Vậy sáu chia hai là ba. Vì vậy, nút năm này, đó là những gì năm này đã đi tới, di chuyển đến đây và năm sẽ di chuyển đến đây.

2177
00:07:37,700 --> 00:08:05,240
Đây cũng là năm và hai. Vậy hãy giải hai và năm. Hãy gọi phương thức biffy này với chỉ số ba và chúng ta thấy đó là hai. Nó nó, nó tạo ra vị trí, sau đó chúng ta sẽ gọi nó bằng chỉ số của Sutent và sau đó được minh họa bằng câu lệnh viết này sau đó nếu chúng ta gọi lại phương thức này bằng ba, vậy hãy gọi bằng ba và hãy chèn vào đây ba, ba lần hai cộng một là bảy.

2178
00:08:05,800 --> 00:08:19,220
Vì vậy, chúng tôi đã chèn khi còn nhỏ và chúng tôi thấy số ba ở đúng vị trí của nó vì số ba lớn hơn số hai mà chúng tôi đã thực hiện. Đây là cách chúng ta có thể xây dựng cấu trúc dữ liệu nhị phân.

2179
00:08:19,380 --> 00:08:39,200
Đây là mảng và đây là cách biểu diễn cấu trúc dữ liệu nhị phân một cách logic. Được rồi, đây là một cách biểu diễn logic. Phương pháp này trước khi
tôi mua vào tomfool thực hiện đăng xuất theo thời gian, độ phức tạp và đăng xuất theo độ phức tạp về không gian cho đệ quy được gọi là ngăn xếp. 

@@@



2180
00:00:00,580 --> 00:00:11,500
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng tôi sẽ triển khai ba phương pháp chọn trang này và trống. Bây giờ, hãy nói về điều đó trước.

2181
00:00:11,510 --> 00:00:23,540
Chúng ta sẽ nói về các trang web. Phương thức này lấy một tham số và nó chỉ đọc trang web. Và trang web là số chỉ mục. Điều đó có nghĩa là ô được sử dụng cuối cùng có bảy.

2182
00:00:24,010 --> 00:00:36,130
Vì vậy, đối với nhị phân đã cho này, nếu bạn gọi phương thức này là site, chúng ta phải thực hiện trong bảy. Nếu chúng ta gọi phương thức này là rỗng, tuyệt đối và sai, vì nửa nhị phân này đã đầy.

2183
00:00:36,520 --> 00:00:49,720
Cái này không trống. Rõ ràng kích thước bằng 0, nhỏ hơn 0. Điều đó có nghĩa là nhị phân của chúng tôi ở đây trống. Vì vậy, chúng tôi gọi điều này được triển khai là trả về sai cho vùng nhị phân đã cho này.

2184
00:00:50,290 --> 00:00:59,800
Bạn nhớ lại phương pháp này chọn các tinnies đại diện, giá trị của nút, phân khu lớn, chuỗi giá trị. Chúng ta không phải làm gì cả. Chúng ta phải trả lại nó thôi.

2185
00:00:59,800 --> 00:01:11,260
Nếu chúng tôi thấy trang web bằng 0, thì giá trị in trống không tồn tại. Trang web phương pháp này sẽ sử dụng Spiga một lần và chọn một độ phức tạp về không gian.

2186
00:01:11,660 --> 00:01:21,640
Phương pháp này trống rỗng. Cũng mất nhiều thời gian và tăng độ phức tạp của một không gian. Và việc chọn phương pháp này cũng sẽ chiếm độ phức tạp một lần và một không gian.

2187
00:01:22,120 --> 00:01:30,340
Chúng ta đã hiểu chính lời giải thích này. Ngay cả khi bạn đang hiểu chính lời giải
thích này, chúng ta cũng đừng hiểu. Tôi đang kiểm tra mã nguồn của video này. 

@@@



2188
00:00:00,680 --> 00:00:10,280
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về phương pháp trích xuất. Bây giờ hãy nói về phương pháp trích xuất này.

2189
00:00:10,310 --> 00:00:21,600
Phương thức trích xuất này sẽ trả về ý chí của Hadnot và nó sẽ loại bỏ phần đầu không phải khỏi cấu trúc dữ liệu của chúng ta. Bây giờ, hãy xem cách chúng ta có thể triển khai phương thức trích xuất này.

2190
00:00:22,460 --> 00:00:31,550
Phương pháp này sẽ hơi khó khăn một chút. Đừng lo lắng về điều đó. Chúng ta sẽ nói về điều đó, đừng lo lắng về điều đó. Chúng ta sẽ nói về từng chi tiết của phương pháp chiết xuất này.

2191
00:00:31,910 --> 00:00:43,070
Đây là chiết xuất kim loại. Phương thức này nhận một tham số bên trong đây, mà nếu bạn thực hiện phép tính thông thường, trừ một, trả về trừ một có nghĩa là một nửa nhị phân trống.

2192
00:00:43,640 --> 00:00:59,150
Sau đó, chúng tôi trích xuất giá trị được trích xuất qua từng cái, giá trị từ chỉ mục một. Sau đó chúng ta sẽ thay thế giá trị ở chỉ số một bằng nốt sâu nhất, được chứ?

2193
00:00:59,180 --> 00:01:11,060
Đó là lưu ý cuối cùng trong khu vực của chúng tôi. Sau đó, bạn đang giảm bên. Chúng tôi chỉ bỏ qua nút cuối cùng. Đó là phần tử cuối cùng trong phần tử cuối cùng hoặc chỉ bỏ qua phần tử cuối cùng.

2194
00:01:11,300 --> 00:01:24,730
Sau đó, chúng tôi gọi đây là phương thức hai chiều từ trên xuống dưới với chỉ mục một với chỉ mục gốc, không phải vì chúng tôi đã cập nhật giá trị của gốc, không phải với nút sâu nhất.

2195
00:01:24,860 --> 00:01:41,580
Vì vậy, chúng tôi phải giúp bạn tìm cấu trúc dữ liệu nhị phân mà chúng tôi tìm thấy sẽ trả về giá trị được trích xuất trong quá trình làm sống động từ trên xuống dưới này. Sau khi ghi lại phương pháp từ trên xuống dưới đáng kinh ngạc này, chúng ta sẽ trả về giá trị được trích xuất.

2196
00:01:42,200 --> 00:01:53,480
Đây là phương pháp. Nếu đánh từ trên xuống dưới thì phương pháp này lấy chỉ mục. Điều đó có nghĩa là chỉ mục của nút gốc của chúng tôi. Sau đó, chúng ta tìm ra biểu đồ bên trái và bên phải và sau đó chúng ta phải tìm ra nó.

2197
00:01:53,480 --> 00:02:11,380
epoxit con nhỏ nhất còn lại ít hơn. Điều đó có nghĩa là nút hiện tại của chúng tôi không có nút con trong trường hợp đó hoặc chỉ bị ảnh hưởng bởi tuyên bố bằng văn bản này. Nếu chúng ta thấy nút hiện tại chỉ còn lại một nút con thì chúng ta sẽ so sánh giá trị với một nút con nhỏ.

2198
00:02:11,900 --> 00:02:28,160
Nếu nút gốc đáng kính lớn hơn nút con bên trái thì chúng ta phải hoán đổi. Nếu chúng ta thấy giá trị của nút gốc lớn hơn giá trị của nút con trái thì chúng ta phải thực hiện hoán đổi bằng cách sử dụng câu lệnh này tại đây.

2199
00:02:28,170 --> 00:02:39,560
Được rồi, sau đó chúng ta chuyển đến chỉ mục của mình và trong giây này ở bên trái và hình elip để tạm thời. Nếu thấy nút hiện tại có trái và phải thì phải tìm nút con nhỏ nhất ở đó.

2200
00:02:40,550 --> 00:02:52,540
Nếu bên trái nhỏ hơn bên phải thì lên nói để biến con nhỏ nhất còn lại con nhỏ nhất bằng bên phải ở đây chỉ kiểm tra, chỉ kiểm tra con bên phải.

2201
00:02:52,550 --> 00:03:13,520
Bởi vì nếu một nút cụ thể có con đúng, điều đó có nghĩa là nút đó có hai lần thử. Điều đó có nghĩa là nút có hai con trái và phải. Ở đây chúng tôi đang kiểm tra xem nút gốc của nhà phát triển có lớn hơn giá trị của nút con nhỏ nhất hay không, sau đó chúng tôi phải thực hiện hoán đổi bằng công thức này.

2202
00:03:14,300 --> 00:03:25,950
Và sau đó chúng ta gọi cái này và chúng ta gọi cái này là biffy từ trên xuống dưới với đứa trẻ nhỏ nhất. Sau khi thực hiện việc hoán đổi ở đây. Con nhỏ nhất là số chỉ mục.

2203
00:03:26,040 --> 00:03:36,470
OK, không phải giá trị của nút. Đây là số chỉ mục. Bây giờ hãy xem nó hoạt động như thế nào. Nếu chúng ta gọi phương thức này là trích xuất những gì được cho là thiểu số, thì nó sẽ trả về 10.

2204
00:03:36,740 --> 00:03:48,950
Làm sao? Hãy xem. Đầu tiên chúng ta sẽ kiểm tra các trang web. Tôi sử dụng kết quả bằng không. Rồi chúng ta rút ra phát triển sẽ không mà là mười. Và sau đó chúng tôi sẽ cập nhật giá trị này.

2205
00:03:48,950 --> 00:04:01,160
Chúng tôi phát triển nút tốt nhất, sau đó chúng tôi sẽ cập nhật giá trị của kẻ phá hoại này với nút sâu nhất, sâu nhất là bảy. Họ sẽ nhận được bằng cách cộng giá trị cuối cùng từ ba của chúng ta và có bảy mươi.

2206
00:04:01,250 --> 00:04:21,870
Vì vậy, hãy cập nhật giá trị này ngay bây giờ. Hãy cập nhật giá trị này với 70 trong khu vực của chúng tôi. Sẽ cập nhật giá trị bảy mươi ngay tại đây. Ở đây cho đến phút cuối cùng sẽ bỏ qua phần tử cuối cùng sẽ làm giảm phe của chúng ta, phe của chúng ta bây giờ là sáu, vì vậy chúng ta sẽ bỏ qua nút này.

2207
00:04:22,740 --> 00:04:34,260
Vì vậy, quyền của ngày hôm nay là bây giờ. Sau đó, thế giới sẽ sống động nếu. Nếu tôi nghe thấy trước thì chúng tôi sẽ đưa đứa trẻ đi trước. Chúng ta sẽ kiểm tra xem nhân vật này có con không.

2208
00:04:34,410 --> 00:04:45,240
Nhân vật đã rời đi. Và ngay bây giờ chúng ta sẽ kiểm tra xem nút hiện tại không có con có phải là lỗi của anh ta hay không. Sau đó, chúng ta sẽ kiểm tra xem nút hiện tại có chỉ còn lại con hay không.

2209
00:04:45,600 --> 00:04:54,900
Không. Điều này cũng sai. Sau đó, chúng ta sẽ kiểm tra xem nút hiện tại có trái và phải với nút hiện tại cũng như không có con trái và phải hay không. Đây là nút hiện tại của bạn 70.

2210
00:04:55,530 --> 00:05:05,490
Vì chúng ta có con trái và con phải nên chúng ta phải tìm nó. Đứa nhỏ nhất, đứa nhỏ nhất là 20. Bây giờ chúng ta sẽ kiểm tra 70 và 20 trong 70 lớn hơn hai mươi.

2211
00:05:05,490 --> 00:05:19,380
Vì vậy, việc tổ chức để giải quyết vấn đề sẽ cập nhật giá trị hai mươi bằng bảy mươi và sau đó chúng tôi sẽ cập nhật giá trị bảy mươi bằng hai mươi. Vì vậy, chúng tôi đã cập nhật các giá trị trong hai mươi và ở đây chúng tôi đã cập nhật giá trị để lấy tích phân 70.

2212
00:05:20,250 --> 00:05:32,790
Và trong khu vực của chúng tôi, những gì chúng tôi sắp làm, chúng tôi sẽ đổi số này thành 20 và 70, lùi về 20. Vậy là hai mươi tất cả Maria và bảy. Hai cái nữa ở đây.

2213
00:05:33,400 --> 00:05:45,350
Thế là hai mươi chuyển tới đây và bảy mươi chuyển tới đây. Vậy hai mươi ở đây và bảy mươi ở đây. Và đây chỉ là sự biểu diễn logic của khu vực này. Sau đó chúng ta sẽ gọi phương thức này với con nhỏ nhất.

2214
00:05:45,370 --> 00:06:02,850
Đứa con nhỏ nhất là đứa trẻ này. Bảy mươi đứa trẻ nhỏ nhất. Chỉ số của nút này là 20 bây giờ nút này chúng ta đã cập nhật là 70 nên chúng ta sẽ gọi nó bằng chỉ mục để bây giờ chúng ta thấy nút này có 2 con trái và phải.

2215
00:06:02,970 --> 00:06:17,850
Tối thiểu là bốn mươi, bây giờ hãy nói là bảy mươi. Và đối với Hoa Kỳ, bảy mươi lớn hơn bốn mươi khi sử dụng công thức này để hai trong số bảy mươi người sẽ chuyển đến đây và bốn mươi sẽ chuyển đến đây và trong khu vực của chúng tôi.

2216
00:06:18,540 --> 00:06:38,390
Chúng ta sẽ hoán đổi bảy mươi và bốn mươi. Vì vậy, ở đây chúng ta sẽ cập nhật 40 với 70 và ở đây chúng ta sẽ cập nhật 70 với 40. Vì vậy, chúng tôi đã loại bỏ, chúng tôi đã phát triển và ở đây chúng tôi phát triển 70, bây giờ chúng tôi sẽ gọi lại phương thức này với chỉ số 70 đã đầy.

2217
00:06:38,860 --> 00:06:49,390
Và trong trường hợp này, chúng ta thấy rằng không có nút con trái và phải của nút này, 70. Vì vậy, hàm thống nhất từ ​​trên xuống dưới này sẽ thoát ra bằng câu lệnh viết này.

2218
00:06:50,020 --> 00:07:02,650
Vì vậy, chúng tôi đã trích xuất chuỗi giá trị từ hệ nhị phân của mình. Và sau đó chúng ta gọi hàm này ở đây trước khi tôi từ trên xuống dưới. Đây là cách hoạt động trích xuất này hoạt động.

2219
00:07:03,010 --> 00:07:13,480
Nếu chúng ta gọi lại phương thức trích xuất này, trong trường hợp đó, nó sẽ trả về 20 và sẽ cập nhật với 60 và chúng ta sẽ xóa 60 và sau đó chúng ta sẽ chỉ hoán đổi 60 và 30.

2220
00:07:14,520 --> 00:07:45,120
Có vẻ như việc nuôi dạy một đứa trẻ ở mức tối thiểu và điều đó sẽ trở nên dễ dàng. Bây giờ hãy xem làm thế nào chúng ta có thể làm điều đó. Có thể gọi phương pháp này, trích xuất tôn giáo 20, có thể gọi phương pháp này, trích xuất lại con số thông minh 20, và rồi chúng ta sẽ có người 60 tuổi ở đây, 60, và sẽ là 20 với 60 tuổi 20 với 60 và sẽ loại bỏ 60 và sẽ cung cấp cho nguyên tố này trong thời đại mới khoảng 180.

2221
00:07:45,120 --> 00:07:55,960
Anh ta sẽ được đánh giá ở mức năm. Sau đó chúng ta sẽ gọi phương thức này. Anh ta sẽ chiến đấu từ trên xuống dưới. Vậy trong trường hợp đó ta sẽ tìm nó là con trái và con phải. Vì vậy, trong trường hợp này, chúng ta thấy rằng chúng ta có trái và phải.

2222
00:07:55,980 --> 00:08:08,160
Ngoài ra, tối thiểu là 30. Bây giờ, hãy giải quyết vấn đề này ngay hôm nay và 60 người hôm nay sẽ chuyển đến đây và 60 người sẽ chuyển đến đây. Được rồi, nếu chúng ta gọi lại, cái này ở ngay dưới cùng với sáu cái để xem.

2223
00:08:08,160 --> 00:08:19,380
Không có con trái và phải. Vì vậy, hàm này sẽ chỉ bằng câu lệnh bằng văn bản này, sau đó chúng ta đã hoàn thành và ở đây chúng ta đang hoán đổi 30 và 60 không tham chiếu, tất cả đều lấy 60.

2224
00:08:19,380 --> 00:08:33,420
Và tôi cá chắc điều này, 20 với 60, sau đó chúng ta sẽ chỉ có 60 và 36 để di chuyển đến đây và sau đó 30 sẽ di chuyển đến đây. OK, chúng ta đã hiểu cách hoạt động của thao tác trích xuất.

2225
00:08:33,630 --> 00:08:49,050
Tôi có một bài kiểm tra, mã nguồn của video này. Kiểm tra mã nguồn. Hoạt động trích xuất này sẽ lấy một lượng lớn nhật ký về độ phức tạp về thời gian và nó cũng sẽ lấy Spiga về nhật ký của độ phức tạp về không gian cho ngăn xếp lệnh gọi đệ quy.

2226
00:08:49,050 --> 00:08:56,370
Nếu tôi hiểu điều này kèm theo lời giải thích, nếu bạn gặp khó khăn khi hiểu phần giải thích
về tốc độ, hãy cho chúng tôi biết. Cảm ơn đã xem. Tôi sẽ gặp bạn trong video tiếp theo. 

@@@



2227
00:00:01,120 --> 00:00:12,640
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này chúng ta sẽ thực hiện phương pháp này, giải quyết nó nếu siêu đơn giản, phương pháp này sẽ siêu đơn giản.

2228
00:00:13,300 --> 00:00:23,960
Đây là phương pháp ở đây. Nó sẽ đưa chúng ta vào trong đây. Chúng tôi chỉ đang ngồi ở đó. Bây giờ, từ viết tắt là một con trỏ trỏ đến độ nghiêng đầu tiên của khu vực.

2229
00:00:24,620 --> 00:00:39,950
Nó nói, tôi làm ngay bây giờ. Khi đó con trỏ sẽ được đổi thành null. Từ viết tắt được chỉ định cho con dấu đầu tiên của khu vực, vì vậy tên mảng bây giờ không được trỏ đến và không có gì trỏ đến con dấu đầu tiên.

2230
00:00:39,960 --> 00:00:54,640
Vì vậy, chúng tôi biết khu vực được thể hiện theo kiểu liền kề. Vì vậy, toàn bộ khu vực sẽ được phân phối bởi người thu gom rác vì chúng tôi đang triển khai khu vực sử dụng HIF nhị phân trong khu vực mà chúng tôi đang nghiêng nhị phân ở đây.

2231
00:00:55,320 --> 00:01:06,230
Đây chỉ là sự biểu diễn logic của khu vực. Những gì chúng tôi đã hiểu lời giải thích này của độc giả. Điều này có nghĩa là một cuốn sách giáo khoa có độ phức tạp một thời, lớn hơn về độ phức tạp về không gian.

2232
00:01:06,790 --> 00:01:14,820
Chúng ta đã hiểu chính lời giải thích này, ngay cả khi bạn hiểu đó là lời giải thích. Hãy
cho chúng tôi biết. Cảm ơn đã xem video này. Tôi sẽ gặp bạn trong video tiếp theo. 

@@@



2233
00:00:01,240 --> 00:00:33,000
Này các bạn quay lại với video này nhé. Chúng ta sẽ nói về ý chí để có được một cấu trúc. Nếu cả ba đều là nhị phân tự cân bằng, lịch sử của ai không được duy trì, thông tin bổ sung được gọi là hệ số cân bằng, có giá trị bằng âm một 0 hoặc cộng một hệ số cân bằng của một nút trong cây đe là chênh lệch giữa chiều cao của cây và chiều cao của cây con bên phải của nút đó trong mỗi cây.

2234
00:00:33,370 --> 00:00:47,010
Nếu hệ số cân bằng của nút không bằng âm một không hoặc cộng một thì cây đó không phải là cây xấu vì nút đó không mang tính chất của cây Aviel.

2235
00:00:47,680 --> 00:00:58,880
Vì vậy, giá trị của hệ số cân bằng phải luôn bằng trừ một 0 cộng với một hệ số cân bằng ghi vào chiều cao của cây con bên trái, trừ đi chiều cao của cây con bên phải.

2236
00:00:59,050 --> 00:01:18,190
Đây là định nghĩa chính thức về cây thật. Bây giờ chúng ta hãy xem một số ví dụ. Đây là một ví dụ về một cái cây. Chúng tôi có vectơ cân bằng cho mỗi nút. Vectơ cân bằng cho nút năm này là một vì chiều cao của nút này là hai.

2237
00:01:19,000 --> 00:01:33,860
Đây là cây con bên trái. Chiều cao là hai, một và hai. Và chiều cao của quyền là một, đây là cây con bên phải nên trừ đi là một. Vậy hệ số cân bằng của cái này, không phải năm, là một.

2238
00:01:34,400 --> 00:01:46,820
Vậy thì nốt nhạc này đang rơi vào tính chất của ma quỷ rồi đối với nốt nhạc này. Mức cao của cây con bằng 0, chiều cao của khu vực bên phải là một không, trừ một là trừ một.

2239
00:01:47,620 --> 00:02:09,190
Và đây là những giá trị trực tiếp không tồn tại, không phải giá trị 0 theo mặc định, vì đối với LoopNet không có cây con trái và phải. Khi đó, giá trị này không phải là một, bởi vì chiều cao của cây con bằng 0 trừ đi chiều cao của bên phải là trừ một, vì không có cây con bên phải.

2240
00:02:09,190 --> 00:02:18,510
Vì vậy giá trị là âm một. Vậy hệ số cân bằng của cái này, không phải bốn, là một. Khi đó, đối với điều này, không phải leptospira là trừ một và cây con bên phải bằng 0.

2241
00:02:18,670 --> 00:02:35,330
Vậy trừ một trừ không bằng trừ một. Vậy hệ số cân bằng cho cái này, không phải sáu, là trừ một. Vì vậy, chúng ta có thể nói đây là một phép thử hợp lệ vì hệ số cân bằng cho mỗi nút đơn lẻ, trừ một không hoặc cộng một.

2242
00:02:35,860 --> 00:02:48,580
Bây giờ hãy xem một ví dụ khác. Đây là một ví dụ về một cây thật. Chúng tôi đã tính toán hệ số cân bằng cho từng nút. Hệ số cân bằng cho nút này là chiều cao của cuộc sống đạt tới quá cao.

2243
00:02:48,580 --> 00:03:00,700
Tư nhân là một, hai, trừ một là một cho việc này chứ không phải một cũng được. Chiều cao của cây bằng chiều cao của tầng phụ bên phải bằng 0. Vì vậy, một phút không là một lý do cho điều này, không phải là không.

2244
00:03:00,880 --> 00:03:12,120
Chiều cao của ghi lên ba không không không không. Đây là những video trực tiếp không dành cho LoopNet. Hệ số cân bằng bằng không. Và đối với mạng này hệ số cân bằng bằng không.

2245
00:03:12,340 --> 00:03:31,750
Vậy chúng ta có thể nói cái cây này đang đổ. Các thuộc tính của Cây Aviel và cây Aviel cũng là một xã hội nhị phân. Nếu một cây không đổ, thuộc tính nhị phân khát thì không thể nói cây đó là cây thật vì nó sẽ như vậy.

2246
00:03:31,750 --> 00:03:46,960
Cây là cây nhị phân. Cái gì? Chúng tôi có thêm thông tin và đó là yếu tố cân bằng. Các giá trị trên cây con bên trái nhỏ hơn các giá trị ở bên phải lớn hơn cho mỗi nút đơn lẻ, cho cây này và cho cây này.

2247
00:03:47,110 --> 00:04:02,140
Như vậy có thể nói qua cây là mỗi cây chúng ta đã hiểu thế nào là cây. Bây giờ, bạn có thể hỏi tại sao chúng ta cần học Aviel Tree. Đó là một câu hỏi hay trong hệ nhị phân.

2248
00:04:02,150 --> 00:04:16,930
Thứ nhất, thao tác chèn mất thời gian tuyến tính, thao tác giãn nở thời gian tuyến tính mất thời gian tuyến tính và thao tác tìm kiếm mất thời gian logarit. Độ phức tạp của thao tác chèn và xóa cây Aviel mất thời gian logarit.

2249
00:04:16,930 --> 00:04:35,200
Độ phức tạp và hoạt động tìm kiếm cũng mất nhiều thời gian phức tạp hơn. Và điều này tương tự như cần thiết. Và ở đây chúng ta thấy rằng đối với các thao tác chèn và xóa, chúng ta có thể cải thiện độ phức tạp về thời gian từ tuyến tính sang logarit.

2250
00:04:35,710 --> 00:04:54,700
Đó là lợi ích sử dụng và đây là lý do tại sao nó sẽ xuất hiện. Và đây là lý do tại sao chúng ta nên học từng cây bằng cách sử dụng từng cây. Chúng ta có thể cải thiện thời gian, độ phức tạp cho các thao tác chèn và xóa từ thời gian tuyến tính, độ phức tạp đến độ phức tạp thời gian logarit.

2251
00:04:55,150 --> 00:05:10,360
Chúng ta đã hiểu tại sao chúng ta nên tìm hiểu từng cây. Bây giờ chúng ta hãy xem ứng dụng của Deviltry để lập chỉ mục cho một bản ghi lớn trong cơ sở dữ liệu mà chúng ta sử dụng nguồn avil ba và bốn trong cơ sở dữ liệu lớn.

2252
00:05:10,480 --> 00:05:25,010
Chúng tôi sử dụng ma quỷ này. Hai trường hợp sử dụng còn lại này và có nhiều trường hợp sử dụng
mà ba trong số chúng ta đã hiểu thế nào là cây thật và tại sao chúng ta nên tìm hiểu từng cây. 

@@@



2253
00:00:01,270 --> 00:00:20,890
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ triển khai phương thức, tạo một cây thật và tạo một phương thức lọc, sẽ tạo một cây thật và cho biết phương thức sẽ tìm kiếm một giá trị trong mỗi cây đó.

2254
00:00:21,280 --> 00:00:38,530
Bây giờ, hãy triển khai điều này vào phương thức. Chúng ta đã tính toán hệ số bạo lực cho từng nốt nhạc, được chứ? Đối với sự bất bạo động này, đối với điều này không trừ một, đối với điều này, không trừ một đối với điều này, không trừ một và không đối với hạch bạch huyết.

2255
00:00:39,220 --> 00:00:53,700
Bây giờ chúng ta hãy xem với một phương pháp. Lớp này, avil ba bên trong đây, chúng ta có một ghi chú, ghi chú của mỗi mục chứa bốn thuộc tính giá trị, chiều cao và con trỏ trái và phải.

2256
00:00:54,010 --> 00:01:06,430
Ở đây chúng ta có gốc rễ của ba điều ác, và chúng ta có phương pháp tuyệt vời này sẽ cố gắng. Phương thức này không có tham số bên trong phương thức này. Chúng tôi chỉ đang thiết lập lộ trình đến bây giờ.

2257
00:01:06,880 --> 00:01:29,470
OK, phương pháp này sẽ đưa chúng ta đi xa hơn về thời gian, độ phức tạp và độ phức tạp lớn hơn về không gian. Ở đây chúng ta có gốc rễ của cả ba điều ác. Sau đó, chúng ta có phương thức này, tạo và sẽ thử phương thức này lấy tham số bên trong ở đây mà chúng ta đang thiết lập gốc cho đến bây giờ và phương thức này sẽ chiếm một thời gian và độ phức tạp lớn của một không gian.

2258
00:01:29,980 --> 00:01:53,320
Bây giờ hãy xem phương pháp tìm kiếm này. Nếu một giá trị tồn tại trong cây Aviel nhất định thì bạn sẽ quay lại giá trị không tồn tại. Nó sẽ trả về sai. Bây giờ chúng ta hãy nói về phương pháp tìm kiếm, đánh giá sẽ lấy một giá trị làm đầu vào và nó sẽ trả về giá trị đó không chỉ trong cây eval.

2259
00:01:53,860 --> 00:02:08,440
Nếu nút không tồn tại, nó sẽ trả về. Bây giờ, đây là thuật toán cho phương pháp Sarsae. Phương thức này nhận giá trị tham số. Thay vào đó, bạn đang gọi phương thức tìm kiếm này bằng phương thức trợ giúp quyết định gốc và giá trị.

2260
00:02:09,130 --> 00:02:17,820
Phương pháp này lấy hai nút nổi bật và mất giá trị. Ban đầu, nút là nút gốc và đánh giá giá trị đã cho trong quá trình kiểm tra của bạn xem kết quả có trả về hay không.

2261
00:02:17,830 --> 00:02:30,700
Bây giờ, đây là Baskette đang hoạt động. Nếu tìm được hoặc phát triển cả vùng mà không bạn sẽ phát hiện ra giá trị hiện tại lớn hơn giá trị. Sau đó tôi sẽ gọi nó là cây ELT bên trái với cây con bên phải.

2262
00:02:31,120 --> 00:02:45,040
Nếu trước tiên chúng ta gọi phương thức này bằng một cây, thì chúng ta sẽ gọi phương thức tìm kiếm bằng Tuyến năm và cây giá trị cho cây đã cho này. Và chúng ta thấy rằng không không phải bây giờ, năm cũng không.

2263
00:02:45,310 --> 00:02:55,360
Và giá trị của nút này không bằng ba. Và chúng ta thấy giá trị lớn hơn cái cây. Vì vậy, chúng ta hãy đi tới cây con bên trái, không phải cây con bên trái.

2264
00:02:55,690 --> 00:03:07,000
Và chúng ta thấy giá trị. Hai là ít hơn ba. Vì vậy chúng ta hãy đi tới cây con bên phải. Đây là cây con bên phải. Và ở đây chúng ta tìm ra giá trị ba. Vì vậy nó sẽ trả về cái này, không phải cái cây.

2265
00:03:07,270 --> 00:03:16,090
Vì vậy, chúng tôi sẽ trả về ba cho lệnh gọi hàm này. Và đây là cách nó hoạt động. Bây giờ, hãy gọi phương pháp này với tám anh ta nhận được, năm không bằng tám.

2266
00:03:16,090 --> 00:03:25,540
Vì vậy chúng ta hãy đi tới cây con bên phải. Và ở đây chúng ta thấy bảy không bằng tám. Vì vậy chúng ta hãy đi tới cây con bên phải. Và đây là tám bằng tám.

2267
00:03:25,540 --> 00:03:42,100
Vì vậy, chúng tôi sẽ trả lại nút số 8 này cho lệnh gọi rối loạn chức năng sẽ phân vùng nút số 8 đó. Đây là cách hoạt động của thao tác tìm kiếm và thao tác tìm kiếm tương tự như thao tác tìm kiếm Sastry nhị phân.

2268
00:03:43,080 --> 00:04:01,080
Chúng tôi biết rằng ngày 3 tháng 4 là một điều cần thiết nhị phân, nơi chúng tôi có thêm thông tin gọi là hệ số cân bằng. Vì vậy, hoạt động tìm kiếm sẽ mất nhiều thời gian hơn, độ phức tạp và độ phức tạp logarit vì chúng tôi đang chia khoảng không quảng cáo thành hai nửa.

2269
00:04:01,080 --> 00:04:16,600
Bốn là gọi hàm đệ quy. Đó là những gì sẽ xảy ra vì độ phức tạp về thời gian dài và độ phức tạp lớn của không gian đăng
nhập đối với ngăn xếp cuộc gọi đệ quy mà chúng tôi hiểu là tạo ra một phương pháp quân sự và hoạt động tìm kiếm. 

@@@



2270
00:00:00,330 --> 00:00:12,750
Này các bạn quay lại với video này nhé. Chúng tôi sẽ thực hiện phương pháp chèn này. Phương thức này lấy một giá trị làm đầu vào và nó sẽ chèn giá trị đó vào đó.

2271
00:00:12,760 --> 00:00:26,660
Tôi sẽ thử phương pháp này sẽ khó hiểu hơn một chút. Chúng tôi có bốn loại xoay vòng để chèn giá trị vào xoay vòng khoảng không quảng cáo. Sự quay của đá ong.

2272
00:00:26,700 --> 00:00:44,210
Phải. Phải. Xoay và phải. Hãy xoay. Trong video này, chúng ta sẽ nói về chuyển động xoay nhỏ. Khi bạn định chèn một giá trị vào ngày 3 tháng 4, thì quá trình này sẽ hơi khó hiểu khi chèn một giá trị liên quan đến ma quỷ.

2273
00:00:44,250 --> 00:00:58,980
Chúng ta có điều kiện kém, điều kiện ít, điều kiện từ trái sang phải. Đúng, đúng. Điều kiện và điều kiện đúng. Trong video này, chúng ta sẽ nói về tình trạng không có môi, tình trạng đó là gì và mức độ hiệu quả của tình trạng đó ít như thế nào.

2274
00:00:59,730 --> 00:01:16,440
Bây giờ, hãy nói về điều đó một cách chi tiết. Ví dụ: nếu bạn được coi đây là một giá trị thực sự làm đầu vào và chúng tôi muốn chèn một giá trị và chúng tôi đã chèn một giá trị hợp lệ ngay tại đây thì đây là một chất kết dính.

2275
00:01:16,440 --> 00:01:33,120
Đây là vị trí đúng của một, bên trái của ghi chú này sẽ được chèn vào. Làm mất giá trị Cây ba tháng tư không tuân theo tính chất của từng cây mà đó là tính chất của hệ số Vallens.

2276
00:01:33,570 --> 00:01:47,700
Tất cả tải phải có hệ số cân bằng trừ một 0 hoặc cộng một. Nhưng khi bạn đã chèn giá trị này vào cây Aviel này thì hệ số cân bằng của nút này trên đó bằng 0.

2277
00:01:48,090 --> 00:01:59,220
Hệ số cân bằng của nút này bằng 0 trừ đi một nằm trên hệ số cân bằng của nút này. Cây con thủy tinh 3S. Đó là một một trừ trừ một.

2278
00:01:59,220 --> 00:02:09,240
Đó là hai. Vì vậy, điều này không phải là không tuân theo yếu tố cân bằng thích hợp. Số dư của số này không phải là trừ một hoặc cộng một. Hệ số cân bằng là ba.

2279
00:02:09,840 --> 00:02:23,480
Vì vậy, hai nút này không tuân theo các thuộc tính của cây thật. Khi bạn đã chèn một giá trị vào bên trái của một nút thì chúng ta phải xử lý tình trạng lật ngược.

2280
00:02:24,150 --> 00:02:37,590
Bây giờ chúng ta phải thực hiện một vòng xoay nhỏ để thực hiện. Cây này là cây Aviel cũng như cây Sastry nhị phân. Để làm được điều đó, chúng ta phải thực hiện một phép quay phải ở đây.

2281
00:02:37,590 --> 00:02:51,030
Được rồi, nếu chúng ta thực hiện phép quay sang phải, thì chữ T sẽ được biểu thị, đại loại như thế này sẽ tắt. Và ba cũng đi về phía bên phải của nút này. Và Tulba đại diện cho điều gì đó như thế này.

2282
00:02:51,180 --> 00:03:11,370
Điều này được gọi là Let Let It Condition. Hãy lấy một ví dụ khác. Ví dụ, nếu bạn lấy cây Aviel này làm đầu vào và bạn đã chèn nút một vào ngay đây, và bây giờ chúng ta thấy rằng hệ số cân bằng của nút hai này là 0 trừ, trừ một là một.

2283
00:03:11,460 --> 00:03:29,880
Hệ số cân bằng của nút này bằng 0. Số dư của nút này là một trừ không. Đó là một trong những yếu tố cân bằng. Hệ số cân bằng của nút năm này là hai trừ 0, chủ đề ưa nước trừ theo chương và đó là hai.

2284
00:03:30,330 --> 00:03:50,210
Vậy nút này không tuân theo tính chất của mọi cây vì số dư của nốt này là hai chứ không phải trừ một không hoặc cộng một. Và chúng ta thấy rằng phổ cân bằng không phải là năm là hệ số cân bằng không phù hợp, bởi vì số dư mà lẽ ra phải có trừ một, cộng một hoặc hệ số cân bằng ở đây chúng ta thấy là hai.

2285
00:03:50,520 --> 00:04:04,860
Vì vậy, đây là nút thủ phạm. Số dư của mạng năm này là hai. Vì vậy, bạn phải thực hiện một phép quay đúng nếu chúng ta làm đúng. Xoay vòng. Sau đó Tulba đại diện cho một cái gì đó như thế này và đây được gọi là điều kiện phân chia.

2286
00:04:05,040 --> 00:04:20,400
Bây giờ hãy xem điều kiện let let hoạt động như thế nào. Đây là thuật toán để chèn một giá trị vào đó. Mỗi cây ở đây chúng ta đều có phương thức trợ giúp này để chèn phương thức này lấy gốc và để đánh giá đây là phương thức trợ giúp.

2287
00:04:20,790 --> 00:04:33,660
Vấn đề này có hai tham số là nút và giá trị. Gốc là gì? Không phải ban đầu. Đây là một cái giỏ. Nếu đến bây giờ chúng tôi đã tìm thấy Noriko thì tức là chúng tôi đang tạo một nút mới và chúng tôi đang trả lại nút đó.

2288
00:04:34,200 --> 00:04:45,090
Chúng tôi nhận thấy giá trị not hiện tại lớn hơn giá trị đã cho. Chúng ta sẽ gọi nó để người khác gọi nó một cách tinh tế. Nếu không, chúng tôi sẽ trả về nút hiện tại.

2289
00:04:45,360 --> 00:04:59,940
Và đây là thuộc tính cho luồng tìm kiếm nhị phân và đây là tìm kiếm nhị phân. Mã cụ thể này ở đây, chúng tôi đã gọi cho một nhiệm vụ cụ thể. Đang chèn nút vào đúng vị trí I.

2290
00:05:00,020 --> 00:05:13,380
Họ đang chèn một nốt nhạc vào một vị trí thích hợp, họ cần tính chiều cao của a. do đó, giá trị đó cắt thành một cộng với chiều cao tối đa của cây con trái và phải.

2291
00:05:13,520 --> 00:05:27,260
Và ở đây chúng tôi có phương pháp này. Chiều cao nhìn thấy phương pháp này trong lúc này lại lo lắng mẹ này lấy laptop viết bài. Sau đó, nó sẽ giữ lại chiều cao của cây con trái và phải và sẽ đạt mức tối đa và sẽ thêm vào một.

2292
00:05:27,620 --> 00:05:38,040
Khi đó ta có hệ số cân bằng sẽ gọi phương pháp này là hệ số cân bằng. Phương pháp này sẽ đọc hệ số cân bằng của một nốt nhất định và sau đó chúng tôi sẽ kiểm tra xem hệ số cân bằng có lớn hơn một hay không.

2293
00:05:38,390 --> 00:05:59,870
Sau đó, chúng tôi tìm thấy giá trị nhỏ hơn mức giá trị đó. Sau đó chúng ta đã gặp điều kiện Lib-Lab và trong video này bạn sẽ thấy điều kiện này. Nếu không, nếu ta tìm ra giá trị lớn hơn giá trị đó thì nếu có đúng điều kiện đó trong điều kiện ta phải gọi là giải phóng đầu tiên thì phải viết.

2294
00:06:00,260 --> 00:06:07,280
Nếu hệ số cân bằng nhỏ hơn âm một thì chúng ta sẽ lấy giá trị này. Giá trị còn lớn hơn thế phải không? Để phát triển thì phải làm đúng. Phải.

2295
00:06:07,280 --> 00:06:17,110
Điều kiện cho quyền. Tình trạng tuyệt vời. Chúng ta phải làm điều đó nếu các giá trị nhỏ hơn bên phải. Để phát triển thần kinh để làm điều đó đúng. Tình trạng tốt cho đúng tình trạng.

2296
00:06:17,120 --> 00:06:29,630
Trước tiên, bạn phải thực hiện ngay thông qua điện cực và cuối cùng, chúng tôi giữ lại nút của mình trong phần này. Chúng ta sẽ thấy tình trạng bên trái này. Bây giờ hãy xem điều kiện này hoạt động như thế nào.

2297
00:06:30,120 --> 00:06:43,430
Giả sử chúng ta muốn chèn nút một vào cấp độ ba này để có thể chèn nút này chứ không phải nút một vào cấp độ ba này. Vì vậy chúng ta sẽ áp dụng điều kiện cơ bản này. Not của chúng tôi không phải là null và giá trị này nhỏ hơn năm.

2298
00:06:43,440 --> 00:06:59,470
Vì vậy chúng ta hãy đi sang bên trái. Giá trị nhỏ hơn ba. Vì vậy chúng ta hãy đi sang bên trái. Giá trị nhỏ hơn hai. Vì vậy chúng ta hãy đi sang bên trái và bên trái. Chúng tôi gặp phải trường hợp không chèn vào đây nút này một bằng câu lệnh mười này, giá trị nhỏ hơn giá trị nút.

2299
00:07:00,260 --> 00:07:11,070
Vì vậy, chúng tôi đã tạo một nút mới với giá trị bằng câu lệnh bằng văn bản này. Và chúng tôi đã chèn ghi chú đó vào bên trái ghi chú này để ghi chú, đây là nút hiện tại của chúng tôi.

2300
00:07:11,780 --> 00:07:23,260
Bây giờ hãy tìm hiểu chiều cao của nút này. Chiều cao của nút này bằng 0 và chiều cao của trang này là âm một. Vì vậy, tối đa là không không, cộng một là một.

2301
00:07:23,390 --> 00:07:34,570
Vì vậy, chiều cao của nút này là một. Và hệ số cân bằng của nút này bằng 0 trừ trừ một, và cũng có một. Vậy số dư của nút hai này là một.

2302
00:07:35,180 --> 00:07:45,470
Vì vậy ta nói hệ số cân bằng không lớn hơn một, không nhỏ hơn âm một. Vì vậy chúng ta sẽ trả nốt số 2 này về bên trái. Vì vậy nốt này sẽ được gán ở bên trái của nốt này chứ không phải nốt ba.

2303
00:07:45,830 --> 00:07:59,150
Hệ số cân bằng của nút ba này là một trừ trừ một. Pin lai trừ đi một. Vậy trừ một bằng hai. Vì vậy tờ tiền này không chứa yếu tố cân bằng thích hợp.

2304
00:07:59,390 --> 00:08:12,930
Vì vậy, ở đây bạn thấy rằng hệ số cân bằng này lớn hơn một. Phương thức này sẽ thấy trong mã giả của chúng ta, có thể thấy phương thức này trong mã nguồn. Và ở đây chúng ta thấy rằng giá trị nhỏ hơn nút tồn tại ở giá trị.

2305
00:08:13,130 --> 00:08:35,450
Vì vậy, không áp dụng được là hai và cái này nhỏ hơn giá trị hai này. Vì vậy, ở đây chúng ta tìm ra điều kiện bên trái và đây là một mức điều kiện trong giá trị được chèn nhỏ hơn chuông ở nốt bên trái hoặc nút hiện tại, nút hiện tại nơi chúng ta tìm ra hệ số cân bằng không phù hợp thì chúng ta phải làm nó xoay phải.

2306
00:08:36,050 --> 00:08:46,430
Vì vậy, nó sẽ gọi và ghi phương thức xoay với nút này ở đây chúng ta có quyền đối với mọi nút đơn lẻ bây giờ hãy gọi nó đúng. Xoay với cái này, không phải một cái cây.

2307
00:08:46,820 --> 00:08:59,330
Đây cũng là mã cho quyền xoay vòng. Phương thức này lấy một tham số nút hiện tại ở đây. Chúng tôi có mục tiêu hiện tại cho việc này, không phải ba. Và Nunally gọi ghi chú này ở bên trái nút hiện tại của chúng tôi.

2308
00:09:00,260 --> 00:09:12,770
Bây giờ hiện tại không áp dụng được cho nút hiện tại. Đừng để DOT đúng. Vì vậy chúng ta phải ngắt kết nối này. Chúng ta phải đặt nó ở bên phải. Quyền này của nút mới này là bây giờ.

2309
00:09:12,770 --> 00:09:26,560
Vậy là chúng ta phải đặt chữ này bây giờ rồi mới đúng. Tương đương với việc cắt nó. Vì vậy, ở đây bạn chèn nút hiện tại này và sau đó chúng tôi sẽ tính chiều cao của hiện tại và chiều cao của đơn vị.

2310
00:09:26,630 --> 00:09:44,030
Thời kỳ nào cũng là một. Chiều cao của Carignan bằng không. Và ở đây bạn thấy chúng ta có chiều cao của loại nút này là hai. Như vậy chúng ta đã tính được chiều cao của nút hiện tại này bây giờ sẽ trả về nút mới này và đơn vị mới này sẽ được chèn vào bên trái của nút này năm.

2311
00:09:44,600 --> 00:09:59,270
Vì vậy đơn vị sẽ nằm bên trái của năm số này, khi đó bảng cân đối kế toán của chúng ta sẽ được trình bày. Một cái gì đó như thế này. Vì chúng tôi đã tính chiều cao của ghi chú hiện tại bằng 0 theo công thức này.

2312
00:09:59,390 --> 00:10:14,510
Chiều cao của. Còn lại là các quý cô chứ không phải số 0 trong cuộc biểu tình. Tối nay chúng ta sẽ nhận thấy làn sóng không sử dụng thứ này. Giá trị của loại này là. Được rồi, bây giờ chúng ta thấy đây là một cái cây thật.

2313
00:10:14,840 --> 00:10:24,130
Đây cũng là một thảm họa nhị phân. Và đây là những gì chúng ta có thể chèn một giá trị vào cây Aviel. Và quá trình này sẽ rất quan trọng để hiểu.

2314
00:10:24,140 --> 00:10:40,730
Nhưng đừng lo lắng, chúng tôi đã giải thích từng chút thông tin mà chúng tôi cần để hiểu vấn đề này. Và thao tác này chỉ mất một thời gian logarit, độ phức tạp và độ phức tạp thời gian để quay phải và chiều cao không đổi.

2315
00:10:41,360 --> 00:10:55,790
Phương pháp này hoạt động trong thời gian không đổi và độ phức tạp không gian không đổi. Và độ phức tạp về thời gian và không gian cho phương pháp chèn này là logarit. Đó là một bản ghi lớn của nó.

2316
00:10:56,840 --> 00:11:08,420
Bây giờ chúng ta hãy xem một ví dụ khác. Bây giờ, giả sử chúng ta được ban cho khả năng này. Chúng ta phải chèn nút một. Vì vậy, hãy chèn cái này vào ngay đây theo điều kiện BSG này.

2317
00:11:08,930 --> 00:11:22,100
Được rồi, sau đó chúng ta phải tìm ra hệ số cân bằng cho từng nút. Hãy tìm chiều cao của nó, chúng ta tìm chiều cao của mỗi từ, chiều cao của nút này là một cho cây nút này hai.

2318
00:11:22,100 --> 00:11:31,940
Và như vậy trên phổ cân bằng không chỉ bằng 0. Hệ số cân bằng của nút này là một 0 trừ đi một là hệ số cân bằng của nút này bằng 0.

2319
00:11:31,940 --> 00:11:49,340
Hệ số cân bằng của nút này là một trừ không. Đó là số dư của nút này là hai trừ không. Đó là hai. Vì vậy, vấn đề ở đây không phải là không chứa hệ số cân bằng thích hợp mà chúng tôi thấy rằng điều kiện này đúng với tuyến đường này.

2320
00:11:49,340 --> 00:12:03,390
Hệ số cân bằng nút lớn hơn một và giá trị được chèn nhỏ hơn giá trị ở bên trái dòng điện của chúng tôi. Không, hiện tại của bạn không hoặc bạn phát hiện ra hệ số cân bằng không phù hợp là nút hiện tại của chúng tôi.

2321
00:12:04,100 --> 00:12:14,270
Bây giờ hãy lấy giá trị này. Nút dẫn đến giá trị, nút ở bên trái của nút này là ba. Vì vậy, ba lớn hơn giá trị chúng ta có bên trong nó.

2322
00:12:15,210 --> 00:12:27,230
Vì vậy, chúng ta phải quay phải vì đây là một điều kiện nhỏ, vì giá trị bên trái của ghi chú lớn hơn giá trị bên trong. Vậy đây là điều kiện bên trái.

2323
00:12:27,780 --> 00:12:47,540
Vì vậy, hãy làm điều đó đúng. Xoay vòng. Đây là mã giả của chúng tôi cho phép xoay phải. Phương thức này lấy một tham số và chúng ta phải kết luận và sơ sinh. Bây giờ chúng ta hãy áp dụng công thức này mà tôi đi hiện tại để các bạn đếm nút bên trái nó sao cho đúng nhé.

2324
00:12:47,570 --> 00:13:05,510
Không, không để bằng hai và không chấm trái. Đúng vậy. Vì vậy ở đây bạn chèn nút này vào sẽ kết nối với nút này. Vậy là nút bên trái đã đúng. Đây không phải là dấu chấm cho tuyến đường mới bằng hiện tại.

2325
00:13:05,990 --> 00:13:30,530
Vì vậy, ở đây, bên phải của mô hình mới này, bên trong hoặc bên trong nút năm và ở bên phải của năm, chúng ta có nút bảy, sau đó ba sẽ được biểu diễn, đại loại như ba đầu tiên này và hai bên trái ở nút bên trái, sau đó tiếp tục bên phải là năm.

2326
00:13:31,040 --> 00:13:44,770
Ở bên trái của năm chúng tôi có bốn. Và ở bên phải của năm chúng ta đã có bảy rồi. Chúng ta phải tính chiều cao của nút này và chiều cao của cây này.

2327
00:13:45,380 --> 00:14:00,050
Vì vậy đây là hình ảnh đại diện của một cái cây thật. Sau khi thực hiện phép quay đúng này thì khả năng của chúng ta sẽ được thể hiện. Đại loại như thế này, chiều cao của nút hiện tại và chiều cao của đợt phun trào mới này.

2328
00:14:01,250 --> 00:14:13,940
Vậy một cộng tạo thành trái và phải. Đó là hai một cộng với tiếng đập trái và phải. Đó chính là nơi chúng ta có thể chèn giá trị vào cây Aviel.

2329
00:14:14,210 --> 00:14:47,750
Và ở đây chúng ta phải làm điều này đúng với điều kiện bên trái nhỏ này. Và đây là câu lệnh cho điều kiện Lavallette và đây là câu lệnh if cho điều kiện đó, khi giá trị trong giá trị đó nhỏ hơn giá trị ở bên trái, apower và nút loại nút trong ghi chú không phù hợp đầu tiên khi chúng ta có hệ số cân bằng không hợp lệ nhưng lùi lại, chèn vào nút, chúng ta đã hiểu phương pháp này và điều kiện liên quan này.

2330
00:14:48,170 --> 00:14:59,420
Hoạt động này sẽ chiếm thời gian, độ phức tạp và độ phức tạp của không gian logarit. Hai phương pháp này sẽ mất thời gian không đổi. Độ phức tạp, yếu tố cân bằng tốt cũng đòi hỏi độ phức tạp về thời gian và không gian không đổi.

2331
00:14:59,880 --> 00:15:13,580
Và độ phức tạp về mặt thời gian tổng thể đối với việc này trong phần lắng đọng là do đăng xuất và độ phức tạp về
không gian là do thiếu thông tin, các lệnh gọi đệ quy mà chúng tôi đã hiểu phần giải thích trong video này. 

@@@



2332
00:00:00,330 --> 00:00:13,020
Này các bạn, chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về cách xoay khi chèn một nút vào cây thật. Thế thì cái cây có thể có được sự cân bằng này.

2333
00:00:13,560 --> 00:00:24,900
Để giải quyết vấn đề này, chúng ta phải thực hiện một phép quay. Ta có bốn loại điều kiện xoay, trượt đất, điều kiện, điều kiện từ trái sang phải. Đúng, đúng.

2334
00:00:24,900 --> 00:00:38,090
Điều kiện và một điều kiện phải trái. Bây giờ, chúng ta hãy xem điều kiện bên trái là gì, điều kiện bên trái là gì, liên minh bên phải, v.v. Bây giờ, trước tiên, hãy nói về tình trạng đóng vai cho tình trạng đó.

2335
00:00:38,340 --> 00:00:56,140
Để hạch bạch huyết của nút hiện tại gây ra sự cân bằng này thì mới giải quyết được vấn đề này, chúng ta phải làm đúng. Xoay vòng. Bạn đã cho cái này một cái cây, nó sẽ chèn cái này không phải cái này vào cây thật này, sau đó với các nút sẽ tạo ra vấn đề.

2336
00:00:56,580 --> 00:01:08,490
Vì vậy, trước tiên hãy tìm hiểu nút hiện tại. Vì vậy sau khi chèn nút này vào bên trái lên trên chúng ta phải lặp lại. Được rồi, bây giờ hãy tính hệ số cân bằng.

2337
00:01:08,610 --> 00:01:20,640
Vậy 0 trừ trừ một, vectơ cân bằng cho nút một này là nút con đó bằng trừ một. Con bên phải là trừ một. Vì vậy số dư của nút này bằng không.

2338
00:01:21,120 --> 00:01:44,340
Số dư của nút này bằng 0 trừ trừ một. Có một cái. Hệ số cân bằng của nút ba này là một trừ trừ một. Đó là hai. Vì vậy, đây là nút hiện tại bởi vì đây là nút đầu tiên không chỉ thấy hệ số cân bằng không phù hợp khi chúng ta diễn tập lại, điều đó có nghĩa là chúng ta sẽ quay lại lệnh gọi hàm đệ quy ở đây.

2339
00:01:44,340 --> 00:01:53,880
Chúng tôi thấy rằng nút Let's của lục địa này đang tạo ra sự cố. Đây là nút tạo ra vấn đề. Vì vậy để giải quyết vấn đề này chúng ta phải thực hiện phép quay phải.

2340
00:01:53,880 --> 00:02:05,370
Nếu chúng ta xoay phải thì đó sẽ là cái đầu mới của chúng ta. Nếu chúng ta thực hiện phép quay đó, cái cây sẽ được biểu diễn như thế này, và cái cây này được cân bằng.

2341
00:02:05,370 --> 00:02:17,100
Và đây là một ma quỷ hợp lệ. Điều này được gọi là tình trạng Lavallette vì nút của nốt hiện tại đang gây ra sự cố hoặc gây ra sự mất cân bằng đó.

2342
00:02:17,850 --> 00:02:25,230
Bây giờ, hãy lấy một ví dụ khác về bệnh tim nhẹ. Giả sử chúng ta đang đưa ra cây này và cho đến nay chúng ta đã chèn nút một ở bên trái.

2343
00:02:25,230 --> 00:02:37,530
Hãy cùng tìm hiểu hệ số cân bằng. Vì vậy số dư của một bằng không. Hệ số cân bằng của hai là 0 trừ trừ một. Đó là hệ số cân bằng của nút này ba là một trừ không.

2344
00:02:37,950 --> 00:02:57,720
Tức là trên thang cân bằng không phải năm là hai trừ 0, tức là hai. Vì vậy, đây là nút đầu tiên. Những gì chúng ta tìm thấy ở hệ số cân bằng thích hợp khi bạn luyện tập lại, điều đó có nghĩa là khi bạn quay lại lệnh gọi hàm đệ quy trước đó của chúng ta, bây giờ chúng ta hãy tìm ra nút bên trái và bên trái của nút này, không phải năm.

2345
00:02:57,720 --> 00:03:07,200
Vậy bên trái là ba, bên trái của cây là hai. Vì vậy, nút này đang tạo ra một vấn đề. Để giải quyết vấn đề này chúng ta phải thực hiện luân chuyển đúng truyền thống.

2346
00:03:07,200 --> 00:03:22,450
Sau đó, đến nút gốc của chúng ta, nó sẽ tạo ra một cái gì đó như thế này. Và điều này đúng với mọi cây và được gọi là điều kiện Leibnitz. Chúng tôi hiểu điều kiện bên trái là gì.

2347
00:03:23,010 --> 00:03:36,270
Bây giờ chúng ta hãy nói về điều kiện từ trái sang phải cho điều kiện điện. Nút của nút hiện tại đang gây ra bạo lực trong trường hợp đó, trước tiên phải xoay, sau đó phải thực hiện đúng truyền thống.

2348
00:03:37,920 --> 00:03:51,000
Bạn được cho một cái cây và bạn đã chèn cái cây vào đây. Bây giờ chúng ta hãy tìm một số dư cân bằng số dư đầu cơ bằng không. Quang phổ của nút này là âm một trừ không.

2349
00:03:51,090 --> 00:04:05,040
Tức là trừ một thừa số cân bằng của cái này không phải bốn mà là một trừ trừ một, tức là hai. Vì vậy, đây là nút hiện tại của chúng tôi hoặc họ thấy nó không phù hợp với hệ số cân bằng không trừ một không hoặc cộng một.

2350
00:04:05,850 --> 00:04:18,450
Ở đây bạn thấy chữ cái ở bên phải của hai chữ cái là cái cây và ở đây chúng ta thấy rằng nút này đang tạo ra sự cố. Và khi nghe bạn nói rằng nút thứ ba này đang tạo ra vấn đề.

2351
00:04:18,750 --> 00:04:33,600
Vì vậy, trước tiên chúng ta hãy thực hiện một vòng xoay nhỏ. Nếu chúng ta làm như vậy, hãy xoay vòng giữa hai nút này, thì Tulba của chúng ta sẽ đại diện cho một cái gì đó như thế này. Bây giờ chúng ta phải thực hiện phép quay phải ở đây.

2352
00:04:33,780 --> 00:04:45,750
Nếu chúng ta thực hiện phép quay sang phải thì chữ T của chúng ta sẽ được biểu diễn, đại loại như thế này. Và điều này hợp lệ cho mọi mục nhập và đây được gọi là Điều kiện từ trái sang phải, chúng ta đã hiểu.

2353
00:04:45,750 --> 00:04:55,770
Điều kiện nào đúng thì điều kiện đó phải làm trước. Hãy xoay vòng sau đó. Phải. Truyền thống. Không, hãy nói về quyền. Phải. Điều kiện cho quyền.

2354
00:04:55,770 --> 00:05:06,140
Phải. Tình trạng. Đúng, đúng. Nút của nút hiện tại đang gây ra điều này. Số dư trong tấm vé đó, chúng ta phải xoay vòng một chút nếu được trao cái này thì chúng ta sẽ cố gắng.

2355
00:05:06,410 --> 00:05:16,550
Và ở đây chúng tôi đã chèn a. tám. Bây giờ chúng ta hãy tìm số dư trở lại hệ số cân bằng của 8 không. Hệ số cân bằng của một là trừ một, trừ không là trừ một.

2356
00:05:17,360 --> 00:05:32,510
Hệ số cân bằng của sáu là 0 trừ trừ một. Có một cái. Số dư của cái này, không phải sáu là không trừ một. Đó là trừ một. Hệ số cân bằng của cái này, không phải bốn là bằng 0 trừ hai.

2357
00:05:32,510 --> 00:05:45,080
Đó là trừ hai. Vì vậy, đây là nút hiện tại. Bây giờ, ai đang không tạo ra vấn đề? Phía bên phải của nút này đang tạo ra sự cố. Đúng đúng chứ không phải xử lý đúng việc này.

2358
00:05:45,080 --> 00:06:08,600
Không phải bốn là bảy, đúng là bốn mươi sáu. Quyền sáu mươi bảy. Vì vậy, nút này đang tạo ra vấn đề. Vì vậy chúng ta phải thực hiện ở đây một phép quay nhỏ. Nếu chúng ta nghe thấy một chút xoay vòng, thì nút sáu này sẽ là tuyến đường của chúng ta, thì nút sáu này sẽ là gốc của nút xoay ba.

2359
00:06:08,840 --> 00:06:20,660
Vì vậy, nếu chúng ta làm điều đó thì chúng ta sẽ có được Aviel ba này. Và đây là một phép thuật hợp lệ và đây được gọi là điều kiện đúng. Chúng tôi đã hiểu điều kiện phù hợp là gì.

2360
00:06:20,990 --> 00:06:32,720
Bây giờ chúng ta hãy nói về điều kiện đúng, điều kiện đúng, lưu ý đúng của dòng điện đang gây ra bạo lực này. Trong trường hợp đó, chuyến đi đầu tiên đến vòng quay bên phải.

2361
00:06:32,730 --> 00:06:45,170
Họ phải thực hiện một vòng quay nhỏ. Ngay cả khả năng này đã chèn nút bệnh ở đây, đã chèn nút này là sáu. Bây giờ chúng ta cùng tìm hiểu hệ số cân bằng.

2362
00:06:45,320 --> 00:06:56,390
Số dư của nút bằng không. Hệ số cân bằng của nút này là bảy và 0 trừ đi một nằm trên số dư của nút này là năm là trừ một.

2363
00:06:56,390 --> 00:07:07,910
Trừ một. Đó là trừ hai. Vì vậy, đây là nút hiện tại của chúng tôi. Chân phải này, không phải năm mà là sáu. Bên phải là bảy, bên trái là sáu. Vì vậy, nút này đang tạo ra vấn đề.

2364
00:07:08,090 --> 00:07:23,470
Đầu tiên, ở đây chúng ta phải thực hiện một phép quay phải. Nếu chúng ta thực hiện phép quay sang phải thì chúng ta sẽ có được ba cái này. Bây giờ chúng ta phải thực hiện phép quay ở đây. Nếu chúng ta thực hiện phép quay thì chúng ta sẽ có được cây này.

2365
00:07:23,480 --> 00:07:34,220
Và đây là phép thuật hợp lệ và đây được gọi là điều kiện phải trái cho điều kiện phải trái. Chúng ta phải làm danh tiếng trước tiên mà phải làm luân chuyển ít.

2366
00:07:34,680 --> 00:07:56,240
Chúng ta đã hiểu thế nào là điều kiện nhỏ, thế nào là điều kiện Leichtfried và thế nào là đúng. Phải. Và điều kiện bên phải bên trái trong Tiberio tiếp
theo sẽ chèn chứ không phải a là ba và chúng ta phải thực hiện phép quay và cũ xem tất cả các kiểu quay và chúng ta cũng sẽ thấy tất cả các điều kiện. 

@@@



2367
00:00:00,440 --> 00:00:10,370
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về thao tác chèn và cụ thể trong video này, chúng ta sẽ nói về tình trạng đá ong.

2368
00:00:10,700 --> 00:00:19,130
Bây giờ, hãy nói chi tiết về tình trạng đá ong. Để dễ hiểu, giả sử chúng ta được ban cho khả năng này và chúng ta phải chèn một ghi chú về giá trị.

2369
00:00:19,150 --> 00:00:33,320
Ba ghi chú được chèn vào đây sẽ mang ghi chú này, sẽ đi đến bên phải của nút này vì đây trước hết là nhị phân vì bộ lọc là một mạch nhị phân và chúng tôi đã tính chiều cao của mỗi nút.

2370
00:00:33,530 --> 00:00:44,780
Bây giờ chúng ta hãy tìm hệ số cân bằng, hệ số cân bằng của cái này, không phải bằng 0. Hệ số cân bằng của nút ba này bằng không. Hệ số cân bằng của nút này là âm một tâm trí và âm một.

2371
00:00:45,140 --> 00:00:56,330
Không có nút nào trên môi của ba người. Vậy chiều cao của leptospira là âm một, trừ một lớp lót là trừ một. Thế thì ở đây một trừ trừ một. Đó là hai.

2372
00:00:56,480 --> 00:01:07,750
Vì vậy, đây là nút không phù hợp vì nút này không tuân theo các thuộc tính của mọi cây. Vectơ cân bằng không trừ một không cộng một. Số dư là hai.

2373
00:01:08,120 --> 00:01:20,340
Ở đây chúng ta thấy bên trong là ba, Velone, nút hộp thư đó, hoặc họ thấy đó là hệ số cân bằng hai không phù hợp và nó nhỏ hơn giá trị được chèn vào.

2374
00:01:20,750 --> 00:01:35,910
Vì vậy, chúng ta phải thực hiện ở đây hãy xoay vòng trước để thực hiện xoay vòng. Vì vậy chúng ta hãy thực hiện một vòng xoay nhỏ. Nếu chúng ta cho phép xoay, nếu chúng ta nghe thấy một chút xoay, thì ý chí của chúng ta sẽ được thể hiện, đại loại như thế này cho đúng điều kiện.

2375
00:01:35,930 --> 00:01:50,760
Bây giờ chúng ta phải làm theo hướng xoay phải. Nếu chúng ta thực hiện xoay phải, thì sự kiện của chúng ta sẽ được thể hiện, đại loại như thế này. Và đây là lá phiếu. Chúng tôi có mọi thứ có chứa yếu tố cân bằng thích hợp.

2376
00:01:51,140 --> 00:02:01,040
Vì vậy, đây là khả năng mà chúng ta phải quay trở lại. Và điều này được gọi là đặt điều kiện đúng cho điều kiện đó. Bước đầu tiên hãy làm một vòng xoay nhỏ nhé.

2377
00:02:01,040 --> 00:02:11,600
Xoay phải. Bây giờ, hãy xem điều này thực sự hoạt động như thế nào khi sử dụng mã giả. Hãy lắng nghe tòa án và phần nào cũng giống hệt như mã giả trong video trước.

2378
00:02:12,740 --> 00:02:34,100
Để dễ hiểu, hãy giả sử chúng ta được cho điều này. Chúng ta sẽ thử chèn một nút ba để Nút ba sẽ đi về bên phải của nút này để tìm chiều cao của mỗi nút đơn lẻ và vectơ cân bằng của nút này, số dư của số dư này không phải là ba số 0 tạo nên tất cả điều này tiếng ồn, trừ một, trừ không là trừ một.

2379
00:02:34,580 --> 00:02:44,030
Bây giờ, số dư của cái này, không phải bốn, là vì một trừ trừ một, tức là hai. Bây giờ chúng ta tìm ra thủ phạm này. Lưu ý nút này không chứa hệ số cân bằng thích hợp.

2380
00:02:44,180 --> 00:03:05,370
Đó là 0 trừ một giờ cộng một không chứa hệ số cân bằng hai. Bây giờ ở đây chúng ta phải thực hiện đúng điều kiện đó trước tiên, hãy gọi nó bằng bên trái của nút này vì đó là hãy gọi bằng cái này chứ không phải danh tiếng của tôi và trả về không phải tất cả được gán cho bên trái của nút này theo phân đoạn.

2381
00:03:05,930 --> 00:03:23,960
Bây giờ chúng ta hãy xem. Vòng quay này là mã giả vòng quay nhỏ của bạn. Ở đây chúng ta có khu vực hiện tại và khu vực sơ sinh của nút hiện tại và tuyến đường mới. Bây giờ những gì chúng ta phải làm, nút hiện tại chấm căn bản của hiện tại, không có dấu chấm bên phải, dấu chấm bên trái.

2382
00:03:24,260 --> 00:03:44,770
Vậy là nút hiện tại đúng rồi. Đây không phải là hiện tại sao? Vì vậy chúng ta phải chèn vào bên phải của nút bây giờ là nút thì chúng ta phải nói rằng yêu tinh của làm như vậy trên phép gán nhỏ nút hai sẽ trả về nút mới này và nốt đó sẽ được gán vào bên trái của nút này.

2383
00:03:45,170 --> 00:03:56,870
Vì vậy, nút ba sẽ được gán cho nút này để sau đó cây của chúng ta sẽ được biểu diễn, đại loại như thế này. Vậy là chúng ta đã hoàn thành tuyên bố về dự án của yêu tinh.

2384
00:03:56,870 --> 00:04:06,980
Lưu ý rằng còn lại. Hãy gọi với lưu ý này rằng chúng ta phải thực hiện đúng dự án. Vì vậy, đây là nút hiện tại của chúng tôi. Vì vậy, hãy gọi với điều này. Không dành cho một nhà văn.

2385
00:04:06,980 --> 00:04:19,360
Muốn nó ở đây, phải không. Đã viết nó cho vòng quay bên phải. Đây là mã giả của chúng tôi. Đây là hiện tại và đây là mới. Loại yêu tinh ở bên trái, chúng ta phải chỉ định loại hiện tại dẫn đến điều đó.

2386
00:04:19,370 --> 00:04:35,150
Phải. Vì vậy, bên phải của máy tính xách tay này là hiện tại. Vì vậy, bây giờ chúng ta hãy chèn nút và các gốc dấu chấm của tuyến đường mới vào mã dành cho và ở đây sẽ trả về tuyến đường mới này.

2387
00:04:35,390 --> 00:04:46,820
Tuyến đường mới này sẽ được chỉ định ở bên trái của nút sáu này, khi bạn gọi nó là yêu tinh để kích động để lại giá trị. Sau đó, cây của chúng ta sẽ được thể hiện như thế này.

2388
00:04:47,180 --> 00:04:59,890
Và chúng tôi đã tính chiều cao của nút mới và tiếp tục sử dụng công thức này. Và sau đó nó sẽ trả cái này về bên trái của nút sáu này. Và đây là đối số và sẽ trả lại ghi chú này cho ý nghĩa này.

2389
00:05:00,710 --> 00:05:12,410
Và đây là cách chúng ta có thể chèn giá trị vào kho. Đây gọi là điều kiện Labourite để cân nhắc đơn giản, họ phải thực hiện đúng truyền thống về điều kiện trái phải, nếu hiểu được.

2390
00:05:12,620 --> 00:05:20,830
Giải pháp này tốn nhiều thời gian, độ phức tạp và giảm độ phức tạp về chi phí. Điều
gì chúng ta đã hiểu là sự giải thích là đang hiểu điều này bằng sự giải thích. 

@@@



2391
00:00:00,660 --> 00:00:09,750
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về hoạt động nội bộ, cụ thể là trong video này. Chúng ta sẽ nói về điều kiện phù hợp.

2392
00:00:09,960 --> 00:00:21,210
Và hãy nói về điều gì đúng, đúng điều kiện. Giả sử chúng ta được cấp khả năng này hoặc nếu được chèn vào Nút 8. Vì vậy, tám sẽ ở bên phải của nút bảy này.

2393
00:00:21,900 --> 00:00:34,500
Và chúng tôi đã tính toán chiều cao của từng nút. Bây giờ chúng ta hãy tìm số dư trở lại số dư của nút này, 18 không. Hệ số cân bằng của cái này không trừ một, trừ 0 là trừ một.

2394
00:00:35,240 --> 00:00:52,080
Hệ số cân bằng của nút này bằng 0 trừ một, tức là trừ một. Khi đó hệ số cân bằng của nút này là 0 trừ 2. Đó là trừ hai. Đây là nút Calvet của chúng tôi.

2395
00:00:52,350 --> 00:01:06,900
Nút này không chứa hệ số cân bằng thích hợp. Vậy đây chính là nút thủ phạm DCG. Phải. Phải. Điều kiện tại sao. Đây là điều kiện từ đúng. Giá trị được chèn vào trong nhị phân hai này là tám.

2396
00:01:07,500 --> 00:01:22,760
Nút hiện tại là nút đầu tiên. Không chỉ tìm thấy nó ở yếu tố cân bằng khi nó tái phát trở lại. Vì vậy, giá trị là sáu chúng ta thấy ở đây. Giá trị này là lớn và sau đó là nút hiện tại có giá trị phù hợp với điều kiện tỷ lệ phù hợp.

2397
00:01:22,770 --> 00:01:35,110
Chúng ta phải thực hiện một vòng xoay nhỏ. Nếu chúng tôi thực hiện phép quay đó, thì Tulba của chúng tôi sẽ đại diện cho thứ gì đó như thế này trên đường phố. Mỗi từ đều chứa hệ số cân bằng thích hợp bằng 0 trừ một hoặc cộng một.

2398
00:01:35,490 --> 00:01:46,770
Và đây chỉ là hiển thị chiều cao của mỗi cạnh nút đơn của nút này. Sáu là chia thành từng mục bên này, v.v. Bây giờ hãy xem điều này thực sự hoạt động như thế nào.

2399
00:01:46,950 --> 00:01:57,960
Và điều này được gọi là ít khi bạn tìm hiểu. Phải? Phải. Có điều kiện để thực hiện vòng quay đó. Họ đọc các từ trong mã, như chúng ta đã thấy ở slide trước.

2400
00:01:58,230 --> 00:02:07,530
Bây giờ, giả sử chúng ta muốn chèn số tám vào Aviel ba này. Vậy tám Will sẽ đi thẳng vào đây để tính chiều cao mà chúng ta tìm được ở độ cao.

2401
00:02:07,860 --> 00:02:18,150
Vậy hệ số cân bằng của số dư Nonnatus zero của tờ tiền này là trừ một, trừ một trừ không là trừ một. Số dư của tờ tiền này là số dư.

2402
00:02:18,150 --> 00:02:30,090
Đó là trừ một hệ số cân bằng của nút này bằng 0 trừ hai. Đó là trừ hai. Vì vậy bạn thấy nó chưa phù hợp với yếu tố cân bằng. Vì vậy, nó sẽ đạt điều kiện này và trừ ba.

2403
00:02:30,660 --> 00:02:45,540
Trừ một. Và ở đây chúng ta thấy. Đúng, đúng. Điều kiện là giá trị 8 lớn hơn giá trị của. Phải. Không phải về, Carignan phản đối, là không được xác định trong đơn vị yếu tố cân bằng không phù hợp khi luyện tập lại.

2404
00:02:46,020 --> 00:02:58,680
Vì vậy chúng ta hãy thực hiện một vòng xoay nhỏ. Đây là mã giả để thanh lý. Vì vậy, đây là nút hiện tại của chúng tôi. Đây là lộ trình hiện tại của chúng ta cũng không phải là căn bản để đếm mà phải trái.

2405
00:02:58,890 --> 00:03:23,610
Vì vậy, tất cả được chèn vào bên phải của nút này năm. Chúng ta hãy thảo luận về điều này và sau đó là lộ trình mới mà hình elip hiện tại. Vì vậy bên trái sẽ kết nối với ghi chú này, sau đó phải tính chiều cao của hiện tại và chiều cao của nút tuyến mới này, sau đó sẽ trả về nút tuyến mới, khi đó ba của chúng ta sẽ được biểu diễn.

2406
00:03:23,610 --> 00:03:36,000
Một cái gì đó như thế này. Hãy tính chiều cao của nút hiện tại này và chiều cao của nút gốc mới. Và ở đây chúng ta thấy chúng ta có phiếu bầu cho từng nút.

2407
00:03:36,570 --> 00:03:51,990
Và nếu chúng ta tính giá trị của nốt hiện tại, chúng ta nhận được tối đa sự kết hợp bên trái và bên phải là 0 và 0. Vì vậy, nếu chúng ta tính chiều cao tối đa ở bên trái và bên phải cộng với một, thì sẽ có một kết hợp giữa bên trái và bên phải.

2408
00:03:51,990 --> 00:04:04,620
Có một cộng một. Và cần biết nếu ta áp dụng giá trị từ cây này thì ta có giá trị này. Bây giờ, nếu chúng ta tính chiều cao, thì chúng ta sẽ nhận được tuyến đường hiện tại hoặc tuyến đường mới là hai.

2409
00:04:05,010 --> 00:04:22,380
Điều đó vẫn được giữ nguyên và cuối cùng sẽ trả về nút tuyến mới này sẽ trả về nút mới này. Và ở đây hàm này sẽ trả về nút mới này bằng câu lệnh viết này cho hàm này có tên là Getable Inspector Metrojet.

2410
00:04:22,620 --> 00:04:33,960
Và một phương thức sẽ hoạt động trong thời gian không đổi và độ phức tạp của không gian không đổi khi nó hiển
thị phương thức này có được sự cân bằng phù hợp. Điều này cực kỳ đơn giản. Chúng tôi có trong mã nguồn. 

@@@



2411
00:00:00,700 --> 00:00:10,990
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về hoạt động nội bộ của ba, cụ thể là trong video này. Chúng ta sẽ nói về điều kiện cuối cùng đó.

2412
00:00:11,030 --> 00:00:25,390
Được rồi. Ví dụ, hãy đặt điều kiện nếu bạn được cung cấp ý chí này và bên trong Nút sáu, chúng tôi đã chèn nút sáu vào bên trái của Nút bảy này vì đây cũng là một tìm kiếm nhị phân.

2413
00:00:25,750 --> 00:00:37,960
Bên trong nó là sáu. Số dư của nút sáu này bằng không. Số dư của nút bảy này bằng 0 trừ trừ một. Có một cái. Số dư của nút này là âm một, trừ âm một.

2414
00:00:37,990 --> 00:00:53,460
Có hai. Vì vậy chúng tôi thấy hệ số cân bằng cho nút này không phù hợp, không đúng với nút hiện tại này. Đây là hiện tại của chúng tôi không phải vì đây không chỉ là tìm ra yếu tố cân bằng không phù hợp khi chúng tôi đang diễn tập trở lại thung lũng, bên phải là bảy.

2415
00:00:53,500 --> 00:01:03,730
Chúng ta nhìn thấy bên trong. Nó nhỏ hơn giá trị bảy. Như vậy đây là điều kiện đúng sáng để chúng ta có thể quay đúng. Sau đó, bạn phải làm một bổ sung nhỏ.

2416
00:01:03,820 --> 00:01:15,640
Nếu chúng ta xoay đúng khả năng này thì cây này sẽ có hệ số cân bằng không phù hợp. Tại Nút 5 này, chúng tôi phát hiện ra rằng chúng tôi phải thực hiện một chút xoay vòng để có điều kiện ánh sáng phù hợp.

2417
00:01:15,880 --> 00:01:25,930
Đó là để cho xoay. Vì vậy, chúng tôi nhận được hàng tồn kho này. Và đây là giá trị mà mọi thứ chứa hệ số cân bằng thích hợp của nút 5 này đều bằng 0.

2418
00:01:25,930 --> 00:01:39,790
Số dư của nút này bằng không. Trong nút này, sáu là một trong các nút, bốn bằng 0 trừ một. Đó là trừ một. Và đối với nút này là bằng không. Vì vậy, đây là một sự kiện hợp lệ.

2419
00:01:40,090 --> 00:01:51,110
Bây giờ hãy xem liên minh trái phải này hoạt động như thế nào trong mã giả. Đây là kỷ lục mà chúng ta đã thấy trong video trước. Bây giờ hãy chèn nút thứ sáu vào cái cây này.

2420
00:01:51,310 --> 00:02:02,400
Vì vậy, sáu tất cả đi về bên trái của bảy. Bây giờ chúng ta hãy tìm hiểu hệ số cân bằng. Trong ghi chú này, sáu số dư bằng 0 hệ số bảy là một số dư. Hệ số năm là trừ một, trừ một, trừ hai.

2421
00:02:02,560 --> 00:02:16,950
Nó gặp phải tình trạng này và ở đây nó đưa ra tuyên bố này. Vì vậy, hãy thử xoay với nút số bảy ở đây. Chúng tôi đã tính toán chiều cao của từng nốt nhạc và con số này thông qua nó.

2422
00:02:16,990 --> 00:02:32,890
Được rồi, bước đầu tiên hãy thực hiện nó với ghi chú phù hợp. Đây là hiện tại của bạn. Vì vậy, nếu chúng ta viết nó, đây là nút mới của chúng ta, hai dòng điện bên trái bên phải hiện tại ở bên trái sẽ chèn vào.

2423
00:02:34,210 --> 00:02:54,870
Vì vậy, ở phần bên trái, bây giờ nó có nút tuyến đường mới. Đúng vậy. Bởi vì dòng điện ở bên phải hoặc bên trong nút bảy này và sẽ trả về giá trị này không phải là chiều cao của nút hiện tại và nút mới và sau đó sẽ trả về nút mới này và đơn vị này sẽ ở bên phải nút năm này.

2424
00:02:55,330 --> 00:03:04,130
Sau đó, Tulba của chúng tôi đại diện cho một cái gì đó như thế này. Hãy tính chiều cao, chiều cao của nút sáu này bằng một chiều cao của nút bảy này đến 0, v.v.

2425
00:03:04,660 --> 00:03:15,670
Vậy là chúng ta đã hoàn thành tuyên bố này. Bây giờ chúng ta hãy thực hiện một phép quay nhỏ với nút này, bởi vì đây là hệ số cân bằng không đủ tiêu chuẩn và không phù hợp hiện tại của chúng tôi.

2426
00:03:16,180 --> 00:03:29,650
Nếu có, hãy coi đây là mã giả xoay vòng của chúng tôi. Được rồi. Đây là hiện tại và đây là tuyến đường mới hiện tại, không phải là cấp tiến cho nút hiện tại chấm ngay.

2427
00:03:29,650 --> 00:03:44,440
Bây giờ bên trái của số sáu là. Vì vậy, ở đây, bên trong bên phải, bây giờ chúng ta hãy chèn vào đây tuyến đường mới cho phép nó đi qua bên trái hoặc chèn dòng điện bằng năm trong năm.

2428
00:03:44,590 --> 00:03:59,010
Và sau đó chúng ta sẽ tính chiều cao của dòng điện và đơn vị và chúng ta sẽ trả về ghi chú này và ghi chú này sẽ được gắn vào bên trái của nút này và điều này sẽ được thực hiện bằng câu lệnh này.

2429
00:03:59,020 --> 00:04:11,530
Phải. Và con cái chúng tôi đại diện cho điều gì đó như thế này. Và ở đây chúng ta đã tính được chiều cao của sáu và chiều cao của năm không và một. Đây là cách nó hoạt động trong điều kiện phù hợp.

2430
00:04:11,780 --> 00:04:28,660
Chúng ta đã hiểu thế nào là đúng khi đặt điều kiện cho đúng điều kiện, bước đầu tiên là viết nó. Trong thư chúng ta đã hiểu lời giải thích này của Avita và 4 điều kiện điều kiện LePoint, điều kiện Liveright.

2431
00:04:28,660 --> 00:04:46,120
Đúng, đúng. Tình trạng và tình trạng phải trái. Đây là tất cả về thao tác chèn trong Deviltry sau khi chèn một nút vào vectơ cân bằng được đánh giá trừ một 0 hoặc một khi bạn yêu cầu quay lại, điều đó có nghĩa là chúng tôi không phải thực hiện xoay vòng.

2432
00:04:46,120 --> 00:04:56,200
Trong trường hợp đó, khi bạn thấy số dư không phù hợp và chỉ yêu cầu quay lại sau khi chèn một nút thì chúng tôi phải thực hiện xoay vòng. Chúng tôi có kiểu xoay chuyển tiếp của bạn.

2433
00:04:56,470 --> 00:05:09,950
Và chúng ta đã nói về điều này trong video cuối cùng. Xoay, điều kiện bên phải xoay cho điều kiện bên phải bên
trái, độ phức tạp về thời gian của thao tác này là đăng xuất và độ phức tạp về không gian cũng là đăng xuất. 

@@@



2434
00:00:01,450 --> 00:00:19,630
Này, các bạn thật tuyệt vời. Chào mừng bạn quay trở lại với video này trong video này. Chúng ta sẽ nói về hoạt động quân sự. Vấn đề này lấy một giá trị tham số làm đầu vào và nó sẽ xóa ghi chú của giá trị đã cho khỏi quân đội.

2435
00:00:20,560 --> 00:00:35,320
Để xóa một ghi chú khỏi thực tế, chúng tôi có thể cần thực hiện xoay vòng, chúng tôi có thể phải xoay khoảng không quảng cáo nếu đó là một ghi chú cụ thể, hệ số cân bằng có thể bị thay đổi.

2436
00:00:35,560 --> 00:00:54,190
Và đó là tùy vào việc quay nhổ a.. Nếu thấy hệ số cân bằng hợp lý thì phải làm phép quay để song ca. A. Từ ngày 3 tháng 4, chúng ta có thể có tình trạng đầy đủ, tình trạng bệnh cùi, tình trạng Labourite, tình trạng giao dịch lại và tình trạng đúng.

2437
00:00:54,760 --> 00:01:13,150
Chúng ta phải xoay cái avil ba nếu tìm thấy nó trong vectơ cân bằng thích hợp cho nút. Nếu chúng ta tìm ra vectơ cân bằng thích hợp cho mỗi nút sau một nút thì chúng ta không cần phải quay.

2438
00:01:13,570 --> 00:01:34,380
Chúng ta không phải lo lắng về việc luân chuyển. OK, bây giờ hãy xem cách xóa nó. Nút từ một cây thật và bạn sẽ thấy điều kiện đầy đủ này. Đầu tiên, chúng ta hãy nói về điều kiện đóng vai đối với điều kiện nào mà mức dòng điện không gây ra sự cân bằng này.

2439
00:01:34,390 --> 00:01:51,880
Trong trường hợp đó, chúng ta sẽ thực hiện phép quay bên phải. Giả sử chúng ta được cấp cây Aviel này và chúng ta muốn xóa nút này năm. Nó sẽ dẫn nó đến đây, không phải năm. Sau đó chúng ta sẽ có cây này và vectơ cân bằng của nút này bằng 0.

2440
00:01:51,880 --> 00:02:07,870
Số dư của nút hai này là 0 trừ trừ một. Số dư của nút này một trừ trừ một, và đó là hai. Vì vậy, đây là nút hiện tại của chúng tôi, nút let let không phải là nút này đang gây ra sự cố.

2441
00:02:07,870 --> 00:02:22,850
Vì vậy phải thực hiện xoay vòng đúng. Nếu chúng ta thực hiện phép quay đúng thì chúng ta sẽ là gốc của cây. Vì vậy, nếu chúng ta viết xoay thì chúng ta sẽ có được cây này. Và đây là một cây hợp lệ và điều này được gọi là tình trạng trượt flipflopped.

2442
00:02:23,110 --> 00:02:34,210
Bây giờ hãy nói về điều kiện trái phải của điều kiện Libbrecht. Việc xử lý nút hiện tại đang gây ra bạo lực này, trong trường hợp đó là theo vòng quay đầu tiên và truyền thống đúng đắn.

2443
00:02:34,780 --> 00:02:50,080
Giả sử chúng ta đang đưa ra cây Aviel này và chúng ta muốn xóa nút năm này, xóa nút năm này. Sau đó, khối u của chúng tôi đại diện cho một cái gì đó như thế này và sự cân bằng của nút ba số không, sự cân bằng của nút hai này là âm một.

2444
00:02:50,320 --> 00:03:00,940
Và sự cân bằng của điều này, không phải bốn mà là một trừ trừ một. Đó là hai. Vậy đây là nút hiện tại của bạn, nút trái hoặc nút phải là ba. Ghi chú này đang tạo ra vấn đề.

2445
00:03:01,120 --> 00:03:17,140
Vì vậy, đầu tiên chúng ta nghe thấy một chút xoay chuyển. Nếu chúng ta để xoay, thì khối u đại diện cho một cái gì đó như thế này và sau đó chúng ta phải thực hiện xoay đúng. Nếu chúng ta thực hiện phép quay phải thì ba sẽ là gốc của cây xoay riêng, phép quay phải.

2446
00:03:17,140 --> 00:03:30,040
Sau đó chúng ta sẽ có được cái cây này. Và đây là cây Aviel hợp lệ và đây được gọi là Điều kiện từ trái sang phải. Chúng tôi đã hiểu điều kiện phù hợp là gì. Bây giờ chúng ta hãy nói về điều kiện đúng cho điều đúng.

2447
00:03:30,040 --> 00:03:43,900
Đúng điều kiện. Đúng, đúng. Nút của nút hiện tại đang gây ra sự cân bằng này. Giả sử chúng ta đang cho cây này và chúng ta muốn xóa nút này một cây. Nếu không phải là cây thì ta sẽ lấy cây này.

2448
00:03:44,080 --> 00:03:53,050
Bây giờ, hãy tìm hệ số cân bằng giữa nút sáu này bằng không. Sự cân bằng của cái này, không phải hệ số cân bằng của nút năm này là trừ một, trừ 0.

2449
00:03:53,050 --> 00:04:04,960
Đó là trừ một. Không có cấp độ nào mà chúng tôi trừ một cho phòng thí nghiệm. Hệ số cân bằng cho cái này, không phải bốn, là trừ một, trừ một. Vậy số dư của cái này không dành cho hai.

2450
00:04:05,230 --> 00:04:14,950
Vì vậy, đây là nút hiện tại của chúng tôi, không phải nút bên phải. Đây là lưu ý đúng đắn. Và ghi chú này đang gây ra vấn đề. Vì vậy chúng ta hãy thực hiện một vòng xoay nhỏ ở đây.

2451
00:04:14,950 --> 00:04:31,370
Nếu chúng ta thực hiện phép quay thì chúng ta sẽ có được cái cây này. Và đây là một cây ý chí hợp lệ và đây là điều kiện đúng, đúng. Chúng tôi đã hiểu điều kiện từ đúng là gì vì việc xử lý đúng nút hiện tại đang gây ra bạo lực này.

2452
00:04:31,780 --> 00:04:41,080
Bây giờ, hãy nói về điều kiện phải, trái, phải, trái. Lưu ý về hiện tại. Điều gì gây ra bạo lực trong trường hợp đó? Trước hết, đúng truyền thống.

2453
00:04:41,080 --> 00:04:54,310
Thế thì bạn phải làm theo truyền thống. Giả sử chúng ta được ban cho khả năng này và chúng ta muốn xóa nó đi, không phải cái cây bên trong nó cũng không phải là cái cây. Khi đó chúng ta có được cây này và hệ số cân bằng của 7 bằng 0.

2454
00:04:54,940 --> 00:05:08,140
Hệ số cân bằng của sáu là 0 trừ trừ một hoặc một. Hệ số cân bằng của cái này, không phải bốn, là trừ một, trừ một, tức là trừ hai. Vì vậy, nút let bên phải đang gây ra sự cố.

2455
00:05:08,320 --> 00:05:19,420
Vì vậy trước tiên chúng ta hãy thực hiện phép quay đúng. Nếu chúng ta thực hiện phép quay đúng thì cả hai sẽ được biểu diễn. Chuyện như thế này thì phải làm sao để xoay vòng rồi mình.

2456
00:05:19,630 --> 00:05:30,430
Bạn sẽ được đại diện như thế này, và chúng tôi nói rằng đây là một trò quỷ hợp lệ, số dư không dành cho số dư, không phải bảy và không. Số dư của sáu cũng bằng không.

2457
00:05:30,940 --> 00:05:43,360
Vì vậy chúng ta có thể nói đây là một phép quỷ hợp lệ và đây được gọi là điều kiện phải trái ở đây. Quyền, không phải đối tác, đang tạo ra vấn đề. Trong trường hợp đó, bạn phải làm đúng truyền thống và truyền thống.

2458
00:05:43,690 --> 00:05:59,430
Như bạn đã thấy, họ nói điều kiện đầu tiên chúng ta phải xử lý để song ca và thậm chí không tìm ra hệ số cân bằng là khả năng áp dụng hợp lệ, bạn biết đấy, sau đó chúng ta phải thực hiện một vòng quay và có trường hợp cơ bản của chúng ta.

2459
00:05:59,680 --> 00:06:13,260
Bây giờ chúng ta hãy xem các quyết định bằng mã giả để tòa án giải quyết vấn đề này. Chúng ta có vấn đề này phải không? Nó nhận một giá trị tham số. Sau đó, chúng tôi đang nói ở đây, thực sự phải làm điều đó và nó cần có gốc rễ và giá trị.

2460
00:06:14,050 --> 00:06:29,140
Đây là phương pháp trợ giúp của chúng tôi ở đây. Chúng tôi đang đưa bạn đến bây giờ, sau đó chúng tôi sẽ quay lại ngay bây giờ, nếu Carnot phát triển kém hơn thì chúng tôi sẽ gọi nó. Hãy đồng ý rằng điều đó còn quan trọng hơn việc phát triển cây con bên phải Cardno.

2461
00:06:29,320 --> 00:06:43,630
Nếu chúng tôi tìm ra nút mà chúng tôi phải thực hiện thì chúng tôi sẽ áp dụng mã này. Và chúng ta đã nói về cách xóa một nút cho hệ thống nhị phân và điều này hoàn toàn tương tự như vậy.

2462
00:06:44,180 --> 00:06:59,370
Và điều này hoàn toàn giống với việc cho phép một nút từ lịch sử nhị phân. Nếu Cardno có con thì bạn áp mã này, nếu hiện tại không có thì chỉ có con áp dụng mã này.

2463
00:06:59,910 --> 00:07:17,640
Nếu nút hiện tại chỉ có con bên phải thì sẽ áp dụng. Mã này trong nút hiện tại là lipner sau đó sẽ nói là không đến bây giờ và sẽ giữ lại nút hiện tại và nghe thấy mã này dành cho từng từ cụ thể và là mã cho mọi cây.

2464
00:07:17,670 --> 00:07:34,800
Được rồi, trước tiên, bạn hãy tính vectơ cân bằng cho nút hiện tại của mình, chúng tôi thấy rằng vectơ cân bằng lớn hơn một. Sau đó, bạn áp dụng điều này. Và ở đây chúng ta có điều kiện đó và điều kiện Libbrecht, số dư EBC nhỏ hơn âm một.

2465
00:07:35,150 --> 00:07:46,130
Sau đó chúng ta có thể có tình trạng đường bên phải, được rồi, tình trạng bên trái, được chứ? Và chúng tôi chỉ đang tính chiều cao. Và cuối cùng, chúng tôi sẽ trả về nút hiện tại.

2466
00:07:46,820 --> 00:08:03,530
Ở đây chúng ta có phương thức trợ giúp Mynatt. Phương pháp này sẽ thấy tối thiểu là không bỏ cuộc hoặc đầu hàng. Và đây là truyền thống đúng đắn. Đây là từ tính và đây là để tính chiều cao của nó chứ không phải cho điều kiện đó.

2467
00:08:04,220 --> 00:08:16,970
Nếu chúng ta áp dây vào cây này và ở đây chúng ta muốn xóa nút thứ năm này, thì Tulba của chúng ta trước tiên chỉ đại diện cho một cái gì đó như thế này. Không phải vậy. Và sau đó nó sẽ quay ngay.

2468
00:08:17,000 --> 00:08:28,100
Sau đó chúng ta sẽ có được khả năng này. Đây chính là nguyên nhân dẫn đến tình trạng đó. Bây giờ chúng ta hãy xem điều kiện Labourite, điều kiện điện. Nếu bạn muốn trì hoãn nút này thì chúng ta lấy cây này.

2469
00:08:28,910 --> 00:08:39,380
Sau đó, ở đây bạn phải thực hiện một phép quay nhỏ ở trên đó, thực hiện một phép quay nhỏ ở ngay đây về việc làm một chút là chúng ta phải thực hiện phép quay phải. Sau đó chúng ta sẽ nhận được ma quỷ này.

2470
00:08:40,100 --> 00:08:52,130
Và đây được gọi là điều kiện Leichtfried. Bây giờ hãy nói về điều kiện tred đúng. Nếu chúng ta đưa ra ý chí này, nếu chúng ta muốn xóa nút ba này, nếu chúng ta trì hoãn nút này chứ không phải ba, thì chúng ta sẽ có được cây này.

2471
00:08:52,580 --> 00:09:17,600
Và ở đây chúng ta phải thực hiện một phép quay nhỏ ở đây, có thể áp dụng đoạn mã này. Được rồi, vậy chúng ta sẽ có được một cái cây thật. Bây giờ hãy nói về điều kiện đúng. Nếu chúng ta được ban cho khả năng này, nếu chúng ta muốn xóa nút thứ ba này và nó sẽ không phải là một cái cây, chúng ta sẽ có được cây này và đây là phép quay bên phải bằng cách sử dụng công thức này trước tiên với điều kiện bên phải, sau đó truyền thống thực hiện bên phải và bên trái.

2472
00:09:17,870 --> 00:09:32,180
Và chúng ta có được cây này và sẽ trả lại cây này. Và đây là cách điều kiện đầy đủ này hoạt động. Nếu chúng tôi muốn xem cách thức hoạt động của nó, tôi sẽ khuyến khích bạn xem qua mã giả.

2473
00:09:32,870 --> 00:09:46,490
Tôi sẽ không đi qua từng dòng mã. Tôi khuyến khích bạn cố gắng viết mọi thứ lên một tờ giấy để nó sẽ được xóa ở đây. Phương pháp này chỉ mất độ phức tạp thời gian logarit.

2474
00:09:46,820 --> 00:10:00,650
Vì vậy, độ phức tạp về thời gian và không gian đối với nút này là rất lớn khi đăng nhập. Chúng tôi
đã hiểu chính lời giải thích này, sự hiển linh. Sự hiểu biết Kitô giáo là lời giải thích. 

@@@



2475
00:00:00,600 --> 00:00:11,750
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về nó trong một cái cây thật. Hãy xem liệu chúng ta có thể áp dụng phương pháp này để vào quân đội hay không.

2476
00:00:12,390 --> 00:00:22,410
Đây là phương thức vào bệnh viện quân đội, lấy thông số bên trong đường ngồi của bạn. Bây giờ, con trỏ tuyến đường này trỏ đến tuyến đường của mỗi mục nhập của chúng tôi.

2477
00:00:23,070 --> 00:00:33,840
Nếu chúng ta nói bây giờ là xong thì nó sẽ bị ngắt khỏi mạng này. Và rồi tất cả chỉ đến bây giờ chẳng có ý nghĩa gì. Bây giờ ở đây chúng ta thấy rằng không có gì khác chỉ ra điều này.

2478
00:00:33,840 --> 00:00:42,720
Không hẳn. Vì vậy Dymocks Collector sẽ xóa ghi chú này khỏi bộ nhớ máy tính. Khi đó bạn thấy không có gì khác chỉ vào nút này, không cho vào nút bảy này.

2479
00:00:42,990 --> 00:00:51,830
Vì vậy ghi chú này sẽ bị người thu gom rác loại bỏ. Khi đó chúng ta thấy không có gì khác chỉ vào nút này, không một đến nút này, không phải ba đến sáu và tới nút này là tám.

2480
00:00:51,990 --> 00:01:02,540
Vì vậy, cái này cho not sẽ bị bộ thu gom rác xóa khỏi bộ nhớ. Vì vậy, hãy loại bỏ chúng. Bây giờ chúng ta thấy rằng không có gì trỏ đến nút này. Không có gì trỏ đến nút chín này.

2481
00:01:03,060 --> 00:01:15,180
Vì vậy, điều này sẽ được gỡ bỏ. Người thu gom rác. Sau đó, chúng tôi thấy mục nhập cấp ba của chúng tôi đã bị xóa khỏi bộ nhớ máy tính. Đây là cách chúng tôi nhập mọi phương thức nhập đều hoạt động.

2482
00:01:15,750 --> 00:01:27,630
Chúng ta phải vạch ra con đường dẫn tới tri thức. Chúng tôi đã nói rằng toàn bộ sẽ bị người thu gom rác tự động xóa. Vì vậy, chúng tôi gọi phương pháp này. Thực thể sẽ bị xóa.

2483
00:01:27,670 --> 00:01:40,350
Chúng tôi có một bộ thu thập hỗn hợp và sự phức tạp về thời gian và không gian cho phương pháp này là do một và
vì một. Vì vậy, phương pháp này hoạt động trong thời gian không đổi và độ phức tạp không gian không đổi. 

@@@



2484
00:00:00,870 --> 00:00:14,180
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về việc cố gắng cấu trúc tri là gì. Đã thử nó, một cấu trúc thường được sử dụng để lưu trữ và bán mọi thứ theo cách hiệu quả về không gian và thời gian.

2485
00:00:14,900 --> 00:00:29,740
Nếu bạn không ở trong đó, hãy cố gắng đánh lạc hướng nhân vật không báo cáo trong cửa hàng của bạn. Chúng ta sẽ nói về điều đó vào lúc khác để lo lắng về điều đó. Nếu không, lưu liên kết của ký tự tiếp theo và mọi ghi chú sẽ theo dõi thành chuỗi.

2486
00:00:30,530 --> 00:00:58,510
Đây là ví dụ về cấu trúc được cung cấp mà chúng tôi đã chèn vào đây ABC, ABCL và Ilim ở đây. Chúng tôi đã chèn ba thứ này vào cấu trúc đã thử này và thử được thể hiện, đại loại như thế này, từng nốt nhạc trong đó để cấu trúc ký tự lặp lại Sternau ở đây chúng tôi phải lặp lại ký tự ở đây chúng tôi thấy chúng tôi có Evvy và Evvy, nhưng chúng tôi có ở đây và ổn thôi.

2487
00:00:58,910 --> 00:01:22,240
Vì vậy, chúng tôi không lặp lại ký tự và mọi thứ sẽ thêm vào ký tự tiếp theo. Vậy đây là A và B. Vậy ở đây ghi chú này là Staats, liên kết của ký tự B tiếp theo này và ở đây nữa, ghi chú này cũng chứa liên kết của ký tự này và mọi để theo dõi trong chuỗi.

2488
00:01:22,280 --> 00:01:42,030
Vì vậy, ở đây không hiển thị chuỗi kết thúc. Chúng ta sẽ nói chi tiết trong phần này của khóa học này. Đừng lo lắng về điều đó. Khi cố gắng cấu trúc, chúng ta có thể đáp ứng thao tác tiêu chuẩn, chèn các phần chèn tiền tố và sau đó xóa thao tác bằng cách sử dụng phép nội suy này, tất cả các từ chèn trong nỗ lực cấu trúc bằng cách sử dụng tiền tố của chúng ta.

2489
00:01:42,450 --> 00:01:59,360
Ngoài ra, nếu một tiền tố nhất định tồn tại trong nó, nó sẽ thử tìm kiếm một từ hoàn chỉnh và sau đó chúng tôi sẽ xóa một từ khỏi cấu trúc cố gắng của chúng tôi và bạn sẽ thấy tất cả các thao tác trong phần này của khóa học này.

2490
00:01:59,900 --> 00:02:08,480
Bây giờ chúng ta hãy xem ứng dụng của việc cố gắng cấu trúc. Tại sao mọi người nên thử. Có hàng nghìn ứng dụng mà tôi đã cố gắng cấu trúc trong đời thực.

2491
00:02:09,050 --> 00:02:18,740
Bây giờ chúng ta sẽ nói về hai cách sử dụng phổ biến, người kiểm tra chính tả sử dụng nó, thử nó, một cấu trúc. Đây là ví dụ về trình kiểm tra chính tả, xem BRW tại đây.

2492
00:02:18,740 --> 00:02:30,620
Đây là một sai lầm. Sử dụng nó cung cấp một cấu trúc mà chúng ta có thể sửa chữa. Điều này có nghĩa là một cái gì đó như thế này. Vì vậy, cách sử dụng bí mật chính tả đã cố gắng cấu trúc các cách sử dụng của Google, hãy thử các đề xuất tìm kiếm tự động.

2493
00:02:31,520 --> 00:02:54,530
Chúng tôi sẽ sử dụng các kỹ thuật tiên tiến hơn. Nhưng khái niệm này vẫn giữ nguyên sự quản lý. Chúng tôi đã nhập Google SCA và nó cung cấp cho chúng tôi các đề xuất và họ đang cố gắng cấu trúc Google, sử dụng các tính năng nâng cao hơn nhưng các nguyên tắc cốt lõi vẫn giữ nguyên.

2494
00:02:55,070 --> 00:03:03,260
Chúng tôi đã hiểu tại sao bạn nên học thử một cấu trúc và nó là gì? Đã thử nó một
cấu trúc. Cảm ơn đã xem video này. Tôi sẽ gặp bạn trong video tiếp theo. 

@@@



2495
00:00:01,140 --> 00:00:13,740
Này các bạn, chào mừng các bạn quay trở lại với video này trong video này. Chúng ta sẽ nói về cách thể hiện cấu trúc dữ liệu khô khan. Cái này thử a.. Cái này không phải thuộc tính con.

2496
00:00:13,860 --> 00:00:32,790
Và trong báo cáo, đứa trẻ này là một Hashmat. Đây là sự thật. Và chúng tôi có Hashmat. Đây là một quyết định của Hashmat, Hashmat. Và đây là ở tòa án. Được rồi, chúng ta phải Pat Hashmat và kết thúc bằng từ is.

2497
00:00:34,140 --> 00:00:49,530
Bây giờ hãy xem TREIS được thể hiện như thế nào. Giả sử chúng ta muốn chèn ba chuỗi ABC, ABC và L này vào. Nếu chúng ta chèn ba chuỗi này vào cấu trúc dữ liệu tri thì cấu trúc dữ liệu của chúng ta sẽ được biểu diễn.

2498
00:00:49,530 --> 00:01:08,480
Đại loại như thế này ABC, ABC, rồi l m m. Và đây là nút ba của chúng tôi. Chúng tôi có hàm băm Hashmat và chúng tôi có một biến trong cổng. Bây giờ chúng ta hãy xem điều này đã cố gắng như thế nào.

2499
00:01:08,480 --> 00:01:25,760
Cấu trúc được thể hiện trong bộ nhớ máy tính. Cấu trúc dữ liệu đó được thể hiện, đại loại như thế này. Nút chuyển đổi nút gốc của chúng tôi ở đây chúng tôi có E và ở đây chúng tôi đang lưu trữ ký tự và thử nghiệm ở đây khôi phục ký tự dưới dạng Khóa và TriNet làm giá trị.

2500
00:01:26,130 --> 00:01:39,930
Vì vậy, chúng ta có cái này để chúng ta có ký tự này ở đây và điểm này trỏ đến nút này và ở đây nút này chứa B và ở đây chúng ta thấy giá trị của B đang trỏ đến nút này.

2501
00:01:40,560 --> 00:01:56,400
Và ở đây chúng ta thấy chúng ta có hai S.A.G. và developes là trỏ tới nốt này và develop này trỏ tới nốt này chứ không phải bằng nút này hay chỉ ra rằng từ đó vào nó C và từ đó vào đó là vì ở đây chúng ta có nó.

2502
00:01:56,400 --> 00:02:15,540
Đúng A. vị trí sai. Đây không phải là kết thúc của từ. Và ở đây chúng ta có nó và ở đây chúng ta có hai cái. Điều đó có nghĩa đó là nhân vật cuối cùng. OK, và đây là ký tự cuối cùng của từ B và G là từ cuối cùng vì chúng ta có ở đây.

2503
00:02:15,540 --> 00:02:26,400
ĐÚNG VẬY. Còn giá trị của cái này cho phím C và G thì ta có cái này thì không. Và những gì chúng ta có ở những đứa con hoang đàng để làm điều đó có nghĩa là chúng ta có một từ hoàn chỉnh trong đó.

2504
00:02:26,400 --> 00:02:38,990
CI a.. Và ở đây chúng ta có một từ hoàn chỉnh rằng thực sự đây là cách phân chia một cấu trúc được thể hiện một cách kém cỏi. Và đây chỉ là hình ảnh đại diện của thành Troy và đây là cách nó được thể hiện.

2505
00:02:39,150 --> 00:02:50,460
Những gì chúng tôi đã hiểu làm thế nào để viết nó. Một cấu trúc được trình bày ở đây, tất cả những điều quan trọng mà chúng ta đã học được trong phép nhân. Chúng tôi có điểm B, nhưng chúng tôi chỉ đang học một điểm.

2506
00:02:50,840 --> 00:03:09,860
Chúng ta có V và ở đây chúng ta chỉ lưu trữ một B, OK, vậy A, B, C là một từ, a b, G là một từ và l m
N là một từ. Điều chúng ta đã hiểu là sự giải thích, cho dù bạn hiểu nó thực sự là sự giải thích. 

@@@



2507
00:00:00,720 --> 00:00:11,380
Này các bạn quay lại với video này trong video này chúng ta sẽ thực hiện thao tác này, chèn phương thức này sẽ chèn chữ vào đó, đúng là một cấu trúc.

2508
00:00:11,400 --> 00:00:27,980
Bây giờ, hãy xem phương pháp này thực sự hoạt động như thế nào. Đây là mã nguồn. Phương thức này nhận tham số word bên trong đây, chúng ta đang tạo ra dòng điện trỏ trỏ đến nút gốc và sau đó chúng ta lặp lại từ đã cho từ trái sang phải.

2509
00:00:28,760 --> 00:00:44,720
Sau đó, chúng tôi sẽ nhận được ký tự hiện tại của bạn bằng cách sử dụng công thức này trong đó biểu đồ I và sau đó chúng tôi đang tạo một nút ba và chúng tôi hiện đang đến đây. Thử thách thiết lập nhân vật hiện tại của chúng tôi không tồn tại trong nút hiện tại của chúng tôi.

2510
00:00:45,140 --> 00:01:02,870
Sau đó nút này sẽ được đánh giá. Bây giờ, nếu nút đã nổ thì chúng tôi sẽ chèn ký tự hiện tại vào nút hiện tại và cũng sẽ chèn khóa TriNet mới làm ký tự và nút trung tính làm giá trị.

2511
00:01:03,200 --> 00:01:14,850
Và điều đó sẽ thay đổi. Hiện tại trỏ đến nút hiện tại và sau đó cũng ở cuối giai đoạn này, ký tự bộ quy tắc trong bảng trở thành đúng. Bây giờ hãy xem điều này thực sự hoạt động như thế nào.

2512
00:01:15,140 --> 00:01:27,410
Đừng lo lắng về điều đó nếu bạn không hiểu. Ban đầu chúng ta có nút gốc này và ở đây chúng ta đang gán dòng điện trỏ này tới nút tuyến đường này. Vì vậy, con trỏ hiện tại và gốc đang trỏ đến ghi chú này.

2513
00:01:27,410 --> 00:01:43,280
Và ở đây chúng tôi không có gì theo mặc định. Chúng ta có các giá trị mặc định trong Prodigals và chúng ta có Hashmat trống này, giả sử chúng ta gọi phương thức này bằng ABC trong chuỗi ABC này, ký tự hiện tại của chúng ta là a bây giờ chúng ta sẽ kiểm tra.

2514
00:01:43,280 --> 00:01:56,750
Nhân vật hiện tại có tồn tại trong này không? Hashmat, nếu chúng ta thấy nó không tồn tại trong này. Hashmat Vì vậy, đứa trẻ hiện tại sẽ nhận được nó ở Ridgen ngay bây giờ. Vì vậy, hiện tại đứa trẻ đó sẽ nhận được nó.

2515
00:01:56,780 --> 00:02:07,010
Nó sẽ được đánh giá ngay bây giờ. Vì vậy, chúng tôi thấy điều đó liên quan đến null. Bây giờ, chúng ta sẽ làm gì để tạo một nút mới và chèn ký tự và đơn vị vào?

2516
00:02:07,920 --> 00:02:21,030
Ngay ở đây nên chúng tôi đã chèn vào đây. Và khi chúng ta sắp chèn nút này, thì trong lần lặp tiếp theo, chúng ta có ký tự B này và ở đây theo mặc định, chúng ta có lỗi ở đây.

2517
00:02:21,030 --> 00:02:33,220
Chúng tôi có lỗi mặc định. Và điểm hiện tại của chúng ta tại mọi điểm đều hướng đến nút trống này. Bây giờ, ký tự hiện tại của chúng tôi là B và chúng tôi thấy B không tồn tại trong nút hiện tại này.

2518
00:02:33,510 --> 00:02:43,770
Vì vậy chúng ta sẽ chèn vào đây B và một nút mới. Vì vậy, hãy chèn nút mới và B mới vào đây, đại loại như thế này. Bây giờ, con trỏ hiện tại này đều trỏ đến nút trống này.

2519
00:02:44,220 --> 00:02:57,600
Bây giờ ký tự hiện tại của chúng tôi là C, C không tồn tại trong nút hiện tại của chúng tôi. Vì vậy, hãy nổi dậy và cả trong nút nữa, đại loại như thế này. Và ở đây chúng tôi có mặc định rất gần.

2520
00:02:57,780 --> 00:03:08,850
Bây giờ chúng ta hãy chuyển sang ghi chú này. Và trong lần lặp lại tiếp theo của sự suy giảm này, chúng ta đã vượt ra khỏi ranh giới chuỗi này. Vì vậy, chúng tôi sẽ thiết lập hiện tại và thiết lập hoặc hoàn nguyên.

2521
00:03:09,030 --> 00:03:26,450
Vì vậy, chúng tôi sẽ thay đổi toàn bộ quyết định mang tính cấu trúc này. Chúng ta có thể chèn một từ để thử cấu trúc. Bây giờ, nếu chúng ta gọi phương thức này bên trong bằng ABC, hãy chèn phương thức này vào hoặc thử cấu trúc nút hiện tại của chúng ta, điều này có ổn không?

2522
00:03:26,550 --> 00:03:38,090
Và đây là ghi chú gốc, như ý muốn. Bây giờ, ký tự hiện tại của chúng tôi là ký tự mà chúng tôi thấy đang tồn tại trong nút hiện tại của chúng tôi, vì vậy nó sẽ không làm gì cả. Hãy chuyển sang quyết định tiếp theo tiếp theo.

2523
00:03:38,100 --> 00:03:52,760
Không. Bây giờ hãy di chuyển hiện tại đến nút này. Chúng ta thấy rằng nhân vật hiện tại của chúng ta là những con ong tồn tại trong này. Không có gì mới để được thực hiện ở đây. Hãy chuyển sang nút này và mã hiện tại của chúng tôi là nó không tồn tại trong nút này.

2524
00:03:52,770 --> 00:04:08,690
Vì vậy, hãy chèn và một nút mới. Vì vậy, chúng tôi đã chèn vào đây và không phải cũng như dòng điện của chúng tôi và sẽ di chuyển dòng điện của chúng tôi đến nút này. Sau đó, ở thế hệ tiếp theo của bức tường nước chảy ra từ dòng suối này, tất cả các ranh giới đều được thiết lập theo lịch trình trong cấu trúc của Oracle.

2525
00:04:08,700 --> 00:04:22,010
Vì vậy, nó sẽ thay đổi bức tường này thành điều này có nghĩa là chúng ta phải làm việc ABC và ABC. Đó là tất cả những gì chúng tôi có ở đây. Hai từ, ABC và ABC. Hai từ này là những từ hoàn chỉnh mà chúng ta có trong việc tạo ra một cấu trúc.

2526
00:04:22,620 --> 00:04:36,870
Bây giờ, hãy gọi phương thức này bằng in và ghi chú hiện tại của bạn. Chúng tôi thấy ý chí nhân vật hiện tại của chúng tôi không tồn tại trong Rubner của chúng tôi. Vì vậy, hãy chèn ở đây L và cũng như trẻ sơ sinh và hãy chuyển hiện tại sang ghi chú này.

2527
00:04:37,410 --> 00:04:52,380
Và ký tự hiện tại của chúng tôi là m không tồn tại trong nút hiện tại của chúng tôi. Vì vậy, hãy chèn M vào đây và như một nút mới, đại loại như thế này, sau đó ký tự tiếp theo của chúng ta sẽ xuất hiện và để tôi đến nút này và ký tự hiện tại của chúng ở đây.

2528
00:04:52,380 --> 00:05:06,360
Ở đây là phần cuối không tồn tại trong ghi chú này. Vì vậy, hãy thêm vào đây và dưới dạng một nút mới, đại loại như thế này, hãy chuyển sang phần tiếp theo và sau đó trong lần lặp tiếp theo của phần tuyệt vời này của ranh giới màn hình này.

2529
00:05:06,520 --> 00:05:19,170
Vì vậy, hãy thay đổi mùa thu này thành tuyên bố này. Vì vậy, chúng tôi đã chèn âm thanh này vào đây và đây là một quyết định đúng đắn, làm thế nào chúng tôi có thể chèn từ vào cấu trúc.

2530
00:05:19,170 --> 00:05:33,090
Và đây là cách thao tác chèn hoạt động. Chúng ta đã hiểu các thao tác chèn. Hoạt động này sẽ có độ phức tạp về thời gian. Và thao tác này cũng có độ phức tạp về không gian trong đó nó là độ dài của chuỗi đã cho.

2531
00:05:33,450 --> 00:05:41,190
Chúng tôi đã hiểu lời giải thích thực sự này. Nếu tôi gặp khó khăn khi hiểu lời giải thích
này, hãy cho chúng tôi biết. Cảm ơn đã xem. Tôi sẽ gặp bạn trong video tiếp theo. 

@@@



2532
00:00:01,010 --> 00:00:11,780
Này các bạn, chào mừng các bạn quay trở lại với video này trong video này. Chúng ta sẽ thực hiện cấu hình sẵn phương thức này. Phương thức này lấy một tham số. Phương pháp này sẽ trở lại.

2533
00:00:11,790 --> 00:00:22,970
Đúng, nếu tiền tố tồn tại trong cấu trúc dữ liệu đó, nếu không nó sẽ trả về sai. Bây giờ, hãy xem cách chúng ta có thể triển khai tiền tố phương thức này để dễ hiểu.

2534
00:00:22,970 --> 00:00:35,420
Giả sử chúng ta được cung cấp cấu trúc đã thử này. Đây là thuật toán của chúng tôi. Phương thức này lấy tiền tố tham số bên trong, chúng ta đang tạo một dòng con trỏ sẽ trỏ đến thư mục gốc.

2535
00:00:35,420 --> 00:00:52,180
Không chạy nó trong khoảng thời gian từ 0 đến độ dài của một tiền tố nhất định bên trong đây hoặc lấy ký tự hiện tại từ tiền tố. Và sau đó chúng tôi đang kiểm tra xem ký tự hiện tại có tồn tại trong nút hiện tại của chúng tôi hay không.

2536
00:00:52,490 --> 00:01:18,200
Nếu nút này được đánh giá là null, điều đó có nghĩa là ký tự hiện tại không tồn tại trong cấu trúc tiêu chí của chúng tôi. Vì vậy, nó sẽ trả về sai. Nếu ký tự hiện tại được tìm thấy trong một cấu trúc thì chúng ta sẽ di chuyển con trỏ hiện tại đến nút đó nếu chúng ta đến cuối tiền tố và nếu chúng ta thấy điều kiện này thì chúng có liên quan đến sẽ chỉ chạy qua.

2537
00:01:18,950 --> 00:01:31,760
Điều đó có nghĩa là tiền tố của chúng tôi tồn tại nếu câu lệnh bằng văn bản này được thực thi. Bây giờ hãy xem nó hoạt động như thế nào. Giả sử chúng ta gọi tiền tố phương thức này bằng chữ B trước.

2538
00:01:31,760 --> 00:02:04,460
Con trỏ hiện tại của chúng tôi sẽ trỏ đến nút gốc này và ký tự hiện tại của chúng tôi là A mà chúng tôi thấy nó chỉ có trong nút này. Vì vậy, không, bây giờ nó không được đánh giá. Chúng ta sẽ di chuyển dòng điện đến nút, thông báo NOROC này, nên nó sẽ di chuyển con trỏ hiện tại của chúng ta đến nút này ngay tại đây trong lần lặp tiếp theo với ký tự B, chúng ta thấy ký tự BES tồn tại trong nút này, điều này không trỏ gì cả trỏ đến nút này và chúng tôi thấy ghi chú đó không phải là rỗng.

2539
00:02:05,520 --> 00:02:16,550
Vì vậy, chúng tôi sẽ di chuyển dòng điện đến Northpoint, cũng như tất cả dòng điện ở ngay đây và trong lần lặp tiếp theo, chúng tôi đã vượt ra khỏi ranh giới hơi nước, vì vậy chúng tôi đã hoàn thành.

2540
00:02:16,830 --> 00:02:29,610
Chúng ta thấy rằng chuỗi, Evvy, có nghĩa là tiền tố Avey, bạn biết đấy, tôi đã thử nó một cấu trúc. Vì vậy, chúng ta sẽ trả về nó để xem liệu chúng ta có gọi hàm này là cấu hình sẵn hay không.

2541
00:02:29,880 --> 00:02:42,090
Nó sẽ đơn giản trở lại. ĐÚNG VẬY. Nếu chúng ta gọi phương thức này bằng Elim, hãy xem nó hoạt động như thế nào. Ban đầu, con trỏ hiện tại sẽ trỏ đến nút này và ký tự hiện tại của chúng ta bị lỗi.

2542
00:02:42,750 --> 00:02:52,920
Và ở đây con trỏ nút này đều trỏ đến nút này. Vì người tạo hiện tại tồn tại trong nút này nên chúng tôi sẽ di chuyển. Hiện tại trỏ tới đây, không phải nút, pointillist trỏ tới.

2543
00:02:53,290 --> 00:03:10,140
Vì vậy chúng ta hãy di chuyển ở đây và ở đây. Chúng tôi sẽ kiểm tra xem ký tự hiện tại có tồn tại hay không. Chúng ta nhìn thấy và tồn tại. Vì vậy, điểm nút ở ngay đây và ở thế hệ tiếp theo sẽ di chuyển dòng điện đến điểm này, không phải ở lần lặp tiếp theo hoặc ra khỏi ranh giới luồng.

2544
00:03:10,440 --> 00:03:36,440
Vì vậy, chúng tôi đã làm điều này trong kết nối không bao giờ là một lỗi liên quan. Đây là. Vì vậy, chúng ta sẽ trả về true cho câu chuyện này và chúng ta thấy rõ rằng tiền tố Ilim tồn tại trong Stryder, cấu trúc của nếu hiểu được phương pháp này thực sự hoạt động như thế nào thì phương pháp này sẽ thành công theo thời gian, độ phức tạp và độ phức tạp không gian không đổi của việc hiểu điều này rất giải thích.

2545
00:03:36,450 --> 00:03:45,450
Nếu chúng ta không hiểu Alali neo ở đây để cố gắng viết ra mọi thứ trên một tờ giấy
và thử nó với các ví dụ khác nhau, thì bạn sẽ thấy nó hoạt động như thế nào. 

@@@



2546
00:00:00,730 --> 00:00:15,310
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng ta sẽ triển khai phương thức này sers. Phương thức này lấy một từ làm đầu vào, phương thức này đã được đưa vào nếu từ đó tồn tại trong cấu trúc dữ liệu thử nghiệm.

2547
00:00:16,000 --> 00:00:25,780
Nếu không nó sẽ trả về thư sai. Chúng ta có thể triển khai phương thức này để hiểu rõ hơn. Giả sử erguven phá hủy cấu trúc nơi chúng ta có ba từ này.

2548
00:00:26,110 --> 00:00:40,780
AVC xem, loại bỏ nguồn phương thức. Chúng tôi sẽ kiểm tra một từ hoàn chỉnh. Chúng tôi không kiểm tra tiền tố, nó sẽ kiểm tra từ hoàn chỉnh. Nếu từ hoàn chỉnh chỉ có trong cấu trúc dữ liệu thử nghiệm thì nó mới trả về true.

2549
00:00:40,990 --> 00:00:53,830
Nếu không nó sẽ trả về sai. Và giả sử thuật toán ở dạng mã giả. Đây là thuật toán của bạn so với phương pháp. Phương thức này lấy tham số Word trong bài nói chuyện Chủ nhật, khai báo một con trỏ hiện tại đến điểm mà nó không thể thực hiện được.

2550
00:00:54,070 --> 00:01:10,960
Và sau đó chúng ta sắp hết AI từ 0 đến độ dài của từ nhất định. Sau đó, chúng tôi đang kiểm tra xem hiện tại hay nó chỉ nằm trong nút hiện tại của chúng tôi, sau đó con trỏ nút này sẽ trỏ đến TriNet được liên kết cho ký tự hiện tại của chúng tôi.

2551
00:01:11,350 --> 00:01:35,440
Nếu không được đánh giá ngay bây giờ thì sẽ trả về sai. Nếu không thì tất cả sẽ chuyển động. Dòng điện trỏ đến nút con trỏ khi chúng tôi hoàn thành bức tường dầu này, hãy kiểm tra xem giá trị đó trong nút hiện tại của bạn có không, khi bạn hoàn thành việc này, Frolov sẽ kiểm tra phía trên nút hiện tại của chúng tôi mà chúng tôi đã tìm thấy trong các phần thân để quay lại nếu trong tất cả các lỗi của nó, các mặc định duy nhất.

2552
00:01:36,130 --> 00:01:59,620
Hãy xem phương pháp này hoạt động như thế nào. Điều đó có nghĩa là chúng ta gọi nguồn hàm này bằng V đầu tiên hoặc is và nút hiện tại là nút gốc này. Và chúng ta thấy ở đây đặc tính này chỉ là con trỏ nút sẽ trỏ đến nút này chứ không phải số lượng không phải là null, sau đó nó sẽ di chuyển dòng điện đến nút này nơi con trỏ nút trỏ tới.

2553
00:02:00,190 --> 00:02:17,860
Sau đó, trong lần lặp tiếp theo, nhân vật của chúng ta là B và các công thức nấu ăn tồn tại trong nút này. Vì vậy, con trỏ nút sẽ trỏ đến nút này và tín hiệu không rỗng. Vì vậy, nó sẽ di chuyển dòng điện đến nút này, con trỏ của cô ấy hoặc nút mà nó trỏ tới.

2554
00:02:18,150 --> 00:02:28,060
Và trong lần lặp tiếp theo, chúng ta đã hoàn thành từ này. Sau đó, những gì sẽ làm sẽ trả về giá trị trong cổng cho nút hiện tại của chúng tôi và chúng tôi nói rằng đó là sai.

2555
00:02:28,070 --> 00:02:43,240
Vì vậy, chúng tôi sẽ trả về false cho việc này. OK, vậy từ này không tồn tại trong cấu trúc dữ liệu tri này vì nó là tiền tố của phương pháp tìm kiếm ABC sẽ so sánh để tìm từ hoàn chỉnh.

2556
00:02:43,810 --> 00:02:55,510
Đó là tất cả những gì nó được viết sai. Bây giờ hãy gọi phương thức này bằng ABC. Hãy xem nó hoạt động như thế nào. Ký tự hiện tại là a và con trỏ hiện tại trỏ đến nút này và chúng ta thấy ký tự này.

2557
00:02:55,540 --> 00:03:10,900
Có phải nó chỉ ở nút này? Vì vậy, tất cả nút được chỉ định đều trỏ đến nút này vì nút này là nút được liên kết cho danh mục này. Chúng ta thấy rằng bây giờ không phải như vậy nên nó sẽ chuyển dòng điện đến nút này trong lần lặp tiếp theo.

2558
00:03:11,680 --> 00:03:26,320
Chúng tôi sẽ di chuyển nút được trỏ đến ghi chú này và chúng tôi thấy không có lý do gì bây giờ không di chuyển con trỏ hiện tại đến nút này. Trăm điểm đáp ứng thì ở thế hệ tiếp theo sẽ di chuyển hoặc không trỏ tới nút.

2559
00:03:26,830 --> 00:03:39,310
Chúng tôi đã nói không, không phải bây giờ. Vì vậy, nó sẽ di chuyển dòng điện đến nút này và sẽ trả về giá trị. Chúng ta thấy rằng thứ tự này chỉ có trong cấu trúc trước đó.

2560
00:03:39,520 --> 00:03:52,890
Vì vậy, đơn hàng này sẽ quay trở lại. Đúng, tôi đã hiểu phương pháp này thực sự hoạt động như thế nào. Bây giờ chúng ta hãy xem thêm một lệnh gọi hàm nữa nếu chúng ta gọi bằng Ilim và hãy xem nó hoạt động như thế nào và nó sẽ trả về kết quả gì.

2561
00:03:53,200 --> 00:04:05,260
Nhân vật hiện tại của chúng tôi không phù hợp với việc phản hồi nút này và chúng tôi cảm thấy rằng đó chỉ là nút chỉ vào ghi chú này. Ghi chú này không phải là bây giờ. Vì vậy chúng ta sẽ di chuyển dòng điện đến nút này.

2562
00:04:06,290 --> 00:04:28,570
Và chúng ta thấy ký tự tiếp theo tồn tại trong nút này, không phải tất cả đều trỏ đến nút này, không có giá trị rỗng đối với tất cả dòng điện đến nút này. Ở thế hệ tiếp theo, nhân vật của chúng ta không quan tâm đến điều này nên chúng ta sẽ di chuyển và chuyển đến điều này không và không phải tất cả những người hiện tại đều biết đến ghi chú này.

2563
00:04:29,110 --> 00:04:46,350
Và trong việc đọc, bất kể giá trị nào chúng ta có đối với thế giới, điều đó đều đúng. Vì vậy, đối với chức năng này, chúng tôi quay trở lại. Đây là cách phương pháp này hoạt động. Đã hiểu cách thức hoạt động thực sự của phương pháp này, phương pháp này thực hiện vì độ phức tạp về thời gian và độ phức tạp lớn hơn của một không gian.

2564
00:04:47,170 --> 00:04:54,220
Chúng tôi đã hiểu chính lời giải thích này, nếu bạn gặp khó khăn trong việc hiểu lời giải
thích nhanh chóng này mới nhất. Cảm ơn đã xem. Tôi sẽ gặp bạn trong một video khác. 

@@@



2565
00:00:00,720 --> 00:00:11,880
Đây nhé, hai bạn sẽ quay lại với video này. Chúng ta sẽ triển khai phương thức này cho đến khi phương thức này lấy một từ làm đầu vào. Nếu từ đó tồn tại trong đó thì đúng.

2566
00:00:11,880 --> 00:00:29,940
Đó là cấu trúc thì phương thức này sẽ loại bỏ từ đó khỏi cấu trúc dữ liệu cây. Nếu từ này là tiền tố của một từ khác thì sẽ chỉ thay đổi ký tự cuối cùng trong từ từ đúng thành sai.

2567
00:00:30,450 --> 00:00:42,940
Hãy xem làm thế nào chúng ta có thể làm điều đó. Bây giờ hãy xem cách chúng ta có thể triển khai phương pháp này để dễ hiểu. Giả sử chúng ta được thử nghiệm câu này trong một cấu trúc trong đó chúng ta có ba từ ABC, ABC và bị loại.

2568
00:00:42,940 --> 00:01:01,110
Và đây là sự thể hiện của một cấu trúc bị chia cắt. Hoặc chúng ta có ba từ này. Đây là thuật toán của chúng tôi. Phương thức xóa này nhận tham số Word bên trong đây hoặc kiểm tra xem từ đó có phải là H-E hay không, chúng tôi đã thử nó theo cấu trúc bằng cách gọi phương thức nguồn trong vùng phương thức tìm kiếm hai.

2569
00:01:01,110 --> 00:01:09,210
Điều đó có nghĩa là từ. Có phải chỉ bạn biết không, tôi đã thử nó một cấu trúc. Sau đó tôi sẽ gọi phương thức này xử lý từ gốc và lập chỉ mục cho ký tự đầu tiên.

2570
00:01:09,540 --> 00:01:26,300
Phương thức này, phương thức này có ba tham số. Hiện tại là mã hiện tại của bạn, sau đó là từ, sau đó là chỉ mục của ký tự hiện tại của chúng tôi ở đây đang kiểm tra xem nút độc lập với nút hiện tại của chúng tôi có sai hay không, sau đó sẽ trả về sai.

2571
00:01:26,670 --> 00:01:52,580
Nếu không, chúng ta sẽ nói phần cuối của từ là sai và chúng ta sẽ trả lại nó. Đúng, nếu trang web của nút hiện tại của chúng tôi bằng 0, điều đó có nghĩa là nếu chúng tôi không có phần tử nào trong nút hiện tại, thì chúng tôi đang đặt giá trị này trong Word thành false vì từ đã cho có thể là tiền tố của một từ khác mà chúng tôi đang đặt giá trị của trong từ của nút hiện tại của chúng tôi thành sai.

2572
00:01:53,130 --> 00:02:05,730
Đây là căn cứ của chúng tôi. Không sao đâu. Đây là từ hiện tại của bạn. Và ở đây bạn đang kiểm tra xem từ hiện tại có nằm trong nút hiện tại của chúng ta hay không, sau đó nút này sẽ quay lại thử nút.

2573
00:02:06,030 --> 00:02:18,060
Nếu nút quay trở lại bây giờ thì sẽ chỉ trả về sai ở đây. Chúng tôi đang gọi hàm này là xóa đệ quy với nút hiện tại, với từ và với ký tự tiếp theo của chúng tôi.

2574
00:02:18,570 --> 00:02:37,590
Và nếu chúng tôi thấy cần xóa dấu chấm hiện tại bằng hai thì chúng tôi sẽ xóa ký tự khỏi nút hiện tại và sẽ quay lại nếu từ hiện tại CitiPower bằng 0 và cuối cùng ở đây sẽ trả về sai và điều này sẽ được thực hiện đệ quy.

2575
00:02:38,130 --> 00:02:50,520
Điều này sẽ có một chút quan trọng. Bây giờ hãy xem điều này thực sự hoạt động như thế nào. Nếu chúng ta gọi phương thức này là xóa bằng Ilim và trong đó chúng ta gọi phương thức này là El-Amine.

2576
00:02:50,910 --> 00:03:02,700
Đầu tiên, nó kiểm tra xem phần tử có tồn tại hay không hoặc cố gắng tái cấu trúc với tư cách là người có thẩm quyền sẽ thực hiện điều đó bằng cách sử dụng phương thức nguồn này và chúng tôi thấy rằng phần tử này tồn tại trong cấu trúc đã thử của chúng tôi.

2577
00:03:02,700 --> 00:03:18,780
Vì thế nó sẽ quay trở lại. ĐÚNG VẬY. Sau đó chúng ta sẽ gọi phương thức xóa này bằng ký tự đầu tiên. Nhân vật đầu tiên năm nay là L. Chỉ số bánh quy ban đầu không bằng Waterland và nhân vật hiện tại bị ốm và chúng ta thấy Elisi tồn tại trong ghi chú gốc của chúng ta.

2578
00:03:18,930 --> 00:03:39,450
Đây là nút hiện tại của bạn và chúng tôi thấy rằng nhân vật hiện tại Eliz tồn tại trong nút hiện tại của chúng tôi. Vì vậy nút này sẽ không trả về giá trị rỗng. Sau đó, chúng ta lại gọi hàm này một cách đệ quy bằng nút và con trỏ nút sẽ trỏ đến nút này bằng câu lệnh này và sau đó chúng ta sẽ gọi nút này bằng chỉ mục.

2579
00:03:39,450 --> 00:03:50,520
Lên nhân vật tiếp theo. Điều đó có nghĩa là ký tự M trong lệnh gọi hàm đệ quy tiếp theo. Đây là nút hiện tại của chúng tôi. Vì vậy, đây là nút hiện tại của chúng tôi cho lệnh gọi hàm đệ quy tiếp theo.

2580
00:03:51,330 --> 00:04:06,450
Và đó chính là hình ảnh nhân vật hiện tại của bạn hoặc nhân vật hiện tại. Và hình ảnh có tồn tại trong này không nên con trỏ nút sẽ trỏ đến nút này và sẽ gọi đệ quy với nút này.

2581
00:04:06,840 --> 00:04:21,540
Vì vậy con trỏ hiện tại sẽ trỏ tới nút này và ký tự hiện tại của chúng ta ở trong và chúng ta nhìn vào. Có phải chỉ là ở điểm nút này không phải vậy không, nó sẽ di chuyển đến nút này, nên không trỏ gì cả.

2582
00:04:21,660 --> 00:04:34,140
Di chuyển tới chúng ta thấy ký tự hiện tại nằm trong nút này. Vì vậy chúng ta sẽ gán nút trỏ tới nút này. Chúng tôi thấy nút không rỗng nên sẽ gọi lại theo cách đệ quy.

2583
00:04:34,350 --> 00:04:49,320
Vì vậy, con trỏ hiện tại và nút sẽ trỏ đến cùng một nút. Bây giờ nếu chúng ta gọi lệnh gọi đệ quy này, chỉ mục là một cây và độ dài của cây này hoặc cây này bây giờ cũng sẽ như vậy.

2584
00:04:49,350 --> 00:04:57,960
Chúng tôi sẽ kiểm tra điểm cuối của nút này. Đó là sự thật. Vì vậy nó sẽ được đánh giá là sai. Sau đó, chúng tôi sẽ quyết định đặt cài đặt này làm mặc định.

2585
00:04:58,890 --> 00:05:16,800
Vì vậy chúng tôi sẽ nói. Đúng thành sai, và chúng ta sẽ quay trở lại trang web của Noticiero này và Ejiro kia, vì vậy nó sẽ quay trở lại điểm hiện tại tại tất cả các điểm không phải này và không phải tất cả đều trỏ đến điểm này, không phải cho hàm đệ quy trước đó.

2586
00:05:16,800 --> 00:05:29,220
Gọi hàm đệ quy này. Yêu cầu điều này không phải tất cả đều được viết vì nó được viết thông qua câu lệnh bằng văn bản này, chúng tôi sẽ xóa ký tự hiện tại có trong đó.

2587
00:05:29,670 --> 00:05:39,840
Chúng tôi sẽ xóa ký tự hiện tại này khỏi ghi chú này. Vì vậy, chúng tôi sẽ xóa nó khỏi ghi chú này và ghi chú này cũng sẽ bị xóa vì không có tham chiếu.

2588
00:05:39,990 --> 00:05:50,490
Vì vậy, chúng tôi đã loại bỏ chìa khóa. Chúng tôi đã loại bỏ chìa khóa đó. Vì vậy, giá trị cũng sẽ bị loại bỏ. Khi đó con trỏ hiện tại của chúng ta sẽ trỏ đến nút này và không trỏ gì cả.

2589
00:05:50,490 --> 00:06:05,190
Trỏ vào ghi chú này, sau đó con trỏ hiện tại sẽ trỏ đến ghi chú này chứ không trỏ gì cả. Các điểm tới nút này sẽ quay trở lại cuộc gọi đệ quy trước đó. Nếu trang web của nút hiện tại của chúng tôi bằng 0, thì nó sẽ trả về true cho hàm trước đó.

2590
00:06:05,190 --> 00:06:15,500
Gọi lại giá trị này là không hợp lệ đúng cho lệnh gọi hàm đệ quy trước đó trong trường hợp này hoặc chúng ta sẽ loại bỏ tiêu chí hiện tại của mình.

2591
00:06:16,110 --> 00:06:26,370
Vì vậy, alderwoman, ký tự này từ nút này, nên nút này cũng sẽ bị xóa, vì bạn đã xóa khóa và sẽ quay lại hàm đệ quy trước đó.

2592
00:06:26,370 --> 00:06:41,270
Gọi nó là nút hiện tại của nhà phát triển. Nếu ghi chú hiện tại của CitiPower bằng 0, chúng ta sẽ thấy thanh bên chứ không phải Ejiro. Vì vậy can trỏ sẽ trỏ tới nút này và không sẽ trỏ đến nút này trong hàm đệ quy trước đó gọi là Allegiant để sử dụng câu lệnh này.

2593
00:06:41,580 --> 00:06:55,800
Vậy câu nói này vẫn đúng. Vì vậy, những gì tôi sẽ làm, nó sẽ loại bỏ nó khỏi nút này và chúng tôi sẽ chuyển nút sang NOROC này từ đây. Chúng tôi sẽ xóa nhân vật hiện tại bị bệnh khỏi ghi chú này.

2594
00:06:56,250 --> 00:07:05,270
Vì vậy, ghi chú này cũng sẽ bị xóa vì bạn sắp xóa khóa và sau đó chúng tôi sẽ trả về false vì nút thanh bên khác 0.

2595
00:07:05,640 --> 00:07:22,110
Bây giờ chúng ta đã hoàn tất. Vì vậy, chúng tôi đã xóa Ilim trong một từ khỏi thử nó một quyết định cấu trúc. Chúng ta có thể xóa một từ, có thể gọi phương thức xóa này là ABC và chúng ta thấy rằng từ ABC đó, nó chỉ là tái cấu trúc ngành và ABC là một từ hoàn chỉnh.

2596
00:07:22,320 --> 00:07:36,900
Vì vậy, chúng ta sẽ gọi nó là nút gốc và với từ và chỉ mục, với bộ thu thập dữ liệu hiện tại, trường hợp cơ sở người dùng. Và chúng ta thấy đặc điểm hiện tại của chúng ta chỉ vì vậy nó sẽ di chuyển nút này sang nút này.

2597
00:07:37,260 --> 00:07:53,020
Và ở đây chúng tôi thấy không có lý do gì chỉ ra một Knowland. Vì vậy, nó không phải là đệ quy. Vì vậy, con trỏ hiện tại sẽ trỏ đến nút này và không phải tất cả đều trỏ đến nút này, vì nút không trỏ đến lệnh gọi đệ quy với cụ thể.

2598
00:07:53,520 --> 00:08:04,170
Bây giờ B là nhân vật hiện tại của chúng ta. Bây giờ trong hàm đệ quy tiếp theo, hãy xem xét trình kết nối hiện tại. Vì vậy Current sẽ di chuyển đến nút này và sẽ di chuyển đến nút này.

2599
00:08:04,890 --> 00:08:17,250
Sau đó chúng ta sẽ gọi đệ quy với ghi chú này. Chúng tôi gọi đó là điểm quy tắc cho ghi chú này. Trong thuật ngữ này, khám nghiệm tử thi ranh giới. Bên của sợi dây là một cái cây và chỉ số là ba Azrael.

2600
00:08:17,790 --> 00:08:32,090
Vì vậy, nó là khối lượng. Trường hợp cơ bản ở đây là chỉ số bằng với vùng nước và chúng ta thấy tripto. Vì vậy, nó sẽ không trả về sai. Và chúng ta sẽ xem xét điều này thông qua sai lầm và chúng ta thấy khía cạnh của toàn bộ khu vực kiến ​​​​thức này thông qua lệnh gọi hàm đệ quy này.

2601
00:08:32,580 --> 00:08:44,790
Vì vậy, hiện tại sẽ trỏ đến nút trước đó và chúng ta thấy rằng câu lệnh này đã được đánh giá. ĐÚNG VẬY. Vì vậy, những gì chúng ta sẽ làm, nó sẽ loại bỏ ký tự hiện tại lớn hơn hiện tại của chúng ta hoặc sẽ loại bỏ khỏi cấu trúc được cung cấp này.

2602
00:08:44,980 --> 00:08:56,580
Vì vậy, hãy xem, vì bạn đã xóa khóa nên valot sẽ bị xóa nút này của Valli và count sẽ chuyển sang nút này chứ không phải cho lệnh gọi đệ quy trước đó.

2603
00:08:57,210 --> 00:09:06,570
Và trang web không phải là không có nội dung hiện tại này, vì vậy nó sẽ củng cố tuyên bố sai sẽ bị đánh giá là lỗi. Vì vậy, nó sẽ chỉ trở lại bằng câu lệnh.

2604
00:09:07,200 --> 00:09:19,680
Vì vậy, Kind đang trỏ đến ghi chú này và phản hồi nút này và chúng ta thấy rằng ký tự hiện tại của chúng ta là B cho lệnh gọi đệ quy trước đó. Chúng tôi có một trạng thái cho mỗi lệnh gọi hàm đệ quy.

2605
00:09:19,680 --> 00:09:32,580
Chúng tôi quyết định có thể truy cập điểm hiện tại của mình vì nó được hàm này trả về sai. Gọi lại sẽ trả về sai. Vì vậy, loại sẽ trỏ đến nút này chứ không phải điểm nút cho nút này.

2606
00:09:32,850 --> 00:09:43,890
Ở đây không có gì phải làm vì bạn nhận được chữ B là tiền tố của từ ABC này. Vì vậy, chúng tôi không thể xóa ký tự hiện tại. Và ở đây chúng ta thấy cạnh của tờ tiền này không bằng 0.

2607
00:09:43,890 --> 00:09:55,830
Vậy là đã sai rồi. Đây lại là một lần nữa nó sẽ mặc định cho hàm đệ quy trước đó. Gọi bitrate và false và nói rằng con trỏ hiện tại của chúng ta đang trỏ đến ghi chú gốc và trả về.

2608
00:09:56,130 --> 00:10:09,950
Chúng tôi đã xóa từ ABC, v.v.. Chúng tôi có thể. Một chút từ việc cố gắng cấu trúc thư trực tiếp sẽ có độ phức tạp lớn
về thời gian và độ phức tạp lớn về không gian với đệ quy có tên Stack, chúng tôi đã hiểu chính lời giải thích này. 

@@@



2609
00:00:00,390 --> 00:00:11,970
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về thuật toán tìm kiếm linnear. Thuật toán của Linus là tìm một phần tử trong iList.

2610
00:00:12,690 --> 00:00:32,510
Nó tuần tự kiểm tra thành phần của danh sách cho đến khi tìm thấy khối lượng lớn hoặc toàn bộ danh sách đã được tìm kiếm. Ví dụ: nếu bạn được cung cấp danh sách số nguyên này thì đây là vùng đại diện cho một phần tử trong vùng này.

2611
00:00:32,670 --> 00:00:52,830
Giả sử chúng ta muốn tìm kiếm phần tử cho DeBois. Nếu chúng ta sử dụng thuật toán tìm kiếm tuyến tính để giải phần tử này trong khu vực này thì chúng ta phải kiểm tra phần tử từ trái sang phải một cách tuần tự, từng phần một, đầu tiên đến một, rồi ba, rồi tám, rồi bảy, rồi chín.

2612
00:00:53,130 --> 00:01:13,380
Sau đó chúng ta sẽ có thời gian nguyên tố mong muốn. Độ phức tạp của thuật toán tìm kiếm tuyến tính là rất lớn và độ phức tạp về không gian cũng lớn hơn. Vì vậy, thuật toán tìm kiếm tuyến tính hoạt động với độ phức tạp thời gian tuyến tính và độ phức tạp không gian không đổi.

2613
00:01:13,980 --> 00:01:27,000
Bây giờ giả sử chúng ta được cung cấp mảng này và chúng ta có mục tiêu bằng bốn. Chúng ta phải tìm ra phần tử thứ tư trong lĩnh vực này bằng thuật toán tuyến tính. Nếu chúng ta áp dụng ở đây, thuật toán tìm kiếm tuyến tính.

2614
00:01:27,210 --> 00:01:37,260
Trước tiên, chúng tôi sẽ kiểm tra giá trị mục tiêu với phần tử đầu tiên mà chúng tôi thấy không gần bằng hai. Vì vậy chúng ta hãy đi tới phần tiếp theo. Chúng ta thấy một là không đến bốn.

2615
00:01:37,560 --> 00:01:45,600
Bây giờ chúng ta hãy đi đến phần tử tiếp theo. Ba sẽ lên tới bốn. Hãy đi đến phần tử tiếp theo. Bốn là liên quan đến tám. Bây giờ chúng ta hãy đi đến phần tử tiếp theo.

2616
00:01:45,600 --> 00:02:02,040
Vì vậy, nó sẽ đi đến bốn. Bây giờ chúng ta hãy đi đến phần tử tiếp theo. Bốn không bằng chín. Sau đó chúng ta chuyển sang phần tử tiếp theo vì bằng 4. Vì vậy, chúng tôi tìm ra phần tử mong muốn của mình ở chỉ số sáu.

2617
00:02:02,400 --> 00:02:13,860
Và đây là một thuật toán tìm kiếm tuyến tính. Nó hoạt động kiểm tra tuần tự từ trái sang phải, từng cái một, đầu tiên là hai, sau đó là một, rồi ba, rồi tám và bảy.

2618
00:02:14,160 --> 00:02:30,150
Chín, rồi bốn. Và thuật toán tìm kiếm tuyến tính hoạt động đối với lỗi được sắp xếp và chưa sắp xếp. Bây giờ hãy xem mã giả cho thuật toán tìm kiếm tuyến tính. Đây là mã giả của chúng tôi cho thuật toán tìm kiếm tuyến tính.

2619
00:02:30,960 --> 00:02:42,390
Phương thức này lấy hai mảng tham số và phần tử đích. Ở đây chúng ta có một vòng lặp cho I từ 0 đến độ dài của mảng ở đây theo mũi tên từ trái sang phải.

2620
00:02:42,840 --> 00:02:56,400
Và ở đây chúng tôi đang kiểm tra xem phần tử hiện tại có bằng mục tiêu trong tất cả các vùng hay không. Chỉ số của phần tử hiện tại. Nếu phần tử đích không tồn tại trong mảng thì sẽ trả về trừ một.

2621
00:02:57,000 --> 00:03:11,100
Nếu chúng ta được cung cấp diện tích này và mục tiêu bằng sáu, thì nếu áp dụng thuật toán này trước tiên, chúng ta sẽ kiểm tra xem sáu trên hai không bằng sáu, sau đó sáu và một trên không bằng sáu.

2622
00:03:11,280 --> 00:03:24,930
Rồi ba và sáu, ba đến sáu, rồi tám. Tám sẽ chuyển sang sáu. Vì vậy, nó sẽ đi đến sáu, chín, sáu. Bốn là liên quan đến sáu. Vì vậy, cuối cùng chúng ta tìm thấy nó 666 sáu ở chỉ số bảy.

2623
00:03:25,770 --> 00:03:39,690
Đây là cách thuật toán tìm kiếm tuyến tính này hoạt động. Thuật toán này mất thời gian tuyến tính, độ phức tạp và độ phức tạp Spetz không đổi. Đây là thuật toán siêu đơn giản trong thuật toán này.

2624
00:03:39,960 --> 00:03:52,190
Chúng ta phải quét khu vực nhất định từ trái sang phải. Chúng tôi đã hiểu lời giải thích này nếu bạn có bất kỳ câu
hỏi nào. Nhưng nếu bạn gặp khó khăn trong việc hiểu điều này cùng với lời giải thích, hãy cho chúng tôi biết. 

@@@



2625
00:00:00,780 --> 00:00:16,430
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng ta sẽ nói về thuật toán của Britney Dessert. Tài nguyên là một thuật toán hiệu quả để tìm một phần tử từ danh sách các mục được sắp xếp.

2626
00:00:17,080 --> 00:00:32,860
Nó hoạt động bằng cách chia đôi liên tục phần danh sách có thể chứa mục đó cho đến khi chúng tôi thu hẹp được vị trí có thể. Đây là định nghĩa chính thức của thuật toán nguồn nhị phân.

2627
00:00:33,400 --> 00:00:50,350
Ví dụ: nếu bạn được cung cấp mảng này và bạn phải tìm ra một phần tử trong khu vực này bằng thuật toán nguồn nhị phân, thuật toán tìm kiếm nhị phân hoạt động với độ phức tạp thời gian logarit và độ phức tạp không gian không đổi.

2628
00:00:50,530 --> 00:01:06,430
Thuật toán tìm kiếm nhị phân hoạt động với độ phức tạp thời gian logarit và độ phức tạp không gian không đổi. Bây giờ hãy xem thuật toán tìm kiếm nhị phân hoạt động như thế nào. Giả sử bạn được cung cấp mảng này và mục tiêu giá trị mục tiêu của bạn bằng bảy.

2629
00:01:06,820 --> 00:01:17,950
Đầu tiên, bạn sẽ làm gì? Chúng ta sẽ khai báo hai con trỏ trái và phải. Con trỏ bên trái sẽ trỏ tới phần tử đầu tiên, điểm bên phải. Nó sẽ trỏ đến phần tử cuối cùng.

2630
00:01:18,160 --> 00:01:36,130
Vì vậy, điểm bên trái chỉ vào phần tử một này và bên phải trỏ đến phần tử số tám này. Bây giờ hãy tính toán giữa. Chúng ta có thể tính toán giữa bằng cách cộng chỉ số của con trỏ trái và phải, sau đó chúng ta sẽ chia tổng của con trỏ trái và phải cho hai.

2631
00:01:36,280 --> 00:01:52,270
Vậy không cộng bảy chia thành ba. Vì vậy, bốn là giữa của chúng tôi. Bây giờ chúng ta sẽ làm gì? Chúng ta sẽ lấy giá trị bảy với giá trị này. Nếu chúng ta nói mục tiêu lớn hơn 4 thì sẽ chuyển sang trái tới phần tử tiếp theo.

2632
00:01:52,480 --> 00:02:05,070
Nếu chúng ta thấy mục tiêu nhỏ hơn giữa thì tất cả sẽ di chuyển sang phải bên trái của chính giữa. Ở đây chúng ta thấy rằng số bảy lớn hơn lực sẽ di chuyển sang trái đến điểm tiếp theo ở giữa.

2633
00:02:05,260 --> 00:02:16,840
Vậy left sẽ trỏ tới phần tử số 5 này. Bây giờ hãy tính bốn cộng bảy ở giữa. Chia hỗ trợ cộng bảy bằng cấp 11, chia thành năm.

2634
00:02:16,960 --> 00:02:32,290
Vậy sáu là tất cả ở giữa. Chúng ta thấy bảy không bằng sáu và chúng ta thấy bảy lớn hơn sáu. Vì vậy, hãy chuyển sang phần tiếp theo ở giữa. Vì vậy chúng ta hãy di chuyển sang trái tới phần tiếp theo của phần giữa.

2635
00:02:32,290 --> 00:02:45,070
Vì vậy, bên trái sẽ trỏ đến phần tử bảy này. Bây giờ hãy tính bảy ở giữa cộng với sáu chia cho sáu. Vậy ở giữa là yếu tố thứ bảy này. Bây giờ chúng ta thấy phần giữa đó chính là mục tiêu.

2636
00:02:45,310 --> 00:02:56,770
Vì vậy, chúng tôi thấy nó là yếu tố mong muốn trong lĩnh vực này. Vì vậy, trong chỉ số của yếu tố này bảy, có sáu. Và đây hiện là một trong những công trình thuật toán của năm nay.

2637
00:02:57,460 --> 00:03:15,370
Nhưng thuật toán của chúng tôi chỉ hoạt động đối với khu vực được sắp xếp. Bạn không làm việc với lỗi chưa được sắp xếp trong thuật toán này sẽ chia lỗi đã cho của chúng tôi thành hai 1/2 trong mỗi bước và bạn sẽ xem nó hoạt động như thế nào hoặc bạn sử dụng mã giả.

2638
00:03:16,000 --> 00:03:30,610
Thuật toán phá hoại tương tự như việc bắt đầu một giá trị trong khát nhị phân. Hãy xem làm thế nào. Đầu tiên, chúng ta sẽ xây dựng một cấu trúc dữ liệu lịch sử từ mảng được sắp xếp này.

2639
00:03:31,390 --> 00:03:57,180
Bốn bốn đầu tiên là nốt gốc của chúng tôi. Ở bên trái, chúng tôi có hai cái ở bên trái, chúng tôi có một cái. Rồi ở bên phải của hai, chúng ta có ba người ở đây, bên phải của bốn là sáu, bên trái của sáu là năm và bên phải của sáu là bảy và bên phải của bảy là tám.

2640
00:03:58,350 --> 00:04:10,890
Bây giờ, bạn có muốn tìm kiếm mục tiêu đó không? Bảy, sau đó tất cả những gì chúng ta có thể làm trước tiên và so sánh phát triển với tuyến đường này, chúng ta thấy mục tiêu đó lớn hơn nên sẽ đi bên phải.

2641
00:04:11,730 --> 00:04:22,470
Vì vậy nó sẽ di chuyển đến cây con bên phải. Harry S. sáu không bằng bảy và sáu nhỏ hơn bảy. Vì vậy chúng ta hãy đi tới cây con bên phải. Ở đây bảy bằng bảy.

2642
00:04:23,070 --> 00:04:37,920
Vậy sẽ nối lại chỉ mục của phần tử này hay việc đọc qua bốn nhị phân sẽ thẳng? Được rồi, chúng tôi có thể lập chỉ mục cho mọi thảm họa mà bạn có thể đọc được và đây là cách hoạt động.

2643
00:04:38,100 --> 00:04:51,300
Và điều này giống hệt như một thảm họa. Và đây chính xác là thuật toán ngược, hoàn toàn giống với thứ bạn đánh giá trong mạch nhị phân. Và đây là cách nó hoạt động.

2644
00:04:51,330 --> 00:05:05,360
Hãy xem nó. Chúng tôi muốn tìm kiếm giá trị thứ ba trong khu vực này ngay bây giờ. Hãy xem nó hoạt động như thế nào ở đây. Chúng tôi đã xây dựng do cần thiết từ khu vực này. Đầu tiên, chúng ta sẽ so sánh điều này với cây gốc không bằng bốn.

2645
00:05:05,460 --> 00:05:16,350
Vì vậy chúng ta hãy đi sang bên trái ở đây. Chúng ta thấy rằng hai không bằng ba và hai nhỏ hơn ba. Vì vậy chúng ta hãy đi về phía bên phải. Và ở đây chúng tôi thấy hai, ba bạn.

2646
00:05:16,350 --> 00:05:31,410
Vì vậy nó sẽ trả về true cho vùng này, sẽ trả về chỉ mục. Đây là cách thuật toán hoạt động. Hiểu nó tệ đến mức nào. Thuật toán liên quan đến. Nhưng đó là cấu trúc dữ liệu Erste khi bắt đầu đánh giá các tệp nhị phân.

2647
00:05:32,310 --> 00:05:43,660
Bây giờ hãy xem mã giả. Đây là mã giả. Đầu tiên, đó là Erste. Phương thức này lấy hai tham số arianda target ở đây hoặc khai báo hai con trỏ bên trái và điểm nhỏ bên phải.

2648
00:05:43,690 --> 00:05:58,580
Người đầu tiên thậm chí còn cố gắng chỉ vào viên đạn cuối cùng. Chúng tôi có quyền của bạn, trái, phải, trái sang phải. Chúng tôi đang tính toán ở đây ở giữa và ở đây chúng tôi có thể sử dụng ở đây chúng tôi có thể sử dụng công thức khác để tránh tràn.

2649
00:05:59,220 --> 00:06:17,700
Vậy thì chúng ta có đây. Nếu Hamid bằng mục tiêu, nếu chúng ta tìm ra phần tử ở giữa để nhắm mục tiêu vào một khu vực, chỉ số coi thường người khác sẽ so sánh nếu mục tiêu lớn hơn phần tử ở giữa thì cả hai sẽ trỏ sang phần tử tiếp theo ở giữa.

2650
00:06:18,060 --> 00:06:35,470
Nếu không, chúng ta sẽ di chuyển con trỏ phải sang bên trái phần tử ở giữa. Nếu giá trị đích không tồn tại trong mảng, giá trị đó sẽ trả về âm một. Ví dụ, hai người được cho mảng này và cố gắng đến sáu ở đây.

2651
00:06:35,480 --> 00:06:48,450
Chúng ta phải chỉ ra quan điểm tự do trái phải của yếu tố này và chỉ ra yếu tố này. Bây giờ chúng ta hãy tìm nó ở giữa. Đây là giữa của chúng tôi. Chúng ta thấy sáu không bằng bốn và sáu lớn hơn lực.

2652
00:06:48,450 --> 00:06:58,530
Nó sẽ di chuyển sang trái này. Vì vậy nó sẽ di chuyển đến phần tử này. Và ở giữa là yếu tố này. Ở đây bạn thấy phần tử ở giữa bằng với phần tử đích.

2653
00:06:58,980 --> 00:07:10,220
Vì vậy, chúng tôi tìm ra chuyển động mong muốn của mình trong lĩnh vực này. Và đây là cách thuật toán nguồn nhị phân này hoạt động. Thuật toán này có độ phức tạp thời gian logarit.

2654
00:07:10,410 --> 00:07:24,630
Bây giờ hãy tìm hiểu độ phức tạp về thời gian của thuật toán này. Ban đầu, độ dài diện tích của chúng ta và biên độ và bằng với độ dài trong lần lặp đầu tiên, đúng với phép chia cho lần lặp thứ hai.

2655
00:07:24,930 --> 00:07:38,850
Linda đi tích phân, phân chia, thời gian tùy ý. Linda đi tới phần ba sau khi lặp lại. Lente đi tích hợp vào bảng k. Vì vậy, ở đây chúng tôi tìm thấy một mô hình ở đây để xem xét.

2656
00:07:38,850 --> 00:07:53,040
Lenticular to được dành cho công việc. Chúng tôi đang chia mảng thành hai nửa. Đó là một bước để cho đến khi phân chia chiều dài của ba sẽ là một để chúng ta có thể ngồi chia giai cấp công nhân thành một.

2657
00:07:53,250 --> 00:08:07,200
Thế là anh ta đi vào rổ. Sau đó, nếu chúng ta lấy log ở đây, cái này để log, thì chúng ta lấy log bất kỳ để log hai lũy thừa và ở đây chúng ta nhận được log liên quan đến K và sau đó cô ấy đăng nhập.

2658
00:08:08,130 --> 00:08:21,720
Đây là nhật ký cơ sở. Vì vậy, độ phức tạp về thời gian khi đăng nhập là rất lớn và độ phức tạp về không gian là lớn nhất vì chúng tôi đang sử dụng khả năng điều chỉnh trái, phải và giữa.

2659
00:08:22,350 --> 00:08:37,200
Haviv hiểu thuật toán nguồn nhị phân và độ phức tạp về thời gian của thuật toán tài nguyên là một vấn đề.
Hiểu rõ lời giải thích của video này hoặc nếu bạn có bất kỳ đề xuất nào, hãy cho chúng tôi biết. 

@@@



2660
00:00:00,510 --> 00:00:14,460
Trong video này, chúng ta sẽ nói về thuật toán tìm kiếm Ababil, sắp xếp Batbold là thuật toán sắp xếp đơn giản nhất hoạt động bằng cách hoán đổi liên tục các phần tử liền kề nếu chúng sai thứ tự.

2661
00:00:14,700 --> 00:00:24,830
Hãy lấy một ví dụ để hiểu. Ví dụ, Babul đã dạy rằng công việc là do bạn được giao. Những số nguyên này là đúng. Bạn phải sắp xếp mảng này trước hoặc bạn sẽ làm gì?

2662
00:00:25,140 --> 00:00:38,520
Những gì sẽ mất đầu tiên để liền kề? Và đây là những liền kề. Và ở đây bạn thấy tám lớn hơn hai ở phần tử bên trái lớn hơn bên phải.

2663
00:00:38,730 --> 00:00:53,930
Chúng ta sẽ trao đổi chúng. Chúng tôi thấy phần tử bên trái nhỏ hơn 8 nên sẽ không hoán đổi. Bây giờ chúng ta hãy lấy cặp tiếp theo và đây là cặp tiếp theo. Và ở đây chúng ta thấy tám lớn hơn năm.

2664
00:00:54,120 --> 00:01:11,070
Vì vậy, chúng ta sẽ hoán đổi tám giải đấu này chuyển sang chỉ số này và năm sẽ chuyển sang chỉ mục này. Bây giờ, hãy so sánh điều này với các cặp. Trong hai cặp này, chúng ta thấy phần tử bên trái lớn hơn phần tử bên phải.

2665
00:01:11,190 --> 00:01:35,680
Vì vậy, chúng tôi sẽ trao đổi chúng. Vậy là 12 tám tất cả chuyển đến đây và một sẽ chuyển đến đây. Bây giờ chúng ta hãy so sánh cặp này. Theo tinh thần này ta thấy lực nâng lớn hơn bên phải nên ta sẽ hoán đổi chúng Epistrophy để chuyển sang chỉ số này, bốn và sáu sẽ chuyển sang chỉ số ba này.

2666
00:01:36,180 --> 00:01:50,720
Bây giờ chúng ta sẽ so sánh năm tới và đây là bến tàu tiếp theo. Và ở bến tàu này, chúng ta thấy phần tử sống lớn hơn bên phải. Vì vậy chúng ta sẽ chuyển tuổi sang chỉ số này, 5 và 3 sang chỉ số 4.

2667
00:01:51,480 --> 00:02:06,000
Vậy hãy chuyển 3 sang chỉ số 4 ngay tại đây. Bạn nên có tám. Chúng tôi nhận được mảng này cho đến lần lặp đầu tiên. Chúng tôi đã tạo phần tử lớn nhất ở bên phải.

2668
00:02:06,480 --> 00:02:22,910
Vì thế phần bên phải của chúng ta không vững chắc. Bây giờ chúng ta sẽ mua một trong những ilmenit lớn nhất ở phần chưa được phân loại này trong tiểu khu vực chưa được phân loại, chúng ta sẽ mua một trong những nguyên tố lớn nhất ở bên phải.

2669
00:02:23,240 --> 00:02:34,970
Vì vậy, hãy so sánh điều này với gấu. Chúng ta thấy hai nhỏ hơn năm. Vậy nên không cần phải làm ở đây trong gấu tiếp theo này. Chúng ta thấy rằng năm lớn hơn một để hoán đổi chúng.

2670
00:02:35,930 --> 00:02:49,000
Một người sẽ chuyển đến đây và năm người sẽ chuyển đến đây. Bây giờ hãy so sánh điều này với Bear. Và ở đây chúng ta thấy năm nhỏ hơn sáu. Vì vậy, chúng tôi không ở trong đó để được thực hiện ở đây.

2671
00:02:49,610 --> 00:03:09,320
Khi đó con gấu tiếp theo là sáu và bốn và chúng ta thấy rằng sáu lớn hơn bốn. Vì vậy, chúng tôi sẽ trao đổi chúng. Vì vậy, Tập bốn sẽ chuyển sang chỉ mục thứ ba và Tập sáu sẽ chuyển sang chỉ mục này cho đến phần thứ hai.

2672
00:03:09,590 --> 00:03:24,640
Chúng ta nhận được mảng này và phần bên phải được sắp xếp và phần bên trái chưa được sắp xếp trong phần chưa được sắp xếp sẽ tạo ra phần tử lớn nhất ở bên phải sang trái, nhưng là một trong những phần tử lớn nhất trong phần chưa được sắp xếp ở bên phải.

2673
00:03:24,890 --> 00:03:37,370
Vì vậy, trước tiên, chúng ta sẽ so sánh cái này với một cặp. Chúng ta thấy hai lớn hơn một. Vì vậy, một người sẽ chuyển đến đây và hai người sẽ chuyển đến đây. Bây giờ chúng ta hãy so sánh con gấu này. Và trong cặp này chúng ta thấy rằng hai nhỏ hơn năm.

2674
00:03:37,790 --> 00:03:53,630
Không cần phải làm gì ở đây. Thế thì hai cặp này, ta thấy năm lớn hơn bốn nên ta phải hoán đổi chúng. Ebisu của bốn người sẽ chuyển đến đây và năm người sẽ chuyển đến chỉ số này, ba người sau người thứ ba.

2675
00:03:54,050 --> 00:04:12,260
Nhưng chúng ta thấy rằng phần bên phải được sắp xếp đúng và phần bên trái là mảng chưa được sắp xếp. Bây giờ chúng ta sẽ bong bóng phần tử lớn nhất trong phần chưa được sắp xếp để cuối danh sách chưa sắp xếp này sẽ so sánh phần tử này với.

2676
00:04:12,710 --> 00:04:24,800
Và chúng ta thấy rằng họ được khuyến khích đặt hàng trong việc này, thấy rằng họ được khuyến khích đặt hàng. Vì vậy, không cần phải làm gì ở đây. Vì vậy, theo mẫu này, chúng ta thấy các bên trái chưa được sắp xếp.

2677
00:04:24,800 --> 00:04:35,780
Và trong phần chưa được sắp xếp, hãy tạo bong bóng của phần tử lớn nhất ở bên phải. Hãy so sánh điều này và chúng ta thấy rằng hai cái đã nổi lên. Phần bên phải này đã được sắp xếp.

2678
00:04:35,780 --> 00:04:46,790
Phần bên trái chưa được sắp xếp. Chúng ta thấy rằng ở bên trái chúng ta chỉ có một phần tử. Vì vậy, không cần phải làm gì ở đây. Và đây là khu vực được sắp xếp, được chứ? Và đây là cách nó hoạt động.

2679
00:04:47,090 --> 00:05:00,850
Ý tưởng là chúng ta sẽ có thể đưa phần tử lớn nhất vào cuối danh sách chưa được sắp xếp của mình và đây là cách nó hoạt động. Bây giờ hãy xem cách chúng ta có thể triển khai khái niệm này bằng mã giả.

2680
00:05:00,890 --> 00:05:13,910
Đây là mã giả để chúng ta có hàm này, nhưng chúng ta sẽ sắp xếp để lấy các số xung quanh bằng với độ dài của mảng này. Đây là độ dài và sau đó chúng ta sẽ chạy một vòng lặp từ nó đến âm hai.

2681
00:05:13,910 --> 00:05:29,510
Vì vậy vòng lặp này sẽ chạy từ chỉ số 0 đến chỉ số for. OK, chúng ta cần so sánh phần tử này ở bên phải phần tử này. Chúng tôi không có phần tử nào và sau đó chúng tôi có cờ này để tối ưu hóa thuật toán này trong các khu vực nhất định đã được sắp xếp.

2682
00:05:29,510 --> 00:05:51,710
Rồi tình yêu này sẽ không chạy trốn Được rồi, và chúng ta có ở đây vào mùa thu năm nay, từ năm hai và trừ tám, trừ hai. Và sau đó chúng ta sẽ so sánh nó với phần tử đầu tiên thắng phần tử bên trái ở phần tử bên trái lớn hơn phần tử bên phải sẽ hoán đổi chúng bằng công thức đã được sắp xếp này, khi đó giá trị này sẽ không bao giờ thay đổi.

2683
00:05:51,860 --> 00:06:01,200
Họ đang làm điều này để tất cả các bạn sẽ tìm thấy Flagel để tuyên bố sai đã được sắp xếp. Chúng ta không cần phải so sánh nữa chỉ cần dừng lại là được. Bây giờ chúng ta có thời gian nghỉ ngơi.

2684
00:06:01,250 --> 00:06:09,860
Hãy để tôi chỉ cho bạn cách nó hoạt động một lần nữa. Vì vậy, lần này chúng ta sẽ có hai và tám. Hãy so sánh chúng. Và tám lớn hơn hai.

2685
00:06:09,860 --> 00:06:28,160
Được rồi, năm nay nó sẽ chuyển đến đây, năm cái sẽ chuyển đến đây. Và trong năm tới, chúng ta sẽ thấy hai người chuyển đến đây và một người sẽ chuyển đến đây. Sau đó, trong lần so sánh tiếp theo của phần tử này với phần tử, nó sẽ di chuyển ở đây và sáu phần tử sẽ di chuyển ở đây.

2686
00:06:28,400 --> 00:06:38,720
Và phép so sánh tiếp theo chúng ta thấy rằng nó sẽ di chuyển đến đây và ba sẽ di chuyển đến đây bằng thuật toán này. Bạn có thể xem qua thuật toán này để xem nó hoạt động như thế nào sau thuật toán đầu tiên.

2687
00:06:38,870 --> 00:06:48,890
Nhưng ta thấy chữ bên phải sao cho phần bên trái không được sắp xếp. Bây giờ, hãy tổ chức sự kiện lớn nhất từ ​​phần chưa được sắp xếp đến phần chưa được sắp xếp này.

2688
00:06:49,160 --> 00:07:02,840
Vì vậy, đây sẽ đưa điều này theo đúng thứ tự. Thế thì cái này năm cái sẽ chuyển tới đây và một cái sẽ chuyển tới đây. Và sau đó trong lần kiểm tra này, chúng tôi thấy rằng chúng theo đúng thứ tự cho cặp này.

2689
00:07:02,840 --> 00:07:18,290
Chúng tôi thấy sáu người sẽ chuyển đến đây và ba người sẽ chuyển đến đây. Vì vậy, bây giờ chúng ta thấy rằng phần này là. Phần bên phải, xin lỗi, phần bên trái chưa được sắp xếp. Hãy tạo bong bóng lớn nhất cho đến hết phần chưa được sắp xếp này.

2690
00:07:18,300 --> 00:07:38,640
Vậy hai lớn hơn một. Vậy chúng ta hãy hoán đổi chúng để di chuyển tới đây và một người sẽ di chuyển tới đây. Sau đó, đối với chúng tôi, họ được khuyến khích đặt hàng, sau đó hai người này sẽ chuyển đến đây và năm người sẽ chuyển đến chỉ mục này, ba người vào thời điểm này.

2691
00:07:38,670 --> 00:07:58,380
Chúng ta thấy rằng phần bên phải đã được sắp xếp và phần bên trái đã được sắp xếp. Nó sẽ thực hiện tất cả các so sánh. Sau đó, chúng tôi thấy lỗi sẽ được sắp xếp, đại loại như thế này và quyết định xem điều gì sẽ hiệu quả cũng như độ phức tạp về thời gian của thuật toán tìm kiếm Babille lớn hơn và vuông góc hơn và độ phức tạp về không gian lớn hơn một.

2692
00:07:58,380 --> 00:08:12,750
Điều đó có nghĩa là nó hoạt động trong độ phức tạp không gian không đổi. Khi bạn xem xét độ phức tạp của không gian, thì chúng tôi có thể sử dụng thuật toán battletoad và tốt nhất nó sẽ phát triển về độ phức tạp của không gian nếu khu vực đã được sắp xếp.

2693
00:08:13,080 --> 00:08:25,860
Bây giờ hãy để tôi chỉ cho bạn sự phức tạp về thời gian. Phân tích nó một cách chi tiết. Được rồi. Chúng ta phải tính toán thời gian, độ phức tạp, thời gian, độ phức tạp cho hàm này.

2694
00:08:25,880 --> 00:08:40,880
OK, ở đây độ dài nó sẽ được tính theo thời gian không đổi. Độ phức tạp khi đó là độ dốc vì độ phức tạp về mặt thời gian thực sự diễn ra theo thời gian, độ phức tạp và độ dài của mảng.

2695
00:08:40,890 --> 00:09:05,590
Nó sẽ bắt đầu từ 0,2 inch. Vì vậy, nó sẽ bắt đầu với độ phức tạp âm một lần và điều đó tương đương với ở trong và ở đây. Điều này sẽ mất thời gian, độ phức tạp không đổi và tất cả điều này xảy ra trong trường hợp xấu nhất vì độ phức tạp trừ một lần tương đương với B đi vào và tất cả điều này sẽ cần độ phức tạp không gian không đổi để phân tích độ phức tạp lần này.

2696
00:09:05,620 --> 00:09:14,090
Chúng ta sẽ lấy mảng này làm ví dụ, độ dài của mảng sáu này cho lần lặp đầu tiên của mảng này vì tình yêu. Ở đây chúng ta có giá trị bằng 0.

2697
00:09:14,400 --> 00:09:34,440
Tình yêu này sẽ được thực hiện năm lần. Vậy cách thực hiện là năm bốn bằng một. Điều này sẽ thực hiện bốn lần trong quá trình thực thi vì tôi phải thực hiện điều này nhưng sẽ thực hiện ba lần đối với bằng ba, sẽ thực hiện hai lần đối với bằng bốn.

2698
00:09:34,950 --> 00:09:47,310
Sẽ thực hiện, sẽ thực hiện một lần. Và ở đây chúng ta thực hiện, ở đây chúng ta thấy một mẫu và chiều dài của khu vực này là sáu. Vì vậy, chúng tôi thấy một mô hình. Đó có phải là âm một không?

2699
00:09:47,490 --> 00:10:00,350
Vì vậy, nó có nghĩa là một cho mảng này. Sáu trừ một. Có năm ở Minnesota, bốn và trừ ba, trừ ba, ba, v.v. Và đồng thời tất cả đều có một.

2700
00:10:00,390 --> 00:10:16,920
OK, cuối cùng sẽ có một cái gì đó như thế này, lần thực thi cuối cùng sẽ được đánh giá một lần để chúng ta có thể viết nó dưới dạng phương trình, đại loại như thế này. Và nếu chúng ta giải phương trình này, thì chúng ta sẽ nhận được phương trình này nhân với trừ một, chia hai.

2701
00:10:16,920 --> 00:10:33,240
Và nếu chúng ta thực hiện phương trình này, thì bạn sẽ có bình phương trừ và chia cho hai. Và bậc của phương trình này là một bình phương. Vì vậy, độ phức tạp về thời gian lớn hơn và bình phương và độ phức tạp về không gian cho giải pháp lớn hơn độ phức tạp mà nó hoạt động trong độ phức tạp không gian không đổi.

2702
00:10:33,240 --> 00:11:09,720
Vì bạn không sử dụng quyết định phân chia ban đầu, làm cách nào chúng tôi có thể phân tích độ phức tạp của thuật toán theo từng thời điểm. Đây là một thuật toán tìm kiếm bập bẹ. Đây là thuật toán khá dễ thực hiện và đây là cách để tìm ra thời gian, độ phức tạp của
thuật toán, những gì chúng ta đã hiểu, thuật toán và thời gian chạy cũng như bao vây A. Hãy chia nhỏ thời gian không đổi và độ phức tạp thời gian tuyến tính ở đây cho mỗi thuật toán để bạn hiểu rõ từng chi tiết, tôi nghĩ bạn hiểu rõ về thời gian, độ phức tạp. 

@@@



2703
00:00:00,480 --> 00:00:21,470
Này, có chuyện gì vậy các bạn, trong video này chúng ta sẽ nói về lựa chọn, thuật toán sắp xếp Thuật toán sắp xếp lựa chọn là một thuật toán dựa trên so sánh không hợp lệ trong đó danh sách được chia thành hai phần, phần liền nét ở đầu bên trái và phần phần chưa được sắp xếp ở cuối bên phải.

2704
00:00:22,170 --> 00:00:36,240
Ban đầu, phần được sắp xếp trống và phần chưa được sắp xếp là toàn bộ danh sách. Đây là thuật toán sắp xếp lựa chọn. Bây giờ hãy xem thuật toán sắp xếp lựa chọn hoạt động như thế nào.

2705
00:00:36,250 --> 00:00:49,980
Hãy lấy một ví dụ. Giả sử rằng chúng ta được cấp khu vực này. Chúng ta phải sắp xếp mảng này bằng thuật toán tìm kiếm lựa chọn. Chúng tôi có hai phần cổng trái và phần bên phải.

2706
00:00:50,280 --> 00:01:05,010
Phần bên trái được sắp xếp và phần bên phải không được sắp xếp. Đầu tiên, phần được sắp xếp của chúng tôi trống. Điều đó có nghĩa là phần bên trái của chúng tôi trống và phần bên phải là toàn bộ danh sách của bạn.

2707
00:01:05,580 --> 00:01:17,430
Ở phần chưa được sắp xếp, điều đó có nghĩa là ở phần bên phải, chúng ta sẽ tìm ra phần tử tối thiểu. Và trong phần bên phải này, phần tử tối thiểu là to.

2708
00:01:18,950 --> 00:01:40,940
Bây giờ bạn sẽ làm gì, giải quyết vấn đề này như thế nào? Valetta với chín? Với chỉ số đầu tiên, OK, đây là chỉ mục đầu tiên, và chúng ta ở đây, 12, sau đó chín sẽ chuyển sang chỉ mục này, bốn và hai sẽ chuyển sang chỉ số này.

2709
00:01:41,360 --> 00:01:58,080
Bây giờ, phần bẩn thỉu của chúng ta là phần này, phần sống đã được sắp xếp. Phải. Một phần chưa được sắp xếp. OK, ở phần chưa sắp xếp, chúng ta hãy tìm phần tử nhỏ nhất và phần tử nhỏ nhất ở phần bên phải là 5.

2710
00:01:58,690 --> 00:02:11,320
Bây giờ, bạn định làm gì? Chúng ta sẽ giải năm câu hỏi này bằng giá trị đầu tiên trong phần chưa được sắp xếp hoặc bằng phần tử đầu tiên trong phần chưa được sắp xếp.

2711
00:02:11,600 --> 00:02:30,310
Vì vậy năm sẽ chuyển đến chỉ mục này, một và sáu sẽ chuyển đến chỉ mục này ba. Bây giờ, phần được sắp xếp của chúng ta là phần này. Vì vậy, phần này hiện đã được sắp xếp. Bây giờ chúng ta hãy tìm mức tối thiểu trong phần chưa được sắp xếp.

2712
00:02:30,610 --> 00:02:44,200
Mức tối thiểu trong phần chưa được sắp xếp là sáu. Vì vậy, chúng ta sẽ giải sáu cái này với phần tử đầu tiên trong phần chưa được sắp xếp, và đó là bảy để chúng ta hãy xem chúng sáu hoặc chuyển sang chỉ mục này.

2713
00:02:44,200 --> 00:02:57,940
Hai và bảy sẽ chuyển sang chỉ số ba này. Vì vậy bây giờ phần được sắp xếp của chúng ta là phần bên trái. Và ở bên trái, phần hai, năm sáu hiện không được sắp xếp ở bên phải.

2714
00:02:57,940 --> 00:03:10,580
Nhưng chúng ta hãy tìm phần tử nhỏ nhất, đó là bảy và bảy ở đúng vị trí của nó. Không có gì để làm ở đây. Vì vậy, ở đây bây giờ, phần bên trái chưa được sắp xếp.

2715
00:03:11,080 --> 00:03:25,540
Bây giờ chúng ta sẽ tìm số nhỏ nhất trong phần chưa được sắp xếp và số nhỏ nhất trong phần chưa được sắp xếp là 8. Vì vậy, chúng ta sẽ chuyển 8 đến chỉ số 4 và chúng ta sẽ chuyển 9 đến chỉ số 5.

2716
00:03:26,260 --> 00:03:41,460
Bây giờ, phần tải này hiện đã được sắp xếp và phần bên phải chưa được sắp xếp vì chúng ta chỉ có một phần tử ở bên phải. Vậy là nó đã được sắp xếp rồi. Bây giờ chúng ta thấy toàn bộ khu vực hiện được sắp xếp thành năm, sáu, bảy, tám, chín.

2717
00:03:41,980 --> 00:03:54,000
Và đây là cách lựa chọn hoạt động. Bây giờ hãy xem cách chúng ta có thể triển khai lựa chọn, sắp xếp bằng mã giả. Đây là thuật toán chọn lọc, sắp xếp để ta có hàm lựa chọn được sắp xếp.

2718
00:03:54,010 --> 00:04:08,350
Việc đó lấy một mảng làm đầu vào, sau đó tính toán độ dài và sau đó chúng ta chạy theo, tức là từ 0 đến trừ hai. Chúng tôi có chỉ số chính này bằng tám.

2719
00:04:08,380 --> 00:04:31,170
ĐƯỢC RỒI. Ban đầu, chỉ mục đầu tiên là chỉ mục tối thiểu và sau đó chúng tôi chạy chỉ mục này cho J từ cộng một đến trừ một. Sau đó, chúng ta sẽ kiểm tra xem nums có nhỏ hơn nums được lập chỉ mục tối thiểu hay không và chúng ta sẽ thay đổi chỉ mục tối thiểu thành chỉ mục hiện tại cho phần tiếp theo.

2720
00:04:31,750 --> 00:04:45,150
Và sau đó chúng ta chỉ hoán đổi phần tử tối thiểu với phần tử đầu tiên trong danh sách chưa sắp xếp. Bây giờ hãy để tôi chỉ cho bạn cách nó hoạt động một lần nữa. Vậy ban đầu chúng ta có chín ở đây, được chứ?

2721
00:04:45,670 --> 00:04:57,790
Và ban đầu chúng ta có danh sách được sắp xếp, nó trống và phần tử tối thiểu trong danh sách được sắp xếp này là hai. Và chúng ta có thể tìm phần tử tối thiểu bằng cách sử dụng diện tích này.

2722
00:04:57,800 --> 00:05:11,320
OK, đại loại như thế này, chúng ta đang tìm phần tử tối thiểu bằng cách sử dụng phần tử tối thiểu này và chúng tôi đã tìm thấy phần tử tối thiểu này ở đây. Có hai và chúng ta sẽ giải phần tử này trong phần tử đầu tiên trong danh sách chưa sắp xếp.

2723
00:05:11,470 --> 00:05:24,610
Vì vậy, để chuyển đến chỉ mục này và chín sẽ chuyển đến chỉ mục này bốn. Vì vậy, chúng tôi đã trao đổi bằng cách sử dụng công thức này. Bây giờ danh sách được sắp xếp của chúng tôi là thế này. Vì vậy, ở bên trái chúng ta đã sắp xếp danh sách và ở bên phải chúng ta đã nhập danh sách.

2724
00:05:24,950 --> 00:05:37,510
Bây giờ, phần tử tối thiểu trong danh sách chưa sắp xếp là năm. Vì vậy, chỉ mục tối thiểu cho lần lặp thứ hai sau đây là mục nhập chỉ mục. Bây giờ chúng ta sẽ hoán đổi phần tử này trong phần tử đầu tiên trong danh sách này và được sắp xếp.

2725
00:05:37,780 --> 00:05:50,380
Và có sáu. Vậy năm người sẽ chuyển tới đây và sáu người sẽ chuyển tới đây. Bây giờ, phần được sắp xếp là hai và năm và phần không được sắp xếp là bảy, sáu, chín, tám.

2726
00:05:50,680 --> 00:06:05,230
Bây giờ, phần tử tối thiểu trong phần chưa được sắp xếp này là sáu. Được rồi, vậy chúng ta sẽ đổi chỗ sáu và bảy. Sáu người sẽ chuyển đến đây và bảy người sẽ chuyển đến đây. Bây giờ, bên trái, Sabra, không vững chắc ở bên phải.

2727
00:06:05,240 --> 00:06:15,790
Hãy tìm hiểu mức tối thiểu. Tối thiểu là bảy. Nó đã ở vị trí hiện tại rồi. Vì thế chúng ta không phải làm gì ở đây. Và ở đây chúng ta có chín và tám.

2728
00:06:15,790 --> 00:06:30,520
Tối thiểu là tám để có được mười hai. Tám sẽ chuyển đến chỉ số này. Bốn và chín sẽ chuyển sang chỉ mục này. Tám. Và sau đó chúng ta sẽ chuyển sang chỉ số 5, được chứ?

2729
00:06:30,960 --> 00:06:53,100
Và chúng ta thấy rằng chúng có thứ tự rất chắc chắn và nếu chúng ta chia ngay ở đây và chúng ta thấy phần bên trái cho phần bên phải trên một phần tử bên phải. Vì vậy, phần tử đó ở vị trí hiện tại của nó, vì bạn chỉ có một phần tử ở bên phải, và chúng ta có thể giải quyết vấn đề này càng sớm và đây là thuật toán lựa chọn và đây là cách nó hoạt động.

2730
00:06:53,220 --> 00:07:06,630
Vâng, chúng tôi đã hiểu các thuật toán lựa chọn. Bây giờ hãy giải quyết độ phức tạp về thời gian và không gian. Độ phức tạp về thời gian của thuật toán này là lớn và bình phương và độ phức tạp về không gian của thuật toán này lớn hơn một.

2731
00:07:06,630 --> 00:07:16,610
Điều đó có nghĩa là độ phức tạp không gian không đổi vì không sử dụng bất kỳ không gian bổ sung nào. Bây giờ hãy xem làm thế nào chúng ta có thể tìm ra độ phức tạp thời gian lớn lên và bình phương ở đây.

2732
00:07:16,620 --> 00:07:32,520
Chúng tôi chia nhỏ thời lượng và ở đây có thể tính toán độ phức tạp về thời gian khi bạn có độ dài của mảng đã cho. Và ở đây chúng tôi có các phép toán liên tục và chúng tôi có một số phép toán tuyến tính và những thứ vận hành này, chính phủ có một và điều đó tương đương để bắt đầu vào.

2733
00:07:32,790 --> 00:07:49,710
Bạn đang lặp lại từ Jeanetta ở Minnesota và điều tương tự ở đây đối với chúng tôi và đây là thời gian tuyến tính, được chứ? Và tất cả các hoạt động khác đều mất thời gian không đổi. Bây giờ cách thức hoạt động của nó và lần đầu tiên là năm lần.

2734
00:07:49,710 --> 00:08:07,850
Vậy cách thực hiện là năm bốn bằng một. Họ thực hiện bốn lần, v.v. và bốn lần bằng nhau. Trước khi chúng ta lấy một ở đây, bạn thấy rằng năm, bốn, ba, hai, một số không, đại loại như thế này tính bằng một tính bằng phút, hai và ba tính bằng phút cho số trừ năm.

2735
00:08:08,010 --> 00:08:24,030
Vì vậy, chúng ta có thể viết phương trình như thế này trong vài phút một cộng và trừ hai cộng và trừ ba khi không biết hoặc bất cứ điều gì. Được rồi, và đến một lúc nào đó chúng ta sẽ tìm ra cách thực thi.

2736
00:08:24,510 --> 00:08:36,340
Và nếu chúng ta làm vậy, công thức này từ cái này sẽ tính nhân với và chia cho và nó tương đương với trong bình phương một bằng chia hai và bậc của phương trình này là bình phương.

2737
00:08:36,600 --> 00:08:45,930
Vì vậy, độ phức tạp về thời gian lớn hơn và bình phương. Độ phức tạp về không gian của giải pháp lớn hơn một. Giải pháp hoạt động trong độ phức tạp không gian không đổi.

2738
00:08:46,590 --> 00:08:59,670
Vì vậy, khi chúng ta cần phân chia giống nhau thì chúng ta có thể xem xét sử dụng lựa chọn hoặc thuật toán.
Và đây là tất cả về video này. Chúng tôi đã hiểu rõ thời gian, độ phức tạp và thuật toán lựa chọn. 

@@@



2739
00:00:01,160 --> 00:00:22,580
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng ta sẽ nói về thuật toán sắp xếp chèn. Thuật toán sắp xếp chèn là một thuật toán dựa trên so sánh ngầm trong đó danh sách được chia thành hai phần, phần vững chắc ở đầu bên trái và phần chưa được sắp xếp ở đầu bên phải.

2740
00:00:22,950 --> 00:00:42,240
Ban đầu, phần rắn trống và phần chưa được sắp xếp là danh sách nhập. Ví dụ: nếu bạn được cung cấp mảng chưa được sắp xếp này, thì việc xáo trộn webisode bằng cách sử dụng tính năng chèn ban đầu sẽ khiến phần bẩn thỉu trống và chưa được sắp xếp.

2741
00:00:42,240 --> 00:00:52,260
Một phần là toàn bộ danh sách. Vì vậy, phần bên trái trống và phần bên phải là danh sách nhập sẽ chọn phần tử đầu tiên từ phần tử chưa được sắp xếp, nhưng trong trường hợp này là bốn.

2742
00:00:52,710 --> 00:01:07,760
Và chúng ta sẽ chuyển nó đến vị trí này. Bây giờ, phần bên trái đã được sắp xếp và phần bên phải chưa được sắp xếp. Vì thuật toán chèn là một thuật toán suy luận.

2743
00:01:08,250 --> 00:01:22,830
Vì vậy chúng ta sẽ sửa đổi mảng đã cho. Bây giờ chúng ta sẽ làm gì? Chúng ta sẽ lấy phần tử này để viết phần tử đầu tiên từ phần chưa được sắp xếp và chúng ta sẽ chèn nó vào đúng vị trí.

2744
00:01:23,130 --> 00:01:35,010
Bây giờ chúng ta sẽ so sánh hai và bốn ở đây. Chúng ta thấy rằng bốn lớn hơn hai. Vì vậy chúng ta sẽ trao đổi chúng. Nếu chúng ta giải quyết chúng, hai người sẽ chuyển đến đây và bốn người sẽ chuyển đến đây.

2745
00:01:36,120 --> 00:01:52,500
Bây giờ chúng ta thấy rằng ở bên trái, chúng ta không có phần tử nào. Chúng ta thấy phần bên trái này chưa được sắp xếp và phần bên phải chưa được sắp xếp, vì vậy hãy chọn phần tử này năm và chèn nó vào đúng vị trí.

2746
00:01:52,650 --> 00:02:10,680
Ở phần liền, chúng ta thấy năm lớn hơn bốn. Vì vậy, không cần phải làm gì ở đây. Bây giờ, phần bên trái đã được sắp xếp, phần bên phải chưa được sắp xếp. Và hãy chọn phần tử số 8 này và đặt nó vào đúng vị trí trong phần được sắp xếp.

2747
00:02:11,010 --> 00:02:21,520
Và chúng ta thấy rằng tám lớn hơn năm. Vì vậy, vẫn chưa có gì để làm ở đây. Bây giờ chúng ta thấy rằng phần bên trái hiện đã được sắp xếp và phần bên phải chưa được sắp xếp từ phần này.

2748
00:02:21,540 --> 00:02:30,120
Phải. Nhưng chúng ta sẽ chọn phần tử sáu này và chúng ta sẽ chèn nó vào đúng vị trí trong phần liền khối, sáu nhỏ hơn tám.

2749
00:02:30,120 --> 00:02:43,200
Vì vậy chúng ta sẽ trao đổi chúng. Nếu nó ở đây, chúng ta có sáu và ở đây chúng ta có tám. Và hãy so sánh sáu và năm, sáu lớn hơn năm. Vì vậy, không cần phải làm gì ở đây.

2750
00:02:43,740 --> 00:02:56,010
Vì vậy, phần bên trái không được sắp xếp. Phần bên phải chưa được sắp xếp. Hãy chọn yếu tố này chín. Chúng tôi thấy chín đã ở đúng vị trí của nó. Vâng. Vậy bây giờ chúng ta thấy phần bên trái là dạng đặc, phần bên phải là chưa được sắp xếp.

2751
00:02:56,460 --> 00:03:07,410
Bây giờ bạn định làm gì? Chúng ta sẽ so sánh cái này với cái gì, chúng ta thấy rằng một nhỏ hơn chín. Hai người trong số họ sẽ được trao đổi chúng. Chín sẽ chuyển đến đây và một sẽ chuyển đến đây.

2752
00:03:07,530 --> 00:03:19,030
Bây giờ hãy so sánh điều này với một và tám. Chúng ta thấy một nhỏ hơn tám. Vì vậy, hãy xem chúng. Nếu chúng ta ngăn chặn chúng, tám sẽ chuyển đến chỉ mục này, năm tám sẽ chuyển đến đây và một sẽ chuyển đến đây.

2753
00:03:19,410 --> 00:03:30,810
Bây giờ chúng ta sẽ so sánh điều này để loại bỏ một và sáu. Và chúng ta thấy rằng một nhỏ hơn sáu. Vì vậy hãy ngăn chặn chúng lại. Nếu chúng ta đổi chỗ, một người sẽ chuyển đến đây và sáu người sẽ chuyển đến đây.

2754
00:03:31,440 --> 00:03:44,540
Bây giờ, hãy so sánh điều này để loại bỏ trên và năm trên nhỏ hơn năm. Vậy hãy thả chúng đi. Vì vậy một người sẽ chuyển đến chỉ mục này, hai và năm sẽ chuyển đến chỉ mục này ba.

2755
00:03:44,550 --> 00:03:56,400
Và một lần nữa, chúng ta thấy rằng bốn lớn hơn một. Hai, hãy ngăn chặn chúng lại. Nếu là mười hai, người ta sẽ chuyển sang chỉ mục này. Một bốn sẽ chuyển đến chỉ mục này. Hai lần nữa.

2756
00:03:56,400 --> 00:04:10,830
Chúng ta thấy rằng một nhỏ hơn hai. Vì vậy, hãy trao đổi chúng. Chúng ta có ở đây hai và ở đây một. Và ở bên trái chúng ta không có phần tử nào. Vì vậy, không có gì để làm ở đây. Bây giờ chúng ta đã hoàn tất.

2757
00:04:11,160 --> 00:04:26,820
Và bây giờ chúng ta thấy rằng mảng này đã được sắp xếp. Bây giờ toàn bộ khu vực đã được sắp xếp và họ chuyển đổi cách chèn nó sẽ là phần tử đầu tiên từ phần chưa được sắp xếp và nó sẽ chèn vào đúng vị trí trong phần được sắp xếp.

2758
00:04:26,860 --> 00:04:38,740
Và đây là cách chèn. Vì vậy, nó hoạt động. Vì vậy chúng ta phải trả về mảng này. Bây giờ chúng ta hãy xem thuật toán. Được rồi, đây là thuật toán chèn được tìm kiếm đầu tiên để có chức năng chèn này.

2759
00:04:38,740 --> 00:04:53,800
Vì vậy, có mảng số nhất định. Sau đó, bạn sẽ tìm ra độ dài và sau đó chúng ta sẽ chạy một vòng lặp từ đó đến âm một. Sau đó chúng ta có 10 biến temp đều lưu trữ phần tử hiện tại và bằng I.

2760
00:04:53,970 --> 00:05:13,570
Sau đó, chúng ta sẽ kiểm tra xem những giá trị này có lớn hơn 0 hay không và phần tử bên trái có lớn hơn tính khí hay không, sau đó chúng ta sẽ thay đổi phần tử hiện tại bằng phần tử tự do khi chúng ta hoàn thành công thức loof sẽ thực hiện công thức này nums jagels thành mười và thì cuối cùng bạn sẽ trả về mảng số.

2761
00:05:13,740 --> 00:05:24,720
Bây giờ hãy xem điều này thực sự hoạt động như thế nào. Trước tiên hãy hiểu, giả sử chúng ta đang đưa ra mảng này cho lần lặp đầu tiên của mảng này cho tình yêu. Tôi sẽ chỉ vào yếu tố thứ tám này.

2762
00:05:25,080 --> 00:05:36,420
Họ sẽ chỉ vào Yếu tố tám này và tạm thời sẽ trỏ đến Yếu tố tám này. Điều kiện bên trong khá giả này là sai vì không có số nào lớn hơn 0.

2763
00:05:36,720 --> 00:05:53,460
Có chỉ mục của phần tử hiện tại của chúng tôi. Vậy cái này sẽ không chạy thì đi tới phần tử tám này với phần tử tám này. Vậy là chúng ta đã hoàn thành lần lặp đầu tiên sau lần lặp đầu tiên, phần bên trái của loại từ bên phải này hiện chưa được sắp xếp.

2764
00:05:53,460 --> 00:06:04,380
Temp đang trỏ đến phần tử này là sáu và đang trỏ đến phần tử này là sáu theo ý muốn. Bây giờ chúng ta sẽ làm gì? Chúng ta sẽ kiểm tra xem nó có lớn hơn 0 hay không.

2765
00:06:04,380 --> 00:06:16,500
Vâng, giá trị này lớn hơn 0. Và phần tử bên trái lớn hơn nhiệt độ. Vậy bạn sẽ làm gì? Bạn định thay số sáu này bằng phần tử bên trái và có tám.

2766
00:06:16,770 --> 00:06:32,640
Phần tử bên trái là tám bây giờ đang trỏ đến phần tử tám này và bây giờ người tôi yêu sẽ dừng ở đây vì không có điểm nào chỉ đến số 0. Vì vậy, chúng ta sẽ giải với giá trị của temp ở biến số 10, chúng ta có giá trị sáu.

2767
00:06:33,030 --> 00:06:51,130
Vì vậy, chúng tôi sẽ thay thế tám này bằng sáu. Bây giờ, bạn định làm gì bây giờ? Chúng tôi thấy rằng chất lỏng đã được sắp xếp và phần bên phải được bật. Đã sắp xếp. Bây giờ, tạm thời của chúng ta đang trỏ đến đối số 5, 10, bởi vì 5, và chúng sẽ trỏ đến phần tử 5 này.

2768
00:06:51,520 --> 00:07:01,250
Bây giờ chúng ta sẽ kiểm tra xem chúng có trừ một không. Và điều đó có nghĩa là phần tử số tám này lớn hơn năm năm. Tám lớn hơn năm. Vậy bạn sẽ làm gì?

2769
00:07:01,280 --> 00:07:17,990
Chúng ta sẽ thay thế năm bằng tám. Sau đó, có trỏ đến chỉ mục này. Bây giờ chúng ta sẽ kiểm tra chúng trừ đi một. Điều đó có nghĩa là phần tử sáu này lớn hơn nhiệt độ sáu phần tử.

2770
00:07:17,990 --> 00:07:30,500
Chimpy kéo dài đến năm năm. Tất cả sẽ thay thế yếu tố tám này bằng sáu. Vì vậy, chúng ta sẽ thay thế phần tử sáu này bằng. Vì vậy, chúng ta sẽ thay thế phần tử tám này bằng phần tử sáu.

2771
00:07:31,790 --> 00:07:43,080
Sau đó, cái này trỏ đến phần tử này ở chỉ số 0. Và đây là một trong những thứ, và chúng ta sẽ thay thế 6 bằng giá trị của biến 10 để gần bằng 5.

2772
00:07:43,100 --> 00:07:57,050
Vậy hãy thay sáu bằng năm. Bây giờ, phần bên trái đã được sắp xếp và phần bên phải chưa được sắp xếp. Và nhiệt độ của chúng tôi sẽ trỏ đến phần tử này cho hai đến bốn điểm điển hình và điểm 0 cho phần tử này, bốn cũng vậy.

2773
00:07:57,470 --> 00:08:08,240
Bây giờ chúng ta sẽ kiểm tra số trừ. Có tám thì tám lớn hơn nhiệt độ. Chúng ta thấy rằng tám lớn hơn bốn. Vì vậy chúng ta sẽ thay thế bốn bằng tám.

2774
00:08:08,510 --> 00:08:24,730
Hãy nhớ rằng temp đang lưu trữ giá trị của phần tử thứ tư này. OK, bây giờ cái này trỏ tới chỉ số này và ở đây chúng ta thấy số trừ một lớn hơn năm.

2775
00:08:24,860 --> 00:08:41,370
Vì vậy, chúng tôi sẽ thay thế nó bằng sáu. Sau đó họ sẽ trỏ tới phần tử này. Bây giờ chúng ta sẽ kiểm tra xem quản trị có lớn hơn năm hay không, chúng ta thấy rằng số trừ trên năm năm của nó lớn hơn bốn và biến số hạng là bốn.

2776
00:08:41,660 --> 00:08:56,920
Vậy bạn sẽ làm gì? Bạn có định thay thế sáu bằng năm không? Vậy hãy thay sáu bằng năm ở đây. Bây giờ chúng ta hãy di chuyển sang bên trái. Và ở đây họ đang trỏ tới phần tử số 5 này và Loop sẽ dừng ở đây.

2777
00:08:57,200 --> 00:09:09,170
Vì vậy, chúng ta sẽ thay số 5 này bằng giá trị của biến số hạng, và đó là 4. Vì vậy, hãy thay thế giá trị năm này bằng bốn. Bây giờ chúng ta đã hoàn thành việc lặp lại.

2778
00:09:09,680 --> 00:09:24,110
Bây giờ chúng ta có phần bên trái này và phần bên phải bây giờ chúng ta có phần bên trái này gần như là đường dẫn bên phải chưa được sắp xếp. Bây giờ, đây là tạm thời của chúng tôi và điều này đang trỏ đến phần tử này và cấu trúc điển hình.

2779
00:09:24,350 --> 00:09:39,940
Bây giờ chúng ta sẽ kiểm tra âm một và mười. Vậy trừ đi phần tử này là 8 và 10 là 2. Chúng ta thấy rằng số trừ một lớn hơn 10. Vì vậy, chúng ta sẽ nói rằng chúng ta sẽ chuyển 8 đến chỉ số này, 8.

2780
00:09:40,310 --> 00:09:55,580
Hãy di chuyển nó ở đây. Và bây giờ Jay đang chỉ vào yếu tố thứ tám này và ở đây trừ một bằng sáu. Sáu lớn hơn hai. Vì vậy, hãy thay thế nó bằng sáu. Sau đó, có chỉ ngay tại đây.

2781
00:09:55,910 --> 00:10:08,240
Bây giờ là trừ một bằng năm. Năm lớn hơn hai. Vậy hãy thay sáu bằng năm. Điểm đến yếu tố này năm. Và bây giờ chúng ta sẽ so sánh số trừ một bằng bốn.

2782
00:10:08,360 --> 00:10:19,700
Bốn là lớn hơn hai. Vậy hãy thay số năm này bằng bốn. Vì vậy, chúng ta sẽ thay thế năm bằng bốn. Và ở bên trái, chúng ta có nguyên tố thứ 4.

2783
00:10:20,060 --> 00:10:31,140
Và có sự chỉ ra yếu tố này với thế giới đồ đạc ở đây. Và bây giờ chúng ta sẽ làm, chúng ta sẽ phản ánh điều này với hai người. Vậy hãy thay bốn bằng hai.

2784
00:10:31,430 --> 00:10:42,290
Bây giờ chúng ta đã hoàn tất. Vì vậy, sau lần lặp này, chúng ta đã sắp xếp phần bên trái này và phần bên phải chưa được sắp xếp. Chỉ có một yếu tố. Bây giờ, hãy chọn phần tử này và đặt nó vào đúng vị trí.

2785
00:10:42,470 --> 00:11:06,110
Vì vậy, bây giờ 10 vì hai một và cái này đang trỏ đến phần tử một ban đầu chúng ta thấy một là chúng ta thấy âm một tám tám lớn hơn nhiệt độ. Vì vậy, chúng ta sẽ thay thế một bằng tám và điểm 0 tương tự ở đây và chúng ta sẽ thay thế tám bằng giá trị ở bên trái.

2786
00:11:06,110 --> 00:11:16,760
Và đó là sáu. Vì vậy bây giờ hãy thay thế tám bằng sáu. Điểm không ở đây. Và đây là trừ một lớn hơn mười. Vậy hãy thay sáu bằng năm.

2787
00:11:17,240 --> 00:11:36,960
Bây giờ, họ sẽ chỉ vào yếu tố số năm này. Và ở đây chúng ta thấy năm lớn hơn một. Vậy hãy thay năm bằng bốn. Tương tự như vậy, chúng ở đây và chúng ta sẽ thay 4 bằng 2 và sau đó là điểm 0 ở đây.

2788
00:11:37,400 --> 00:11:54,200
Bây giờ chúng ta đã hoàn thành việc này. Vì vậy, chúng tôi sẽ thay thế điều này. Với một thay thế đơn giản này, hãy làm tất cả, chúng ta sẽ có được điều này ngay bây giờ, toàn bộ khu vực của chúng ta đã được sắp xếp và đây là cách chèn sắp xếp các kiểm tra và họ cho biết thuật toán của bạn để giải quyết vấn đề này.

2789
00:11:54,500 --> 00:12:05,160
Chúng ta đã hiểu cách sắp xếp chèn. Bây giờ, hãy để tôi chỉ cho bạn độ phức tạp của thời gian, độ phức tạp và độ phức tạp của không gian. Độ phức tạp về không gian của vấn đề này lớn hơn một bậc.

2790
00:12:05,160 --> 00:12:18,120
Điều đó có nghĩa là nó hoạt động trong độ phức tạp không gian không đổi. Vì chúng tôi đang sửa đổi khu vực nhất định nên chúng tôi không sử dụng thêm bất kỳ khoảng trống nào. Bây giờ, hãy xem độ phức tạp về thời gian để phân tích vấn đề này.

2791
00:12:18,630 --> 00:12:45,180
Vì sự hiểu biết. Chúng tôi giả sử đây là mảng đã cho của bạn cho bản phác thảo đầu tiên và đây là thuật toán của bạn. Và ở đây chúng ta phải tính toán thời gian, độ phức tạp, thời gian, giao dịch và ở đây chúng ta chia nhỏ từng dòng và phần tiếp theo này sẽ diễn ra trong thế giới ý chí này, bắt đầu ngay từ lần đánh bắt đầu tiên và tất cả những điều khác sẽ mất thời gian không đổi , độ phức tạp.

2792
00:12:45,850 --> 00:13:01,860
Và ở đây chúng tôi đã chia nhỏ các lần lặp lại cho cuộc sống của mình và ở đây chúng tôi có cách thực hiện. Nếu chúng ta cộng tất cả các lần thực hiện, thì chúng ta sẽ có kết quả như thế này một cộng hai cộng cộng bằng với thời gian kết thúc cộng một chia hai.

2793
00:13:02,220 --> 00:13:11,710
Và ở đây chúng ta có phương trình này theo bình phương cộng với hai được thêm vào. Và mức độ của tình huống là N bình phương. Điều đó có nghĩa là số hạng tích phân cao nhất là số bình phương.

2794
00:13:11,910 --> 00:13:21,040
Vì vậy, độ phức tạp về thời gian đủ lớn và vuông góc và độ phức tạp về không gian là bằng
một vì bạn không sử dụng bất kỳ lời nói gốc nào hoặc chỉ sửa đổi khu vực nhất định. 

@@@



2795
00:00:01,020 --> 00:00:15,660
Này các bạn quay lại với video này nhé, trong video này chúng ta sẽ nói về thuật toán Buckshot. Bucket Short là một thuật toán sắp xếp hoạt động bằng cách phân phối các phần tử của mảng vào một số nhóm.

2796
00:00:15,670 --> 00:00:28,610
Sau đó, mỗi nhóm được sắp xếp riêng lẻ bằng cách sử dụng thuật toán sắp xếp khác hoặc bằng cách áp dụng đệ quy thuật toán sắp xếp nhóm. Đây là định nghĩa chính thức của thuật toán sắp xếp nhóm.

2797
00:00:29,550 --> 00:00:44,100
Vì vậy, chúng tôi được cung cấp mảng này. Chúng ta phải trả về mảng này. Đây là chưa được sắp xếp. Điều này đã được sắp xếp và bạn phải sắp xếp nó bằng cách sử dụng nhóm. Và trong video này, chúng ta sẽ tìm hiểu khái niệm về thuật toán tìm kiếm và cách thức hoạt động của nó.

2798
00:00:44,550 --> 00:00:57,840
Thuật toán sắp xếp nhóm chỉ hữu ích cho dữ liệu được phân phối đồng đều. Nếu dữ liệu không được phân bố đồng đều thì đầu ra của nhóm sẽ bị hỏng.

2799
00:00:58,530 --> 00:01:14,390
Bây giờ, hãy xem thuật toán nhóm hoạt động như thế nào và cách chúng ta có thể sắp xếp một mảng bằng cách sử dụng nhóm ngắn. Vì vậy, đầu tiên chúng ta sẽ tạo một số nhóm. Điều đó có nghĩa là trước tiên chúng ta sẽ tìm ra số thùng bằng cách sử dụng một công thức đơn giản, bằng cách lấy tỷ lệ.

2800
00:01:14,400 --> 00:01:33,170
Tầng căn bậc hai của chiều dài của mảng đó sẽ lặp qua phần tử của nó và đặt nó vào thùng thích hợp, sinh học thích hợp để chèo thuyền, rồi nhân số lượng xô lên 12 lần và sẽ chia cho giá trị lớn nhất trong diện tích.

2801
00:01:33,720 --> 00:01:44,220
Và đây là nơi chúng ta có thể tìm thấy thùng thích hợp. Và sau đó chúng ta sẽ sắp xếp tất cả các nhóm và gần như tất cả các nhóm và sau đó chúng ta sẽ có được mảng vững chắc.

2802
00:01:44,460 --> 00:01:59,240
Bây giờ hãy xem nó hoạt động như thế nào. Ví dụ: nếu bạn được cho mảng này, trước tiên chúng ta phải tìm ra số lượng nhóm để tìm số lượng nhóm. Sử dụng công thức này và anh ta sẽ lấy cô gái bán hàng, căn bậc hai của đậu lăng của sự khốn khổ.

2803
00:01:59,460 --> 00:02:10,920
Vì vậy, xếp hàng Ariston này để căn bậc hai của quần vợt ba điểm gì đó. Và nếu chúng ta lấy điểm âm tiết thì sẽ bị quá tải nên chúng ta sẽ xây dựng bốn dấu ngoặc.

2804
00:02:10,920 --> 00:02:20,960
Chúng tôi không có thùng nào bằng bốn ở đây. Xô nghèo. Sau đó, chúng ta sẽ xem xét nó là ilmenite và cho nó vào thùng thích hợp. Đầu tiên chúng ta có 40.

2805
00:02:21,570 --> 00:02:44,790
Vì vậy, trong túi của anh ta, chúng ta sẽ nhét 40. Vậy xô bằng giá trị bán nhân với số nhóm chúng ta có bốn nhóm. Vì vậy, 40 lần bằng một trăm sáu mươi và một trăm sáu mươi chia giá trị tối đa trong một trăm một điểm này có nghĩa là việc bán một điểm gì đó là mười bốn.

2806
00:02:44,790 --> 00:03:03,420
Tất cả đều đi vào nhóm này để sau đó chúng ta có thể tìm ra nhóm thích hợp bằng cách sử dụng công thức này. Sau đó tất cả sẽ vào thùng này, một ba mươi sẽ vào thùng này, tương tự như vậy, chín mươi sẽ vào thùng này, sau đó một do sẽ vào thùng này cho bảy mươi.

2807
00:03:03,420 --> 00:03:17,250
Tất cả đi vào thùng này. Ba hai mươi nó vào xô một sáu mươi vào xô. Ba người vào xô hai và một trăm người đều vào xô.

2808
00:03:17,790 --> 00:03:30,480
Bây giờ đây là thùng của bạn. Chúng tôi đã chèn đúng phần tử vào nhóm thích hợp. Bây giờ chúng ta sẽ sắp xếp thùng. Nếu chúng ta thấy xô hoặc xô sẽ được đại diện.

2809
00:03:30,480 --> 00:03:51,870
Một cái gì đó như thế này. OK, bây giờ nhóm của chúng ta đã được sắp xếp. Bây giờ mục tiêu của chúng tôi là hợp nhất tất cả các nhóm và đổi lại khả năng làm chủ đó. Và nếu chúng ta hợp nhất các nhóm thì chúng ta sẽ nhận được số này cứ sau 10, 20, 30, 40, 50 và 60, 70, 80, 90, 100.

2810
00:03:52,500 --> 00:04:01,980
Và đây là cách nó hoạt động. Bây giờ, hãy để tôi chỉ cho bạn thuật toán và sau đó chúng ta sẽ xem nó thực sự hoạt động như thế nào theo từng dòng một. Đây là thuật toán của chúng tôi cho nhóm.

2811
00:04:01,980 --> 00:04:20,040
Chúng ta có nên sử dụng số nhóm công thức này để tính căn bậc hai của chiều dài của mảng đã cho, sau đó là giá trị tối đa và tối thiểu không? Được rồi, bằng cách sử dụng cái này, nếu chúng ta định tìm ra giá trị tối thiểu và giá trị tối đa và sau đó chúng ta khai báo một nhóm có trang web của.

2812
00:04:21,220 --> 00:04:39,480
Số lượng nhóm chúng tôi đã tính toán ngay tại đây, sau đó chúng tôi tạo số lượng nhóm cần chèn vào danh sách này, sau đó chúng tôi chèn phần tử phù hợp vào nhóm thích hợp, sau đó chúng tôi sắp xếp là nhóm và sau đó chúng tôi sẽ hợp nhất các nhóm xô sử dụng công thức này.

2813
00:04:40,220 --> 00:04:50,160
Ở đây bạn đang sử dụng quicksort và bạn có thể sử dụng bất kỳ loại nào khác như Morisot bất kể thế nào. Và hãy xem điều này thực sự hoạt động như thế nào. Một lần nữa cho sự hiểu biết siêu việt.

2814
00:04:50,240 --> 00:05:05,330
Giả sử chúng ta đang đưa ra mảng này và chúng ta có ở đây cho nhóm bằng cách thực hiện công thức này. Vì vậy, Martin sẽ được đánh giá ba điểm một cái gì đó và nói yêu ba điểm một cái gì đó là bốn siêu thị hiện nay 40 cho 40.

2815
00:05:05,510 --> 00:05:20,380
Xô thích hợp là 40 nhân bốn, chia cho một trăm một phẩy sáu. Việc bán một điểm sáu là đến bốn mươi. Will đi tới chỗ này. Vậy là Forty Will đi vào thùng này đến mười lần mười.

2816
00:05:20,390 --> 00:05:33,760
Bốn mươi bốn chia một điểm không một cái gì đó thật chân thành đi vào thùng này một xu sau đó Thada chậm trễ cho mỗi một trăm hai mươi và một trăm hai mươi chia một trăm là một điểm ba.

2817
00:05:33,770 --> 00:05:51,740
Vậy việc bán một điểm ba là hai. Vì vậy, Taroom đi đến thùng này tới chín mươi bốn lần chín mươi bốn lần chín mươi cuộc gọi tới ba trăm sáu mươi ba trăm sáu mươi chia một trăm bằng ba điểm sáu.

2818
00:05:52,400 --> 00:06:03,830
Đó là đánh giá việc bán ba điểm sáu là bốn. Vì vậy, 92 đi vào nhóm này và chúng ta có thể tìm ra nhóm thích hợp bằng cách sử dụng công thức này khá dễ dàng.

2819
00:06:04,580 --> 00:06:18,260
Và đây là công thức và nó sẽ di chuyển đến nhóm này rồi bảy đến nhóm này. Ba hai mươi đi vào thùng này. Một sáu mươi. Ai đi đến cái xô này.

2820
00:06:18,260 --> 00:06:30,740
Ba năm mươi thuộc về thùng hai trăm một trăm này. Bây giờ nó đi vào thùng này. Công việc của chúng ta là sắp xếp thùng theo thứ tự thùng là thùng.

2821
00:06:30,740 --> 00:06:47,810
Chúng tôi nhận được cái xô này. Được rồi, bây giờ mục tiêu của chúng ta là hợp nhất tất cả các nhóm bùng nổ nhóm đầu tiên là 10, sau đó là 20, rồi 30, 40, 50, 60, 70, 80, 90, 100. Vậy là tất cả đều là nhóm.

2822
00:06:47,810 --> 00:07:03,080
Chúng tôi nhận được mảng này và loại nhóm này hoạt động. Chúng tôi đã hiểu khái niệm xô ngắn. Nếu diện tích không được phân bố đồng đều thì mục đích bán khống vé sẽ bị thất bại.

2823
00:07:03,320 --> 00:07:26,660
Tất cả các phần tử đều chỉ được đưa vào một nhóm và phần đó sẽ trở nên tồi tệ nhất, trở nên lớn hơn trong thời gian phức tạp đáng sợ. Và đó là điều tồi tệ nhất. Và trong trường hợp tốt nhất mà điều này sẽ xảy ra, nếu dữ liệu được phân phối đồng đều, thì độ phức tạp về thời gian đó sẽ lớn hơn đối với mỗi lần đăng nhập đối với thuật toán sắp xếp nhanh.

2824
00:07:26,660 --> 00:07:51,660
Và nếu chúng ta cộng tất cả phần giảm của độ phức tạp thời gian và chúng ta nhận được dữ liệu đầu vào lớn hơn khi chúng ta đi vào, cộng với chúng ta đi vào, cộng với chúng ta đi vào. Và độ phức tạp về thời gian tổng thể sẽ lớn hơn khi đăng nhập vào quicksort hoặc khu nghỉ dưỡng của tôi thuật toán hoặc bất kỳ thuật toán nào bạn sử dụng để sắp xếp nhóm và độ phức tạp về không gian sẽ lớn hơn ở bạn.

2825
00:07:51,670 --> 00:08:08,120
Sau đó, bạn sẽ không cần thêm dung lượng, nhưng bạn phải xây dựng nhóm để độ phức tạp về không gian sẽ lớn hơn. Nếu dữ liệu không được phân bổ đồng đều thì độ phức tạp về thời gian sẽ lớn đối với Entocort và đó không phải là nhóm ngắn.

2826
00:08:08,390 --> 00:08:18,800
Nếu dữ liệu được phân phối đồng đều thì chúng tôi mới cân nhắc sử dụng loại nhóm. Đúng
rồi các bạn, chúng ta đã hiểu khái niệm xô ngắn rồi. Cảm ơn đã xem video này. 

@@@



2827
00:00:01,220 --> 00:00:11,480
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về thuật toán sắp xếp sao Hỏa, đây là một trong những thuật toán sắp xếp hiệu quả.

2828
00:00:11,810 --> 00:00:29,390
Bây giờ hãy xem lượng muối thực sự có tác dụng trong video này. Chúng ta sẽ xem muối có tác dụng như thế nào. Sau đó, bạn sẽ thấy lời giải thích từng dòng một. Sau đó, bạn sẽ thấy thời gian chạy phân tích từng phân chia chính và đầu vào thành hai trung tâm.

2829
00:00:29,960 --> 00:00:41,830
Hãy thực hiện việc phá vỡ hai trung tâm đó theo cách đệ quy cho đến khi chúng trở nên đủ đơn giản để giải quyết, sau đó loại bỏ các phần bị hỏng được hợp nhất lại với nhau. Chúng ta sẽ thấy điều này thực sự hoạt động như thế nào.

2830
00:00:42,170 --> 00:00:55,440
Đây là định nghĩa chính thức của thuật toán sắp xếp sao Hỏa. Ví dụ: nếu bạn được cung cấp mảng này bằng thuật toán này, chúng ta phải sắp xếp mảng này theo thứ tự tăng dần, đại loại như thế này.

2831
00:00:56,150 --> 00:01:06,540
Vì vậy, đối với mảng đã cho này, chúng ta phải trả về mảng này. Bây giờ, hãy xem lượng muối thực sự có tác dụng như thế nào đối với sự hiểu biết của Sidcup. Giả sử chúng ta đang đưa ra mảng này.

2832
00:01:07,100 --> 00:01:16,010
Bây giờ, chúng ta sẽ chia giờ này thành hai bước bằng cách thực hiện một công thức đơn giản, chỉ mục của phần tử đầu tiên, cộng với chỉ mục của phần tử cuối cùng.

2833
00:01:16,370 --> 00:01:30,770
Vậy 0 cộng sáu chia ba sẽ bằng ba. Vì vậy, ở nửa đầu, chúng ta có phần tử từ 0 đến 3. Và ở phần tử thứ hai từ đầu đến cuối và chúng ta sẽ chia nó thành hai bước theo chiều sâu của DFS.

2834
00:01:30,770 --> 00:01:41,720
Vấn đề đầu tiên. Vì vậy, trước tiên, chúng ta sẽ chia nó thành nửa này. Vì vậy, trong ngôi nhà này, chúng ta có bốn yếu tố này. Và một lần nữa, chúng tôi sẽ chia nhỏ bản tóm tắt này thành hai phần.

2835
00:01:42,020 --> 00:01:53,560
Sau đó, chúng tôi nhận được điều này từ bản tóm tắt này. Và một lần nữa, chúng ta sẽ chia nhỏ nó ra, bản tóm tắt này, và sau đó chúng ta chỉ có một bản tóm tắt này và chúng ta không thể chia nhỏ nó ra nữa.

2836
00:01:53,780 --> 00:02:05,600
Sau đó chúng ta hãy đi sang bên phải bên phải của cả hai. Và bây giờ chúng ta sẽ sắp xếp và hợp nhất hai sabari này ở đây. Chúng ta sẽ sử dụng kỹ thuật được gọi là hợp nhất hai mảng đã được sắp xếp.

2837
00:02:05,780 --> 00:02:20,660
Và điều đó cực kỳ đơn giản, nếu chúng ta hợp nhất và sắp xếp mảng này thành mảng hai sẽ di chuyển đến đây và bốn sẽ di chuyển đến đây. Được rồi, vậy là chúng ta đã hấp thụ Sabari này và Sabari này. Chúng tôi nhận được hai.

2838
00:02:20,660 --> 00:02:32,850
Và bây giờ, hãy chia nó thành nửa sau của quá trình khám phá để chúng ta có được năm và tám. Và hãy chia nhỏ nó hơn nữa. Chúng tôi nhận được năm và tám. Bây giờ, bạn định làm gì?

2839
00:02:32,870 --> 00:02:42,800
Chúng ta sẽ tới sao Hỏa và sắp xếp hai bài phát biểu đơn lẻ này nếu được hợp nhất. Và thế là hai nốt đơn này, chúng ta có năm và tám. Bây giờ, bạn định làm gì? Chúng ta sẽ tới sao Hỏa.

2840
00:02:42,970 --> 00:02:58,790
Hai mảng này được sắp xếp tóm tắt và hai mảng này được sắp xếp. Vì vậy, nếu chúng ta hợp nhất hai mảng đã được sắp xếp này thì chúng ta sẽ có được hai mảng. Sau đó cho 5 cái nó như vậy nó sẽ gộp 2 cái này lại và sắp xếp riêng biệt.

2841
00:02:58,800 --> 00:03:09,710
Lấy cái Southbury này hai, bốn, năm nó. Vậy là bây giờ chúng ta đã hoàn thành phần bên trái. Bây giờ chúng ta hãy chuyển sang phần bên phải và đây là phần bên phải. Và hãy chia nó thành hai bước.

2842
00:03:09,800 --> 00:03:21,050
Ở bên trái chúng ta có hai phần tử. Và một lần nữa, hãy chia nhỏ nó ra. Chúng ta có sáu và ở đây chúng ta có chín. Chúng ta không thể chia nó thành sáu và chúng ta không thể chia nó thành chín nữa.

2843
00:03:21,440 --> 00:03:37,220
Vì vậy bây giờ hãy sắp xếp chúng và hợp nhất chúng. Vậy nếu chúng ta hợp nhất và tách hai cái này ra, chúng ta sẽ có sáu và chín. Bây giờ chúng ta hãy đi sang bên phải bên phải. Và bây giờ hãy hợp nhất và sắp xếp hai mảng được sắp xếp này và tóm tắt lại.

2844
00:03:37,230 --> 00:03:52,010
Vậy hai cái này tách ra, ta được một sáu, chín, một, sáu và chín. Bây giờ chúng ta đã giải quyết được vấn đề này để tách trái và phải. Và ở đây chúng ta thấy rằng hai cái riêng biệt này được sắp xếp theo thứ tự.

2845
00:03:52,130 --> 00:04:10,160
Chúng được sắp xếp. Vì vậy, nếu chúng ta hợp nhất hai mảng được sắp xếp này, thì chúng ta sẽ có được mảng được sắp xếp, đại loại như thế này một, rồi hai, rồi ở đây cho một, hai, bốn, rồi ở đây chúng ta sẽ có năm, rồi sáu, rồi tám và chín.

2846
00:04:10,430 --> 00:04:27,380
Được rồi. Vì vậy, nó sẽ được hợp nhất và sắp xếp. Là hai riêng biệt. Sau đó, chúng tôi gặp lỗi này và đây là cách hợp nhất các loại ngắt. Chúng tôi sẽ phá vỡ nó. Cái đã cho đã sắp xếp hai trung tâm bằng cách sử dụng đệ quy và sẽ chia nhỏ nó bằng cách sử dụng độ sâu.

2847
00:04:27,380 --> 00:04:38,230
Tìm kiếm đầu tiên được gọi là độ sâu, lần đầu tiên duyệt qua những thứ tương tự. Và đây là cách nó hoạt động. Bây giờ hãy xem thuật toán và sau đó chúng ta sẽ xem nó thực sự hoạt động như thế nào.

2848
00:04:38,240 --> 00:04:50,450
Một lần nữa, đây là thuật toán tổng thể. Đầu tiên bạn có chức năng này, loại của tôi. Phải mất mảng nums trái và phải. Nếu bên phải lớn hơn bên trái thì chúng ta sẽ tính phần giữa bằng cái này.

2849
00:04:50,480 --> 00:05:12,960
Trái, cộng phải, trừ hleb chia hai. Chúng ta có thể làm điều đó một cách đơn giản là trái cộng phải. Chia hai mà tràn nhất. Đó là lý do tại sao chúng tôi đang sử dụng cái này. Họ gọi hàm này là Amersfoort bằng các con số, để lại tôi và các số sắp xếp của tôi là Metellus ở bên phải theo cách đệ quy và họ đang hợp nhất và sắp xếp hai sabari.

2850
00:05:13,190 --> 00:05:26,720
OK, và đây là chức năng của sao Hỏa và sắp xếp hai sabari. Chúng tôi có thang máy tạm thời. Phải tạm thời sau đó sao chép lại phần tử từ mảng của chúng tôi để tạm thời và tạm thời bên phải.

2851
00:05:26,900 --> 00:05:39,460
Và vào cuối tháng 9, chúng tôi đã chèn số nguyên tối đa chỉ dành cho thuộc tính Marsing. Và điều đó thật thú vị. Và sau đó bạn sẽ có thể hướng lên sao Hỏa để đoàn kết.

2852
00:05:39,470 --> 00:05:49,010
Và điều này cực kỳ thú vị và siêu đơn giản. Bây giờ hãy xem cách nó hoạt động và chúng ta sẽ gọi hàm này một cách đệ quy như thế này.

2853
00:05:49,790 --> 00:06:00,620
Và chúng ta không thể gọi hàm này nữa. Chúng tôi đã đề cập đến Sabari này. Bây giờ hãy gọi thông báo Mussert này là cộng một và. Phải. Và sau đó chúng tôi nhận được bốn và hai.

2854
00:06:00,830 --> 00:06:14,500
Bây giờ, hãy sắp xếp nó. Sử dụng hàm murse này, hàm này sẽ hợp nhất và sắp xếp cả hai. Southbury Satou sẽ chuyển đến đây và bốn người sẽ chuyển đến đây. Bây giờ, hãy gọi nó bằng bên phải, nhưng phần bên phải là năm và tám.

2855
00:06:14,510 --> 00:06:33,770
Parlette bên trái. Thế thì năm là bao nhiêu. Đúng, nhưng đúng là có tám. Bây giờ chúng ta sẽ hợp nhất hai phần này ở đây. Chúng tôi đã xử lý phần này thành bản tóm tắt ở đây và sau đó hãy xử lý phần này để hợp nhất hai hình elip riêng biệt này cho mùa hè này và bên phải tương đương với bản tóm tắt tạm thời này.

2856
00:06:33,770 --> 00:06:46,240
Và sau đó chúng ta cộng số nguyên tối đa này chỉ nhằm mục đích sắp xếp, chỉ nhằm mục đích sắp xếp và phân tích cú pháp. Sau đó, chúng ta sẽ hợp nhất phần này để chèn tập và hợp nhất hai samarium này.

2857
00:06:46,260 --> 00:06:58,220
Sau đó, chúng tôi nhận được điều này và chúng tôi sẽ hợp nhất. Và thật đáng lo ngại, tôi đã không đạt được bốn điều đó. Vậy đây là hai, rồi bốn. Như vậy bạn thấy bản tóm tắt này hiện đã được sắp xếp.

2858
00:06:58,220 --> 00:07:07,280
Hai, bốn, năm, tám. Bây giờ hãy gọi nó với phần bên phải. Con đường đúng đắn là sáu chín một. Hãy gọi nó là bên trái. Bên trái là sáu chín và bên phải là một.

2859
00:07:07,490 --> 00:07:19,840
Và sau đó là bên trái của sáu. Chín là sáu và bên phải là chín. Bây giờ hãy sắp xếp Soran hợp nhất hai Sabari này. Và nếu chúng ta làm điều đó, thì tôi sẽ nhận được bản tóm tắt này. OK, điều này đã được sắp xếp.

2860
00:07:20,180 --> 00:07:33,620
Bây giờ hãy gọi nó là cái này và chỉ chúng ta có một cái. Không, hãy hợp nhất hai mảng được sắp xếp này. Sau đó chúng ta sẽ có một sáu, rồi chín. Vì vậy, bây giờ mảng bên trái và bên phải.

2861
00:07:33,860 --> 00:07:57,590
Chúng ta sắp xếp các mảng bên trái này thành các mảng bên phải và đây là Sabari. Có thể hợp nhất hai mảng được sắp xếp này. Sau đó, chúng tôi nhận được một cái gì đó như thế này. Bây giờ chúng ta thấy rằng nếu chúng ta Meur hai mảng đã sắp xếp này và đến khu vực này, chúng ta có thể hợp nhất mảng này với mảng đã sắp xếp bằng cách sử dụng hàm murres này và đây là cách tìm kiếm của tôi hoạt động, hiểu khái niệm này.

2862
00:07:58,010 --> 00:08:09,410
Khi bạn hợp nhất hai khung con bên trái này, chúng tôi sẽ sửa đổi phần tử theo thứ tự dành cho khu vực chính. Và bạn chỉ phát ngán vì hiểu biết. Đúng vậy.

2863
00:08:09,670 --> 00:08:22,280
Chúng tôi chỉ đang sửa đổi điều đó ngay tại đây. Nhưng thực ra chúng tôi đang thêm giá trị đó vào danh sách của mình vì chúng tôi đang sử dụng tài liệu tham khảo ở đây. Chúng tôi chỉ gửi mảng đã cho và ở đây chúng tôi chỉ trực tiếp thêm vào khu vực đó.

2864
00:08:22,670 --> 00:08:33,140
Chúng tôi sẽ không hợp nhất khu vực đó vào khu vực tạm thời của chúng tôi. Và phần tử đó chúng ta sẽ chèn vào đúng vị trí vào mảng chính của mình. Đừng nhầm lẫn về điều đó.

2865
00:08:33,140 --> 00:08:41,390
Chỉ vì sự hiểu biết. Chúng tôi chỉ đang hợp nhất hai cái này và chúng tôi sẽ ném nó vào đây. Chúng tôi thực sự đang thêm giá trị này vào tình trạng vô kinh của mình.

2866
00:08:41,390 --> 00:08:51,770
OK, chúng ta đã hiểu thuật toán sắp xếp hợp nhất và đây là cách thuật toán của tôi hoạt động. Bây giờ, hãy để tôi phân tích độ phức tạp về thời gian, độ phức tạp và độ phức tạp của không gian.

2867
00:08:51,890 --> 00:09:04,520
Độ phức tạp về không gian của giải pháp này lớn hơn vì chúng tôi đang tạo một mảng tạm thời cho Austudy. Chúng ta sẽ tạo hai phần tạm thời và chia hai và chia hai.

2868
00:09:04,790 --> 00:09:29,720
Vì vậy, độ phức tạp của không gian tổng thể lớn hơn. Bây giờ hãy để tôi phân tích sự phức tạp về thời gian đó. Được rồi, ở đây chúng ta chia nhỏ nó ra từng dòng và chúng ta phải tính toán t này theo độ phức tạp về thời gian đối với độ dài của các mảng đã cho và thao tác này cần một số lớn hơn thao tác này cần lớn hơn một.

2869
00:09:29,990 --> 00:09:41,170
Và chúng tôi chỉ chia mảng này cho hai trung tâm. Đã đến lúc thực hiện ngăn xếp cuộc gọi đệ quy này và sau đó chúng ta là Marsing, hai Southbury và chức năng này cuối cùng sẽ hoạt động.

2870
00:09:41,180 --> 00:09:59,660
Ở đây bạn có thể thấy cách chúng tôi có thể tính toán vì cuối cùng chúng tôi chỉ có một số tính toán siêu đơn giản. Vì vậy, hàm này sẽ bắt đầu. Vì vậy, nếu chúng ta cộng tất cả độ phức tạp theo thời gian ở đây t của bất đẳng thức, vì một lớn của một thì T của bất kỳ ai hòa tan vào hai cộng trong.

2871
00:09:59,740 --> 00:10:14,890
Ở đây chúng tôi đang thực hiện các vụ hành quyết, vì vậy ở đây có hai điều và đó là chúng tôi có ở thành phố này những kẻ bất hợp pháp để phát bóng với thái độ nhựa. Bạn có bất cứ nơi nào để cắm vào và chúng ta có thể bỏ qua vì một nơi vì chúng không đổi.

2872
00:10:15,780 --> 00:10:25,180
Bây giờ, hãy để tôi chỉ cho bạn cách chúng ta có thể tìm thời gian, độ phức tạp để tìm thời gian của nó, độ phức tạp cập nhật ngược lại thay thế. Bây giờ hãy xem chúng ta có thể làm điều đó như thế nào.

2873
00:10:25,960 --> 00:10:41,320
Được rồi, chúng ta được cho cái này nên chúng ta tìm ra phương trình của một niken để hòa tan trong hai cái kia cộng với hai lên và chia để cắm nó vào. Và nếu chúng ta thêm cái này vào phần mở đầu bằng hai, thì chúng ta sẽ đi đến phần cuối của cắm nó vào.

2874
00:10:41,320 --> 00:10:55,000
Và đây chỉ là một. Và nếu chúng ta thay thế bất kỳ ai vào phương trình một, thì chúng ta sẽ có được phương trình này và bạn có thể tính nó bằng cách thay bất kỳ ai vào phương trình một này.

2875
00:10:55,570 --> 00:11:07,810
Bây giờ, nếu chúng ta thay phương trình này vào phương trình một, thì chúng ta sẽ có được phương trình này. Bạn có gần đến trạng thái lúc khởi hành khi cố gắng thực hiện thanh hai cộng hai lần không?

2876
00:11:08,020 --> 00:11:20,270
Một lần nữa, nếu chúng ta chèn số chia 4 ở phần cam kết vào phương trình một, thì chúng ta sẽ có được phương trình này. Nếu chúng ta thay thế phương trình này ba vào phương trình, một phương trình đó sẽ có được phương trình này.

2877
00:11:21,040 --> 00:11:31,690
Vì vậy, ở đây chúng tôi tìm ra một mô hình. Mô hình được xác định là điều gì đó xảy ra như thế này tương đương với các phần nằm sâu trong thung lũng, bên phải cộng với tám lần vào trong.

2878
00:11:32,140 --> 00:11:44,650
Đây là mô hình chúng tôi đã xác định. Lần này chúng ta đang gọi hàm Marzotto hoặc chúng ta đang gọi với cá nhân mà chúng ta đang gọi là các hàm chính.

2879
00:11:44,950 --> 00:11:56,250
Chúng ta đang chia mảng đó thành hai nửa là thời gian. Tại một thời điểm nào đó, chúng ta sẽ tìm thấy trong Divided cách đặt các biểu tượng thành một để chúng ta có thể giả định rằng trong phần dành cho thanh bằng một.

2880
00:11:56,560 --> 00:12:09,610
Và ở đây, nếu chúng ta giải quyết được vấn đề này, chúng ta sẽ gặp may mắn với bất kỳ cuộc gọi nào tới Tôi có thể thay thế I vào tình huống bằng may mắn thứ hai. Và sau đó chúng ta có được phương trình này ở đây để thực hiện khóa nguồn cho đến hết.

2881
00:12:09,640 --> 00:12:24,940
Nó sẽ được tải vào và ở đây D chia thành vì điều này sẽ liên quan đến và sau đó chúng ta có khóa để kết thúc thời gian ở đây. Chúng tôi tìm hiểu về thời gian bật cộng với khóa kết thúc ở loại một.

2882
00:12:24,940 --> 00:12:38,450
Vì vậy chỉ mất thời gian liên tục, phức tạp và đây là một cái giỏ. Vì vậy, khi bạn có các cạnh của mảng hoặc khi bạn gọi đệ quy, thì chỉ cần thực hiện một lần thực thi để chúng ta có thể lập luận khi anh ta thực hiện một lần.

2883
00:12:39,490 --> 00:13:00,940
Vì vậy, trong nhân một cộng đăng nhập để kết thúc lần trong và cuối cùng chúng ta nhận được cộng khóa vào trong, nhân với. Và đây là số hạng cao nhất trong phương trình này. Vì vậy, sự phức tạp về thời gian là do trong những thời điểm muốn kết thúc, nên chúng tôi phát hiện ra rằng sự phức tạp về thời gian là do thời gian bị khóa để kết thúc.

2884
00:13:01,330 --> 00:13:16,520
Và độ phức tạp về không gian là do trong và đây là thuật toán được suy nghĩ nhiều nhất. Chúng tôi đã hiểu chi tiết thuật toán của tôi.
Ngoài ra, nếu tôi hiểu phân tích thời gian chạy, nếu bạn gặp bất kỳ vấn đề nào với các bổ sung trước đó, hãy cho chúng tôi biết. 

@@@



2885
00:00:00,960 --> 00:00:10,950
Này các bạn quay lại với video này trong video này chúng ta sẽ nói về một thuật toán ngắn gọn nhanh chóng. Đây là một trong những thuật toán sắp xếp hiệu quả.

2886
00:00:11,950 --> 00:00:26,880
Trong video này, bạn sẽ thấy tính năng ngắn hoạt động nhanh như thế nào và tất cả thông tin bạn cần hiểu. Thuật toán nhanh, ngắn gọn thì mình nói hết về phân tích ngẫu nhiên của thuật toán này cho nhanh.

2887
00:00:26,950 --> 00:00:44,200
Chắc chắn. Nó hoạt động bằng cách chọn một phần tử trục từ mảng và nó sẽ phân vùng tại điểm xoay thành hai trung tâm trong đó phần tử nhỏ hơn ở bên trái và phần tử lớn hơn ở bên phải, nó sẽ tiếp tục thực hiện quy trình này một cách đệ quy cho đến khi toàn bộ mảng được sắp xếp .

2888
00:00:44,920 --> 00:01:07,380
Ví dụ: nếu bạn được cung cấp mảng này, bạn phải trả về thứ tự tăng dần của mảng đã sắp xếp này bằng cách sử dụng khái niệm thuật toán sắp xếp nhanh. Khái niệm là trước tiên bạn phải chọn một trục và chúng ta phải phân vùng mảng đó dựa trên trục xoay tất cả phần tử trên trục trái hoặc lasdun và tất cả phần tử ở bên phải, trục xoay đều tuyệt vời.

2889
00:01:07,490 --> 00:01:18,100
Sau đó, hãy để tôi chỉ cho bạn thấy thuật toán thực sự hoạt động nhanh như thế nào. Chúng ta sẽ xem xét phần tử ngoài cùng bên phải, phần tử trục. Được rồi, bây giờ hãy xem nó hoạt động như thế nào.

2890
00:01:18,790 --> 00:01:31,210
Để dễ hiểu, hãy giả sử rằng chúng ta đang đưa ra mảng này ở đây. Chúng ta có số chỉ mục từ 0 đến 8 và đầu tiên chúng ta sẽ chọn vị trí thứ 5 này và phép đệ quy mới này được gọi là 3.

2891
00:01:31,780 --> 00:01:44,020
Và điều này sẽ giải quyết vấn đề này. Đừng lo lắng. Trước tiên, hãy xem cách chúng ta có thể giải quyết vấn đề này và giải quyết vấn đề này một cách sâu sắc. Vấn đề đầu tiên hoặc trong vấn đề DFS.

2892
00:01:44,470 --> 00:02:02,080
Hãy xem làm thế nào. Vì vậy, đây là phần tử trục ban đầu của chúng ta và chúng ta phải chèn phần tử trục này vào đúng vị trí nơi chúng ta có phần tử bên trái là lasdun và phần tử bên phải lớn hơn chúng ta phân vùng mảng này bằng cách coi năm là trục.

2893
00:02:02,080 --> 00:02:11,890
Sau đó, chúng tôi nhận được mảng này. Được rồi, đây là năm, đây là trục xoay. Và ở bên trái, chúng ta có tất cả các phần tử nhỏ hơn ở bên phải, tất cả các phần tử đều lớn hơn trục.

2894
00:02:11,890 --> 00:02:24,910
Và ở đây chúng ta thấy chúng ta có chỉ số tổng hợp dành cho. Chúng ta sẽ xem cách chúng ta có thể phân vùng mảng này theo điểm mấu chốt này. Đừng lo lắng về điều đó. Sau đó chúng ta sẽ di chuyển sang trái và ở bên trái chúng ta có từ 0 đến 3.

2895
00:02:24,910 --> 00:02:43,300
Và ở đây chúng ta có số chỉ mục và chúng ta sẽ chọn xoay vòng và xoay vòng sẽ là chỉ mục THÊM của chúng ta, được chứ? Và tất cả những thứ khi chúng ta nhìn thấy bên trái đều lớn hơn bên phải và chúng ta sẽ xem xét bất cứ khi nào chúng ta triển khai thuật toán, sau đó chúng ta sẽ xem nó hoạt động như thế nào.

2896
00:02:43,990 --> 00:02:53,950
Vì vậy, cả hai sẽ chuyển sang chỉ mục hai này và chúng tôi phân vùng vòng lặp này thành hai bước nhảy. Phần bên trái nhỏ hơn và phần bên phải lớn hơn.

2897
00:02:54,070 --> 00:03:05,140
Vậy là chúng ta đã phân vùng mảng này bằng cách xét trục xoay, bây giờ chúng ta hãy chuyển sang bên trái. Ở bên trái, chúng ta có một cái ở chỉ số 0 sẽ xem xét việc xoay phần tử này lên chính nó.

2898
00:03:05,470 --> 00:03:15,360
Vì vậy, không cần phải làm gì ở đây. Chỉ có chúng tôi chỉ có một yếu tố. Và để thực hiện thuật toán, chúng ta sẽ thấy hai quyền tự do cơ bản đã được thống nhất.

2899
00:03:15,370 --> 00:03:27,760
Phải. Và ở đây chúng ta chuyển sang lưới Leptis bên phải. Phải. Vì vậy, chúng ta sẽ dừng lại và sẽ thấy điều đó khi chúng ta triển khai thuật toán. Bây giờ chúng ta hãy đi sang bên phải của nút này.

2900
00:03:27,940 --> 00:03:38,830
Hãy xem xét điều này không phải như vậy. Chúng ta hãy đi sang bên phải của nút này. Và chúng ta ở đây, hai, ba. Vì vậy, trong khoảng từ hai đến ba, hãy chọn ba eSport. Vì vậy, chúng tôi chọn ba vị trí.

2901
00:03:39,160 --> 00:03:50,890
Sau đó nó sẽ chuyển sang chỉ số hai. Điều này sẽ được thể hiện, đại loại như thế này. Và sau đó chúng ta có một ở bên trái. Đây là những gì chúng tôi phân tích thuật toán để triển khai thuật toán của chúng tôi.

2902
00:03:50,890 --> 00:04:00,520
Sau đó, chúng tôi sẽ xem nó hoạt động như thế nào và chia nhỏ từng thứ để bạn có thể hiểu rõ hơn. Khi đó chúng ta có ba và ba của bạn và chúng ta chỉ có một phần tử.

2903
00:04:00,520 --> 00:04:14,170
Vì vậy không cần phải làm gì cả. Đây là thời kỳ bị bao vây và chúng ta không phải làm gì ở đây và ở đây. Chúng tôi có hai bên trái và bên phải dành cho cuộc gọi đệ quy. Và chúng ta hãy đi bên phải hoặc bên trái của tuyến đường này.

2904
00:04:14,500 --> 00:04:28,240
Bây giờ chúng ta hãy đi sang bên phải. Và trong trường hợp này, chúng ta có năm và tám. Và ở đây, nếu chúng ta chọn nó, chúng ta chọn số 8 làm điểm xoay giữa chỉ số 5 và 8 này, thì điểm xoay của chúng ta sẽ là 7, Rudnic 7.

2905
00:04:28,240 --> 00:04:37,000
Vì vậy, nó sẽ được đại diện như thế này. Và nếu chúng ta tiếp tục thực hiện quá trình này thì nó sẽ giống như thế này. Sau đó, sáu trục của chúng tôi và sáu trục của chúng tôi sẽ di chuyển đến đây.

2906
00:04:37,000 --> 00:04:46,840
Thế thì chúng ta chỉ có bảy, bảy trong ba và chẳng có gì để làm ở đây, rồi chỉ còn chín Lip-Sync Không mệt mỏi và chưa có gì để làm ở đây. Và khu vực này là vững chắc.

2907
00:04:47,260 --> 00:04:59,020
Vì vậy, chúng tôi đang phân vùng khu vực bằng cách chọn một trục cho đến khi toàn bộ khu vực được sắp xếp. Chúng tôi đang thực hiện điều này trong cam kết. Vì vậy, điều này sẽ không tốn thêm bất kỳ bộ nhớ nào.

2908
00:04:59,080 --> 00:05:10,270
Nhưng điều này sẽ hoạt động với độ phức tạp không đổi và không gian. Bây giờ hãy xem điều này thực sự hoạt động như thế nào và chúng ta có thể xem cách chúng ta có thể phân vùng mảng bằng cách chọn một điểm xoay.

2909
00:05:10,570 --> 00:05:26,370
Được rồi. Ở bên phải chúng ta có cây đệ quy dạng cây và đây là Pivot, ban đầu mình sẽ chỉ ra phần ngoài của mảng này. Đây là P thì họ sẽ trỏ tới phần tử đầu tiên vào khu vực của chúng ta.

2910
00:05:26,640 --> 00:05:45,780
Bây giờ chúng ta sẽ kiểm tra xem có nhỏ hơn hoặc bằng trục xoay không, sau đó chúng ta sẽ di chuyển I điều đó có nghĩa là sẽ tăng giá trị của I sẽ chuyển sang trục tiếp theo và ngoài ra nếu tôi kết thúc Z trong trường hợp này chúng ta thấy rằng năm không phải là lớn hơn hoặc bằng tám.

2911
00:05:45,930 --> 00:05:58,890
Vì vậy, nó sẽ chỉ chuyển sang phần tử tiếp theo. Vì vậy họ sẽ chuyển sang phần tử này. Bây giờ chúng ta sẽ kiểm tra xem năm có lớn hơn hoặc bằng bốn hay không, chúng ta sẽ chuyển nó sang số tiếp theo.

2912
00:05:59,550 --> 00:06:12,890
Hãy bay ngay tới đây. Và bây giờ chúng ta sẽ làm như vậy, chúng ta sẽ chuyển hướng. Và nếu chúng ta đổi chỗ chúng, chúng ta sẽ có bốn ở đây và chúng ta có tám ở đây. Bây giờ, hãy chuyển sang phần tử tiếp theo.

2913
00:06:12,900 --> 00:06:29,420
Nếu chúng ta chuyển sang phần tử tiếp theo thì chúng sẽ trỏ đến phần tử thứ ba này. Và đây là điều chúng ta sắp làm, chúng ta sẽ kiểm tra xem một ống có lớn hơn hoặc bằng điểm hai ở đâu và chúng ta thấy năm lớn hơn ba.

2914
00:06:29,430 --> 00:06:46,320
Vì vậy, chúng ta sẽ chuyển sang phần tử tiếp theo. Phần tử tiếp theo là tám trong trường hợp này. Vì vậy hãy di chuyển đến đây tôi và hãy di chuyển. Cuối cùng chúng ta giao bóng ở A2 di chuyển ngay tại đây và G sẽ di chuyển sang trái.

2915
00:06:46,320 --> 00:06:58,410
Ngay tại đây. OK, bây giờ chúng ta hãy chuyển sang phần tử tiếp theo và chúng sẽ di chuyển ngay tại đây. Đây là chỉ vào yếu tố thứ sáu này. Bây giờ chúng ta hãy lấy một chiếc bánh có số lớn hơn hoặc bằng sáu.

2916
00:06:58,770 --> 00:07:09,480
Sau đó chúng tôi sẽ phục vụ. Tuy nhiên, chúng ta thấy năm không lớn hơn sáu nên không phải là mười hai. Hãy chuyển sang phần tiếp theo. Vì vậy, bây giờ cái này đang trỏ đến phần tử này.

2917
00:07:09,690 --> 00:07:23,090
Và trong trường hợp này, chúng ta thấy năm lớn hơn một. Vì vậy, những gì chúng ta sắp làm, chúng ta sẽ chuyển nó sang phần tiếp theo. Chúng ta sẽ di chuyển nó ngay tại đây và chúng ta sẽ giải quyết năng lượng này.

2918
00:07:23,250 --> 00:07:44,580
Vậy tám người sẽ di chuyển tới đây và một người sẽ di chuyển ngay tại đây. Bây giờ, hãy di chuyển sang bên phải và trỏ 0 vào phần tử số bảy này. Và chúng ta thấy rằng năm không lớn hơn bảy để chúng ta chuyển sang điểm 0 tiếp theo ở đây và ở đây chúng ta thấy hai nhỏ hơn năm.

2919
00:07:44,820 --> 00:07:57,410
Vậy năm lớn hơn hai. Vì vậy, chúng tôi sẽ làm, chúng tôi sẽ chuyển nó sang phần tiếp theo. Tôi sẽ chuyển đến đây, sau đó chúng ta sẽ đổi chỗ cho hai và sáu. Mật độ sắt sẽ di chuyển tới đây và sáu sẽ di chuyển tới đây.

2920
00:07:57,840 --> 00:08:08,490
Bây giờ, hãy chuyển nó sang phần tử tiếp theo. Và phần tử tiếp theo là chín. Vậy điểm này của năm thứ chín lớn hơn năm. Vì vậy bây giờ họ cần phải được thực hiện ở đây một lần nữa.

2921
00:08:08,490 --> 00:08:20,430
Hãy chuyển sang phần tiếp theo. Bây giờ đang trỏ đến P, và chúng ta thấy rằng P ít hơn ba lệnh gọi đến Z. Vậy chúng ta sẽ làm gì? Chúng tôi sẽ chuyển nó sang phần tiếp theo.

2922
00:08:20,430 --> 00:08:32,130
Tôi sẽ di chuyển ngay tại đây và chúng ta sẽ chuyển hướng I và Z, nếu chúng ta đổi chỗ cho nhau, tám người sẽ di chuyển tới đây và năm người sẽ di chuyển tới đây. Được rồi. Chúng ta đã hoàn thành lần lặp đầu tiên.

2923
00:08:32,400 --> 00:08:47,630
Sau lần lặp đầu tiên, chúng ta thấy rằng mảng này đã được chia thành hai nửa, đại loại như thế này. Vì vậy, sau lần lặp đầu tiên, chúng ta có được mảng này và chúng ta phân vùng mảng này tại điểm mấu chốt thứ năm.

2924
00:08:48,270 --> 00:09:00,750
Bây giờ, hãy giải quyết vấn đề này cho bên trái. Sabari, hãy nhặt cái này lên. Đây là trục xoay của chúng tôi và đang chỉ ra ngoài ranh giới mảng này. Sau đó, họ đang chỉ vào đây.

2925
00:09:01,530 --> 00:09:13,050
Chúng ta thấy bốn lớn hơn hai. Vì vậy bây giờ họ cần phải được thực hiện ở đây. Hãy chuyển sang phần tử tiếp theo ở đây. Điều tương tự. Ba lớn hơn hai. Vì vậy, không cần phải làm gì ở đây.

2926
00:09:13,080 --> 00:09:28,740
Hãy chuyển sang phần tiếp theo. Và ở đây chúng ta thấy rằng một nhỏ hơn hai. Vì vậy, chúng ta sẽ chuyển nó sang phần tử tiếp theo. Tôi sẽ chỉ ngay đây và sau đó chúng ta sẽ đổi hướng và một chiếc sẽ chuyển động ở đây và bốn chiếc sẽ chuyển động ở đây.

2927
00:09:29,460 --> 00:09:41,130
Hãy chuyển sang phần tử tiếp theo. Phần tử tiếp theo là hai. Vậy chúng sẽ chuyển động tới đây và ta thấy ta thấy có ít hơn hoặc bằng P nên chúng bằng nhau.

2928
00:09:41,130 --> 00:09:59,550
Vì vậy chúng ta sẽ chuyển sang phần tiếp theo. Tôi sẽ chuyển đến đây và chúng ta sẽ trao đổi cái này cho Ayanda. Vậy là hai người sẽ chuyển đến đây và ba sẽ chuyển đến đây. Vì vậy, sau lần lặp này, chúng ta nhận được mảng này và ở đây chúng ta đã phân vùng mảng này theo một hoặc hai điểm xoay này.

2929
00:09:59,550 --> 00:10:10,200
Vậy là chúng ta có được mảng này, đại loại như thế này. Và vấn đề này sẽ thực hiện việc phân vùng này bằng cách chọn điểm xoay. Và ở đây chỉ có bạn có một cái nếu chúng tôi chọn cái này làm trục.

2930
00:10:10,870 --> 00:10:23,800
Tôi nghĩ nó phải được thực hiện ở đây, nó đã ở vị trí hiện tại rồi ở đây sẽ đưa mọi người đến ngay đây và chúng ta sẽ phân vùng bản tóm tắt này và sau đó chúng ta sẽ phân vùng khu vực này bằng cách lấy một điểm mấu chốt.

2931
00:10:24,040 --> 00:10:33,430
Vì vậy, nếu chúng ta lấy trục quay là một, thì chúng ta sẽ có cái này là trục quay và sau đó chúng ta sẽ chiếm vị trí ở đây. Sau đó nó sẽ được hoán đổi và nó sẽ giống như thế này.

2932
00:10:34,180 --> 00:10:42,630
Và sau đó chúng ta sẽ nhận được sự trợ giúp xoay trục, phần mới được phân vùng. Sau đó chúng ta sẽ nhận được một cái gì đó như thế này. Sau đó, chúng ta sẽ lấy Pivot ngay ở đây sáu và nó sẽ giống như vậy.

2933
00:10:42,630 --> 00:10:52,370
Rồi chúng ta có bảy, rồi tám, chín. Và đây là cách chúng ta có thể giải quyết vấn đề này. Và đây là cách quicksort hoạt động. Như vậy là chúng ta đã hiểu được khái niệm thuật toán quicksort.

2934
00:10:52,840 --> 00:11:04,930
Bây giờ hãy xem thuật toán cho vấn đề này. Đây là thuật toán sắp xếp nhanh. Chúng ta đang gọi hàm Scrooged với mảng số và bắt đầu ở đây bắt đầu là chỉ mục của phần tử đầu tiên.

2935
00:11:04,930 --> 00:11:15,550
Và chỉ mục có phải là phần tử cuối cùng không? Sau đó, chúng tôi đang kiểm tra những người mới lên ít hơn và sau đó chúng tôi sẽ tìm thấy những điểm xoay của nó. Sau đó, chúng ta sẽ gọi với danh sách và sau đó chúng ta sẽ gọi nó như vậy.

2936
00:11:15,550 --> 00:11:28,210
Phải. Điều đó có nghĩa là từ đầu đến trục, chúng ta sẽ phân vùng mảng này từ 0 đến trục trừ một, và sau đó chúng ta sẽ phân vùng mảng này theo trục cộng ở cuối.

2937
00:11:28,480 --> 00:11:48,550
Và sau đó chúng ta có các phân vùng. Chúng ta thực sự phải kết thúc và tôi phải bắt đầu trừ một năm từ đầu đến cuối. Nếu nums thực sự gần với phần tử trục, thì chúng ta sẽ tăng I, điều đó có nghĩa là chúng ta sẽ chuyển nó sang phần tiếp theo và sau đó chúng ta sẽ có Ayanda và cuối cùng Ulrichsen trả lại I và cái này là cách nó hoạt động.

2938
00:11:48,760 --> 00:12:03,670
Điều đầu tiên tôi hiểu là hãy để Adam hoặc cho mảng này và đệ quy này gọi ba và chúng tôi vẫn gọi hàm này một cách đệ quy khi chúng tôi tìm ra giá trị Leptis hơn bên phải.

2939
00:12:03,670 --> 00:12:12,910
Và ở đây chúng ta thấy Leptis guerdon. Phải. Và ở đây chúng tôi có OK. Và bạn có thể xem phép gọi đệ quy thứ ba này, sau đó bạn sẽ hiểu vấn đề này khá dễ dàng.

2940
00:12:13,120 --> 00:12:24,910
Ở đây chúng ta có chỉ mục bắt đầu và kết thúc và ở đây chúng ta có điểm mấu chốt cho lệnh gọi đệ quy đó. Và ở đây chúng ta có chỉ số bắt đầu và kết thúc. Và đây là kết quả được phân vùng.

2941
00:12:24,910 --> 00:12:35,820
Và điều này sẽ được trả về bởi chức năng phân vùng này. Và bốn là trục. Đây là cách chúng ta nên làm việc. Hãy để tôi chỉ cho bạn một lần nữa. Phải. Vì vậy, đây là cuộc gọi đệ quy của chúng tôi ba.

2942
00:12:36,280 --> 00:12:47,830
Và năm nay, với những nỗ lực của chúng tôi để duy trì sự hiểu biết của chúng tôi và trong bốn cuộc gọi đầu tiên, chúng tôi có điểm mấu chốt là năm rồi hai, rồi một, rồi ba, bốn.

2943
00:12:48,370 --> 00:12:59,350
Rồi ở đây chúng ta có tám, rồi sáu, rồi bảy, rồi chín. Và chúng ta đã hoàn thành. Và đây là cách nó hoạt động. Bạn đã hiểu khái niệm về thuật toán quicksort.

2944
00:12:59,600 --> 00:13:11,230
Đây là cách nó hoạt động. Nếu bạn chưa hiểu, hãy xem đệ quy có tên Stack này và bạn có thể thấy nó hoạt động như thế nào và bạn đã giải thích cách chúng ta có thể phân vùng mảng.

2945
00:13:11,380 --> 00:13:23,260
Bây giờ chúng ta hãy xem độ phức tạp thời gian chạy của vấn đề này. Chúng tôi đang sửa đổi độ phóng đại của mảng đã cho, vì vậy chúng tôi không sử dụng bất kỳ khoảng trống bổ sung nào. Vì vậy độ phức tạp của không gian lớn hơn một.

2946
00:13:23,260 --> 00:13:34,390
Điều đó có nghĩa là nó hoạt động trong độ phức tạp không gian không đổi. Hãy xem thời gian chạy phân tích nó ở đây. Để chia nó thành dòng và chúng ta phải tính thời gian đó cho đường vào.

2947
00:13:34,390 --> 00:13:47,170
In là độ dài của mảng đã cho. Hoạt động này chiếm một. Điều này đưa chúng tôi đi từ các quận của từng cá nhân đến đấu trường đến các trung tâm có điểm xoay và cả ở đây.

2948
00:13:48,320 --> 00:14:04,130
Và phân vùng chức năng, nó diễn ra rất lớn trong WI, bạn có thể thấy ở đây và hoạt động này sẽ diễn ra nếu chúng ta thêm tất cả chúng để có bất kỳ cuộc gọi nào đến với chúng tôi vì một cộng với tính cá nhân và hai cái còn lại.

2949
00:14:04,130 --> 00:14:19,470
Ngoài ra, ở Hoa Kỳ, chúng tôi sẽ tham gia ngay bây giờ. Bạn có bất kỳ cuộc gọi nào để yêu cầu bạn dừng lại, có ai để đưa vào đây không? Phải thực hiện các bước trong quá trình thực thi để tìm ra phân vùng hoặc phân vùng khu vực.

2950
00:14:20,120 --> 00:14:30,840
Bây giờ, nếu chúng ta thực hiện phép thay thế ngược lại, chúng ta có thể tìm thấy độ phức tạp tại thời điểm đó. Hãy xem đây là phương trình đã cho của bạn như thế nào. Và chúng ta có được phương trình này bằng cách cộng hai số này và chúng bằng nhau.

2951
00:14:30,860 --> 00:14:48,980
Vậy hai nhân D và chia, hai cộng trong mọi thay thế bằng hai trong phương trình một. Sau đó, chúng ta có được phương trình này và B thay thế phương trình này thành một phương trình, một phương trình mà chúng ta có được phương trình này một lần nữa để thay thế và bằng phương trình thứ ba, sau đó chúng ta có được phương trình này.

2952
00:14:50,000 --> 00:15:08,960
Và nếu chúng ta thay phương trình này ba thành một, thì bạn sẽ có được phương trình này và ở đây bạn tìm thấy nó theo mẫu. Mẫu được xác định là mẫu này mà chúng tôi đang gọi hàm sắp xếp nhanh theo cách đệ quy, tại một số điểm, chúng tôi sẽ gọi nó là phần tử một.

2953
00:15:09,440 --> 00:15:20,390
Như vậy vào thời điểm đó chỉ cần thực hiện một thao tác nên ta có thể coi việc hòa tan trong phần chia hai để ra bằng một. Vì vậy, trong sự chia rẽ càng sâu hơn tôi đi đến một.

2954
00:15:21,420 --> 00:15:37,350
Nếu bạn xét điều đó và nếu chúng ta giải nó, thì chúng ta sẽ có được tôi phải đi bộ đến cuối và nếu chúng ta thay I vào phương trình này, thì bạn sẽ có được kết quả như thế này. Và nếu chúng ta giải tình huống này, chúng ta sẽ có được phương trình này dưới dạng số bị chia.

2955
00:15:37,830 --> 00:15:48,930
Và dự đoán tốt nhất ở đây là Châu Âu chỉ đi đến một khi gọi các hàm có phần tử này, một hàm sẽ chỉ thực hiện một thao tác và sẽ chỉ thực hiện bốn lần.

2956
00:15:49,380 --> 00:16:24,120
Vì vậy, Dearborne đi đến một phần và ở đây chúng ta có được tình huống kéo dài hơn nhiều lần trong một tập phim. Điều này chúng ta sẽ trở nên lớn hơn vào những thời điểm muốn kết thúc. Và đây là những gì chúng ta có thể tìm ra, rằng độ phức tạp ngẫu nhiên cho thuật toán sắp xếp nhanh này sao cho độ phức tạp dài hạn của chúng ta lớn hơn độ phức tạp về thời gian đăng nhập và nó sẽ tăng lên đáng kể trong độ phức tạp không gian hoặc không sử dụng bất kỳ lời nói gốc nào, nhưng đối với đệ quy được gọi là ngăn xếp, nó sẽ loại bỏ Spiga về độ phức tạp của không gian.

2957
00:16:24,420 --> 00:16:32,670
Hoofy đã hiểu khái niệm thuật toán QuickStart, thậm chí còn hiểu rõ. Hãy cho chúng
tôi biết. Cảm ơn đã xem video này. Tôi sẽ gặp bạn trong video tiếp theo. 

@@@



2958
00:00:01,140 --> 00:00:17,080
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về một thuật toán sắp xếp, thuật toán sắp xếp mà anh ấy nghĩ là một trong những thuật toán sắp xếp được sử dụng để sắp xếp danh sách các phần tử theo thứ tự.

2959
00:00:17,370 --> 00:00:46,590
Thuật toán sắp xếp của ông sử dụng một trong ba khái niệm gọi là HIF nhị phân. Cấu trúc dữ liệu nhị phân còn được gọi là cấu trúc dữ liệu của mình. Nếu chúng ta được cung cấp mảng cụ thể này, chúng ta phải sắp xếp mảng này theo thứ tự tăng dần, sử dụng thuật toán sắp xếp bây giờ để chúng ta có thể sắp xếp một mảng nhất định theo thứ tự tăng dần, phải không?

2960
00:00:46,860 --> 00:00:57,590
Bây giờ chúng ta hãy nói về điều đó. Ví dụ: giả sử chúng ta được cung cấp mảng này trước tiên. Chúng ta sẽ làm gì? Chúng ta sẽ xây dựng cấu trúc dữ liệu nhị phân từ khu vực này.

2961
00:00:57,930 --> 00:01:15,480
Chúng tôi sẽ quét khu vực này từ trái sang phải, sau đó chúng tôi sẽ xây dựng cấu trúc nhị phân của mình nếu đó là một cấu trúc, sau đó chúng tôi sẽ trích xuất nút ghét của mình và chúng tôi sẽ đặt nút đó vào vị trí đầu tiên rồi lại trích xuất tất cả.

2962
00:01:15,600 --> 00:01:30,810
Sau đó chúng ta sẽ đưa cái đầu đó về vị trí thứ hai, v.v. và tất cả đều thấy rằng chúng ta có thể làm được điều đó như thế nào. Bây giờ, trước tiên hãy xây dựng cấu trúc dữ liệu của chúng ta. Chúng tôi có ma trận này.

2963
00:01:31,080 --> 00:01:50,010
Vì vậy, sáu là lộ trình của chúng tôi và chúng tôi đã rời đi. Và ngay bây giờ theo mặc định, phần tử tiếp theo dành cho những gì bạn chỉ có một nút mà chúng ta không phải lo lắng. Nếu bạn thấy bây giờ chúng ta có ghi chú này thì bây giờ hãy chèn ghi chú này để thay đổi nút sáu này.

2964
00:01:50,500 --> 00:02:04,710
Bây giờ chúng ta hãy làm điều đó. Nếu tôi ở đây, chúng ta thấy cha của 46, vì vậy hãy hoán đổi chúng vì phần lớn hơn nút hiện tại. Vậy bốn người sẽ đi đây và sáu người sẽ đi đây.

2965
00:02:05,430 --> 00:02:20,430
Sau đó, phần tử tiếp theo của chúng tôi là bảy. Vậy hãy chèn số bảy vào đây. Ở đây xây dựng lại ý nghĩa. Được rồi, chúng tôi không xây dựng số lượng lớn ngay cả khi hiểu cách chúng tôi đang xây dựng số nhị phân, đừng lo lắng về điều đó.

2966
00:02:20,640 --> 00:02:36,450
Chúng tôi có một phần hoàn chỉnh nơi chúng tôi đã nói chi tiết về hệ nhị phân. Bây giờ hãy xem liệu chúng ta có thấy số bảy ở mỗi vị trí chính xác hay không vì phần tử gốc nhỏ hơn số bảy hiện tại so với phần tử tiếp theo là ba.

2967
00:02:36,450 --> 00:02:50,900
Hãy chèn số ba vào bên trái của nút số sáu này. Bây giờ giả sử chúng ta thấy ba ít hơn cha mẹ. Cha mẹ sáu tuổi, vì vậy hãy trao đổi chúng. Vậy là chúng ta đã đổi chỗ ba và sáu.

2968
00:02:51,240 --> 00:03:04,480
Bây giờ là cha của ba, bốn, ta thấy bốn lớn hơn ba. Vì vậy, hãy xem chúng. Ebisu của Wisoff ba và bốn, sau đó ba người sẽ chuyển đến đây. Và trên hết, Maria.

2969
00:03:07,400 --> 00:03:18,350
Bây giờ, phần tử tiếp theo là một, hãy chèn một vào phần tử con bên phải của nút này và chúng ta thấy for nhỏ hơn và chúng ta thấy bốn lớn hơn một. Vì vậy, hãy trao đổi chúng.

2970
00:03:19,520 --> 00:03:33,200
Một người sẽ chuyển đến đây và bốn người sẽ chuyển đến đây. Vậy thì cha mẹ của một người là ba. Chúng ta thấy ba lớn hơn một. Vậy là hai người, ba người sẽ chuyển đến đây và một người sẽ chuyển đến đây.

2971
00:03:34,250 --> 00:03:48,380
Sau đó, phần tử tiếp theo là hãy bất an với con bên trái, một nút cơ sở bảy. Bây giờ hãy làm rõ. Đây là bảy lớn hơn hai. Vì vậy, hãy có thêm hai người nữa ở đây và bảy người sẽ chuyển đến đây.

2972
00:03:49,400 --> 00:04:06,430
Khi đó ta thấy cha của hai là một và một nhỏ hơn hai. Như vậy chúng ta đã tìm đúng vị trí của nút này để phần tử tiếp theo là 5. Hãy chèn số năm vào bên phải và lên trên và ở đây bạn thấy năm lớn hơn hai.

2973
00:04:06,440 --> 00:04:22,460
Vì vậy, không cần phải làm gì ở đây. Chúng tôi đã xây dựng cấu trúc nhị phân của mình. Bây giờ chúng ta sẽ làm gì? Chúng tôi sẽ trích xuất nó ẩn khỏi cấu trúc dữ liệu của mình và chúng tôi sẽ chèn nó vào chỉ mục đầu tiên cho lần lặp đầu tiên của chỉ mục này.

2974
00:04:23,120 --> 00:04:37,420
Sau đó, trong lần lặp thứ hai, chúng ta sẽ lấy Hadnot và chúng ta sẽ cập nhật giá trị tại chỉ mục, v.v. Hãy và làm điều đó. Vì vậy, trước tiên chúng ta sẽ trích xuất nút này, trích xuất nút này, không phải một nút.

2975
00:04:37,430 --> 00:04:47,660
Chúng tôi nhận được một. Vì vậy, hãy cập nhật giá trị ở chỉ số 0 bằng một. Bây giờ chúng ta sẽ làm gì? Chúng ta sẽ lấy phần trăm đầu tiên. Vậy điều gì là tốt nhất?

2976
00:04:47,660 --> 00:04:58,190
Không phải tổng thống là mệnh lệnh mà chúng tôi nhận được bằng cách duyệt qua HIF nhị phân, sử dụng cấp độ hoặc bất cứ thứ gì. Vì vậy, bất kể cấp độ nhị phân này là bao nhiêu, chúng ta đã có được năm.

2977
00:04:58,190 --> 00:05:11,030
Vì vậy, năm là tốt nhất. Chúng tôi sẽ cập nhật cái có giá trị của nút đầu tiên. Vì vậy, hãy cập nhật giá trị này. Vì vậy, hãy cập nhật giá trị một bằng năm và chúng ta sẽ loại bỏ nút năm này.

2978
00:05:11,570 --> 00:05:25,420
OK, chúng tôi đã hướng dẫn nút đầu sau khi trích xuất hadnot. Chúng tôi phải giúp bạn tìm đống nhị phân. Bây giờ, bạn định làm gì? Chúng ta sẽ tìm ra mức tối thiểu của bên trái và bên phải.

2979
00:05:26,120 --> 00:05:40,670
Vậy tối thiểu con trái và con phải, ta thấy có hai. Vì vậy, chúng ta sẽ hoán đổi năm và hai vì năm lớn hơn hai. Vì vậy, hãy trao đổi chúng. Năm đi đây, hai đi đây.

2980
00:05:41,090 --> 00:05:56,750
Bây giờ chúng ta thấy rằng đối với nút này, chúng ta chỉ có một con còn lại và chúng ta thấy phía bên trái lớn hơn năm. Vì thế không có gì phải làm ở đây. Bây giờ chúng tôi đã hoàn thành thế hệ tiếp theo của điều này cho Loof, chúng tôi cũng sẽ trích xuất bản hit.

2981
00:05:56,930 --> 00:06:15,790
Vì vậy, hãy giải nén cái này và chèn nó vào vị trí này. Vì vậy, chúng ta đang giải nén những điều ẩn giấu ngay bây giờ, chúng ta sẽ làm gì? Chúng ta sẽ thấy nút phòng thủ số bảy là nút sâu nhất, vì vậy hãy chia giá trị cho bảy và hãy xóa nút sâu nhất cũng như xóa nút bị chán nản.

2982
00:06:15,870 --> 00:06:33,560
Và bây giờ chúng ta hãy tìm ra mức tối thiểu của bên trái và bên phải. Tối thiểu là ba. Vì vậy, hãy trao đổi chúng. Và chúng tôi thấy mức tối thiểu là ba. Vậy hãy đổi chỗ bảy và ba, ba nước ở đây và bảy nước ở đây.

2983
00:06:35,550 --> 00:06:49,200
Được rồi, bây giờ chúng ta hãy tìm xem con trái và con phải nhỏ nhất của bảy, nhỏ nhất là bốn. Vì vậy, giả sử bảy và bảy ở đây và bốn ở đây.

2984
00:06:50,100 --> 00:07:04,170
Chúng ta đã xong. Được rồi, đối với lần lặp tiếp theo của lần lặp lại này, hãy trích xuất lịch sử lần truy cập. Vì vậy, bây giờ chúng tôi sẽ cập nhật bảy thành ba. Chúng tôi sẽ cập nhật ba ghi chú tốt nhất.

2985
00:07:04,680 --> 00:07:19,210
Có bảy. Vì vậy, hãy cập nhật giá trị của nút ba này bằng bảy và cũng phải loại bỏ mạng nút sâu nhất mà chúng ta phải gọi hàm vivify để chia heap nhị phân.

2986
00:07:19,710 --> 00:07:36,150
Bây giờ chúng ta hãy tìm con nhỏ nhất của nó, và đó là bốn Lietzau bốn và bảy. Vậy chúng ta hãy có bốn và bảy bảy bước ở đây và bỏ qua ở đây. Bây giờ, chúng ta chỉ còn lại một con cho nút bảy này, vì vậy hãy hoán đổi chúng vì sáu là bảy.

2987
00:07:36,750 --> 00:07:55,270
Sáu nữa ở đây và. Bảy động thái ở đây đã được thực hiện cho thế hệ tiếp theo của diễn đàn này. Chúng ta sẽ trích xuất bốn, vì vậy hãy trích xuất thêm và cập nhật cho anh chàng này với bốn và chúng ta sẽ có được bảy trong Thượng viện.

2988
00:07:55,720 --> 00:08:16,400
Vì vậy, hãy loại bỏ bảy và cập nhật phần thô sơ với bảy. Bây giờ chúng ta hãy tìm ra mức tối thiểu ở bên trái và bên phải, tối thiểu là năm, vì vậy hãy hoán đổi năm và bảy năm mục tiêu ở đây và bảy mục tiêu ở đây cho lần lặp lại tiếp theo của mùa thu này.

2989
00:08:16,400 --> 00:08:27,550
Nếu chúng ta muốn bắt Hitner thì có năm. Vì vậy, hãy trích xuất năm và cập nhật cái này trên một với năm. Hãy cập nhật quy tắc năm này với bảy, bảy trầm cảm ở đây.

2990
00:08:28,220 --> 00:08:39,260
Vì vậy, hãy cập nhật nút này với bảy và hãy thực hiện một nửa ngay tại đây và tại đây. Bạn thấy đấy, chúng tôi chỉ có một nút, LoopNet và Lipner ít hơn nút gốc này.

2991
00:08:39,260 --> 00:08:56,750
Vì vậy, hãy có bảy và sáu, bảy GWAS ở đây và sáu GWAS ở đây cho lần lặp lại tiếp theo của bức tường này. Chúng ta sẽ tìm được điều ẩn giấu dưới sáu điều đó. Vì vậy, hãy cập nhật nó sáu và hãy cập nhật sáu ở đây với ghi chú sâu sắc nhất.

2992
00:08:56,780 --> 00:09:13,870
Đó là bảy. Vì thế. Bây giờ, chúng tôi chỉ có một lưu ý là phục vụ điểm trái và phải, bây giờ bạn có cân nhắc cho thế hệ tiếp theo của mùa thu này nếu chúng tôi định lấy Hadland này và chúng tôi sẽ cập nhật năm với bảy.

2993
00:09:15,660 --> 00:09:42,570
Được rồi, sau đó chúng tôi sẽ xóa ghi chú này. Và chúng ta đã hoàn thành, đây là cách thuật toán sắp xếp của anh ấy hoạt động với chúng ta, chúng ta phải xây dựng cấu trúc dữ liệu mà chúng ta phải trích xuất từ ​​cấu trúc và sau đó chúng ta phải cập nhật vùng đó bằng cách trích xuất từ ​​cấu trúc dữ liệu, thậm chí hiểu cả chèn và trích xuất phương pháp.

2994
00:09:42,600 --> 00:09:59,280
Đừng lo lắng về điều đó. Chúng tôi có một phần hoàn chỉnh trong bài diễn thuyết. Kiểm tra phần nhị phân ở đây. Đây là cách anh ấy làm việc. Ông cho biết thuật toán sẽ loại bỏ Spiga về độ phức tạp về thời gian đăng nhập và đó là độ dài của khu vực nhất định và tất cả đều có độ phức tạp không gian không đổi.

2995
00:10:00,060 --> 00:10:14,840
Tôi nói với mã nguồn nơi chúng tôi sử dụng độ phức tạp của không gian vì khi bạn bắt đầu xây dựng cấu trúc dữ liệu của chúng tôi bằng cách sửa đổi khu vực nhất định của chúng tôi, thì bạn có thể giải quyết vấn đề này với độ phức tạp của không gian không đổi.

2996
00:10:15,060 --> 00:10:28,860
Nhưng điều đó làm cho vấn đề này khó khăn hơn rất nhiều. Đó là lý do tại sao chúng tôi đang tạo ra nó. Mảng mới để tạo cấu trúc dữ liệu của chúng tôi. Đừng lo lắng về điều đó. Mình cho các bạn biết source code của video này để dễ thực hiện nhé.

2997
00:10:29,430 --> 00:10:55,440
Chúng tôi không xây dựng hoặc thậm chí là một cấu trúc bằng cách sửa đổi khu vực nhất định của chúng tôi. Chà, chúng tôi đã hiểu lời giải thích này của Avita. Đây là tất cả về thuật toán mà anh ấy nghĩ rằng chúng tôi đang sử dụng ở đây có nghĩa là nếu cấu trúc dữ liệu bạn có thể sử dụng Max, nếu bạn sử dụng, bạn phải cập nhật khu vực của chúng tôi từ phải sang trái và quy trình chính xác giống như cách chúng tôi đã hiểu.

2998
00:10:55,440 --> 00:11:05,460
Thuật toán của anh ấy là gì và nó hoạt động như thế nào. Tôi có một bài kiểm tra. Nguồn có
thể kiểm tra mã nguồn. Cảm ơn đã xem video này. Tôi sẽ gặp bạn trong video tiếp theo. 

@@@



2999
00:00:01,020 --> 00:00:18,930
Này, rất nhiều chàng trai sẽ quay lại video này trong video này. Chúng ta sẽ nói về đệ quy là gì. Đệ quy là một phương pháp giải một bài toán nhỏ trong đó lời giải của nó phụ thuộc vào lời giải của các trường hợp nhỏ hơn của cùng một bài toán, đó là các tính chất của đệ quy.

3000
00:00:19,440 --> 00:00:36,890
Chúng ta có ba tính chất của đệ quy. Hoạt động của SIM được thực hiện nhiều lần với đầu vào khác nhau ở mỗi bước. Chúng tôi cố gắng làm cho vấn đề nhỏ hơn và chúng tôi phải có sự va chạm cơ sở với hệ thống nghiêng để dừng đệ quy.

3001
00:00:37,350 --> 00:00:55,390
Và đây là định nghĩa chính thức của đệ quy. Bây giờ hãy lấy một ví dụ để hiểu đệ quy ở đây. Các thuộc tính của mô phỏng đệ quy được thực hiện nhiều lần với đầu vào khác nhau trong mỗi bước chúng tôi cố gắng thực hiện vấn đề này.

3002
00:00:56,070 --> 00:01:11,280
Và chúng ta nên có một điều kiện cơ bản. Đây là một hộp quà tuyệt vời. Bên trong hộp quà này, có thể chúng ta sẽ có một món quà nào đó. Bây giờ chúng ta hãy mở hộp này. Bên trong hộp này, chúng ta có một hộp khác.

3003
00:01:12,060 --> 00:01:27,500
Hãy mở hộp này. Bên trong hộp này, chúng ta có một hộp khác. Hãy mở hộp này một lần nữa. Bên trong hộp này, chúng ta thấy mình có một hộp khác ở đây. Chúng ta thấy rằng chúng ta đang thực hiện cùng một nhiệm vụ nhiều lần, được chứ?

3004
00:01:27,780 --> 00:01:39,210
Ở đây chúng tôi đang thực hiện cùng một thao tác nhiều lần. Bây giờ chúng ta hãy mở hộp này một lần nữa. Chúng ta thấy bên trong chiếc hộp này chúng ta có một chiếc hộp khác. Bây giờ chúng ta hãy mở hộp này một lần nữa.

3005
00:01:39,540 --> 00:01:56,460
Cuối cùng, chúng tôi thấy đó là món quà tuyệt vời. Và đây là món quà tuyệt vời nhẫn vàng. Vì vậy, đây là những gì bạn đã hiểu. Chúng tôi hiểu rằng chúng tôi đang thực hiện cùng một nhiệm vụ nhiều lần với các đầu vào khác nhau.

3006
00:01:57,180 --> 00:02:10,510
Và trong mỗi bước chúng tôi cố gắng làm cho vấn đề trở nên nhỏ hơn. Chúng tôi đang mở hộp. Chúng ta đang mở hộp, được chứ? Chúng tôi đang làm cùng một nhiệm vụ. Chúng ta phải có điều kiện cơ bản là ai vẫn là hệ thống, khi nào thì dừng đệ quy.

3007
00:02:10,710 --> 00:02:27,300
Vì vậy, đây là giỏ cơ sở của chúng tôi. Vậy chiếc nhẫn vàng này chính là cái giỏ. Vì vậy, chúng tôi đang lặp lại cùng một nhiệm vụ nhiều lần trong mỗi bước với một đầu vào khác nhau. Vì vậy, chúng tôi đang làm cho vấn đề của chúng tôi nhỏ hơn.

3008
00:02:27,300 --> 00:02:41,230
Có EZchip và đây là điều kiện tốt nhất của chúng tôi. Khi bạn phát hiện ra chiếc nhẫn vàng của chúng tôi, chúng tôi sẽ nhét đồ vào. Và điều này hoàn toàn tương tự như đệ quy. Bây giờ chúng ta hãy thử tìm hiểu đệ quy với Coey.

3009
00:02:41,590 --> 00:02:51,770
Chúng tôi được cung cấp một tìm kiếm nhị phân và chúng tôi muốn tìm kiếm một giá trị trong một tài nguyên này. Đây là thuật toán để tìm kiếm một giá trị trong cái này. Đó là đường phố của chúng tôi.

3010
00:02:52,500 --> 00:03:07,670
Phương thức này có hai tham số và được phát triển bên trong đây. Bây giờ bạn thực sự phải biết tất cả, đây là điều kiện cơ bản. Hoặc nếu bạn đi đến giá trị, nếu giá trị của Ruggeri về giá trị đã cho sẽ trả về root root.

3011
00:03:08,310 --> 00:03:20,520
Chúng ta đang kiểm tra xem giá trị có lớn hơn giá trị hay không thì chúng ta sẽ gọi đó là môi quyền. Giả sử chúng ta gọi phương thức này với gốc tám và giá trị sáu.

3012
00:03:21,240 --> 00:03:33,240
Chúng tôi bảo tồn giá trị sáu. Trong cái này thì coi như Rudys Records biết và nó không bằng sáu. Và chúng ta thấy giá trị lớn hơn giá trị đã cho.

3013
00:03:33,240 --> 00:03:45,150
Nó lớn hơn sáu. Vì vậy, hãy tạm gọi nó là vượt qua cây con này, chúng ta thấy rằng ba không bằng sáu và ba không rỗng đối với lệnh gọi đệ quy.

3014
00:03:45,420 --> 00:03:57,090
Bây giờ chúng ta sẽ kiểm tra xem giếng đó có lớn hơn Harlow không. Không. Ba không lớn hơn sáu. Vì vậy, hãy gọi nó. Phải. Chúng tôi không đồng ý. Chúng ta chỉ có một nút ở đây và đây là sáu bằng sáu.

3015
00:03:57,390 --> 00:04:11,760
Vì vậy, chúng tôi sẽ trả lại nút sáu. Trên thực tế, trong đoạn mã này, chúng ta có điều kiện tốt nhất. Đây là điều kiện tốt nhất của chúng tôi. Nếu ghi lại để biết cả khu vực thì không còn gì nữa.

3016
00:04:11,760 --> 00:04:29,400
Nếu bạn không phát triển thì sẽ trả về root. Đây là điều kiện cơ bản của chúng tôi ở đây. Chúng tôi thấy rằng trong mỗi bước chúng tôi đều cố gắng giải quyết vấn đề này ở đây. Chúng tôi đang thực hiện cùng một thao tác nhiều lần với các đầu vào khác nhau.

3017
00:04:29,460 --> 00:04:41,460
Được rồi, vậy ở đây chúng ta đang thực hiện cùng một thao tác với các đầu vào khác nhau và trong mỗi bước chúng ta cố gắng làm cho vấn đề nhỏ hơn. Vì vậy, trong mỗi bước chúng tôi đang làm cho vấn đề đó nhỏ hơn.

3018
00:04:41,820 --> 00:04:52,380
Đầu tiên chúng ta gọi với toàn bộ cây. Có ba cái mà chúng ta gọi là đúng tâm và chúng ta phải có điều kiện cơ bản. Và đây là điều kiện cơ bản của chúng tôi.

3019
00:04:53,440 --> 00:05:14,620
Chúng ta đã hiểu đệ quy là gì và nó hoạt động như thế nào. Đệ quy, sử dụng nội bộ là. Đối với việc gọi hàm đệ quy bây giờ chúng ta hãy nói về những gì chúng ta nên học, đệ quy, đệ quy giúp viết dễ dàng so với việc lặp với một bài toán cho trước có thể chia thành các bài toán nhỏ hơn.

3020
00:05:15,050 --> 00:05:30,140
Nó được sử dụng nhiều trong biểu đồ cây, v.v. và đệ quy, được sử dụng nhiều trong các kỹ thuật như chia để trị, lập trình động. Có nhiều trường hợp sử dụng đệ quy trong khóa học này.

3021
00:05:30,710 --> 00:05:45,560
Chúng tôi đã thấy rất nhiều thuật toán sử dụng đệ quy. Chúng tôi đã hiểu đệ quy là gì và bạn nên học nó những
gì nếu có. Nếu bạn hiểu việc phân phối lại này hoặc nếu có bất kỳ đề xuất nào, hãy cho chúng tôi biết. 

@@@



3022
00:00:00,600 --> 00:00:15,320
Chúng ta sẽ quay lại video này trong video này. Chúng ta sẽ nói về định dạng của Precursor, chúng ta phải đoán bộ công cụ có tên là Biscuit và Kit đệ quy.

3023
00:00:15,330 --> 00:00:42,170
Chức năng không tái diễn. Điều đó có nghĩa là trong đó chức năng của bộ đệ quy là bộ công cụ, hàm recor hỗ trợ hàm đệ quy sẽ phải hôn một chiếc bánh quy và katch đệ quy, chức năng của at Biscuit và hàm sẽ gọi hàm cho bộ đệ quy lettieri không xác định theo hệ số năm.

3024
00:00:42,360 --> 00:00:55,050
Làm thế nào có thể tìm thấy nó. Giai thừa của năm sẽ gọi đệ quy một cái gì đó như thế này. Giai thừa cho giai thừa ba liên bang hai giai thừa một. Và đây là bộ cơ sở của chúng tôi cho giai thừa một khu vực.

3025
00:00:55,170 --> 00:01:06,660
Sau đó chúng ta sẽ có hai lần. Khi anh ta đi làm như vậy cho hai người, nó sẽ quay trở lại với họ. Ba đến sáu Morphettville ba để trả lại sáu. Sáu học kỳ bốn bằng hai mươi bốn.

3026
00:01:06,870 --> 00:01:19,230
Vậy bốn giai thừa bốn. Nó sẽ trở lại hai mươi bốn. Hai mươi bốn nhân năm bằng một trăm hai mươi và sẽ trở về giai thừa năm. Và đây là định dạng đệ quy.

3027
00:01:19,420 --> 00:01:31,800
Đây là cái bánh quy và chúng ta đang gọi đệ quy là liên bang, bốn liên bang, ba liên bang này được gọi là bộ đệ quy và đây là mã để tìm nó là giai thừa của nó.

3028
00:01:31,800 --> 00:01:43,080
Không, đây là Biscuit và đây là git đệ quy của chúng tôi về mặt nội dung và
điểm trừ khá dễ hiểu. Định dạng đệ quy là gì. Cảm ơn đã xem video này. 

@@@



3029
00:00:00,600 --> 00:00:14,230
Đây nhé, hai bạn sẽ quay lại với video này. Chúng ta sẽ nói về cách đệ quy hoạt động nội bộ. Đệ quy là một quá trình trong đó hàm gọi chính nó một cách trực tiếp hoặc gián tiếp.

3030
00:00:14,760 --> 00:00:30,060
Đây là định nghĩa chính thức của đệ quy cho đệ quy. Chúng ta phải phân biệt trường hợp cơ sở và trường hợp đệ quy và chúng ta sẽ nói về điều đó trong video này. Chúng ta sẽ nói về cách đệ quy hoạt động nội bộ.

3031
00:00:30,660 --> 00:00:40,440
Đệ quy sử dụng cấu trúc dữ liệu công nghệ của nó để gọi hàm đệ quy. Bây giờ hãy xem chức năng màu sắc hoạt động như thế nào. Chúng tôi có chức năng chính này bên trong chức năng này.

3032
00:00:40,470 --> 00:00:55,890
Chúng ta gọi một hàm khác vì bên trong hàm này chúng ta gọi một hàm khác là bar và đây là hàm bar. Và bên trong hàm thanh này, trước tiên chúng tôi đã in và var cách nó thực sự hoạt động trong ngăn xếp.

3033
00:00:55,920 --> 00:01:16,400
Hàm chính này là khi chúng ta gọi hàm chính này bên trong hàm này, chúng ta có bốn. Vì vậy, trước khi in, ý tôi là nó sẽ gọi hàm này sao cho đầy đủ được đặt trong bộ nhớ ngăn xếp đó bên trong vì chúng ta có một thanh chức năng khác trước khi thực hiện bản in này, chúng ta phải gọi hàm thanh này.

3034
00:01:16,470 --> 00:01:31,110
Vì vậy, hàm thanh được đặt vào một ngăn xếp, sau đó bên trong hàm thanh này nó sẽ chỉ in và sau đó thanh này sẽ được bật ra khỏi ngăn xếp. Sau đó nó sẽ chuyển sang câu lệnh in này.

3035
00:01:31,140 --> 00:01:46,710
Vì chúng ta đã hoàn tất lệnh gọi hàm này nên bây giờ nó sẽ in. Và bây giờ đối với hàm chính này, hàm này đã xuất hiện từ ngăn xếp. Như vậy lệnh gọi hàm này đã được thực hiện, nghĩa là hàm này đã được thực thi.

3036
00:01:47,460 --> 00:02:00,000
Bây giờ chúng ta hãy đi đến dòng tiếp theo. Cái này mỗi bản in nên nó sẽ in. Tôi là tôi và đây là chức năng của bạn. Cuộc gọi hoạt động và sử dụng chức năng là công nghệ. Bây giờ hãy xem hàm đệ quy hoạt động như thế nào.

3037
00:02:00,900 --> 00:02:09,900
Giả sử chúng ta muốn tìm giai thừa của một số nguyên nhất định và vấn đề này lấy một tham số bên trong để chèn cái gì, nếu có, vào một tham số sẽ chia vùng.

3038
00:02:09,900 --> 00:02:21,540
Một cái khác sẽ trở lại theo giai thừa trong trừ một. Và ở đây chúng ta gọi hàm này theo cách đệ quy và đây là điều kiện dựa trên và đây là điều kiện đệ quy.

3039
00:02:22,050 --> 00:02:34,310
Bây giờ hãy xem nó hoạt động như thế nào. Nếu chúng ta không biết, hãy xem nó hoạt động như thế nào. Nếu chúng ta gọi giai thừa là năm thì số năm liên bang sẽ được xếp vào một ngăn xếp. Được rồi.

3040
00:02:34,500 --> 00:03:02,580
Và đây là thứ tự gọi hàm đệ quy đầu tiên. Chúng tôi gọi nó là bốn năm, sau đó năm nhân bốn trong bốn lần, ba trong ba lần liên bang, hai thành một liên bang đó, năm đầu tiên được đặt vào bộ nhớ ngăn xếp, sau đó là giai thừa bốn, rồi giai thừa ba, rồi thực tế đến số thực và aracy cho hàm này gọi là khớp với cơ sở đó nên nó sẽ từ chối một.

3041
00:03:02,820 --> 00:03:18,780
Vậy hai lần chỉ thành hai. Vì vậy, đối với hàm này, hãy gọi hai, nó sẽ quay trở lại Vì vậy, Pacula khi nó được bật ra từ Ngăn xếp. Bây giờ, hãy tính giá trị Veliz hai lần để tiến đến sáu để sáu sẽ được trả về hàm này.

3042
00:03:19,530 --> 00:03:30,450
Vì vậy, vật liệu này sẽ được lấy ra khỏi Ngăn xếp và bốn lần nó sẽ chuyển thành 24 và 24 này sẽ quay trở lại hàm này gọi giai thừa bốn.

3043
00:03:31,140 --> 00:03:43,560
Vì vậy, điều này được giám sát và liên bang cho khu vực 24. Hai mươi bốn lần năm. Gần 120 ở đây là giai thừa cho khu vực 24 và năm lần 24 chỉ là 20.

3044
00:03:43,560 --> 00:03:55,520
Vì vậy, liên bang năm. Vùng một trăm hai mươi. Vì vậy, cuối cùng kết quả của liên bang năm là trên hai mươi. Đây là cách đệ quy này hoạt động và đây là những gì chúng ta có thể tìm thấy.

3045
00:03:55,520 --> 00:04:11,730
Nó là giai thừa của một số hàm đệ quy được gọi là tác phẩm của. Nếu hiểu cách đệ quy hoạt động nội bộ. Độ phức tạp về thời
gian cho lệnh gọi hàm này là arfin lớn và độ phức tạp về không gian cũng lớn hơn đối với hàm đệ quy có tên là ngăn xếp. 

@@@



3046
00:00:00,600 --> 00:00:13,100
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng ta sẽ giải quyết một vấn đề. Bạn muốn chúng tôi thấy Rich sử dụng đệ quy nếu cần, đó là danh sách các số.

3047
00:00:13,620 --> 00:00:27,550
Hai số đầu tiên là một. Sau đó, số tiếp theo được tạo bằng cách thêm số trước vào số một. Cộng một là hai. Hai cộng một là ba hai ba năm năm cộng ba là tám, v.v.

3048
00:00:27,840 --> 00:00:44,010
Bây giờ chúng ta phải triển khai phương thức năm sẽ lấy một số nguyên và trả về số imp cho số A.C. từ những người cần thiết. Hãy cùng xem mã này như thế nào để tìm hiểu nhé.

3049
00:00:44,490 --> 00:00:59,760
Và nếu bạn muốn xem số, phương thức 5 này lấy một tham số làm đầu vào bên trong ở đây, chúng tôi đang kiểm tra xem nó lớn hơn hoặc bằng ba. Sau đó chúng ta sẽ quay lại bằng cách cộng thêm 15 phút.

3050
00:00:59,760 --> 00:01:14,830
Một cộng thêm 15 phút nữa đã có sẵn ở đây. Đây là cơ sở của chúng tôi và đây là cổng đệ quy của chúng tôi. Bây giờ hãy xem nó thực sự hoạt động như thế nào. Điều này sẽ hơi quan trọng để hiểu Daury.

3051
00:01:14,850 --> 00:01:29,730
Tôi sẽ giải thích mọi thứ. Vì vậy, nếu chúng ta gọi phương pháp thứ năm này là phương pháp thứ năm để tìm ra sự phù hợp nếu bạn muốn xem phương pháp thứ tư. Vì vậy, số thứ năm trong số này sẽ ổn.

3052
00:01:30,180 --> 00:01:43,890
Vì vậy, nếu chúng ta gọi năm là năm thì nó sẽ trả về năm. Nhưng thế nào mỗi vùng năm. Bây giờ chúng ta hãy tìm hiểu xem ở đây có khu vực thứ năm ở Manasquan. Vì vậy bây giờ chúng ta hãy đi sang bên trái.

3053
00:01:43,890 --> 00:01:57,920
Hãy đi sang bên trái một lần nữa cho đến khi chúng ta đạt được điều kiện cơ bản này. Chúng ta hãy đi sang bên trái một lần nữa. Và ở đây chúng ta thấy in lớn hơn bằng ba. Lực va chạm hai này không lớn hơn ba.

3054
00:01:58,230 --> 00:02:12,720
Vì vậy, nó sẽ trả lại một. Đây là cổng cơ sở Vậy là chúng ta đã hoàn thành chức năng này. Gọi ba người. Bây giờ, hãy gọi ngay bây giờ, hãy gọi hàm này là 15 phút để có 15 phút đến một giờ năm.

3055
00:02:12,720 --> 00:02:25,260
Người ta sẽ trả lại một vì đây là điều kiện cơ bản và sẽ thêm hai điều kiện này vào và tiếp tục. Và đó là năm ba. Vì vậy, hãy quay lại đây để chúng ta hoàn thành chức năng này.

3056
00:02:25,260 --> 00:02:38,020
Gọi năm phút, một, bốn, năm, bốn. Bây giờ chúng ta hãy đi sang bên phải. Điều đó có nghĩa là lệnh gọi hàm này trừ hai và đó là năm lệnh gọi hàm này sẽ chạm vào chiếc bánh quy này.

3057
00:02:38,050 --> 00:02:50,780
Vậy nó sẽ trả về một, hai cộng một là ba ở đây. Nước Anh cũ ba. Vậy là chúng ta đã hoàn thành chức năng này. Gọi bốn đến năm. Bây giờ chúng ta hãy đi đến lệnh gọi hàm này ở Minnesota.

3058
00:02:51,210 --> 00:03:05,040
Vậy năm giờ sáng là năm bộ, ba. Vì vậy, chúng tôi có ba. Cuộc gọi hàm này sẽ không ăn bánh quy. Bây giờ hãy gọi năm một cho năm ba này. Ở đây chúng tôi có hai.

3059
00:03:05,040 --> 00:03:16,770
Vậy chúng ta hãy quay trở lại đây ngay bây giờ. Chúng ta hãy đi sang bên phải. Điều đó có nghĩa là không có chức năng cho ba cái này ở đây chúng ta có năm một. Tất cả được viết ở đây một. Vậy một cộng một ở đây là vùng hai.

3060
00:03:17,130 --> 00:03:30,440
Và cuối cùng sẽ có diện tích ba cộng hai, tức là năm. Và đây là những gì chúng ta có thể tìm thấy nó qua con số từ mọi người. Đó là sự đệ quy. Chúng tôi đã hiểu làm thế nào để tìm ra trong ba phút.

3061
00:03:30,460 --> 00:03:41,250
Số lượng từ những người cần thiết. Bây giờ hãy lấy một ví dụ khác để hiểu rõ hơn. Bây giờ hãy gọi hàm năm này với sáu để từ đó chúng ta tìm ra số thứ sáu.

3062
00:03:41,260 --> 00:03:53,070
Nếu bạn muốn tìm kiếm thì có tám. Vì vậy, hãy tìm ra số tám này bằng cách sử dụng mã này. Bây giờ chúng ta sẽ gọi mười lăm phút, một phút theo cách đệ quy cho đến khi chúng ta chạm vào giỏ này.

3063
00:03:53,400 --> 00:04:07,680
Thế là năm, năm, rồi năm, bốn, rồi ba, rồi hai. Vì vậy, điều này đánh vào bánh quy. Chúng tôi thực sự không muốn không, hãy gọi đây là năm phút, hai, bốn, năm, ba.

3064
00:04:08,160 --> 00:04:22,410
Vì vậy, chúng tôi nhận được năm một. Nó cũng sẽ trả lại một cái. Vậy một cộng một là hai. Vậy là chúng ta đã hoàn thành với năm phút. Một, bốn, năm, bốn. Không, hãy tính đến phút của bốn người và người này mười lăm tuổi.

3065
00:04:22,410 --> 00:04:32,520
Vậy là nó sẽ đánh vào chỗ trống, lấy được nó sẽ trả về cái gì. Một cộng hai là ba. Cho nên rối loạn sẽ trở lại ba, bốn, năm, năm. Chúng tôi đã hoàn thành việc này.

3066
00:04:33,000 --> 00:04:45,090
Mười lăm phút trôi qua. Hãy gọi mười lăm phút tới. Vì vậy, chúng tôi nhận được ở đây năm ba. Bây giờ chúng ta hãy đến mười lăm trừ một và cái này sẽ chạm vào rổ nên nó sẽ quay trở lại chức năng này.

3067
00:04:45,100 --> 00:04:56,610
Will, sẽ đánh vào rổ vì nó đã đến số 2. Vì vậy nó sẽ quay trở lại. Không, hãy gọi nó là bốn phút với ba phút để chúng ta có năm một, nó cũng sẽ quay trở lại.

3068
00:04:56,730 --> 00:05:10,110
Vậy một cộng một là hai, hai cộng ba là năm. Bây giờ, hãy gọi đến Minnesota với giá năm, sáu, năm, bốn, không, chúng ta hãy gọi lại là ba. Hãy đến ví dụ như Thụy Điển, khu vực một.

3069
00:05:10,350 --> 00:05:21,110
Điều đó tốt, phải không? Nó sẽ chia một thành một cộng một là hai. Chúng ta hãy đi sang phải miễn phí, nghĩa là mất 15 phút để đến đó. Vì vậy, nó sẽ bắt đầu.

3070
00:05:21,120 --> 00:05:35,870
Vậy hai cộng một là ba, hai cộng năm là tám. Vì vậy, đối với hàm này, hãy gọi năm sáu, tất cả là vùng tám. Đây là cách nó có thể hoạt động và đây là những gì chúng ta có thể tìm ra về mức độ nghiêm trọng từ những người hy vọng.

3071
00:05:35,990 --> 00:05:48,210
Chúng ta đã hiểu đệ quy hoạt động như thế nào. Đệ quy này gọi ba trong mã này. Chúng tôi đang lặp lại cùng một nhiệm vụ nhiều lần ở đây. Chúng tôi đã tính toán giá trị bốn, năm, ba.

3072
00:05:48,390 --> 00:06:16,710
Ở đây chúng tôi đang tính toán lại ở đây chúng tôi đã tính giá trị miễn phí ở đây chúng tôi đang tính toán lại. Chúng ta có thể giảm lệnh gọi hàm bằng cách sử dụng lập trình động nếu chúng ta áp dụng ở đây lập
trình động sẽ không có bất kỳ sự lặp lại nào của lệnh gọi hàm và điều đó sẽ nói đến trong phần lập trình động của khóa học này những gì chúng ta đã hiểu cách tìm hiểu trong vài phút, một số từ một vài phút. 

@@@



3073
00:00:01,290 --> 00:00:16,640
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về đệ quy và lặp lại. Đối với đệ quy và lặp lại, trước tiên chúng ta hãy tìm hiểu tốc độ, hiệu quả và hiệu quả về thời gian cho đệ quy.

3074
00:00:17,500 --> 00:00:37,020
Chúng ta phải gọi một hàm theo cách đệ quy. Chúng ta phải thêm phần tử vào bộ bài của nó và chúng ta phải xóa phần tử khỏi ngăn xếp. Và điều đó cần một lượng lớn bộ nhớ để đệ quy, OK, và để lặp lại, sẽ không cần thêm bất kỳ công tắc nào để đạt hiệu quả về thời gian.

3075
00:00:37,870 --> 00:00:54,010
Chúng ta phải thêm phần tử vào một thanh và điều đó đôi khi sẽ mất. Tôi gọi hàm theo cách đệ quy, đôi khi phải mất, nhưng đối với các vòng lặp thì mất ít thời gian hơn so với đệ quy để đạt được hiệu quả về không gian và hiệu quả về thời gian.

3076
00:00:54,400 --> 00:01:07,690
Lặp lại là người chiến thắng là một mã. Điều đó có nghĩa là khi chúng ta gặp vấn đề, các vấn đề đó có thể được chia thành các vấn đề phụ nhỏ hơn. Và cái đó được gọi là mã.

3077
00:01:08,230 --> 00:01:24,170
Để giải quyết vấn đề. Việc đệ quy được khuyến khích. Phép chia của cô không dành cho một mật mã. Đệ quy là bây giờ chúng ta sẽ sử dụng đệ quy và đệ quy trung bình điểm.

3078
00:01:24,310 --> 00:01:39,510
Bây giờ chúng ta hãy nói về điều đó. Đến khi chúng ta có thể dễ dàng chia một vấn đề thành một vấn đề tương tự. Sau đó, chúng ta nên sử dụng đệ quy khi bạn thấy ổn với không gian và thời gian bổ sung.

3079
00:01:39,690 --> 00:01:56,000
OK, độ phức tạp về không gian, độ phức tạp và thời gian. Sau đó, một lần nữa, hãy xem xét đệ quy khi bạn cần một giải pháp làm việc nhanh chóng thay vì giải pháp hiệu quả mà hiện tại chúng ta phải sử dụng đệ quy với hy vọng tránh được đệ quy.

3080
00:01:56,970 --> 00:02:10,230
Nếu câu trả lời cho bất kỳ câu nào ở trên là không thì chúng ta không nên sử dụng đệ quy. Trong trường hợp đó, chúng ta nên xem xét phép lặp có nghĩa là vòng lặp.

3081
00:02:10,790 --> 00:02:24,770
Vì vậy, chúng ta phải sử dụng đệ quy khi có thể dễ dàng chia nhỏ một vấn đề thành một vấn đề nhỏ hơn và chúng ta chấp nhận được chi phí bổ sung. Và để có giải pháp nhanh chóng, chúng ta nên xem xét đệ quy.

3082
00:02:25,640 --> 00:02:43,580
Bây giờ chúng ta hãy xem một số ứng dụng thực tế của thuật toán sắp xếp cây ngăn xếp đệ quy quicksort, tìm kiếm sắp xếp hoặc linh hồn của tôi, chèn, xóa, chia và chinh phục, lập trình động, biểu đồ, v.v.

3083
00:02:44,240 --> 00:03:01,790
Có nhiều trường hợp sử dụng đệ quy, đệ quy gần như bắt buộc đối với các bài toán về cây và có
nhiều trường hợp sử dụng đệ quy. Chúng ta đã thấy rất nhiều hàm đệ quy trong khóa học này. 

@@@



3084
00:00:00,690 --> 00:00:16,260
Này, các bạn cũng vậy, chào mừng bạn quay trở lại với video này trong video này, chúng ta sẽ nói về băm im lặng là một phương pháp lập chỉ mục dữ liệu là gì. Ý tưởng đằng sau việc băm là cho phép một lượng lớn dữ liệu được lập chỉ mục bằng cách sử dụng chữ hoa chữ thường.

3085
00:00:17,580 --> 00:00:29,790
Việc sử dụng phổ biến nhất cho hàm băm là triển khai hàm băm. Băm ổn định thường được sử dụng để xác minh mật khẩu hoặc xác thực mật khẩu.

3086
00:00:30,870 --> 00:00:47,880
Bây giờ bạn có thể nghĩ chúng ta nên học băm gì. Chúng tôi có rất nhiều cấu trúc dữ liệu khác nhau. Đã thêm Các bác sĩ sẽ mất độ phức tạp theo logarit để tìm một phần tử trong khu vực được sắp xếp trong danh sách liên kết.

3087
00:00:47,930 --> 00:00:58,970
Tất cả đều cần độ phức tạp thời gian tuyến tính đối với một cây. Sẽ mất nhiều thời gian hơn để làm cho thời gian trở nên phức tạp. Phải mất rất nhiều thời gian phức tạp đối với một xã hội nhị phân và đối với mỗi cái cây.

3088
00:01:00,050 --> 00:01:17,480
Ở đây chúng ta thấy ở phần cuối, bạn sẽ mất nhiều thời gian hơn để lập danh sách thời gian, độ phức tạp và liên kết. Tất cả đều mất thời gian tuyến tính. Độ phức tạp hoặc hàm băm sẽ áp dụng cho các trường hợp tốt nhất, độ phức tạp về thời gian không đổi và đối với các trường hợp xấu nhất sẽ cần độ phức tạp theo thời gian tuyến tính.

3089
00:01:18,650 --> 00:01:34,220
Đây là lý do tại sao chúng ta nên học băm. Việc băm tất cả cần độ phức tạp về thời gian không đổi và cực kỳ hiệu quả đối với trường hợp tốt nhất, điều mà chúng ta có thể giả sử trong các trường hợp trung bình, việc băm sẽ có độ phức tạp về thời gian không đổi.

3090
00:01:34,550 --> 00:01:47,720
Vì vậy, chúng tôi thấy rằng độ phức tạp về thời gian không đổi sẽ tốt hơn nhiều. Vâng, độ phức tạp ba lần là gì? Vì lý do này, chúng ta nên học băm. Đây là một mảng có chiều dài.

3091
00:01:47,750 --> 00:02:00,200
16. Chúng ta có số chỉ mục từ 0 đến 15. Giả sử chúng ta muốn lưu trữ chuỗi mọi CTF và X widget trong vùng này và nó sẽ làm gì, bạn sẽ làm gì.

3092
00:02:00,200 --> 00:02:14,060
Nó sẽ lưu trữ sự xoắn này trong khu vực này. Và nếu muốn tìm một bụi thì bạn sẽ quét toàn bộ mảng để tìm ra chuỗi mỗi c d f hoặc bị kích thích để nó có thể lưu chuỗi vào mảng này.

3093
00:02:14,330 --> 00:02:33,860
Hoạt động tìm kiếm sẽ tăng gấp đôi độ phức tạp thời gian tuyến tính, nhưng bằng cách sử dụng hàm băm, chúng ta có thể tìm thấy chuỗi trong mảng theo thời gian không đổi đối với các trường hợp trung bình. Điều đầu tiên tôi sẽ làm là tìm cho nó một giá trị nguyên từ chuỗi này.

3094
00:02:34,130 --> 00:02:45,500
Để làm được điều đó, chúng ta sẽ gọi hàm băm với cây này. Giả sử hàm băm sẽ trả về sáu cho chuỗi này và cho bốn chuỗi. Hàm băm sẽ trả về.

3095
00:02:45,920 --> 00:03:03,470
15. Và đối với chuỗi, hàm băm sẽ là vùng 11. Bây giờ bạn định làm gì hoặc đi lưu trữ gì? Nếu bạn nhìn thấy tại Chỉ mục sáu trong khu vực này và bạn sẽ lưu trữ chuỗi này ở Chỉ mục 15 và bạn sẽ lưu trữ tiện ích Chuỗi X này ở Chỉ mục 11.

3096
00:03:03,740 --> 00:03:14,960
Bây giờ, nếu bạn muốn tìm phần tử đó, nếu bạn nhìn thấy nó trước tiên, bạn sẽ làm gì? Chúng ta sẽ tìm ra giá trị băm của chuỗi này. Đó là tất cả những gì chúng tôi muốn tìm hiểu.

3097
00:03:14,960 --> 00:03:25,790
Nếu trước tiên chúng tôi thấy bạn sẽ làm gì, nó sẽ tìm thấy giá trị băm bốn. Nếu bạn thấy khi gọi chuỗi này bằng hàm băm thì hàm băm đó đã có giá trị rồi.

3098
00:03:26,360 --> 00:03:41,270
Vì vậy, chúng tôi tìm thấy nó ở đây. Hizbul là sáu và chúng ta sẽ di chuyển ở chỉ số sáu trong khu vực này. Bây giờ chúng ta sẽ tra cứu Chỉ số sáu trong lĩnh vực này và chúng ta sẽ so sánh nó với các phần tử ở mọi C và ở đây chúng ta thấy mọi C và chúng ta thấy đều giống nhau.

3099
00:03:41,360 --> 00:03:53,920
Vì vậy, chúng ta sẽ chọn vùng hai vì chúng ta đã tìm thấy phần tử trong vùng đó. Và đây được gọi là cấu trúc dữ liệu băm. Băm này được sử dụng rộng rãi trong thế giới thực.

3100
00:03:53,930 --> 00:04:04,940
Hàm băm phức tạp hơn nhiều, nhưng nguyên tắc cốt lõi ở đây vẫn giống nhau. Cách chúng tôi tìm ra giá trị băm này. Chúng tôi đang sử dụng một chức năng đơn giản.

3101
00:04:05,240 --> 00:04:28,850
Chúng tôi đang chuyển chuỗi này vào hàm băm và chúng tôi đang thêm tất cả giá trị yêu cầu cho ký tự trong chuỗi. Chúng tôi đang thêm để hỏi bạn một tình yêu, cộng với ước tính của B cộng với ký hiệu của C và chúng tôi sẽ tính toán chế độ gửi để hỏi bạn và bạn sẽ thấy cách chúng tôi tính giá trị băm này.

3102
00:04:29,060 --> 00:04:37,700
Chúng ta sẽ thấy một hàm băm đơn giản, nhưng trong thế giới thực, hàm băm phức tạp hơn nhiều. Trong video tiếp theo, bạn sẽ thấy thuật ngữ băm.

3103
00:04:37,820 --> 00:04:48,860
Hàm băm có xung đột giá trị. Bây giờ hãy nói về ứng dụng băm. Băm cung cấp thời gian không đổi, tìm kiếm trong tìm kiếm và thực hiện thao tác ở mức trung bình.

3104
00:04:49,490 --> 00:05:05,720
Đây là lý do tại sao băm là một trong những cấu trúc dữ liệu được sử dụng nhiều nhất. Các bài toán ví dụ là các phần tử riêng biệt đếm tần số của các mục, tìm các bản sao để giải các bài toán này hoặc các loại bài toán này hoặc sử dụng hàm băm.

3105
00:05:06,080 --> 00:05:26,390
Trên thực tế, việc giải quyết loại vấn đề này là một động lực rất lớn. Ổn định sử dụng cấu trúc dữ liệu băm trong nội bộ để phân loại vấn đề. Chúng tôi sử dụng băm. Đây là ứng dụng của hàm băm mật mã, xác minh mật khẩu để xác minh mật khẩu hoặc sử dụng hàm băm.

3106
00:05:26,690 --> 00:05:46,310
Hàm băm mật mã được sử dụng rất phổ biến trong việc xác minh mật khẩu. Các hoạt động biên dịch sử dụng hàm băm mà thuật toán Robin Curve nổi tiếng sử dụng. Việc gấp rút, liên kết file anh và vỗ nhẹ vào nhau trên PC hoặc máy tính đều sử dụng cấu trúc dữ liệu băm.

3107
00:05:46,610 --> 00:05:58,700
Không, hãy xem những ứng dụng thực tế của việc băm. Bây giờ hãy giả sử đây là máy chủ Facebook và đây là máy tính của bạn. Ở đây đang cố gắng đăng nhập vào tài khoản Facebook của chúng tôi.

3108
00:05:59,090 --> 00:06:10,310
Giả sử đây là tài khoản Facebook của bạn. Email Đây là email và đây là mật khẩu. Bây giờ chúng ta có thể lưu trữ mật khẩu này vào máy chủ. Bạn khôi phục mật khẩu đơn giản một hai ba bốn năm sáu bảy tám.

3109
00:06:10,490 --> 00:06:39,590
Nếu bằng cách nào đó máy chủ bị Hacker Ben Hacker tấn công có thể truy cập vào tài khoản của chúng tôi. Và nếu đây là thông tin tài khoản ngân hàng hoặc tài khoản trực tuyến của bạn, nếu máy chủ được tăng tốc và nếu mật khẩu pin được lưu trên máy chủ thì hacker có thể truy cập thông tin của bạn và hacker có thể đánh cắp rất nhiều tiền và không được bảo mật thay vì lưu trữ mật khẩu đơn giản.

3110
00:06:39,830 --> 00:06:57,740
Bạn làm nghề gì? Nó sẽ tạo ra Chevelle cao thấp. Giá trị cao nhất cho mật khẩu này là giá trị băm của anh ấy. Thay vào đó, việc lưu trữ mật khẩu hiển thị đều được lưu ở mức cao này trên máy chủ khi nó nhập email và mật khẩu này vào máy tính của bạn.

3111
00:06:58,220 --> 00:07:10,820
Mật khẩu sẽ được chuyển đổi thành đồng băm bằng hàm băm và bạn có thể truy cập vào tài khoản nếu chúng tôi nhập đúng mật khẩu. Chúng ta không cần phải nhớ giá trị băm này.

3112
00:07:11,150 --> 00:07:25,760
Chúng tôi chỉ cần nhớ mật khẩu của mình và điều này được bảo mật để xác thực mật khẩu. Chúng tôi sử dụng cấu trúc dữ liệu băm này. Có rất nhiều hàm băm có thể tạo ra những giá trị khổng lồ trong thế giới thực.

3113
00:07:25,940 --> 00:07:36,190
Các hàm băm phức tạp hơn nhiều, nhưng logic cốt lõi là SIM và các cách sử dụng băm phổ biến khác là mức độ ổn định phải được xây dựng trong một cấu trúc.

3114
00:07:36,190 --> 00:07:48,080
Nó sử dụng cấu trúc dữ liệu băm trong nội bộ. Bằng cách sử dụng độ ổn định cao, chúng tôi có thể
làm cho chương trình của mình trở nên siêu hiệu quả và có rất nhiều ứng dụng băm vào cấu trúc. 

@@@



3115
00:00:01,260 --> 00:00:15,880
Trong video này, bạn sẽ nói về các thuật ngữ băm. Đầu tiên chúng ta hãy nói về hàm băm trong hàm băm là một hàm có thể được sử dụng để ánh xạ dữ liệu của một trang web tùy ý tới dữ liệu của một trang web cố định.

3116
00:00:16,780 --> 00:00:28,840
Hàm băm sẽ lấy đầu vào từ người dùng và tạo ra các giá trị băm từ mã thông báo đã cho. Bây giờ hãy nói về các khóa chính mà dữ liệu do người dùng cung cấp.

3117
00:00:29,770 --> 00:00:42,910
Là gì? Nó có giá trị. Giá trị được trả về bởi hàm băm được gọi là mã băm Hijuelos. Ngoài ra, nó được gọi đơn giản là băm. Nó ổn định đến mức nào?

3118
00:00:42,910 --> 00:00:54,640
Cấu trúc dữ liệu đang triển khai cản trở ARI liên quan do loại cấu trúc có thể ánh xạ các nhà phát triển chính. Nó sử dụng hàm băm để tính toán.

3119
00:00:54,640 --> 00:01:10,690
Mã băm có cấu trúc hai chữ số trong khóa. Nó sử dụng cấu trúc dữ liệu băm bằng bảng has. Chúng tôi có thể lưu trữ dữ liệu ngang hàng đáng tin cậy. Chúng ta có thể truy cập dữ liệu về mức độ ổn định hoặc trung bình trong thời gian không đổi.

3120
00:01:10,900 --> 00:01:23,830
Và điều đó cực kỳ hiệu quả. Bây giờ liên minh băm là gì? Tất nhiên, một liên minh đã đi đến khóa khác để hàm băm tạo ra cùng một đầu ra gọi là giá trị băm.

3121
00:01:24,460 --> 00:01:42,130
Nếu hàm băm trả về cùng một giá trị hoặc cùng một giá trị băm cho các đầu vào khác nhau thì nó được gọi là xung đột trên mỗi xung đột. Quy tắc cấu trúc dữ liệu băm áp dụng cho các trường hợp xấu nhất.

3122
00:01:42,190 --> 00:02:04,000
Độ phức tạp thời gian tuyến tính Nếu không có xung đột, nó sẽ mất độ phức tạp thời gian không đổi bất kể thế nào. Trong phần thảo luận này, bạn sẽ thấy cách giảm xung đột khi băm cấu trúc dữ liệu, do đó, hàm băm hoặc khóa chỉ mục làm giá trị băm đầu vào và ghi.

3123
00:02:04,630 --> 00:02:19,380
Nếu hàm băm trả về SIM có giá trị cho các đầu vào khác nhau thì xung đột là đúng và chúng ta phải làm như vậy. Đó là một sự va chạm về năng khiếu, một hàm băm tốt trong các kỹ thuật giải quyết xung đột.

3124
00:02:19,450 --> 00:02:31,150
VIDEO Chúng ta sẽ nói về cách xử lý xung đột khi hàm băm trả về. SIM có
bốn đầu vào khác nhau trong video tiếp theo hoặc sẽ nói về hàm băm. 

@@@



3125
00:00:00,730 --> 00:00:10,260
Các bạn đây, hai bạn cùng quay lại với video này, các bạn sẽ nói về tiếng Nga khắc nghiệt. Đây là một hàm băm đơn giản, rối loạn chức năng có hai tham số.

3126
00:00:11,530 --> 00:00:33,760
Chuỗi ở đây có phải là số nguyên hay chuyển đổi chuỗi thành vùng ký tự? Và đây không phải là biến này. Chúng tôi đang thêm giá trị hỏi bạn cho ký tự trong chuỗi đã cho và ở đây tính toán lại giá trị ASCII bằng công thức này sau khi tính giá trị hỏi.

3127
00:00:34,100 --> 00:00:52,870
Chúng tôi đang trả lại một số mô-đun. Đây là hàm băm đơn giản. Bây giờ, hãy giả sử đây là một khu vực của Lent 610. Ở đây chúng tôi có chỉ mục từ 0 đến 15 cho chuỗi mỗi C cho chuỗi DFA và bốn tiện ích Chuỗi X.

3128
00:00:52,910 --> 00:01:12,320
Nếu bạn gọi, nếu bạn gọi hàm băm này hoặc chuỗi ibs-c và sáu, thì nó sẽ trả về sáu. Bởi vì với chuỗi này và giá trị không đổi 16, nó sẽ trả về Putin và bốn tiện ích x vào khu vực bạn đang sống ở đây.

3129
00:01:12,350 --> 00:01:34,870
Chúng tôi gọi chức năng này là chức năng nhà. Đó là sự trở lại. Sáu. Bây giờ chúng ta hãy xem nó được thực hiện như thế nào. Sáu. Đầu tiên, chúng ta cộng giá trị ASCII cho nó, cho B và cho C. Vậy 65 là yêu cầu ID, 66 cho B và 67 cho C nếu chúng ta cộng tất cả số thập phân nhưng mô hình 198 198 của 16 bằng sáu.

3130
00:01:35,350 --> 00:01:48,970
Vì vậy, đối với đầu vào này, 106 cho chuỗi D này, nếu nó là 15, bây giờ chúng ta tìm ra số sáu. Bây giờ chúng ta sẽ làm gì? Chúng tôi sẽ chèn chuỗi này vào Index sáu trong khu vực này.

3131
00:01:49,090 --> 00:02:02,870
Vì vậy hãy chèn vào đây. Bây giờ, hãy gọi hàm này với D F và 16. Nó là 15. Ở đây chúng ta đang cộng giá trị yêu cầu. Hỏi anh ta theo thứ tự từ sáu đến tám. Hãy hỏi anh ấy đủ sáu giờ tối nay và xin anh ấy nghỉ nếu anh ấy 70 tuổi.

3132
00:02:03,420 --> 00:02:15,730
Nếu chúng ta chơi bóng rổ, chúng ta sẽ có ít nhất 207 207. 16 tương đương với 15. Nếu bạn không biết Malone đang hỏi gì thì hỏi giá trị là giá trị đằng sau phím is trên bàn phím.

3133
00:02:16,120 --> 00:02:27,100
Đối với tất cả các ký tự chúng tôi có, hãy hỏi bạn bên dưới, bạn sẽ thấy bảng ASCII sau đó là các biểu đồ trong Bảng 4 của Google ASCII. Chúng tôi đã hỏi bạn rất nhiều. Sáu mươi lăm cho B, chúng tôi đã hỏi về số.

3134
00:02:27,370 --> 00:02:40,360
Sáu hai sáu bốn chữ thường. Nó sẽ có một câu hỏi khác mà bạn cảm thấy là phím trên bàn phím. Chúng tôi đã hỏi bạn giá trị. Nếu bạn muốn xem danh sách giá trị ASCII, chỉ cần tìm kiếm trên Google.

3135
00:02:40,720 --> 00:02:51,890
Bảng giá trị ASCII nhiều người sẽ thấy danh sách giá trị ASCII. Đây là bảng ASCII. Ở đây chúng ta có giá trị ASCII cho mỗi ký tự. Ở đây cho ABC, cho chữ ABC viết hoa.

3136
00:02:51,910 --> 00:03:03,130
Chúng tôi thấy ở đây bạn là sáu hai năm sáu hai sáu sáu hai bảy bốn dd. Nếu bạn nhìn thấy tiện ích hỏi bạn ở đây sáu hai tám sáu ba chín bảy mươi và bốn x, thì chúng tôi có nó ở đây.

3137
00:03:03,130 --> 00:03:22,210
Hỏi anh hẹn hò bao lâu? Tám mươi chín và chín mươi. Bây giờ ở đây chúng ta tìm ra chỉ số, một số nguyên mười lăm từ hàm này. Đây là giá trị băm. Bây giờ chúng ta sẽ chèn chuỗi này vào Index Fifty, vì vậy hãy chèn vào đây DCF bây giờ hãy gọi bằng tiện ích X.

3138
00:03:22,540 --> 00:03:35,590
Giá trị của X là tám mươi tám. Như Kevin, 89 thì bỏ cuộc là 90. Nếu cộng già thì hãy hỏi anh ấy thật nhiều. Chúng tôi đưa hai sáu bảy hai sáu bảy 16 tuổi đến Iran.

3139
00:03:35,950 --> 00:03:51,280
Chúng tôi nhận thấy ở đây có giá trị mà bạn đang hướng tới. Đây là chuỗi. Vì vậy, hãy chèn xếp hạng ở Chỉ số 11. Bây giờ, nếu bạn muốn kiểm tra xem chuỗi này có tồn tại hay không thì bạn đã biết cấu trúc dữ liệu băm của chúng tôi.

3140
00:03:51,310 --> 00:04:07,150
Đầu tiên, chúng ta sẽ gọi hàm băm với chuỗi này là if và với giá trị 16 sẽ tìm ra giá trị 15, chỉ mục bên phải được chuyển vào, tất cả sẽ lấy những giá trị đó ở chỉ mục 15.

3141
00:04:07,160 --> 00:04:24,540
Chúng ta có chuỗi f mà chúng ta thấy ở đây. Vâng, chúng tôi có D. Nếu vậy, hãy trả lại nó hoặc thứ gì đó tương tự. Vì vậy, chúng tôi đã mã hóa chuỗi thành số nguyên này và chúng tôi đặt chuỗi ở chỉ mục này.

3142
00:04:24,550 --> 00:04:35,320
Được rồi, đây là khái niệm về hàm băm trong thế giới thực. Hàm băm phức tạp hơn nhiều, nhưng ở đây chúng tôi sẽ chỉ cho bạn một ví dụ đơn giản, đơn giản về hàm băm.

3143
00:04:35,680 --> 00:04:49,090
Logic cốt lõi là như nhau. Đây là logic cốt lõi của hàm băm. Đây là cách hoạt động của cấu trúc dữ liệu băm để chúng ta có thể tra cứu dữ liệu về việc băm cấu trúc đó theo thời gian trung bình không đổi.

3144
00:04:49,150 --> 00:04:59,110
Bây giờ, hãy lấy các đầu vào khác nhau để kiểm tra ý chí cho chuỗi và cho chuỗi ADC mãi mãi, để nó sẽ trở về bốn tệp thực thi được viết là hai và bốn.

3145
00:04:59,110 --> 00:05:10,930
Đó là nơi nó sẽ quay trở lại. Vì vậy, đối với các đầu vào khác nhau mà chúng tôi thấy hiện tại có giá trị băm sim hoặc chúng tôi nên kể lại những gì chúng tôi nên lưu trữ khóa và cách chúng tôi nên lưu trữ nó bây giờ là vấn đề.

3146
00:05:11,010 --> 00:05:21,060
Mảng ở đây. Hãy xem làm thế nào chúng tôi có thể tìm thấy nó để hỏi bạn, liệu bạn có gọi hàm băm này bằng Will không và với hằng số 5, nó sẽ quay trở lại và đây là cách nó quay trở lại?

3147
00:05:21,110 --> 00:05:32,400
Ở đây chúng tôi đã thêm tất cả để yêu cầu bạn tìm kiếm nhân vật được tiết lộ và chúng tôi đang tìm mô hình cho 207 và 5. Chúng tôi cũng tìm thấy cô ấy. Chúng ta sẽ chèn ivill vào Index two.

3148
00:05:32,480 --> 00:05:46,820
Bây giờ bạn gọi hàm băm với chuỗi này, sau đó bạn tìm nó để biết nên chèn SDK chuỗi này vào đâu. Ngoài ra, nếu bạn gọi hàm này bằng ADC và 5, bạn nên biết mình nên chèn thêm những gì.

3149
00:05:47,070 --> 00:05:57,240
Chúng ta đã có một phần tử ở Index 2. Môn thể thao này đã có người chiếm rồi, hoặc bạn nên nhét thẻ vào và Hauner nên nhét EDC vào, và điều này gọi là va chạm.

3150
00:05:57,330 --> 00:06:07,630
Họ đang cố gắng GWAS trên chỉ mục SIM. Bây giờ đây là một liên minh mà bạn nên chèn ba sợi dây này vào đó. Đầu tiên, chúng ta phải hiểu liên minh.

3151
00:06:07,920 --> 00:06:20,310
Hai chuỗi này sẽ cung cấp những gì để bạn có thể đặt SDK và ADC nướng này để hiểu điều đó. Đầu tiên, chúng ta phải hiểu các kỹ thuật giải quyết va chạm.

3152
00:06:20,550 --> 00:06:31,910
Trong video tiếp theo, chúng ta sẽ nói về các kỹ thuật giải quyết va chạm. Bây giờ hãy nói về các thuộc tính của hàm băm tốt. Các thuộc tính của hàm băm tốt sẽ phân phối Hijuelos đồng đều.

3153
00:06:31,950 --> 00:06:42,270
Nó phải dễ dàng để tính toán. Nó sẽ giảm thiểu va chạm và sẽ dẫn đến
bất kỳ va chạm nào. Đây là những đặc điểm của một hàm băm tốt. 

@@@



3154
00:00:00,570 --> 00:00:15,360
Trong video trước, chúng ta đã thấy rằng chúng ta đã chèn chuỗi tại Chỉ mục hai, nhưng chúng ta không hiểu họ nên chèn các cạnh và không an toàn như thế nào. Điều này xảy ra do va chạm.

3155
00:00:16,260 --> 00:00:27,390
Bây giờ chúng ta có hai kết quả va chạm. Bây giờ hãy nói về các kỹ thuật giải quyết va chạm. Chúng ta có thể giải quyết vấn đề này theo ba cách. Bây giờ chúng ta hãy nói về điều đó từng cái một.

3156
00:00:28,230 --> 00:00:38,070
Bây giờ chúng ta sẽ nói về các kỹ thuật giải quyết va chạm cho các kỹ thuật giải quyết va chạm. Chúng ta có thể giải quyết xung đột bằng cách sử dụng phương pháp đào tạo trực tiếp này.

3157
00:00:38,280 --> 00:00:47,700
Và bạn có thể giải quyết xung đột bằng cách sử dụng địa chỉ mở cho địa chỉ mở. Chúng ta có ba cách chứng minh tuyến tính, thăm dò bậc hai và băm kép.

3158
00:00:48,390 --> 00:01:06,600
Đầu tiên, hãy nói về đào tạo trực tiếp. Chúng ta sẽ nói về thăm dò tuyến tính, thăm dò bậc hai và băm kép. Đào tạo lại đào tạo trực tiếp là gì? Triển khai các nhóm khi các phần tử xung đột về mặt ngôn ngữ học được lưu trữ trong danh sách này.

3159
00:01:07,530 --> 00:01:22,650
Ở đây chúng tôi có bốn chuỗi mỗi k-ville. Đây rồi. Và ở đây chúng ta có một mảng có độ dài. 16. Bây giờ hãy nói về đào tạo trực tiếp. Bây giờ hãy xem đào tạo trực tiếp hoạt động như thế nào.

3160
00:01:23,160 --> 00:01:34,500
Giả sử chúng ta được cấp chuỗi này. Vì vậy chúng ta gọi hàm băm là hàm băm trả về. Cái này có giá trị một. Thay vào đó, chúng tôi sẽ không chèn chuỗi này vào chỉ mục một.

3161
00:01:34,560 --> 00:01:46,830
Chúng tôi sẽ tạo một danh sách liên kết ở chỉ mục một. Hãy tạo một nhà ngôn ngữ học ở đây và chèn nút này vào danh sách chiến đấu. Vì vậy, ở đây chúng tôi có một danh sách dài.

3162
00:01:47,190 --> 00:01:58,980
Bây giờ chúng ta sẽ chèn vào nút và trong nút đó, hãy chèn chuỗi này. Bây giờ giả sử chúng ta đã tạo nút này với địa chỉ từng cái một. Chúng tôi có ở đây đây là chuỗi và trong con trỏ null.

3163
00:01:59,790 --> 00:02:16,920
Bây giờ chúng ta sẽ lưu trữ người giới thiệu của danh sách liên kết này ở đây. Vì vậy, chúng ta sẽ xâu chuỗi địa chỉ này để nó sẽ được thể hiện giống như thế này. Nếu tìm thấy, hàm băm trả về cùng một giá trị, chúng ta sẽ thêm chuỗi đó vào con trỏ tiếp theo của nút này.

3164
00:02:17,160 --> 00:02:28,710
Bây giờ đối với chuỗi này, nó được ghi vào. Bây giờ chúng ta sẽ tạo chứ không phải mọi bệnh tật và chúng ta sẽ chèn nó vào Chỉ mục hai. Và ở đây chúng ta sẽ lưu trữ tham chiếu ghim địa chỉ của ghi chú này.

3165
00:02:28,890 --> 00:02:41,610
Đó là 01:58 Vậy hãy chèn vào đây 2-2-2, sau đó nó sẽ được thể hiện như thế này. Bây giờ chuỗi tiếp theo của chúng tôi không an toàn. Bây giờ chuỗi tiếp theo của chúng ta là chuỗi gốc an toàn trong mối quan hệ ngôi nhà.

3166
00:02:41,880 --> 00:02:55,650
Chúng tôi thấy rằng chỉ số hai đã bị chuỗi Every chiếm giữ. Bây giờ điều tôi sắp làm là tạo một nút mới và tôi sẽ thêm tham chiếu của nút này vào đây.

3167
00:02:56,010 --> 00:03:08,130
Vì vậy, chúng ta sẽ thêm nút này làm nút hỗn hợp của nút này. Vì vậy, nó sẽ được đại diện như thế này. Bây giờ đối với chuỗi này, chúng ta thấy rằng nó cũng được viết với giá trị cao nhất.

3168
00:03:08,610 --> 00:03:19,710
Chúng tôi thấy rằng nó đã được lập chỉ mục bởi một số phần tử. Bây giờ bạn định làm gì? Chúng tôi sẽ tạo một nút mới và chúng tôi sẽ thêm nút này làm nút tiếp theo.

3169
00:03:20,250 --> 00:03:29,370
Vì vậy, chúng tôi sẽ lưu trữ tài liệu tham khảo này ở đây. Vì vậy, chúng ta sẽ thêm nút này làm nút tiếp theo của nút này. Vì vậy, nó sẽ được đại diện như thế này.

3170
00:03:29,790 --> 00:03:42,270
Và điều này được gọi là đào tạo trực tiếp. Giả sử bạn muốn tìm hiểu chuỗi thực thi ở đây sẽ quay trở lại chuỗi này, ví dụ: chỉ trong cấu trúc băm của chúng tôi cho những gì bạn sẽ làm.

3171
00:03:42,420 --> 00:03:52,170
Đầu tiên chúng ta sẽ gọi hàm băm, hàm băm sẽ quay về. Bây giờ chúng ta sẽ xem xét Index hai. Ở đây chúng ta thấy yếu tố đầu tiên chúng ta có trong này, không phải mọi yếu tố.

3172
00:03:52,170 --> 00:04:11,820
Vì vậy, đó không phải là năng lượng bằng nhau. Bây giờ chúng ta sẽ chuyển sang nút tiếp theo và đó là ở đây. Ở đây chúng ta thấy tâm lý. Vì vậy, chúng tôi phát hiện ra đây là chuỗi cho trường hợp xấu nhất, nếu xảy ra va chạm, thao tác thứ hai sẽ giảm vì độ phức tạp về thời gian, đó là trường hợp xấu nhất đối với những đứa trẻ giỏi nhất.

3173
00:04:12,150 --> 00:04:37,320
Trung bình, nó sẽ đòi hỏi độ phức tạp về thời gian không đổi. Nếu bạn muốn biết đây là chuỗi, nó sẽ trả về. Cái này có một và bạn có thể tra cứu chỉ mục một, và đó là mọi khóa nếu bạn muốn tìm giá trị này, nếu muốn, thì nếu bạn gọi hàm băm bằng chuỗi này, hàm băm hoặc được ám chỉ tại chỉ mục, chúng ta thấy yếu tố đầu tiên đó là nếu bạn làm như vậy bạn sẽ có vùng thứ hai.

3174
00:04:37,680 --> 00:04:52,470
Vì vậy, trung bình, nó sẽ mất độ phức tạp về thời gian không đổi. Bây giờ chúng ta hãy nói về địa chỉ mở địa chỉ mở kém. Chúng ta có ba cách để giải quyết việc thăm dò tuyến tính va chạm, thăm dò bậc hai và băm kép.

3175
00:04:52,500 --> 00:05:06,500
Bây giờ chúng ta hãy nói về việc thăm dò tuyến tính địa chỉ mở trong các phần tử xung đột địa chỉ mở là gì. Trong các dấu ngoặc trống khác, nó sẽ không lưu trữ nhiều phần tử trên cùng một vị trí như đào tạo trực tiếp.

3176
00:05:06,770 --> 00:05:20,660
Vì vậy, chúng tôi đang mở, chúng tôi có thể sử dụng các gói phía sau. Bây giờ hãy nói về việc thăm dò tuyến tính. Thăm dò tuyến tính là một chiến lược giải quyết xung đột bằng cách đặt khóa mới vào ô trống rơi gần nhất.

3177
00:05:21,440 --> 00:05:31,890
Hãy xem nó hoạt động như thế nào. Bây giờ chúng ta sẽ nói về thăm dò tuyến tính. Đầu tiên, chúng ta có chuỗi này. Bây giờ, bạn định làm gì? Chúng ta sẽ tìm ra giá trị cao nhất bằng cách gọi hàm băm.

3178
00:05:31,910 --> 00:05:42,500
Vì vậy, hàm băm chỉ có một ở chỉ mục một, chúng ta sẽ chèn mọi khóa. Vì vậy, hãy chèn MBK của bạn ngay bây giờ cho chuỗi này, vì hàm băm, hàm băm hoặc Luyanda cũng có giá trị.

3179
00:05:43,400 --> 00:05:54,260
Vậy chúng ta sẽ làm gì? Chúng ta sẽ chèn cái giếng này vào Index 2. Chúng tôi thấy rằng chỉ mục chọn trống, vì vậy hãy chèn chuỗi vào đây. Vì vậy, hãy chèn.

3180
00:05:54,440 --> 00:06:08,570
Chúng tôi sẽ thêm chỉ số hai. Bây giờ chúng ta có đạo đức dây ở đây. Ở đây chúng ta thấy nó được gọi là hàm băm. Hàm băm sẽ trở về tại chỉ mục. Chúng tôi đã có một phần tử nhưng chỉ mục đã bị chiếm dụng.

3181
00:06:09,290 --> 00:06:19,100
Vậy bạn sẽ làm gì? Chúng tôi sẽ di chuyển đến ngọn đồi tiếp theo. Tôi sẽ lấy hỗn hợp. Vì vậy, nếu phần tô hỗn hợp trống, chúng ta sẽ chèn Asuka vào phần tiếp theo.

3182
00:06:19,310 --> 00:06:29,450
Ở đây chúng ta thấy ô trống ở chỉ số thứ ba. Vậy hãy chèn vào đây, Ezike. Bây giờ chúng ta hãy xem. Chúng tôi muốn chèn chuỗi này. Chúng tôi vì hàm băm.

3183
00:06:29,960 --> 00:06:41,090
Nếu hàm băm vùng hai, chúng ta sẽ chèn hai vào chỉ số hai. Nhưng chúng ta thấy rằng chỉ số hai đã bị một phần tử chiếm giữ. Bây giờ chúng ta sẽ làm gì?

3184
00:06:41,390 --> 00:06:51,950
Chúng ta sẽ chuyển sang ô tiếp theo. Chúng tôi sẽ lấy hai cái tiếp theo. Chúng ta thấy ô tiếp theo không trống nên chúng ta sẽ chuyển sang ô tiếp theo. Và ở đây chúng ta thấy chỉ mục cho ô này trống.

3185
00:06:52,160 --> 00:07:04,370
Vì vậy chúng ta sẽ chèn một chữ số ngay tại đây. Và điều này được gọi là tuyến tính, chứng tỏ ô hiện tại của bạn trống. Chúng ta sẽ tìm ô avec un gần nhất và đây được gọi là thăm dò tuyến tính.

3186
00:07:04,970 --> 00:07:16,670
Hiểu thế nào là tuyến tính, thăm dò tuyến tính hoặc tìm cách tìm ra nó gần nhất với môn thể thao này. Nếu bạn thấy chỗ trống thì chúng tôi sẽ chèn chuỗi đó hoặc dữ liệu đó vào.

3187
00:07:17,150 --> 00:07:34,010
Bây giờ giả sử chúng ta muốn tìm ra chuỗi này. Bạn biết bạn sẽ phải cấu trúc những gì nếu chuỗi này tồn tại, dẫn đến những chuỗi khác đã mở ra. Điều đầu tiên bạn sẽ gọi là hàm băm hoặc chuỗi và hàm băm được ám chỉ nếu hàm băm quay trở lại thì bạn sẽ làm gì?

3188
00:07:34,040 --> 00:07:44,970
Chúng tôi sẽ di chuyển chỉ mục đó đến khu vực này tại index. Bây giờ chúng tôi có yếu tố này của bạn. Bạn định làm gì? Chúng tôi sẽ kiểm tra trình soạn thảo phần tử này và Erbil, và chúng không bằng nhau.

3189
00:07:45,410 --> 00:07:57,250
Vì đây là thăm dò tuyến tính nên chúng ta sẽ chuyển sang ô hỗn hợp đó. Hỗn hợp vẫn là chìa khóa, nhưng đây là ADC. Vậy chúng ta hãy chuyển sang ô tiếp theo bên cạnh là ô đó.

3190
00:07:57,260 --> 00:08:10,730
Ở đây chúng ta có ADC. Vì vậy, bạn tìm thấy nó là nó sẽ quay trở lại cho mạch hoặc. Chúng tôi phải duyệt qua toàn bộ cấu trúc dữ liệu băm và tất cả sẽ diễn ra đúng lúc.

3191
00:08:10,730 --> 00:08:29,180
Sự phức tạp của nó hiểu thế nào là thăm dò tuyến tính và đối với đây là chuỗi và đối với tài nguyên quan trọng này, không tin tưởng rằng nó sẽ trả về true theo thời gian không đổi tại chỉ mục khi chúng tôi có nó và tại chỉ mục hai, chúng tôi đã xem xét để có thể tìm kiếm vòng xoắn này trong thời gian không đổi .

3192
00:08:29,870 --> 00:08:40,590
Vì chúng ta có xung đột, nó có thể khắc phục được độ phức tạp về thời gian tuyến tính và đây là điều tồi tệ nhất mà chúng ta có thể hiểu được thế nào là tuyến tính không phù hợp. Bây giờ chúng ta hãy nói về việc thăm dò bậc hai.

3193
00:08:40,610 --> 00:08:55,610
Thăm dò bậc hai là gì? Thăm dò bậc hai hoạt động bằng cách lấy chỉ số băm ban đầu và cộng các giá trị liên tiếp của một đa thức bậc hai tùy ý cho đến khi tìm thấy một ô trống.

3194
00:08:55,940 --> 00:09:13,580
Đây là định nghĩa của thăm dò bậc hai. Bây giờ hãy xem cách thăm dò bậc hai hoạt động như thế nào. Và vì vậy chúng ta có góc phần tư thăm dò được mã hóa chuỗi đầu tiên này. Đó là công thức đa thức cho số lượng đến hoặc đi sử dụng đa thức này một bình phương, hai bình phương, ba bình phương, bốn bình phương R2 và bình phương.

3195
00:09:13,670 --> 00:09:23,300
Bây giờ hãy chèn chuỗi này. Chà, giả sử chúng ta muốn chèn chuỗi này vào cấu trúc dữ liệu băm của mình. Điều đầu tiên tôi sẽ làm là gọi hàm băm, cho phép hàm băm chiếm một vùng.

3196
00:09:23,450 --> 00:09:33,050
Vì vậy, tại chỉ mục một, chúng ta sẽ chèn chuỗi này vì tại chỉ mục một, chúng ta thấy chỗ trống. Vì vậy, hãy chèn nhóm vào chỉ mục một. Bây giờ bạn muốn chèn chuỗi này.

3197
00:09:33,050 --> 00:09:42,080
Nếu bạn gọi hàm băm hoặc chuỗi U thì hàm băm sẽ không tải hai. Bây giờ ở chỉ mục hai, chúng ta sẽ chèn chuỗi này vào chỉ mục hai.

3198
00:09:42,110 --> 00:09:53,380
Chúng tôi thấy chúng tôi có chỗ trống. Vì vậy, hãy chèn Ehlert Index hai. Bây giờ chúng tôi muốn chèn chuỗi này. Nếu chúng ta gọi hàm băm thì hàm băm sẽ quay trở lại hàm băm được ám chỉ.

3199
00:09:53,450 --> 00:10:04,790
Chúng ta thấy rằng tại Chỉ mục hai, chúng ta đã có một phần tử nhưng Chỉ mục hai đã bị chiếm giữ. Bây giờ chúng ta phải giải quyết vấn đề liên minh ở đây vì chúng tôi nhận thấy sự bất bình đẳng trong liên minh ngày càng tăng.

3200
00:10:05,090 --> 00:10:14,920
Bạn làm nghề gì? Chúng tôi sẽ thêm một hình vuông vào bức tường quay lại phía trên các hàm băm khi liên minh phù hợp. Vì vậy, chúng ta sẽ thêm hai và một hình vuông, chúng ta có được ở đây.

3201
00:10:14,930 --> 00:10:30,410
Ba. Bây giờ hãy kiểm tra chỉ số thứ ba. Chúng tôi thấy mình có một chỗ trống. Vì vậy, hãy chèn vào đây là chìa khóa. Bây giờ giả sử chúng ta muốn chèn chuỗi ADIZ này. Nếu bạn gọi hàm băm là hàm băm, hãy đọc nó để thêm chỉ mục vào những gì chúng ta đã có và loại bỏ.

3202
00:10:30,560 --> 00:10:41,620
Vì vậy, chúng tôi tìm thấy nó liên minh ở đây. Bây giờ điều tôi sắp làm là thêm một hình vuông vào vùng màu vàng này, một hình vuông cộng với hai là ba và chỉ số ba.

3203
00:10:41,630 --> 00:10:52,970
Chúng tôi thấy chúng tôi có một yếu tố. Vì vậy, chúng ta sẽ lấy phần tử tiếp theo. Vì vậy chúng ta sẽ lấy hai bình phương từ đa thức này. Bây giờ chúng ta sẽ lấy hai hình vuông và chúng ta sẽ cộng vùng, tiếp theo là các hàm băm.

3204
00:10:53,120 --> 00:11:02,750
Vậy hai cộng với hai một hình vuông sẽ được thành sáu. Bây giờ chúng ta hãy kiểm tra Chỉ số sáu. Chúng tôi thấy Thêm chỉ mục sáu. Chúng ta có một chỗ trống, vì vậy hãy chèn số nguyên chuỗi vào đây.

3205
00:11:03,050 --> 00:11:15,230
Giả sử chúng tôi muốn chèn một chuỗi khác, bạn có muốn chèn một AEI khác không? Tôi gọi hàm băm trên chuỗi tất cả vùng hai mà chúng ta thấy ở chỉ mục hai. Chúng tôi đã có ở Element.

3206
00:11:15,470 --> 00:11:23,700
Vì vậy chúng ta không thể chèn ở đây hai theo số lượng. Có lẽ. Hãy giải quyết liên minh này. Bây giờ chúng ta sẽ cộng một hình vuông thành hai. Chúng tôi nhận được ba ở chỉ số ba.

3207
00:11:23,720 --> 00:11:34,790
Chúng tôi có một phần tử nên không thể chèn vào đây. Bây giờ chúng ta hãy giữ nguyên hình vuông và cộng hai số điểm và hai số mà chúng ta nhận được. Sáu ở chỉ mục là chúng tôi có một phần tử nên chúng tôi không thể chèn vào đây.

3208
00:11:34,880 --> 00:11:43,460
Bây giờ chúng ta sẽ lấy ba hình vuông này và chúng ta sẽ cộng hai hình vuông vào đây thay vì hai. Vì vậy, chúng tôi nhận được chỉ mục bên phải của tôi trong thùng. Chúng ta sẽ làm gì?

3209
00:11:43,520 --> 00:11:55,940
Chúng tôi sẽ chèn phần tử này. Vì vậy hãy chèn vào đây vì ở đây chúng ta có môn thể thao trống. Đây là cách thăm dò bậc hai hoạt động. Bây giờ chúng ta hãy xem. Chúng tôi muốn tìm ra chuỗi này trong hàm băm của chúng tôi, bạn là cấu trúc.

3210
00:11:56,000 --> 00:12:05,150
Và ở đây chúng tôi đang sử dụng phương pháp thăm dò bậc hai để giải quyết liên minh. Bây giờ điều tôi sắp làm là tôi sẽ vào Typekit Index để thêm chỉ mục vào những gì chúng tôi có, nếu bạn muốn, không bằng air.

3211
00:12:05,180 --> 00:12:14,690
Bây giờ chúng ta sẽ lấy 12 đầu tiên ở đây, và chúng ta sẽ cộng nó vào đây để thêm X ba. Chúng tôi có một DC chỉ được phát sóng. Sau đó chúng ta sẽ lấy hai hình vuông để ghi điểm.

3212
00:12:14,690 --> 00:12:27,780
Cộng hai bằng hai sáu ở chỉ số sáu. Chúng tôi có nó. Có phải vậy không? Nó sẽ tiến tới AA, mặc dù chúng ta sẽ lấy số tiếp theo từ đa thức có ba bình phương, hai cộng hai sẽ bằng số liệu ở mức 11.

3213
00:12:27,830 --> 00:12:40,340
Chúng tôi thấy một bài đọc ở trường trung học cũng vậy. Đây là những gì chúng ta có thể tìm nguồn một phần tử trong quá trình băm thành cấu trúc đơn giản khi chúng ta đang giải quyết bằng cách sử dụng số lượng được hiểu rõ về độ xé lõi một cách chính xác.

3214
00:12:40,400 --> 00:12:53,420
Bây giờ hãy nói về phép băm kép cuối cùng. Khoảng thời gian băm kép giữa các đầu dò được tính toán bằng các hàm băm khác. Vì vậy, trong băm kép, chúng tôi sử dụng các hàm băm khác.

3215
00:12:53,600 --> 00:13:02,930
Vì vậy, khi băm kép, chúng tôi sẽ sử dụng PU Hash Russian để giải quyết xung đột. Nào, hãy xem chúng ta có thể làm điều đó như thế nào. Bây giờ, giả sử chúng ta muốn chèn chuỗi vào mỗi K.

3216
00:13:03,170 --> 00:13:14,330
Nếu bạn gọi hàm băm tất cả, thì giả sử bạn là 201. Nếu đó là sinh viên một và ở chỉ mục một, chúng ta sẽ thấy các điểm trống. Vì vậy, hãy chèn vào đây nó đã trở thành. Bây giờ chúng tôi muốn chèn một hóa đơn.

3217
00:13:14,810 --> 00:13:25,700
Chúng tôi gọi hàm băm này là một hàm. Sau đó, để thêm chỉ mục hai, chúng tôi phải hỗ trợ chọn chèn vào đây mọi lúc. Chúng tôi muốn chèn hàm băm cuộc gọi SDK B.

3218
00:13:25,940 --> 00:13:36,380
Giả sử nó sẽ quay trở lại. Nếu nó quay trở lại với những gì tôi định làm, tôi sẽ đi kiểm tra trên đường phố. Chúng tôi thấy Chỉ số hai đã bị chiếm giữ bởi một phần tử nên chúng tôi đã gặp phải xung đột.

3219
00:13:36,410 --> 00:13:51,140
Bây giờ chúng ta sẽ gọi hàm băm thứ cấp. Hãy gọi hàm băm thứ cấp có hai. Bây giờ chúng ta sẽ gọi một hàm băm khác với chuỗi này SC Q Giả sử hàm này là một vùng cho hàm băm này và đây là hàm băm.

3220
00:13:51,380 --> 00:14:02,510
Bây giờ chúng ta sẽ áp dụng Công thức hai điểm cộng này cho giá trị của mắt một hai ba cho đến N. Ban đầu, tôi có hai một. Vậy chúng ta có hai cộng một nhân khá gần với sáu.

3221
00:14:02,690 --> 00:14:14,880
Bây giờ chúng ta sẽ kiểm tra chỉ số sáu và các chỉ mục. Chúng tôi thấy mình có một chỗ trống. Vì vậy hãy chèn vào đây. Được rồi, bây giờ chúng ta muốn chèn chuỗi này vào hàm băm thông qua cấu trúc của chuỗi đó.

3222
00:14:14,900 --> 00:14:24,920
Đầu tiên, chúng ta sẽ tìm ra giá trị cao nhất mà chúng ta gọi là hàm băm này và giả sử nó sẽ trở về cuối khi được lập chỉ mục cho những gì chúng ta đã có và các phần tử.

3223
00:14:25,130 --> 00:14:34,040
Thế là chúng tôi lại gặp phải va chạm. Bây giờ chúng ta phải giải quyết nó để băm đôi hoặc gọi. Bây giờ chúng ta sẽ gọi một hàm băm khác bằng ADC.

3224
00:14:34,280 --> 00:14:46,190
Giả sử hàm băm thứ cấp trả về. Bốn. Bây giờ ở đây bạn sẽ áp dụng công thức này hai cộng một lần khi bạn đạt đến sáu ở chỉ số sáu. Chúng tôi thấy chúng tôi có một yếu tố.

3225
00:14:46,640 --> 00:14:58,460
Vì vậy chúng ta sẽ tăng giá trị của IE từ một lên hai. Vì vậy, hai cộng hai lần những gì anh ấy đạt tới 10 khi được lập chỉ mục. Chúng tôi thấy chúng tôi có chỗ trống, vì vậy hãy chèn nó vào đây ngay bây giờ.

3226
00:14:58,460 --> 00:15:11,250
Hãy nói rằng chúng tôi muốn. Để chèn chuỗi này vào hàm băm, cấu trúc, trước tiên, chúng ta sẽ gọi hàm Haiti và giả sử Vùng hai, và chúng ta thấy ở Chỉ mục hai, chúng ta có một phần tử.

3227
00:15:11,460 --> 00:15:26,750
Vì vậy, chúng tôi đã gặp phải sự liên minh và chúng tôi sẽ gọi nó là phải hoạt động. Giả sử nó phải hoạt động rồi và chúng ta sẽ áp dụng ở đây, công thức sáu bốn đầu tiên này, tôi có hai một lúc sáu giờ.

3228
00:15:26,760 --> 00:15:38,820
Chúng ta có một phần tử, vì vậy hãy tăng dòng chảy. Tôi và chúng ta nhận được 10 và ở số 10, chúng ta có một phần tử để anh ta có thể chèn vào đây là 10. Vậy hãy tăng giá trị của EI từ hai lên ba.

3229
00:15:39,300 --> 00:15:50,280
Bây giờ ở Chỉ số 14, chúng ta nhận được 14 bằng cách tăng giá trị EI từ hai lên ba lên cộng ba lần giá trị mà anh ta đạt tới 14. Tại Chỉ số 14, chúng ta thấy mình có chỗ trống.

3230
00:15:50,370 --> 00:16:04,980
Vì vậy, hãy chèn vào đây chúng ta có một chuỗi khác trong vùng chuỗi đó, hai chuỗi cho hàm Hasharon. Và nếu điều này phải trả về bốn, thì chuỗi đã cho. Bây giờ bạn làm gì?

3231
00:16:04,980 --> 00:16:20,160
Sẽ mất sáu ở chỉ số sáu. Chúng tôi có một phần tử tại chỉ mục. Chúng tôi có một yếu tố bổ sung trong xuất khẩu. Chúng tôi có một yếu tố. Bây giờ chúng ta sẽ kiểm tra chỉ số cộng hai cộng bốn lần để nó tiến tới 18 và chúng ta thấy chỉ số 18 này nằm ngoài ranh giới ổn định này.

3232
00:16:20,520 --> 00:16:31,020
Vậy chúng ta sẽ làm gì? Chúng ta sẽ tìm thấy mô đun 18 ở đây. Chúng ta sẽ sử dụng 16. Vì vậy, chúng ta sẽ áp dụng ở đây công thức 18. Maula 16.

3233
00:16:31,410 --> 00:16:47,380
Và đây là những gì chúng ta có thể hoán đổi liên minh bằng cách sử dụng hàm băm kép. Chúng tôi hiểu kỹ thuật băm kép đó. Bây giờ, nếu trước tiên chúng ta muốn tìm hiểu API chuỗi, những gì sẽ làm hoặc những gì sẽ tạo ra chỉ mục bổ sung giá trị băm cho những gì chúng ta thấy.

3234
00:16:47,400 --> 00:17:01,500
Chúng tôi không có Yếu tố III. Chúng ta sẽ gọi nó là cái này có hai chức năng và nó được viết để chúng ta áp dụng. Công thức này đầu tiên sẽ lấy số 6 để có 10, sau đó chúng ta sẽ lấy số 14.

3235
00:17:01,500 --> 00:17:12,840
Ở tuổi 14, bạn sẽ tìm thấy nó ở tuổi hai. Và đây là cách băm kép hoạt động. Chúng ta
đã hiểu cách giải quyết xung đột bằng cách sử dụng đối chiếu, sử dụng hàm băm kép. 

@@@



3236
00:00:00,450 --> 00:00:09,570
Này, các bạn thật tuyệt vời. Chào mừng bạn quay trở lại với video này, chúng ta sẽ nói về ưu và nhược điểm của kỹ thuật giải quyết va chạm để điều chỉnh trực tiếp.

3237
00:00:10,350 --> 00:00:23,010
Chúng tôi không sợ điều chỉnh đã quay trở lại. Chúng tôi không phải tạo lại hàm băm chỉ để cấu trúc, để chèn các phần tử mới, nhưng chúng tôi lo ngại về Big Lindquist.

3238
00:00:23,370 --> 00:00:38,790
Nó có thể tạo kịch bản cho một nhà ngôn ngữ học lớn có thể gây ra sự phức tạp về thời gian chậm hơn đối với việc đánh địa chỉ mở. Nó rất dễ thực hiện, nhưng chúng tôi lo ngại việc điều chỉnh sẽ ảnh hưởng đến thị trường.

3239
00:00:39,000 --> 00:00:56,800
Chúng tôi có thể phải tạo cấu trúc dữ liệu băm mới để chèn dữ liệu mới, chọn khóa đào tạo phù hợp và thời điểm chọn mở. Việc giải quyết phía đầu vào không phải là tất cả mà chúng ta nên xem xét việc đánh địa chỉ mở.

3240
00:00:56,880 --> 00:01:10,680
Và nếu tỷ lệ xóa rất cao thì phải luôn đào tạo trực tiếp. Và đây là những ưu và nhược
điểm, và chúng tôi đã hiểu khi nào nên chọn quay lại và bấm còi để chọn địa chỉ mở. 

@@@



3241
00:00:00,360 --> 00:00:23,880
Bây giờ trong video này, chúng ta sẽ nói về những gì bạn nên làm khi hàm băm do cấu trúc của chúng ta đã đầy. Hãy để anh ta ở đây sáu chuỗi này và giả sử chuỗi này có vùng hàm băm, 0 cho vùng bị gãy chuỗi băm, một bốn phân biệt, hai cho chuỗi, ba cho hàm băm chuỗi vùng bốn và bốn hàm băm chuỗi vùng bảy.

3242
00:00:24,690 --> 00:00:43,320
Trong cấu trúc dữ liệu băm này, chúng tôi đã chèn năm chuỗi này vào mỗi C K L và C K và đúng như vậy và chúng tôi thấy hàm băm do cấu trúc đã đầy. Chúng tôi không thể chèn chuỗi mới vào hàm băm này do cấu trúc.

3243
00:00:44,100 --> 00:01:03,600
Vùng chuỗi bảy bốn quay trở lại, chúng ta có thể tìm ra giá trị băm này có thể phù hợp với phạm vi chỉ số này từ 0 đến 4. Ở đây chúng ta có thể sử dụng toán tử Model S và một số nguyên không đổi để khớp với số bảy.

3244
00:01:03,600 --> 00:01:18,360
Trong chiếc cờ lê trong gói này, chúng tôi phải sử dụng chuỗi trực tiếp và chúng tôi phải quản lý các chuỗi với tư cách là một nhà ngôn ngữ học. Nhưng để đánh địa chỉ mở, chúng ta phải tạo ra một hàm băm mới cho cấu trúc thị giác.

3245
00:01:18,570 --> 00:01:34,380
Việc nhân đôi cấu trúc dữ liệu băm hiện có này dường như tạo ra một hàm băm cho một cấu trúc để chèn chuỗi này vào địa chỉ mở. Bây giờ hãy tạo hàm băm cho cấu trúc có độ dài 10.

3246
00:01:34,530 --> 00:01:44,450
Độ dài của hàm băm do cấu trúc này là năm và độ dài của hàm băm do cấu trúc này là 10. Bây giờ chúng ta sẽ chỉnh sửa nó thông qua người hướng dẫn phụ trợ này và chúng ta sẽ tìm ra chỉ mục.

3247
00:01:44,620 --> 00:02:01,770
ABC bằng 0 trong NIC, vì vậy mỗi năm là một bốn tám hai bốn sáu thực hiện ba bốn thêm bạn bốn. Bây giờ bạn muốn chèn chuỗi này vào cấu trúc dữ liệu này thì phải làm như thế nào?

3248
00:02:02,070 --> 00:02:14,520
Chúng ta nên kiểm tra chỉ số bảy. Và ở đây chúng tôi thấy chúng tôi có chỗ trống. Vì vậy, ở đây chúng ta có thể chèn chuỗi. Vì vậy hãy chèn vào đây. Ở đây, chúng ta thấy rằng cấu trúc dữ liệu băm này đã cạn kiệt.

3249
00:02:14,850 --> 00:02:27,310
Chúng tôi đang tạo ra đơn vị một cấu trúc. Nếu cấu trúc này đã đầy vào thời điểm này thì tôi phải tạo hàm băm mới cho cấu trúc Darvel của cấu trúc uder hiện có này.

3250
00:02:27,390 --> 00:02:41,970
Ở đây chúng ta đang nói về chuỗi này. Nếu hàm băm này, cấu trúc này đã đầy và nếu chúng ta thấy chỉ mục không phù hợp với phạm vi chỉ mục này, thì tôi sẽ làm gì, chúng ta sẽ sử dụng toán tử mô đun và một ràng buộc.

3251
00:02:42,240 --> 00:02:56,520
Giả sử, nếu chúng ta sử dụng hằng số năm của bạn và chúng ta được gọi là các toán tử thì ít nhiều năm bằng hai. Vậy trong trường hợp đó, hai người hãy di chuyển tới đây. Nhưng nếu chúng ta thực hiện việc đánh địa chỉ mở ở đây, chúng ta không thể tấn công chớp nhoáng ở bất kỳ vị trí nào vì không có nền tảng.

3252
00:02:56,520 --> 00:03:23,040
Vì vậy, trong trường hợp này, chúng ta phải chèn làm phần tử tiếp theo của phần tử này và tất cả phần tử sẽ được lưu dưới dạng danh sách liên kết. Vì vậy, đối với địa chỉ mở, chúng tôi có thể cần tạo lại hàm băm do cấu trúc, nhưng đối với chuỗi trực tiếp, chúng tôi có thể có một nhà ngôn ngữ học dài và điều đó có thể khiến thời gian truy cập chậm hơn và điều đó sẽ làm tăng độ phức tạp về thời gian.

3253
00:03:23,250 --> 00:03:32,130
Được rồi, các bạn, hoặc chúng tôi đã hiểu điều này với lời giải thích cho mọi câu hỏi ở đây trong ấn bản
này hoặc thậm chí là sự hiểu biết. Gửi câu hỏi của bạn trong diễn đàn Hỏi đáp, tôi sẽ liên hệ với bạn. 

@@@



3254
00:00:00,420 --> 00:00:10,050
Ở đây có một số người quay lại video này trong video này, chúng ta sẽ nói về cách hoạt động của bản đồ băm trong nội bộ. Ở đây chúng tôi khai báo một phương thức bản đồ băm.

3255
00:00:10,140 --> 00:00:25,020
Toán số nguyên chuỗi bằng hai hàm băm mới ở đây trong bản đồ băm này hoặc bạn muốn lưu trữ khóa xuất hiện chuỗi dưới dạng khóa và số nguyên dưới dạng giá trị. Vì vậy, giá trị khóa cửa hàng cũ xuất hiện.

3256
00:00:25,470 --> 00:00:42,900
Phía mặc định của hàm băm là 16. Hệ số tải bằng 0,75. Đây là hệ số tải mặc định và ngưỡng tương đương với bản dựng. Hệ số tải có nghĩa là chúng tôi có thể lưu trữ 70 phần trăm trang web nhất định.

3257
00:00:43,140 --> 00:00:59,250
75 phần trăm của 16 được xây dựng để chúng tôi có thể lưu trữ 12 mục trong phép toán băm. Trang web là 16, nhưng chúng tôi có thể lưu trữ 12 mục, vì vậy kích thước mặc định là 16 và hệ số tải là 0,75.

3258
00:00:59,610 --> 00:01:20,220
Hệ số tải 0,75 có nghĩa là chúng tôi có thể tải dữ liệu 75 phần trăm của 16. 75 phần trăm tăng 16 là Trump. Nếu nó tăng hệ số tải, điều đó có nghĩa là nếu nó tăng ngưỡng đó, thì hàm băm của chúng ta sẽ tăng gấp đôi.

3259
00:01:20,730 --> 00:01:35,220
Nếu chúng ta chèn 11 mục vào thùng Hashgraph, sẽ không có gì xảy ra khi bạn chèn 12 mục vào hàm băm --. Hỗn hợp băm sẽ tăng gấp đôi vì ở đây chúng ta có hệ số tải là 75.

3260
00:01:35,490 --> 00:01:53,550
Chúng tôi có thể lưu trữ 75 phần trăm Sixt trong 75 phần trăm, tăng 16 lên 12. Bất cứ khi nào nó xóa ngưỡng này, hiền nhân trong bản đồ băm của chúng tôi sẽ được nhân đôi và đó là những thứ bên trong mà chúng tôi không thể nhìn thấy.

3261
00:01:53,970 --> 00:02:08,640
Khi Chèn Quilt Item vào hiền nhân, hashmi của chúng ta sẽ được nhân đôi. Chúng ta có thể chỉ định trang web và hệ số tải cho bản đồ băm này, đại loại như thế này. Ở đây chúng tôi đang chỉ định trang web và hệ số tải.

3262
00:02:08,970 --> 00:02:21,390
Giả sử chúng tôi đã chèn CC 09:45 và hệ số tải bằng 1. Vì vậy, ở đây chúng tôi có thể lưu trữ 100 phần trăm trang web. Vì vậy, ở đây chúng ta có thể. Đó là 100 phần trăm tắt các trang web.

3263
00:02:21,390 --> 00:02:34,290
10. Vậy ở đây chúng ta có 10 mục như vậy khi nó nâng ngưỡng này lên. Tỷ lệ băm của chúng tôi sẽ tăng gấp đôi. Khi chèn chín mục thì sẽ không có gì xảy ra.

3264
00:02:34,560 --> 00:02:47,310
Khi chúng tôi chèn mục lều vào Hashgraph, thông số của Hashgraph sẽ được nhân đôi cho trang web này. Din và hệ số tải tiến tới một. Chà, chúng tôi đã hiểu cách hoạt động của bản đồ băm.

3265
00:02:47,550 --> 00:03:04,710
Bây giờ hãy xem cách nó lưu trữ dữ liệu và lấy dữ liệu như thế nào. Bây giờ chúng ta sẽ nói về cách thức hoạt động của phương thức thực phẩm và phương thức get trong toán băm. Bây giờ chúng ta sẽ nói về cách hoạt động của phương thức put và get trong cấu trúc dữ liệu băm.

3266
00:03:05,040 --> 00:03:19,620
Bây giờ chúng ta hãy nói về điều đó. Một điều quan trọng ở đây là Hashgraph sử dụng cấu trúc dữ liệu băm. Ở đây chúng tôi có một loạt các trang web được cố định ở phía mặc định của hàm băm là nhà ngôn ngữ học cửa hàng 16 tuổi.

3267
00:03:19,800 --> 00:03:43,380
Đây không phải là aria của số nguyên. Đây là một mảng danh sách liên kết. Nếu chúng tôi khai báo biểu đồ băm này thì chúng tôi sẽ tạo một khu vực Blinkist ngoài trang web. 16. Bây giờ, nếu chúng ta chèn khóa AVC ở đầu cuối thì nó sẽ được lưu trữ như thế nào trong biểu đồ băm và làm cách nào chúng ta có thể lấy giá trị khóa này từ Hashgraph.

3268
00:03:43,560 --> 00:04:00,870
Bây giờ chúng ta hãy xem. Đầu tiên, chúng ta sẽ tạo giá trị cao nhất cho khóa MVC này. Và sau đó bạn sẽ tính chỉ số của khóa này bằng công thức. Bây giờ chúng ta hãy xem hàm tạo mã băm hoặc giá trị băm từ khóa AVC này tại đây.

3269
00:04:00,900 --> 00:04:11,970
Đây là hàm lưới băm. Hàm này lấy chuỗi tham số làm đầu vào bên trong. Ở đây chúng tôi đang chuyển đổi chuỗi thành mảng ký tự. Sau đó, chúng tôi có số 0 bán tùy chỉnh biến của bạn.

3270
00:04:12,150 --> 00:04:27,690
Và ở đây bằng cách sử dụng điều này cho tất cả chúng tôi, chúng tôi đang thêm vòng lặp hỏi bạn một vòng lặp gồm tất cả các ký tự trong chuỗi đã cho. Ở đây chúng ta có ký tự Air B và C, và ở đây chúng ta đang thêm ASCII của Air B và C, và nó sẽ quay lại yêu cầu bạn mua chức năng lưới băm này.

3271
00:04:27,960 --> 00:04:44,190
Đây là một hàm băm lưới đơn giản sử dụng hàm băm lưới nâng cao. Nhưng ở đây để thiết lập sự hiểu biết hoặc giả định rằng chúng ta chỉ trả về tổng giá trị ASCII của tất cả các ký tự trong một chuỗi nhất định.

3272
00:04:45,090 --> 00:04:54,150
Bây giờ chúng ta sẽ làm gì? Chúng ta sẽ tìm thấy nó được lập chỉ mục bằng cách sử dụng một công thức. Đây là công thức lập chỉ mục các tòa án cho các tòa án băm, tiện ích chính và mã băm.

3273
00:04:54,480 --> 00:05:07,890
Và ở đây chúng ta đang sử dụng toán tử này. Đây là toán tử bidets. Và ở đây trong tôi, cái chúng ta đang ở đây là độ dài của bản đồ băm ở đây, bất kỳ phần tư nào đến 16 16 trừ một là 15.

3274
00:05:08,100 --> 00:05:20,460
Nếu chúng ta gọi hàm này với mọi C và một rối loạn chức năng Thế giới Khu vực hai chín bốn hai, chín, bốn và 15 bằng hai ở đây và toán tử. Đây là một nhà điều hành lớn.

3275
00:05:20,460 --> 00:05:45,120
Nếu chúng ta gọi số này là chín, bốn và 15 thì chúng ta sẽ có sáu cho chỉ số sáu. Bây giờ chúng ta sẽ chèn giá trị khóa ngang hàng này vào Chỉ mục sáu, nhưng cách chúng ta chèn dữ liệu vào Chỉ mục sáu, chúng ta sẽ tạo trong nút nút, bạn sẽ có bốn phần mã băm giá trị khóa và con trỏ tiếp theo.

3276
00:05:45,390 --> 00:05:58,500
Hãy tốt và lưu ý ở đây chúng tôi đã tạo một nút có giá trị có giá trị. Đây là hai chín bốn ở đây chuỗi mọi C và giá trị đó ở đây là một và con trỏ tiếp theo bây giờ ban đầu đã kết thúc.

3277
00:05:58,500 --> 00:06:09,150
Địa chỉ của nút này là một một. Hãy lưu địa chỉ của this not here bằng chuỗi tham chiếu của nút này, vì vậy nó sẽ được biểu diễn giống như thế này.

3278
00:06:09,450 --> 00:06:20,800
Không, chúng ta hãy chèn phím này sẽ xuất hiện. Chìa khóa là bcd và giá trị. Được gọi là hàm băm này có thể hoạt động. Nó sẽ trở lại chín bảy. Và sử dụng công thức này, chúng ta sẽ nhận được chỉ mục.

3279
00:06:20,820 --> 00:06:34,900
Bảy. Hãy chèn một nút tại Chỉ số bảy. Nó có giá trị 297 với chuỗi là khóa và giá trị ở cuối. Con trỏ tiếp theo là bây giờ. Ban đầu, hãy chèn nút đó vào lần truy cập Index thứ bảy.

3280
00:06:34,920 --> 00:06:45,960
Thêm cái này lên. Ghi chú này là 2.2. Hãy chèn địa chỉ này vào đây. Đây là tài liệu tham khảo. Được rồi, đây là tài liệu tham khảo của nút này. Sau đó nó sẽ được đại diện như thế này.

3281
00:06:46,230 --> 00:06:59,160
Vì vậy, chúng tôi đã lưu trữ điều này để nó xuất hiện nếu bạn nhìn thấy một và truy cập hai, bây giờ hãy chèn phím này sẽ xuất hiện d f và thêm ba. Đầu tiên, hãy gọi hàm băm này được bắt bằng F.

3282
00:06:59,160 --> 00:07:10,080
Nó sẽ trả về ba không ba, sau đó chỉ số bằng mười lăm. Chúng ta sẽ bắt đầu lấy các bản ghi chỉ mục bằng cách sử dụng công thức này. Bây giờ chúng ta hãy chèn bàn phím này xuất hiện ở Index 15.

3283
00:07:10,320 --> 00:07:25,590
Đầu tiên, hãy tạo lưới A.. Đây là nút. Đây là nút. Ở đây chúng ta có giá trị ba không ba. Chúng ta có Chuỗi D nếu đây là giá trị khóa thứ ba. Và không, hãy lưu địa chỉ của ghi chú này vào đây để tham khảo nhé.

3284
00:07:25,830 --> 00:07:39,630
Sau đó nó sẽ được đại diện như thế này. Bây giờ hãy chèn Kiva Lapeer SC và trước tiên hãy tính hàm băm bên dưới. Giá trị băm là hai chín bảy, và hãy tìm chỉ số ở Mexico từ hai đến bảy.

3285
00:07:39,900 --> 00:07:51,300
Bây giờ chúng ta sẽ chèn cái này. Keeble xuất hiện ở Index bảy, nhưng ở đây chúng ta thấy rằng ở Index bảy, chúng ta đã có trong node. Vì vậy, đây là một va chạm để giải quyết va chạm.

3286
00:07:51,480 --> 00:08:04,050
Highsmith sử dụng chuỗi trực tiếp. Hãy tạo lưới A. Và hãy để nút này là bit tiếp theo của nút này. Vậy hãy vẽ lưới A.. Đây là nút ở vị trí hai, chín, bảy và C bốn này, và không.

3287
00:08:04,080 --> 00:08:12,600
Bây giờ ở đây chúng ta sẽ lưu trữ sự khác biệt của nốt nhạc này. Đây là ghi chú tiếp theo của ghi chú này. Vì vậy, hãy lưu trữ ở đây bốn bốn, sau đó nó sẽ được biểu diễn như thế này.

3288
00:08:12,750 --> 00:08:26,700
Bây giờ hãy chèn mọi C và năm. Ở đây chúng tôi thấy điều này đã tồn tại. Và đây là những gì tôi sẽ làm. Tôi sẽ chỉ cập nhật bản phát triển năm cho nút này ở đây hoặc sẽ cập nhật nút này từ một lên năm.

3289
00:08:26,700 --> 00:08:35,460
Chúng ta sẽ làm điều đó như thế nào. Đầu tiên, hãy tìm mã băm. Mã băm là hai chín bốn. Bây giờ chúng ta hãy đi chỉ số tốt ở Mexico từ hai đến sáu. Bây giờ chúng ta hãy thêm Index 6.

3290
00:08:35,610 --> 00:08:44,130
Bây giờ hãy thử so sánh khóa của nút này với khóa này. Chúng tôi thấy họ bình đẳng. Vì vậy, chúng tôi sẽ cập nhật giá trị này từ một đến năm từ một đến năm.

3291
00:08:44,160 --> 00:08:53,720
Vì vậy, hãy cập nhật cho nhà phát triển từ một đến năm. Bây giờ chúng ta sẽ cập nhật giá trị của nút này lên sáu tại đây. Được rồi, vì vậy chúng tôi sẽ cập nhật điều này từ 4 đến 6 về cách chúng tôi sẽ thực hiện điều đó.

3292
00:08:53,730 --> 00:09:04,610
Đầu tiên, chúng ta sẽ gọi hàm này là nó sẽ quay trở lại chín bảy trong thời gian ngắn như thế nào. Bây giờ chúng ta sẽ tìm thấy chỉ số của nó là bảy. Bây giờ chúng ta hãy đến Index bảy ở đây, Index bảy, và hãy so sánh SC này với nút này.

3293
00:09:04,650 --> 00:09:16,350
Chúng ta sẽ so sánh chìa khóa ở đây. Chúng ta thấy B, C D và ở đây SC, chúng không giống nhau. Vì vậy, hãy thử chuyển sang nút tiếp theo. Chúng tôi thấy rõ mình có liên minh nên phải chuyển sang A..

3294
00:09:16,530 --> 00:09:26,710
Đây là lưu ý tiếp theo. Bây giờ hãy thử so sánh chữ C và phím này. Hãy xem, chúng ta thấy họ bình đẳng. Vậy chúng ta sẽ làm gì ở đây? Chúng tôi sẽ cập nhật đồng nghiệp này từ đầy đủ đến.

3295
00:09:27,360 --> 00:09:37,860
Sáu. Vì vậy, điều đó cũng được cập nhật từ bốn đến sáu. Sau đó nó sẽ được đại diện như thế này. Nếu chúng ta gọi phương pháp này là đặt trọng lượng ngay bây giờ và bảy. Bây giờ bạn đã làm gì?

3296
00:09:37,980 --> 00:09:48,540
Đây là dự đoán tốt nhất về biểu đồ băm về mức độ ổn định của nó, nhưng mức độ ổn định của nó ngoại trừ bây giờ là chìa khóa cho null keytruda jun zero. Vậy tốt như thế nào sẽ trả về số 0?

3297
00:09:48,690 --> 00:09:59,390
Đây là cái giỏ và hãy tính chỉ số chỉ số sẽ có liên quan bằng 0 nếu chúng ta áp dụng công thức này ngay bây giờ ở chỉ số 0 hoặc sẽ lưu trữ công thức này ở đây ngay bây giờ và bảy, đây là nút chúng ta.

3298
00:09:59,530 --> 00:10:09,220
Xin chào. Không, ở đây chúng tôi có kỹ thuật số của bạn và ở đây. Giá trị bảy và con trỏ tiếp theo không phải bây giờ, hãy thực hiện địa chỉ này ở đây và nó sẽ được biểu diễn giống như thế này.

3299
00:10:09,460 --> 00:10:19,310
Đây là cách phương pháp đặt này hoạt động. Hy vọng bạn đã hiểu cách hoạt động của phương thức put trong bản đồ băm. Bây giờ hãy xem phương thức get hoạt động như thế nào. Có thể gọi phương thức này là phương thức.

3300
00:10:19,360 --> 00:10:30,610
Nhận với MVC 805. Làm thế nào nó sẽ hủy hoại năm. Đầu tiên, nó sẽ tính toán giá trị băm được gọi. Tỷ lệ băm là hai chín bốn. Và bây giờ chúng ta sẽ tính chỉ số sáu.

3301
00:10:30,640 --> 00:10:42,700
Bây giờ chúng ta hãy chuyển sang Chỉ số sáu và so sánh điều này với Norval đầu tiên. Bây giờ chúng ta sẽ cấu hình bộ công cụ bằng khóa của nút đầu tiên này. Chúng tôi thấy ABC và NBC bằng hoặc sẽ trả về giá trị từ nút này.

3302
00:10:42,850 --> 00:10:52,180
Vì vậy, chúng ta sẽ trả về giá trị từ đây bây giờ là 5. Vậy nó là 3,5. Vì vậy, nó là khu vực năm. Không. Chúng tôi gọi đây là đúc tiền bằng BCT. Đầu tiên, chúng ta sẽ tính mã băm.

3303
00:10:52,210 --> 00:11:01,510
Mã băm là 297. Chỉ số là 7. Vì vậy, chúng ta hãy thêm chỉ số bảy. Ở đây chúng ta sẽ so sánh điều này về cơ bản với khóa C. Chúng đều bằng hai chữ được viết.

3304
00:11:01,540 --> 00:11:13,150
Nếu bạn gọi phương thức này, hãy lấy nó. Xem này, chúng ta có chìa khóa này đây. Vì vậy, trước tiên, hãy tìm nó. Mã băm tốt là 297 chỉ mục. Bảy. Thôi, chúng ta hãy xem Chỉ số bảy ở đây với trợ cấp và thấy chúng không bằng nhau.

3305
00:11:13,150 --> 00:11:25,210
Vậy chúng ta chuyển sang nốt tiếp theo ở đây chúng ta có sự va chạm nên chúng ta thấy như thấy và ở đây cũng vậy. Vì vậy, tất cả đã viết quy tắc sáu này. Đây là không. Phương pháp tuyệt vời này hoạt động cho trường hợp trung bình.

3306
00:11:25,210 --> 00:11:37,060
Nó tranh chấp phương thức và phương thức get này hoạt động với độ phức tạp về thời gian không đổi. Nếu không có xung đột, nếu có xung đột thì MyGov có thể gặp phải sự phức tạp về mặt thời gian.

3307
00:11:37,300 --> 00:11:54,610
Hy vọng bạn hiểu cách Hirshman hoạt động nội bộ. Đây là cách Hirshman hoạt động. Ở đây chúng ta có các hàm lưới băm đơn giản này, nhưng hàm băm sử dụng hàm lưới băm nâng cao để tạo ra giá trị băm và có thể sử dụng các kỹ thuật nâng cao để tìm chỉ mục từ Haynesville.

3308
00:11:54,700 --> 00:12:07,030
Đây là nội dung của chức năng Kashmir. Đây là công việc của Joe Hashomer và chúng tôi thấy rằng Hashgraph sử dụng hàm băm để chỉ cấu trúc trước tiên hoặc chuyển đổi khóa thành giá trị băm từ hàm băm bên dưới.

3309
00:12:07,180 --> 00:12:17,470
Nơi tính toán chỉ số. OK, vậy ở đây chúng ta thấy rõ rằng hàm hủy Hashem Abedi sử
dụng hàm băm để tạo ra một cấu trúc. Vâng, chúng tôi đã hiểu lời giải thích này. 

@@@



3310
00:00:00,580 --> 00:00:21,510
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng ta sẽ nói về lập trình động là gì. Lập trình động là một kỹ thuật để giải quyết một vấn đề phức tạp bằng cách chia nhỏ nó thành một tập hợp các cách giải quyết vấn đề đơn giản của vấn đề này chỉ một lần và lưu trữ giải pháp của chúng nếu có vấn đề xảy ra lần sau.

3311
00:00:21,520 --> 00:00:36,780
Tất nhiên, thay vì tính toán, giải pháp của nó chỉ trông giống như giải pháp được tính toán trước đó. Và đây là khái niệm về lập trình động. Ví dụ, nếu bạn được cho biểu thức này, một cộng hai cộng ba cộng bốn cộng năm sẽ bằng 15.

3312
00:00:37,450 --> 00:01:00,010
Vì vậy, bạn đã tính biểu thức này cộng hai cộng ba cộng bốn cộng rất gần với 15. Nếu bạn được cho biểu thức này cộng hai cộng ba cộng bốn cộng năm cộng sáu, thì ở đây chúng ta không cần phải tính biểu thức này một cộng hai cộng ba cộng bốn cộng năm vì chúng ta đã tính biểu thức này trước đây.

3313
00:01:00,190 --> 00:01:16,380
Vì vậy, sẽ sử dụng nghiệm đã tính toán trước đó và sẽ cộng nó vào sáu hoặc sáu cộng với mười lăm là hai mươi mốt. Vì vậy, chúng tôi đã giảm bớt sự cạnh tranh và đây là khái niệm về lập trình động.

3314
00:01:16,570 --> 00:01:36,580
Chúng tôi đã sử dụng giải pháp được tính toán trước đó thay vì tính toán và đây là khái niệm về lập trình động. Chúng tôi sử dụng kết quả được tính toán trước đó để tiết kiệm thời gian nên không phải tính toán động đó.

3315
00:01:36,580 --> 00:01:52,360
Lập trình có hai thuộc tính. Một trong số đó được gọi là bài toán chồng chéo và cấu trúc con tối ưu. Nếu phát hiện một bài toán, hai thuộc tính này là bài toán chồng chéo hoặc cấu trúc con tối ưu thì có thể áp dụng quy hoạch động cho bài toán đó.

3316
00:01:52,930 --> 00:02:09,450
Vấn đề. Chúng tôi có hai cách tiếp cận từ trên xuống và cách tiếp cận từ dưới lên. Trong video tiếp theo, chúng ta sẽ nói chi tiết về cách tiếp cận từ trên xuống và cách tiếp cận từ dưới lên trong video này, hãy nói về vấn đề chồng chéo và cấu trúc con tối ưu.

3317
00:02:10,030 --> 00:02:24,970
Đầu tiên chúng ta hãy xem định nghĩa của vấn đề chồng chéo. Sau đó chúng ta sẽ thấy. Điều này có nghĩa là gì? Trên thực tế, một trong những đặc điểm chính là chia bài toán thành các bài toán như vậy, tương tự như cách tiếp cận chia để trị.

3318
00:02:25,390 --> 00:02:41,980
Vấn đề phụ chồng chéo được tìm thấy trong vấn đề đó là những vấn đề lớn hơn ở đây. Vấn đề nhỏ hơn tương tự. Tuy nhiên, không giống như chia để trị, có nhiều vấn đề trong đó tình yêu của chúng ta không thể được xử lý một cách rõ ràng hoặc độc lập.

3319
00:02:42,700 --> 00:02:57,760
Giả sử chúng ta muốn tìm thấy nó trống rỗng. Khi tôi nói không, đây là mã giả để tìm nó. Nếu bạn muốn từ chối nếu cần thiết, thì chức năng này sẽ nhận tham số bên trong việc kiểm tra của bạn.

3320
00:02:57,760 --> 00:03:10,480
Nếu nó lớn hơn hoặc bằng ba thì chúng ta gọi hàm này là mười lăm phút một cộng và trừ hai. Đối với Baskette, chúng tôi đang trả lại một chiếc. Đây là Recursive Catch và đây là Baskette.

3321
00:03:11,560 --> 00:03:23,470
Bây giờ hãy vẽ một cây gọi đệ quy. Đây là cây gọi đệ quy. Khi tìm ra giá trị ở đây, chúng tôi sẽ giải thích vấn đề SG&A chồng chéo ở đây là gì.

3322
00:03:23,470 --> 00:03:41,320
Chúng tôi gọi chức năng này là năm sáu. Sau đó, chúng tôi đang làm cho vấn đề này ngày càng nhỏ hơn. Và ở đây chúng ta không thể chia bài toán này thành bài toán nhỏ hơn. Sau năm, hai, ba, một để giải quyết vấn đề này, chúng ta sẽ trả về giá trị cho năm ba này.

3323
00:03:41,410 --> 00:03:55,450
Vì vậy, nó sẽ trả về một và nó sẽ trả về một. Vì vậy ở đây sẽ trở lại một. Cộng một là hai. Vậy là chúng ta đã giải được bài toán năm ba. Và ở đây chúng ta thấy rằng chúng ta lại có năm ba và ở đây chúng ta lại có năm ba.

3324
00:03:55,630 --> 00:04:08,050
Vì vậy, chúng tôi thấy rằng ở đây chúng tôi có sự lặp lại hoặc chồng chéo. Sau đó, bạn có hai. Nó sẽ trả về một, rồi bốn người đều trả về hai cộng một là ba. Vì vậy, chúng tôi đã giải quyết vấn đề này trước đây.

3325
00:04:08,290 --> 00:04:19,810
Và ở đây chúng ta thấy rằng chúng ta lại có năm, bốn. Vì vậy, chúng tôi có vấn đề SG&A chồng chéo. Đây là vấn đề của chúng tôi bị chồng chéo và đây được gọi là vấn đề chồng chéo.

3326
00:04:19,810 --> 00:04:30,940
Khi thấy vấn đề chồng chéo, chúng ta có thể áp dụng quy hoạch động tại đây. Chúng tôi gọi hàm này là 086 ở đây. Chúng tôi gọi hàm này bằng số sáu.

3327
00:04:31,090 --> 00:04:44,530
Nếu chúng ta gọi con số này là một triệu thì bạn sẽ có rất nhiều sự lặp lại của hàm. Gọi ở đây chúng ta thấy chúng ta có 2 lần lặp lại hàm này. Gọi nó là ba.

3328
00:04:44,740 --> 00:04:59,830
Và ở đây chúng ta thấy vấn đề tương tự bị chồng chéo ở đây. Năm mươi thay vì chồng chéo, hãy gọi lại hàm này và tính toán những gì chúng ta có thể làm. Chúng ta chỉ có thể lưu trữ kết quả khi giải quyết vấn đề này.

3329
00:05:00,170 --> 00:05:13,670
Trong một lĩnh vực mà bạn có thể sử dụng dữ liệu đó để giúp tòa án hoạt động hiệu quả và chúng tôi có thể giảm bớt danh tiếng hoặc chức năng. Và ở đây chúng ta thấy năm, ba, 50 50 lệnh gọi hàm đó bị chồng chéo.

3330
00:05:13,670 --> 00:05:23,630
Và đây được gọi là vấn đề chồng chéo. Đây là một vấn đề chồng chéo ở đây. Năm, bốn, năm, bốn chồng lên nhau. Và đây được gọi là vấn đề chồng chéo.

3331
00:05:23,750 --> 00:05:35,540
Khi bạn tìm hiểu về vấn đề S, chúng ta có thể áp dụng quy hoạch động để làm cho mã trở nên hiệu quả. Bây giờ trước tiên hãy nói về cấu trúc con chồng chéo. Chúng ta hãy xem định nghĩa sau đó.

3332
00:05:35,540 --> 00:05:56,250
Ngoài ra, điều này có ý nghĩa gì khi có sẵn một số cấu trúc để có thể thu được giải pháp tối ưu từ giải pháp tối ưu của nó? Vấn đề à? Vì vậy, cấu trúc con tối ưu chỉ đơn giản là sự lựa chọn tối ưu trong số tất cả các cấu trúc con có thể giúp chọn ra cấu trúc tốt nhất cùng loại để tồn tại.

3333
00:05:56,270 --> 00:06:06,860
Một lần nữa, giả sử chúng ta muốn tìm ra một số từ Syrett trước đó trong vài phút. Đây là mã và đây là hàm đệ quy có tên. Ở đây chúng tôi chia vấn đề này thành vấn đề nhỏ hơn.

3334
00:06:07,250 --> 00:06:20,150
Vì vậy, chúng tôi chia vấn đề này thành vấn đề nhỏ hơn mà bạn gặp phải và bạn đang nhận được một vấn đề. Chúng tôi không thể phá vỡ vấn đề này nữa. Bây giờ, nếu chúng ta giải quyết vấn đề này một cách hiệu quả, điều đó có nghĩa là tối ưu.

3335
00:06:20,360 --> 00:06:32,440
Bây giờ, ở đây, tôi muốn hỏi bạn một câu hỏi. Nếu tôi bán bài toán phụ đó một cách hiệu quả hoặc tối ưu thì liệu tôi có thể giải quyết được vấn đề từ giải pháp đến vấn đề không?

3336
00:06:32,510 --> 00:06:51,110
Câu trả lời của bạn là gì? Tôi nghĩ nó sẽ nói, vâng, chúng ta có thể. Vì vậy, ở đây chúng ta có cấu trúc con tối ưu. Nếu chúng ta. Vì vậy, đó là vấn đề của chúng tôi. Một cách tối ưu, nếu chúng ta có thể hỗ trợ bài toán đã cho bằng cách giải quyết bài toán đó một cách tối ưu thì chúng ta có thể nói bài toán có cấu trúc con tối ưu.

3337
00:06:51,550 --> 00:07:02,300
Vì vậy, ở đây chúng tôi có và trên. Vì vậy, ở đây chúng tôi có hai và chúng tôi muốn nó sẽ trở lại trên một chiếc thông minh. Thế là nó sẽ về rồi nó sẽ về đây nó sẽ về, rồi nó sẽ về ba.

3338
00:07:02,570 --> 00:07:13,480
Rồi năm năm này chúng ta có ba. Vậy ba cái này sẽ quay trở lại vì bên trái và bên phải sẽ có và ở đây hai cộng ba bằng năm ở bên phải đây tập.

3339
00:07:13,480 --> 00:07:27,170
Chúng ta đã đến đây chưa? Ba đến ba cộng năm là tám. Vì vậy, chúng ta có thể giải quyết vấn đề này bằng cách giải quyết vấn đề. Nếu chúng ta có thể giải quyết vấn đề của mình một cách hiệu quả thì chúng ta có thể giải quyết vấn đề này.

3340
00:07:27,170 --> 00:07:42,050
Vậy bài toán này có cấu trúc đỉnh tối ưu và được gọi là cấu trúc đỉnh tối ưu. Chúng ta đã hiểu thế nào là cấu trúc kiểu tối ưu khi gặp bài toán chồng chéo hoặc cấu trúc tối ưu cho bài toán, sau đó có thể áp dụng quy hoạch động.

3341
00:07:42,320 --> 00:07:58,400
Trong phần này của khóa học này, chúng ta sẽ giải quyết bảy vấn đề lập trình động nếu cần thiết. Ngôi nhà tiếp theo tăng dài nhất. Rober có nghĩa là Pathum, vấn đề phổ biến lâu nhất, không gây khó chịu tiếp theo và một biểu thức chính quy.

3342
00:07:58,490 --> 00:08:08,780
Chúng tôi sẽ giải quyết vấn đề này nếu bạn gặp vấn đề nghiêm trọng khi sử dụng phương pháp từ trên xuống và từ dưới
lên và phần còn lại của vấn đề sẽ được giải quyết bằng cách sử dụng phương pháp từ dưới lên trong video tiếp theo. 

@@@



3343
00:00:00,870 --> 00:00:09,250
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về cách tiếp cận từ trên xuống. Cách tiếp cận từ trên xuống là gì? Đầu tiên, hãy lấy một ví dụ.

3344
00:00:09,600 --> 00:00:22,800
Đây là dấu chân của chúng tôi như một ống tiêm. Hai số đầu tiên bắt đầu bằng một. Sau đó, số tiếp theo được tạo bằng cách thêm số trước vào số một. Cộng một là hai hai cộng trên ba, ba cộng hai là năm năm, sáu tám.

3345
00:00:23,040 --> 00:00:35,840
Tám cộng năm là 13 13, xe buýt tám là 21, v.v. Đây là mã của chúng tôi và đây là lệnh gọi hàm đệ quy. Bây giờ bạn có thể hỏi cách tiếp cận từ trên xuống là gì.

3346
00:00:36,390 --> 00:00:53,040
Bây giờ bạn có thể hỏi cách tiếp cận từ trên xuống là gì trong cách tiếp cận từ trên xuống, thuật toán bắt đầu từ giá trị trên cùng và từ dưới cùng để có được giá trị cao nhất của chúng tôi. Vậy việc tìm ra giá trị của hàm này có ý nghĩa gì?

3347
00:00:53,040 --> 00:01:06,120
Cuộc gọi sẽ chia vấn đề này thành vấn đề nhỏ hơn cho đến khi chúng ta không thể chia vấn đề nhỏ hơn nữa. Vì vậy, chúng tôi đang giải quyết vấn đề này ở đây. Năm, bốn, ba, hai.

3348
00:01:06,270 --> 00:01:14,990
Và chúng ta không thể phá vỡ vấn đề này nữa và chúng ta không thể phá vỡ vấn đề này nữa. Vì vậy chúng ta sẽ giải quyết vấn đề này trước tiên. Vì vậy, nó sẽ trả lại hoặc nó sẽ trả lại một.

3349
00:01:15,210 --> 00:01:27,030
Và sau đó vấn đề này sẽ quay trở lại. Vì vậy, chúng ta sẽ phải chạm đáy và sau đó chúng ta sẽ đi f và đây được gọi là cách tiếp cận từ trên xuống đối với bạn.

3350
00:01:27,300 --> 00:01:42,610
Sau đó, nó sẽ trở lại cho tất cả điều này. Nó sẽ trở lại trong bốn năm phi tôn giáo năm. Thế thì đối với cây con này là be thì nó sẽ trả về là ba, ba cộng năm là tám.

3351
00:01:43,200 --> 00:01:56,320
Vì vậy, đầu tiên chúng tôi bán vấn đề nhỏ hơn. Chúng tôi sẽ đi từ trên xuống dưới để có được giá trị cao nhất. Và đây gọi là cách tiếp cận từ trên xuống, hay chúng ta đã hiểu thế nào là cách tiếp cận từ trên xuống.

3352
00:01:56,760 --> 00:02:07,320
Đây là một thuật toán chia để trị, trong đó chỉ chia bài toán thành các bài toán nhỏ hơn hoặc không tối ưu hóa bài toán này. Và ở đây chúng tôi chỉ cho bạn thấy cách tiếp cận từ trên xuống đó.

3353
00:02:07,650 --> 00:02:25,590
Vì vậy bây giờ hãy tối ưu hóa vấn đề này. Sử dụng quy hoạch động để giải bài toán này trong quy hoạch động, chúng ta phải lập bảng quy hoạch động nếu được cho số sáu thì phải tìm ra số Fibonacci thứ sáu của Estridge trước đó.

3354
00:02:26,220 --> 00:02:42,690
Chúng ta phải tạo một bảng lập trình động LENTE sáu cộng một. Vì vậy, bảy ở đây chúng tôi đã lập chỉ mục từ 0 đến 6. Đây là mã của chúng tôi. Đây là bảng lập trình động của Lente in plus one đây.

3355
00:02:42,840 --> 00:02:57,780
Kiểm tra xem giá trị hiện tại có khác 0 hay không thì chúng ta sẽ trả về giá trị cho số hiện tại từ bảng lập trình động. Khi chúng ta tạo ra một lỗi số nguyên trong ngôn ngữ lập trình, mảng sẽ chứa đầy số 0.

3356
00:02:57,780 --> 00:03:14,010
Theo mặc định, giá trị mặc định là 0 mà bạn đang kiểm tra xem N có khác 0 hay không. Và ở đây, phép bắt đệ quy của chúng ta, nếu có, lớn hơn hoặc bằng ba thì chúng ta sẽ gọi nó là năm trừ một trừ hai.

3357
00:03:14,160 --> 00:03:32,990
Và đây là bánh quy của bạn. Giỏ là bốn một và hai cho một. Nó sẽ trả về một và hai nó sẽ trả về. Một sẽ không sử dụng ba đầu tiên này. Vì vậy, OK, chúng ta có thể giả định, chúng ta được thông báo rằng chúng ta có năm đầu tiên chúng ta có ở đây và sẽ có nó ở đây.

3358
00:03:33,030 --> 00:03:47,400
Trên thực tế, hầu như chúng ta có thể cho rằng chúng ta có một cái ở đây. Và cuối cùng chúng ta sẽ có câu trả lời cuối cùng. Bây giờ hãy xem làm thế nào chúng ta có thể tìm ra giá trị của năm sáu.

3359
00:03:48,090 --> 00:03:57,120
Vì vậy, ở đây chúng tôi đang chia vấn đề này thành vấn đề nhỏ hơn. Vì vậy, đây là vấn đề. Và ở đây chúng ta không thể phá vỡ vấn đề này nữa. Tính năng này sẽ đánh vào giỏ.

3360
00:03:57,120 --> 00:04:13,560
Nó sẽ trả lại một. Và nếu bạn muốn, nó sẽ trả về một. Vì vậy, ở đây sẽ trả lại một cộng một. Điều đó đúng với ba điều này, khi nó quay trở lại lệnh gọi hàm này, chúng ta sẽ chèn giá trị ở chỉ mục thứ ba vào ngay tại đây.

3361
00:04:13,830 --> 00:04:26,340
Vì vậy, hãy chèn vào đây quá. Chúng tôi nhận thấy vấn đề chồng chéo của bạn sẽ không lặp lại vấn đề chồng chéo này. Animal sẽ giảm lệnh gọi hàm bằng bảng lập trình động này và hãy xem cách thực hiện.

3362
00:04:26,700 --> 00:04:38,720
Và ở đây chúng tôi có hai. Đây là trường hợp cơ bản. Điều này sẽ đạt được điều kiện cơ bản. Vậy hai cộng một là ba. Vì vậy, đối với chức năng này, hãy gọi ở đây tại chỉ mục cho tất cả.

3363
00:04:38,730 --> 00:04:51,000
Chèn giá trị ba. Hãy chèn vào đây ba bây giờ bốn năm năm. Những gì nó sẽ trả về ở bên trái, chúng ta có ba cái ở bên phải. Gọi hàm này ở đây chúng ta thấy rằng chúng ta cần nó với ba.

3364
00:04:51,240 --> 00:05:23,020
Nó sẽ dính ở hiện tại. Vì vậy hiện tại là ba bộ. Hiện tại chúng tôi có hai Wilmont tính toán lại nó. Không tính toán lại, chúng ta không phải đi hết lời gọi hàm ở đây, OK, vậy là tất cả chỉ cần quay về từ bảng lập trình động chỉ cần OK, nếu những gì chúng ta có ở đây cũng vậy, và chúng ta thấy rằng chúng ta không cần phải tính toán lại 53 một lần nữa, chúng ta chỉ trả về giá trị từ bảng lập trình động.

3365
00:05:23,270 --> 00:05:33,950
Chức năng này được gọi là giảm bớt. Được rồi, vậy hai cộng ba là năm. Vậy hai cộng ba là năm. Và hãy chèn số 5 vào đây cho số 5 ở chỉ số 5.

3366
00:05:33,980 --> 00:05:43,390
Được rồi, đối với hàm này, hãy gọi năm sáu. Ở bên trái chúng ta có năm, năm, bốn, năm, năm. Chúng tôi có giá trị năm. Bây giờ chúng ta hãy đi sang bên phải. Ở bên phải.

3367
00:05:43,600 --> 00:05:56,320
Chúng ta phải tính lại phần này, được rồi, để có được giá trị của nó vì trước tiên chúng ta phải tính năm ba. Rồi nếu hai bạn thì nếu muốn thì bạn lại thuần khiết ở chỉ số bốn.

3368
00:05:56,320 --> 00:06:08,620
Chúng tôi đã lưu trữ giá trị ba và chúng tôi đã giải quyết ở đây. OK, vậy là chúng ta đã giải quyết chỉ một lần và sau đó chúng ta sẽ sử dụng lại ở đây. Chúng ta không phải tính toán lại hàm này.

3369
00:06:08,620 --> 00:06:22,000
Cuộc gọi sẽ trực tiếp quay trở lại từ bảng lập trình động của chúng tôi. Đó là ba. Vậy chúng ta có ở đây ba, vậy ba cộng năm là tám. Hãy quay lại số 8 cho lệnh gọi hàm này và chèn số 8 vào đây.

3370
00:06:23,020 --> 00:06:43,090
Chúng ta đã xong. Chúng ta sẽ tái sinh. Và bạn thấy rằng chúng ta không cần phải tính hàm này. Hãy gọi nếu chúng tôi có ở đây, hãy sử dụng số thay thế. Thứ sáu, nếu chúng ta được cho một con số một nghìn, hai nghìn hoặc thậm chí lớn hơn như một triệu thì sẽ có rất nhiều chức năng danh tiếng.

3371
00:06:43,420 --> 00:06:58,270
Chúng ta phải gọi một hàm rất nhiều lần, điều này sẽ làm giảm hiệu quả của mã của chúng ta và điều đó sẽ được coi là bình thường. Nếu chúng ta không sử dụng bảng quy hoạch động đó thì lời giải sẽ mang tính hàm mũ.

3372
00:06:58,450 --> 00:07:12,600
Điều đó có nghĩa là cấp nguồn vào. Nhưng khi sử dụng quy hoạch động, vấn đề này xảy ra vì độ phức tạp về thời gian và độ phức tạp về không gian. Nhưng nếu chúng ta không áp dụng quy hoạch động ở đây thì giải pháp sẽ giảm đi.

3373
00:07:12,640 --> 00:07:24,580
Chúng tôi đã gặp cậu bé thô lỗ. Chúng ta đang ở trong đó. Đó là điều tồi tệ nhất. Vì vậy, chúng ta có thể giảm độ phức tạp thời gian theo cấp số nhân này thành độ phức tạp thời gian tuyến tính bằng cách sử dụng lập trình động.

3374
00:07:24,730 --> 00:07:38,380
Và ở đây chúng tôi có câu trả lời ở quy mô lập chỉ mục này sẽ chỉ trả về đánh giá này. Nếu chúng ta có một số đã sử dụng, chúng ta có thể áp dụng khái niệm này để giảm độ phức tạp về thời gian từ hàm mũ sang tuyến tính.

3375
00:07:38,650 --> 00:07:50,650
Đây là một chương trình năng động đi vào hình ảnh. Chúng tôi chỉ đang lưu trữ kết quả tính toán của chúng tôi. Sau đó chúng ta sẽ không tính kết quả nữa. Và đây chính là ưu điểm của lập trình động.

3376
00:07:50,650 --> 00:08:03,550
Đây được gọi là cách tiếp cận từ trên xuống, khi chúng ta đã hiểu cách tiếp cận từ trên xuống là gì và các đặc tính của
quy hoạch động là gì. Trong video tiếp theo, chúng ta sẽ nói về cách tiếp cận từ dưới lên trong video tiếp theo. 

@@@



3377
00:00:00,730 --> 00:00:12,340
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng ta sẽ nói về cách tiếp cận từ dưới lên. Hãy lấy một ví dụ. Đây là mã của chúng tôi để tìm hiểu trong vài phút.

3378
00:00:12,370 --> 00:00:30,310
Không, trong video trước chúng ta đã nói về cách tiếp cận từ trên xuống và cách tiếp cận từ dưới lên. Nếu bạn nhìn vào thuật toán này, nó thực sự bắt đầu từ các giá trị thấp hơn, sau đó gặp khó khăn là tôi muốn tìm ra số Fibonacci thứ sáu.

3379
00:00:30,490 --> 00:00:44,020
Sau đó, điều tôi sắp làm là tôi sẽ tính số đầu tiên, rồi đến số thứ hai, rồi đến số thứ ba cho đến UFF, số thứ sáu. Những kỹ thuật này thực sự được gọi là kỹ thuật từ dưới lên.

3380
00:00:44,470 --> 00:00:56,050
Vì vậy chúng ta sẽ bắt đầu từ những giá trị thấp hơn rồi sẽ đi lên. Bây giờ hãy xem nó thực sự hoạt động như thế nào. Đây là bảng lập trình động của chúng tôi và ở đây đầu ra một bằng một.

3381
00:00:56,230 --> 00:01:05,500
Lúc đầu, chúng ta sẽ chèn một cái vào lúc thứ hai, vì vậy chúng ta sẽ chèn một cái, sau đó chúng ta sẽ bắt đầu lặp lại từ ô này. Và lúc này, bạn sẽ làm gì?

3382
00:01:05,530 --> 00:01:17,820
Chúng ta sẽ cộng số trước để bán giá trị, cộng ba với một cộng một bằng hai để tìm ra giá trị của cái này. Vì vậy, hãy cộng giá trị của hai số trước cộng với lịch sử thứ ba tại đây.

3383
00:01:17,830 --> 00:01:29,200
Những gì chúng ta đang làm, chúng ta bắt đầu từ giá trị thấp hơn một một, sau đó chúng ta bắt đầu, OK, và ở đây hai cộng ba thành năm, rồi năm cộng ba thành tám.

3384
00:01:30,070 --> 00:01:42,160
Và điều này cực kỳ dễ dàng. Và đây được gọi là cách tiếp cận từ dưới lên. Chúng ta đang bắt đầu từ giá trị thấp hơn và sau đó chúng ta sẽ chuyển sang giá trị cao hơn. Và đây được gọi là đáy của cách tiếp cận.

3385
00:01:42,190 --> 00:01:53,100
Chúng ta đang bắt đầu từ dưới lên và sau đó chúng ta sẽ đi đến F và đây được gọi là cách tiếp cận từ dưới lên hoặc chúng ta đã hiểu cách tiếp cận từ dưới lên là gì. Và ở đây chúng tôi có mã cho cách tiếp cận từ dưới lên.

3386
00:01:53,620 --> 00:02:19,930
Được rồi, chúng tôi đã hiểu cách tiếp cận từ dưới lên là gì và giải pháp sẽ đưa Spiga về độ phức tạp tạm thời và nó cũng phát triển ở độ phức tạp về không gian. Bây giờ, tôi hy vọng bạn đã hiểu cách tiếp cận từ trên xuống là gì và cách tiếp cận từ dưới lên của lập trình động cho bài toán dãy Fibonacci đối với trẻ bình thường là gì, đối với trẻ bình thường, phải mất thời gian theo cấp số nhân và độ phức tạp.

3387
00:02:19,930 --> 00:02:35,300
Nó diễn ra trong không gian và thời gian, độ phức tạp cho đến tận đáy sâu của cách tiếp cận. Đối với những đứa trẻ bình thường, nó có độ phức tạp lớn về không gian và thời gian. Nó tốn thời gian theo cấp số nhân, độ phức tạp và đó là điều tồi tệ nhất từ ​​​​trước đến nay.

3388
00:02:35,620 --> 00:02:46,450
Bây giờ tại sao bạn không từ trên xuống và từ dưới lên bây giờ? Hãy so sánh chúng để dễ dàng cho thuật toán. Cách tiếp cận từ trên xuống dễ dàng đưa ra giải pháp và cách tiếp cận từ dưới lên.

3389
00:02:46,630 --> 00:03:07,390
Không dễ để tìm ra giải pháp về mặt thời gian. Hãy xem, từ trên xuống thì chậm và bất cứ thứ gì nhanh để tiết kiệm không gian. Cách tiếp cận từ trên xuống sử dụng ngăn xếp nội bộ cho đệ quy được gọi là ngăn xếp và đối với bất kỳ cách tiếp cận nào chúng tôi sử dụng, chúng tôi sẽ sử dụng loof để không có ngăn xếp nào được sử dụng cho cách tiếp cận mà chúng tôi phải sử dụng.

3390
00:03:07,570 --> 00:03:23,800
Bảng lập trình động cho hầu hết các casette. Vì vậy, đối với cách tiếp cận từ dưới lên của cơ quan vũ trụ, chúng ta có thể nói rằng người chiến thắng là người nắm giữ một lượng lớn từ trên xuống và từ dưới lên. Khi cần giải pháp nhanh chóng thì chúng ta nên xem xét từ trên xuống và chỉ cần giải pháp hiệu quả.

3391
00:03:23,800 --> 00:03:35,100
Sau đó chúng ta nên tìm kiếm theo cách tiếp cận từ dưới lên. Chúng tôi đã hiểu mọi thứ về cách tiếp cận từ trên xuống
và từ dưới lên. Nếu bạn không hiểu cách tiếp cận từ trên xuống và từ dưới lên là gì, hãy cho chúng tôi biết. 

@@@



3392
00:00:00,450 --> 00:00:27,600
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này. Chúng ta sẽ giải một câu hỏi đố về tiếng Hàn, tăng dần dài nhất, tiếp theo. Cho một vùng số nguyên Eminem, độ dài của dãy con tăng nghiêm ngặt dài nhất tiếp theo là một Cequent có thể được lấy từ một mảng bằng cách xóa một số hoặc không có phần tử nào mà không thay đổi thứ tự của các phần tử còn lại.

3393
00:00:27,630 --> 00:00:43,140
Ví dụ: ba sáu đến bảy là phần tiếp theo của mảng số không ba một sáu đến bảy. Ở đây chúng ta thấy chúng ta đã xóa số 0. Rồi một. Sau đó, bất kỳ trong số đó.

3394
00:00:43,820 --> 00:00:59,870
OK, và chúng ta có cái tiếp theo này và chúng ta có cái OK khác, khi bạn đang nói về Sequence, chúng ta đang tìm kiếm một chuỗi có thể liền kề và cũng có thể không liền kề.

3395
00:01:00,050 --> 00:01:23,250
liền kề là gì? Tiếp giáp có nghĩa là đầu tiên, sau đó là chín, rồi đến và ở đây mười, chín, hai là tiếp giáp. Nếu chúng ta nói năm bảy. Mười tám, và đó không phải là người đóng góp, và điều này được gọi là không liền kề, do đó, chuỗi con có thể liền kề và nó cũng có thể không liền kề.

3396
00:01:24,090 --> 00:01:37,110
Bây giờ hãy lấy một số ví dụ. Ví dụ: nếu bạn được cung cấp khu vực này làm đầu vào, thì bạn phải trả lại phần đất có dãy con tăng nghiêm ngặt dài nhất trong khu vực này.

3397
00:01:37,140 --> 00:01:54,000
Chúng ta phải bao bọc chặt chẽ hai số năm bảy, một trăm lẻ hai, năm, bảy và 18 tiếp theo. Vì vậy, chúng ta phải trả về độ dài của bất kỳ dãy con tăng dài nhất nào.

3398
00:01:54,840 --> 00:02:11,340
Vì vậy, đối với khu vực nhất định này, chúng tôi phải trả về bốn vì khu vực được bao bọc nghiêm ngặt dài nhất tiếp theo trong khu vực này là khu vực thực sự này. Vì vậy, chúng ta phải trả về độ dài của khu vực này và có bốn phần cho những gì đã cho phải trả về.

3399
00:02:12,060 --> 00:02:30,500
Nếu chúng ta được cung cấp thông tin đầu vào của khu vực này, thì tôi phải tìm ra độ dài của dãy con tăng nghiêm ngặt dài nhất, dãy bao bọc nghiêm ngặt dài nhất. Tiếp theo là số 0 này, hai, ba riêng biệt và độ dài của số này tiếp theo.

3400
00:02:30,510 --> 00:02:42,540
Và đây là lần tăng nghiêm ngặt dài nhất tiếp theo. Và độ dài của phần tiếp theo này là bốn. Vì vậy, đối với đầu vào đã cho này, bây giờ chúng ta phải quay lại cách chúng ta có thể tiếp cận vấn đề này.

3401
00:02:42,570 --> 00:02:53,370
Bây giờ hãy nói về cách chúng ta có thể giải quyết vấn đề này để dễ hiểu. Giả sử chúng ta được cấp khu vực này. Chúng ta có thể giải quyết vấn đề này thành hai để giải quyết vấn đề phức tạp về thời gian.

3402
00:02:53,580 --> 00:03:03,450
Và đó là giải pháp tồi tệ nhất. Và chúng ta không nói về điều đó trong video này. Chúng ta sẽ giải quyết vấn đề này về số lượng, thời gian, độ phức tạp bằng cách sử dụng quy hoạch động.

3403
00:03:03,630 --> 00:03:16,640
Chúng tôi sẽ sử dụng kết quả trung gian của bạn để giải quyết vấn đề này. Bây giờ hãy tạo một bảng lập trình động. Đây là bảng lập trình động của chúng tôi. Ban đầu, chúng ta sẽ điền vào ô đầu tiên đó một ô.

3404
00:03:16,650 --> 00:03:29,690
Tại sao vậy? Khi bạn coi đây là diện tích đất của chúng tôi ở đây, chúng tôi chỉ có một yếu tố. Vì vậy, chúng ta có thể giả định rằng chúng ta có thời gian dài nhất bao gồm cả vùng đất tiếp theo.

3405
00:03:30,000 --> 00:03:42,800
Đó là lý do tại sao chúng ta chèn vào đây một số và chúng ta sẽ sử dụng năng lượng hai con trỏ I. Ban đầu tôi sẽ trỏ đến phần tử thứ hai và sẽ trỏ đến phần tử đầu tiên và chúng ta sẽ có một biến Emacs.

3406
00:03:43,080 --> 00:03:53,910
Bây giờ chúng ta sẽ kiểm tra điều này để đánh giá những gì tôi và quan điểm phản hồi của bạn bây giờ chúng ta sẽ kiểm tra. Giá trị thêm vào con trỏ có nhỏ hơn giá trị mà Người chỉ định Valot biết hay không.

3407
00:03:54,090 --> 00:04:06,270
Vì vậy, hãy chuyển sang phần tiếp theo và chỉ vào đây khi Joel chỉ vào đây sẽ bắt đầu, bởi vì Z đang trỏ đến cùng phần tử đó. Bây giờ, trong trường hợp đó, bạn sẽ làm gì?

3408
00:04:06,540 --> 00:04:23,130
Chúng ta sẽ chèn dấu vết tối đa vào dấu tương ứng của bảng lập trình DB nơi tôi đã chỉ nó tới. Vì vậy, hãy chèn vào đây Mike cộng một và đó là một và hãy chuyển nó sang phần tiếp theo và tất cả các điểm của nó sẽ thuộc về phần đầu tiên.

3409
00:04:23,130 --> 00:04:35,250
Vì vậy, khi bạn chuyển sang điều đó tiếp theo. Bây giờ chúng ta hãy thực hiện so sánh. Dustin ít hơn hai. Không, vậy hãy chuyển sang phần tử tiếp theo. Có chín là ít hơn hai.

3410
00:04:35,580 --> 00:04:48,060
Không. Vậy hãy chuyển sang phần tử tiếp theo. Là điểm kết thúc cho những yếu tố giống nhau, những thứ cũ. Bây giờ chúng ta sẽ chèn vào đây. Vậy Max cộng một và có một.

3411
00:04:48,060 --> 00:04:58,830
Vì vậy hãy chèn vào đây một cái. Bây giờ, hãy chuyển sang phần tử tiếp theo và hai phần tử đầu tiên. Bây giờ chúng ta hãy thực hiện so sánh. Có hai là ít hơn năm.

3412
00:04:58,860 --> 00:05:22,200
Không. Vậy hãy chuyển sang phần tiếp theo. Có chín là ít hơn năm. Không. Vậy hãy chuyển nó sang phần tiếp theo. Bây giờ chúng ta thấy hai nhỏ hơn năm. Khi bạn tìm thấy giá trị tại con trỏ nhỏ hơn giá trị của con trỏ, thì chúng ta sẽ lấy giá trị từ bảng lập trình động nơi con trỏ trỏ đến ô tương ứng và chúng ta sẽ lấy giá trị tối đa.

3413
00:05:22,410 --> 00:05:34,020
Vì vậy, Max of Max và giá trị cộng lại tương ứng đã tăng lên cho đến khi điểm này đạt mức tối đa bằng 0 và một là một. Vì vậy, chúng ta sẽ có cơ hội từ 0 đến 1.

3414
00:05:34,200 --> 00:05:50,310
Vậy là Mexico hai một. Sau đó, hãy chuyển sang ô tiếp theo và phần cuối trỏ đến cùng một ô. Vì vậy, chúng ta sẽ xem những nội dung cũ ở đây và chúng ta sẽ chèn Max plus vào ô này, nơi tôi cũng chỉ định bản đồ.

3415
00:05:50,640 --> 00:06:02,700
Vì vậy, hãy chèn vào đây và cũng phải đặt mức tối đa của chúng tôi thành 0. Bây giờ, hãy chuyển sang phần tử tiếp theo và phần tử đầu tiên. Bây giờ chúng ta hãy làm một so sánh.

3416
00:06:02,700 --> 00:06:12,060
Có phải mười nhỏ hơn ba không phải vậy. Hãy chuyển sang phần tiếp theo. Có chín là ít hơn ba. Không. Vậy hãy chuyển sang phần tiếp theo. Bây giờ chúng ta thấy hai nhỏ hơn ba.

3417
00:06:12,180 --> 00:06:27,810
Bây giờ, chúng ta sẽ làm gì. Chúng tôi sẽ cập nhật giá trị của Maximiliano, vì vậy chúng tôi sẽ tìm ra mức tối đa tối đa của Max. Vì vậy, Max bằng 0 và giá trị gia tăng được trỏ đến ô tương ứng trong bảng lập trình động của chúng ta.

3418
00:06:27,810 --> 00:06:39,670
Và có một cái. Vậy Max của 0 và một là một. Vì vậy, hãy cập nhật giá trị Max này thành một. Bây giờ chúng ta hãy chuyển sang phần tiếp theo. Năm có nhỏ hơn ba không? KHÔNG.

3419
00:06:39,690 --> 00:06:51,630
Vì vậy, hãy chuyển sang phần tiếp theo. Và bây giờ chúng ta thấy phần cuối đang trỏ đến cùng một ô. Vì vậy, hãy chèn vào ô max cộng một. Có hai và họ phải tăng tối đa lên 0.

3420
00:06:51,960 --> 00:07:03,120
Bây giờ chúng ta hãy chuyển sang phần tiếp theo. Và đó là yếu tố đầu tiên. Bây giờ chúng ta hãy thực hiện so sánh. Có 10 là ít hơn bảy. Không. Vậy hãy chuyển sang phần tử tiếp theo.

3421
00:07:03,750 --> 00:07:14,010
Chín có nhỏ hơn bảy không. Vì vậy, hãy chuyển sang yếu tố tiếp theo. Tức là hai nhỏ hơn bảy. Vâng, đúng vậy. Bây giờ, những gì chúng ta sắp làm là cập nhật giá trị của biến max.

3422
00:07:14,370 --> 00:07:25,260
Bây giờ những gì chúng ta sắp làm là cập nhật giá trị của biến max. Vậy giá trị lớn nhất của Max, Max bằng 0 và giá trị tại vị trí tương ứng của chúng ta với bảng lập trình của đối phương.

3423
00:07:25,470 --> 00:07:36,900
Phản hồi của WidePoint là một, vì vậy tối đa bằng 0 và một là một. Vì vậy, hãy thay đổi giá trị này thành một. Bây giờ chúng ta hãy chuyển sang phần tiếp theo. Đó là năm nhỏ hơn bảy.

3424
00:07:36,910 --> 00:07:51,730
Vâng, đúng vậy. Vậy bạn sẽ làm gì? Chúng ta sẽ cập nhật giá trị của biến max. Vì vậy, tối đa Max Max là một và giá trị tại vị trí tương ứng với bảng lập trình động nơi con trỏ trỏ tới và có hai.

3425
00:07:51,990 --> 00:08:04,590
Vậy Max của một và hai là hai. Vì vậy, hãy cập nhật cái này thành hai. Bây giờ chúng ta hãy chuyển sang phần tử tiếp theo, đó là phần tử thứ ba. Ba nhỏ hơn bảy. Vâng, đúng vậy.

3426
00:08:04,830 --> 00:08:18,480
Bây giờ, bạn định làm gì? Chúng ta sẽ phát triển biến max. Vậy giá trị tối đa của Max và giá trị của con trỏ trong bảng lập trình động. Vậy Max, là cộng giá trị tại vị trí này vào bảng lập trình động là hai.

3427
00:08:18,690 --> 00:08:29,790
Vậy tối đa hai và hai là hai. Vì vậy giá trị này của biến này, Max, không thay đổi. Bây giờ, hãy chuyển sang phần tử tiếp theo. Và đây là nó và tôi đang chỉ vào cùng một phần tử.

3428
00:08:29,790 --> 00:08:40,250
Vì vậy, nó sẽ không làm gì ở đây. Và chúng ta sẽ chèn vào đây giá trị của max cộng một đến hai, cộng một bằng ba. Vì vậy, hãy chèn ba vào đây và đặt lại biến tối đa về 0.

3429
00:08:40,590 --> 00:08:57,070
Bây giờ chúng ta hãy chuyển sang phần tiếp theo và hai phần tử đầu tiên. Bây giờ chúng ta hãy làm một so sánh. Có mười là ít hơn một trăm. Vâng, đúng vậy. Bây giờ chúng ta sẽ cập nhật biến max thành giá trị tối đa Max và giá trị trong bảng lập trình động.

3430
00:08:57,300 --> 00:09:08,880
Điểm của điều này chỉ ra một. Vậy tối đa số 0 và một là một. Vì vậy hãy chèn vào đây một cái. Bây giờ, hãy chuyển sang phần tử tiếp theo. Có chín. Có chín là ít hơn một trăm một.

3431
00:09:08,880 --> 00:09:20,910
Vâng, đúng vậy. Vì vậy, hãy cập nhật giá trị của biến max của chúng tôi. Tối đa tối đa có một và cái này. Vậy tối đa một và một là một. Vì vậy giá trị này không thay đổi.

3432
00:09:21,390 --> 00:09:32,760
Hãy chuyển sang phần tử tiếp theo một lần nữa. Chúng ta thấy hai là ít hơn một trăm một. Vì vậy, hãy cập nhật biến tối đa. Vì vậy, tối đa Max và cái này. Vì vậy, Max cứ tiếp tục là một.

3433
00:09:33,780 --> 00:09:50,900
Cái này vẫn không thay đổi. Bây giờ hãy chuyển sang phần tử tiếp theo. Năm nhỏ hơn một trăm một và hãy phát triển biến tối đa. Vì vậy, tối đa của max và giá trị ở đây chúng ta phải hiển thị tối đa của một và hai là hai.

3434
00:09:51,000 --> 00:10:00,660
Vì vậy, hãy cập nhật phần này thành phần hai và chuyển sang phần tử tiếp theo. Có ba. Ba là ít hơn một trăm một. Vì vậy, hãy cập nhật biến tối đa.

3435
00:10:01,140 --> 00:10:17,940
Vì vậy, tối đa là Max và giá trị này là hai, vì con trỏ ánh xạ tới hai giá trị này. Vậy tối đa hai và hai là hai. Vì vậy, điều này là không thay đổi. Bây giờ chúng ta hãy chuyển sang phần tử tiếp theo, đó là số bảy.

3436
00:10:17,940 --> 00:10:29,150
Bảy là ít hơn một trăm một. Vì vậy, hãy cập nhật biến phát triển tối đa. Vậy tối đa của Max và giá trị ở đây chúng ta có ba, vậy tối đa của hai và ba là ba.

3437
00:10:29,160 --> 00:10:40,820
Vì vậy, hãy cập nhật giá trị này từ hai đến ba. Bây giờ chúng ta hãy chuyển sang phần tiếp theo. Và bây giờ chúng ta thấy phần cuối đang trỏ đến cùng một phần tử. Vì vậy, chúng ta sẽ chèn max cộng một vào đây.

3438
00:10:40,840 --> 00:10:53,190
Vì vậy tôi cũng chỉ bản đồ của anh ấy. Vì vậy hãy chèn vào đây Max cộng một. Có ba cộng một bốn. Và hãy đặt số 0 tương đối này. Bây giờ, hãy chuyển sang phần tử tiếp theo.

3439
00:10:53,370 --> 00:11:08,690
Và đó là yếu tố đầu tiên. Bây giờ, hãy so sánh nó nhỏ hơn 18, vì vậy hãy cập nhật giá trị của Maxo, tối đa bằng 0 và một là một. Vì vậy, hãy cập nhật giá trị này thành một.

3440
00:11:08,950 --> 00:11:24,040
Sau đó chúng ta chuyển sang số 9 tiếp theo nhỏ hơn 18 để Abda phát triển ở mức tối đa. Vậy tối đa của max và một là một. Vì vậy giá trị này không thay đổi. Hãy chuyển sang hai số tiếp theo nhỏ hơn 18.

3441
00:11:24,160 --> 00:11:35,460
Vì vậy, hãy cập nhật biến max thành giá trị tối đa Max. Và cái này, cái kia là một. Vì vậy giá trị này vẫn không thay đổi. Vì vậy, hãy chuyển sang yếu tố tiếp theo. Năm là ít hơn 18.

3442
00:11:35,650 --> 00:11:47,110
Vậy giá trị lớn nhất của max và giá trị lớn nhất ở đây là một và hai là hai. Vì vậy, hãy cập nhật giá trị này từ một đến hai. Bây giờ, hãy chuyển sang phần tử tiếp theo ở đây.

3443
00:11:47,110 --> 00:12:00,220
Chúng ta nói ba nhỏ hơn 18. Vì vậy, hãy cập nhật biến max max. Vì vậy, tối đa của max và giá trị tối đa của hai và hai là hai. Vì vậy giá trị hai này không thay đổi.

3444
00:12:00,400 --> 00:12:10,990
Bây giờ, hãy chuyển sang phần tử tiếp theo. Bây giờ chúng ta thấy 7 nhỏ hơn 18. Vì vậy, hãy thực sự khai triển biến max của max và 3. Vậy tối đa hai và ba là ba.

3445
00:12:11,020 --> 00:12:23,530
Vì vậy, hãy theo đuổi hai đến ba điều này. Bây giờ, hãy chuyển sang phần tử tiếp theo. Đó là 101. 101 lớn hơn 18. 101 không nhỏ hơn 18. Vậy hãy chuyển nó sang số tiếp theo.

3446
00:12:24,460 --> 00:12:36,130
Và trong trường hợp này, điều này trỏ đến cùng một yếu tố mà tôi đã chỉ ra phản hồi này. Vì vậy, chúng ta sẽ bắt đầu ở đây và chúng ta sẽ chèn vào đây ba cộng một và có bốn ở lần lặp tiếp theo.

3447
00:12:36,130 --> 00:12:49,500
Tôi sẽ chỉ ra mọi ranh giới. Vậy là chúng ta đã hoàn tất. Đây là những gì chúng ta có thể giải quyết, vấn đề này. Đây là trực giác để giải quyết vấn đề này. Đây là một bài toán quy hoạch động mà chúng ta đang sử dụng kết quả trung gian để giải bài toán này.

3448
00:12:50,430 --> 00:13:12,190
Được rồi, chúng tôi đã hiểu sự xâm nhập. Giải pháp này chỉ giải quyết được độ phức tạp lớn hơn và thời gian bình phương cũng như độ phức tạp không gian vuông lớn hơn để hạn chế bảng lập trình động của chúng tôi, câu trả lời cho câu hỏi này là giá trị tối đa chúng tôi có trong lĩnh vực này.

3449
00:13:12,570 --> 00:13:22,680
Chúng tôi có thể quét vùng lập trình động này để tìm giá trị tối đa và giá trị tối đa mà chúng tôi thấy vì chúng tôi có con sói đó và chúng tôi có thể nhận được bất kỳ giá trị nào trong số chúng. Chúng tôi có bốn đôi.

3450
00:13:22,690 --> 00:13:44,190
Điều đó có nghĩa là chúng ta phải tăng dãy con một cách chặt chẽ. Điều đó có nghĩa là chúng ta phải tăng dãy con nghiêm ngặt lâu nhất. Chúng ta có thể quét bảng lập trình động này bằng cách sử dụng cho tất cả hoặc chúng ta có thể theo dõi hoặc phần tử tối đa bằng cách sử dụng một biến và điều đó chúng ta sẽ thấy trong mã giả và quét không nút.

3451
00:13:44,190 --> 00:13:56,340
Bảng lập trình động này cho giá trị tối đa của chúng tôi sẽ theo dõi giá trị tối đa của chúng tôi trong quá trình tạo bảng lập trình động. Bây giờ chúng ta hãy xem mã giả năm nay, Sudhakar.

3452
00:13:56,340 --> 00:14:10,860
Để giải quyết vấn đề này. Chúng ta có độ dài hàm tăng dài nhất L AI tiếp theo là hàm này lấy một tham số bên trong quá trình kiểm tra của bạn, nếu không áp dụng được cho các mảng đã cho trống thì sẽ trả về 0.

3453
00:14:11,370 --> 00:14:29,130
Sau đó, chúng ta đang xây dựng bảng lập trình giả và chèn vào vị trí đầu tiên bảng mà chúng ta đã chèn, bảng mà chúng ta đã nói đến ở trang trình bày trước, sau đó ban đầu chúng ta có mã nhập vào một bảng vì ban đầu chúng ta có một phần tử mang lại phần tử đầu tiên.

3454
00:14:29,550 --> 00:14:40,620
Phần tử đầu tiên là một danh sách dài, có thứ tự tăng dần. Chúng ta có thể xem xét điều đó. Và đó là những gì chúng ta đang chèn nó vào cái đầu tiên và sau đó chạy một tình yêu tức là từ 0 đến thích trừ một.

3455
00:14:40,860 --> 00:15:02,590
Và chúng tôi có biến tối đa của bạn và do đó J từ 0 đến 8 trừ một. Nếu mắt của NOM lớn hơn Nomsa, chúng ta sẽ thấy đó là câu trả lời tối đa của Gault đến mức tối đa và giá trị đó không được phản hồi từ bảng lập trình động.

3456
00:15:02,810 --> 00:15:15,400
Và sau đó chúng tôi sẽ chèn sau sự sụp đổ của Max bludge một và chúng tôi đang theo dõi giá trị tối đa của mình bằng cách sử dụng biến trả lời này. Chúng ta không cần phải quét mảng để tìm ra giá trị lớn nhất.

3457
00:15:15,920 --> 00:15:28,730
Và khi kết thúc việc trả lời câu trả lời của chúng ta, mã này sẽ đưa chúng ta trở lại và bình phương độ phức tạp theo thời gian cho mạch cũ và nó sẽ tăng độ phức tạp về không gian để xây dựng bảng lập trình động.

3458
00:15:28,880 --> 00:15:37,700
Và ở đây chúng ta có mảng và mảng lập trình động. Chúng ta đã xây dựng được bảng lập trình động. Chúng tôi không muốn lãng phí thời gian của bạn.

3459
00:15:37,880 --> 00:15:47,560
Tôi sẽ để lại tài nguyên cho bạn và tôi khuyên bạn nên xây dựng bảng lập trình động này, sử dụng khái niệm mà chúng tôi đã sử dụng trong trang trình bày trước.

3460
00:15:47,810 --> 00:15:59,860
Được rồi các bạn, đây là giải pháp của tôi cho vấn đề này. Chúng tôi đã hiểu lời giải thích tà thuật này. Nếu bạn có bất kỳ câu hỏi
nào, nếu bạn có bất kỳ đề xuất nào hoặc nếu bạn gặp khó khăn trong việc hiểu lời giải thích tà thuật này, hãy cho chúng tôi biết. 

@@@



3461
00:00:00,810 --> 00:00:16,020
Này các bạn, chào mừng bạn quay trở lại với video này trong video này. Chúng ta sẽ giải quyết một vấn đề quy hoạch động. Cướp như thế nào Bạn là một tên cướp chuyên nghiệp lên kế hoạch cướp những ngôi nhà ven đường là làm sao có được một số tiền nhất định.

3462
00:00:16,320 --> 00:00:32,910
Hạn chế duy nhất ngăn cản bạn cướp từng ngôi nhà là các ngôi nhà liền kề có hệ thống an ninh được kết nối và nó sẽ tự động liên hệ với cảnh sát nếu hai ngôi nhà liền kề bị đột nhập trong cùng một đêm.

3463
00:00:33,570 --> 00:00:45,320
Trong bài toán này, bạn được cho một số nguyên. Mọi con số đại diện cho số tiền đã hết, đạt đến số tiền tối đa bạn có thể cướp tối nay mà không cần báo cho người Ba Lan.

3464
00:00:45,600 --> 00:01:03,860
Ví dụ: nếu bạn đang cho đi thứ này trong lĩnh vực này, chúng tôi có năm yếu tố là các yếu tố chỉ ra một yếu tố. Và trong ngôi nhà đặc biệt đó, chúng ta có một số tiền và chúng ta phải lợp mái nhà mà không báo cảnh sát.

3465
00:01:04,080 --> 00:01:16,460
Điều đó có nghĩa là chúng ta không thể cướp nhà liền kề và phải giữ lại số tiền tối đa. Nếu chúng ta rời khỏi ngôi nhà này thì chúng ta không thể đến được ngôi nhà này.

3466
00:01:17,040 --> 00:01:42,410
Vậy nếu chúng ta chạy ở nhà này hai, rồi chín, rồi một, nếu chúng ta chạy ở nhà này bảy. Sau đó lại vào lúc ba giờ. Và ở đây chúng ta thấy rằng nếu chúng ta cộng vào lúc 9:00 và sau đó vào lúc một, mức tối đa mà chúng ta có thể nhận được, nó sẽ cải thiện vào lúc 7:00, khi đó giá trị chúng ta sẽ nhận được, nghĩa là tiền sẽ bị ăn sạch.

3467
00:01:43,030 --> 00:01:54,980
Thế nên ở đây chúng ta phải trở về trill mà không cướp bóc ở những ngôi nhà liền kề. Chúng ta có thể kiếm được mười hai đô la nếu chúng ta xem xét nó, chúng ta coi con số đã cho là một đô la.

3468
00:01:55,510 --> 00:02:09,760
Vì vậy, chúng tôi được trao khu vực này. Chúng ta phải trả về 12. Hãy lấy một ví dụ khác. Ví dụ: nếu bạn lấy khu vực này làm đầu vào thì số tiền tối đa bạn có thể nhận được từ mảng này là bao nhiêu?

3469
00:02:10,150 --> 00:02:26,950
Vì vậy, đầu tiên tất cả sẽ diễn ra lúc bảy giờ, sau đó sẽ chạy lúc 30 giờ, sau đó sẽ lăn bánh lúc bốn giờ. Ở đây chúng ta thấy là chúng ta đang cướp lúc ba mươi, sau đó chúng ta không cướp ở nhà liền kề mà OK, ở đây chúng ta thấy là chúng ta có thể chạy vào nhà này để xúi giục.

3470
00:02:26,950 --> 00:02:43,540
Cướp nó đi đâu. Cướp nó cho Epirus lúc hai giờ. Khi đó chúng ta sẽ có ít tiền hơn. Đó là những gì chúng tôi đang giữ HOUGE này. Số tiền tối đa có thể khó khăn. Bốn mươi mốt cho khu vực này bảy cộng ba mươi cộng bốn bản ghi đến bốn mươi mốt.

3471
00:02:43,820 --> 00:02:57,130
Vì vậy, nếu chúng ta được trao quyền này, chúng ta phải trả lại bốn mươi mốt. Bây giờ hãy lấy một ví dụ khác. Ví dụ: nếu bạn được cung cấp mảng này làm đầu vào, số tiền tối đa có thể nhận được khi không có Ruby ở các ngôi nhà liền kề là bao nhiêu.

3472
00:02:57,310 --> 00:03:10,090
Đầu tiên sẽ chạy ở 20, sau đó tất cả sẽ quay trở lại, đột nhiên họ sẽ chạy ở 40 với số tiền tối đa có thể rút ra từ mảng này là 73, 40 cộng 13 cộng 20 gọi tới 73.

3473
00:03:10,300 --> 00:03:23,290
Vì vậy, nếu chúng ta được đưa ra mảng này, chúng ta phải trả lại bảy mươi ba mối tình đầu tiên tại ngôi nhà này, nơi chúng ta có tiền 20 thì tất cả cướp ở đây sẽ nhận được tiền bắt đầu thì Robert ở đây sẽ nhận được tiền.

3474
00:03:23,290 --> 00:03:32,890
Bốn mươi. Vì vậy, chúng tôi sẽ trả lại bảy mươi ba cho khu vực nhất định này. Bây giờ làm thế nào chúng ta có thể giải quyết vấn đề này. Chúng ta sẽ giải quyết vấn đề này bằng cách sử dụng quy hoạch động.

3475
00:03:33,100 --> 00:03:46,150
Chúng ta biết rằng đối với bài toán quy hoạch động, chúng ta có thể sử dụng cách tiếp cận từ trên xuống hoặc chúng ta có thể sử dụng cách tiếp cận từ dưới lên. Trong video này, chúng ta sẽ xem cách giải quyết vấn đề này theo cách tiếp cận từ dưới lên.

3476
00:03:46,390 --> 00:03:56,380
Chúng ta sẽ không nói về cách tiếp cận từ trên xuống. Chúng ta cũng có thể thiết lập một cách tiếp cận. Bây giờ, hãy xem liệu chúng ta có thể giải quyết vấn đề này bằng cách sử dụng cách tiếp cận từ dưới lên để dễ hiểu hay không.

3477
00:03:56,380 --> 00:04:05,410
Giả sử bạn đã được cung cấp mảng này trong bài toán này. Chúng tôi sẽ áp dụng cách tiếp cận từ dưới lên để giải quyết vấn đề này. Đầu tiên, hãy tạo một bảng lập trình động.

3478
00:04:05,750 --> 00:04:20,410
Đây là bảng lập trình động. Chúng tôi biết rằng cách tiếp cận từ dưới lên sẽ không biến vấn đề của chúng tôi thành vấn đề nhỏ nhất. Thay vào đó, chúng ta sẽ bắt đầu giải quyết vấn đề nhỏ nhất có thể xảy ra.

3479
00:04:20,800 --> 00:04:33,640
Đầu tiên hãy xem chúng ta có thể giải quyết vấn đề này như thế nào. Vì vậy, với số tiền tối đa, chúng ta có thể thả D'Arista lần thứ hai. Vì vậy chúng ta phải thử nó bởi Robin lúc này. Houge và không đến Houge này.

3480
00:04:33,640 --> 00:04:43,710
Nếu chúng ta dừng lại ở ngôi nhà này, số tiền tối đa lại có thể là bảy. Nếu chúng tôi không chạy ở nhà cái này, số tiền tối đa chúng tôi có thể quyết định, chúng tôi sẽ chỉ sao chép từ đó.

3481
00:04:43,720 --> 00:04:54,670
Chúng ta hãy lấy số lớn nhất là bảy và hai là bảy nên sẽ chèn vào đây là bảy. Bây giờ chúng ta đã giải quyết được vấn đề này cho phần này. Bây giờ chúng ta hãy tập trung vào thung lũng cho việc này.

3482
00:04:54,670 --> 00:05:13,300
Vì vậy, ở đây chúng tôi có chín. Lựa chọn đầu tiên của chúng ta là nếu chúng ta chạy ở nhà cái này số chín, số tiền tối đa chúng ta có thể loại bỏ chín cộng hai, chúng ta sẽ bỏ qua số đó. Vì chúng ta không thể chạy ở Howard liền kề nên chúng ta sẽ bỏ qua phần này và sẽ cộng sẽ cộng từ 2 đến 9.

3483
00:05:13,480 --> 00:05:25,270
Vậy mười một chín cộng hai là mười một. Và nếu chúng ta không chạy ở mức này thì làm sao chúng ta có thể giảm được mức tối đa bảy. Vậy tối đa mười một và bảy là mười một. Vì vậy, hãy chèn vào đây mười một.

3484
00:05:25,420 --> 00:05:37,000
Tại thời điểm này, chúng tôi đã giải quyết được vấn đề cho Sabari này. Bây giờ chúng ta hãy tập trung vào thung lũng cho việc này. Vì vậy, nếu chúng ta nhìn vào ngôi nhà thứ ba này, giá trị tối đa chúng ta có thể cải thiện ở ngôi nhà này.

3485
00:05:37,000 --> 00:05:57,660
Ba, nếu chúng ta chạy ở Houge này, số tiền tối đa chúng ta có thể rút được là ba cộng bảy, tức là mười. Nếu chúng ta không chạy ở ngôi nhà này giá trị tối đa, nếu chúng ta không chạy ở ngôi nhà này là ba, nếu không nếu chúng ta không chấp thuận ở ngôi nhà này là ba, thì mức tối đa chúng ta có thể chứng minh rằng thậm chí là cà phê từ bên trái tế bào.

3486
00:05:57,750 --> 00:06:09,240
Vậy tối đa mười và mười một là mười một. Vì vậy, hãy chèn vào đây mười một. Chúng tôi đã giải quyết vấn đề này cho phần bên trái nên chúng tôi không phải lo lắng về giá trị ở bên trái.

3487
00:06:09,260 --> 00:06:20,500
Vì vậy, tại thời điểm này, chúng tôi đã giải quyết được vấn đề này để khám phá. Tại thời điểm này, chúng tôi đã giải quyết được vấn đề cho khám phá này. Bây giờ hãy điền giá trị cho ô này.

3488
00:06:20,500 --> 00:06:36,030
Bạn chúng tôi ở ngôi nhà này, số tiền tối đa chúng tôi có thể bỏ ra một cộng thậm chí là ba mươi. Ở nhà cái này số tiền tối đa chúng ta có thể loại ra sẽ là từ Clipsal nên tối đa 11 và 12 là 12.

3489
00:06:36,300 --> 00:06:48,000
Vì vậy, hãy chèn dải ở đây và đây là câu trả lời. Vì vậy, nếu chúng ta đang đưa ra mảng này, chúng ta phải quay lại để trợ giúp. Đây là cách chúng ta có thể giải quyết vấn đề này để hiểu rõ hơn.

3490
00:06:48,240 --> 00:07:01,140
Hãy lấy một ví dụ khác. Giả sử lúc đầu chúng tôi đang cung cấp cho khu vực này và bảng lập trình động của chúng tôi số tiền tối đa có thể, khoảng sáu cho giây.

3491
00:07:01,150 --> 00:07:13,590
Vì vậy, số tiền tối đa chúng tôi có thể đưa ra, tối đa cho lần bán đầu tiên và tối đa cho lần bán thứ hai. Vì vậy và đó là bảy. Vì vậy, hãy chèn Suban vào đây bây giờ hãy phổ biến giá trị cho điều này.

3492
00:07:13,590 --> 00:07:30,660
Như vậy chúng ta đã giải quyết được vấn đề này cho phần tóm tắt của Leape. Bây giờ hãy điền giá trị cho ô này cho việc này. Vì vậy chúng ta phải thử nó. Lúc này, làm thế nào chúng ta có thể đạt được giá trị tối đa Roaf một cộng sáu bằng cách tính bằng bao nhiêu?

3493
00:07:30,660 --> 00:07:45,600
Bởi vì chúng tôi không thể vì chúng tôi không thể di dời ở Houge liền kề. Vậy một cộng sáu là bảy. Và nếu chúng ta không đạt được điều này, làm thế nào số người đổi tiền tối đa là bảy người sẽ đến từ bên trái.

3494
00:07:45,780 --> 00:08:01,110
Vậy tối đa là bảy và bảy mươi bảy. Vì vậy hãy chèn số bảy vào đây. Vì vậy, chúng tôi đã giải quyết vấn đề này cho việc này. Hãy để Soury trước hoặc giải quyết vấn đề nhỏ hơn sau đó chúng ta sẽ tiếp tục. Bây giờ hãy điền vào phễu cho ô này.

3495
00:08:01,500 --> 00:08:18,920
Bằng cách nhìn vào điều này, làm thế nào số tiền tối đa mà chúng ta có thể tạo ra là ba mươi cộng bảy ba mươi bảy bằng cách không cướp tại ngôi nhà này số tiền tối đa mà chúng ta có thể là bảy, vì vậy tối đa bảy và ba mươi bảy là ba mươi bảy.

3496
00:08:19,050 --> 00:08:38,760
Vì vậy hãy chèn vào đây ba mươi bảy. Vì vậy, chúng tôi đã giải quyết vấn đề này cho vụ cướp này vào thời điểm này, số tiền tối đa mà chúng tôi có thể cướp được là ba mươi bảy. Vì vậy, chúng tôi đã hiểu, chúng tôi hiểu rằng nếu chúng tôi coi đây là Sabari của mình thì mức tối đa chúng tôi có thể bỏ là sáu.

3497
00:08:38,760 --> 00:08:48,780
Nếu chúng tôi coi đây là Sabari của chúng tôi, số tiền tối đa chúng tôi có thể rút là bảy, nếu chúng tôi coi đây là chủ quyền của chúng tôi, số tiền tối đa chúng tôi có thể rút là bảy.

3498
00:08:48,990 --> 00:09:06,330
Và nếu chúng ta coi cuộc vây hãm Sabari này của chúng ta thì số tiền tối đa đó sẽ kiểm soát ba mươi bảy. Bây giờ hãy điền giá trị cho ô này. Nếu chúng ta yêu cầu vào thời điểm quá hạn này, số tiền tối đa chúng ta có thể nhận được là 8 cộng 7, tức là 15.

3499
00:09:06,840 --> 00:09:17,600
Nếu chúng ta không đến được Houge này, số tiền tối đa có thể rút ra là ba mươi bảy. Vậy tối đa ba mươi bảy và mười lăm là ba mươi bảy. Vì vậy hãy chèn số bảy vào đây.

3500
00:09:18,360 --> 00:09:35,400
Vì vậy, đến thời điểm này, chúng tôi đã tìm ra số tiền tối đa mà chúng tôi có thể nhận được. Ba mươi bảy. Bây giờ chúng ta hãy điền giá trị cho ô này ở ngôi nhà này với số tiền tối đa mà chúng ta có thể quyết định là cộng ba mươi bảy.

3501
00:09:35,610 --> 00:09:56,600
Có ba mươi chín ở đây. Chúng tôi bỏ qua Houge một vì chúng tôi không thể cướp ở Houge liền kề. Vậy 39 nếu chúng ta không lăn ở nhà cái này thì số tiền tối đa chúng ta có thể cai 37 là tối đa là 37 và 39 là 39.

3502
00:09:56,600 --> 00:10:09,580
Vì vậy hãy chèn vào đây ba mươi chín. Bây giờ, hãy điền vào thung lũng cho ô này. Mỗi phòng trong ngôi nhà này với số tiền tối đa chúng ta có thể lăn được cộng thêm 37.

3503
00:10:09,590 --> 00:10:22,120
Đó là bốn mươi mốt. Nếu chúng ta không lăn ở nhà cái này số tiền tối đa chúng ta có thể lăn là 39. Vậy tối đa 41 và 39 là 41. Vì vậy, tất cả trong ba mươi hoặc bốn mươi mốt.

3504
00:10:22,640 --> 00:10:34,850
Vì vậy, nếu chúng tôi được cấp diện tích này, chúng tôi phải trả lại 41. Giải pháp này sẽ mang lại hiệu quả lớn về độ phức tạp về thời gian vì chúng ta sẽ đi qua khu vực nhất định một lần từ trái sang phải.

3505
00:10:35,660 --> 00:10:48,020
Và nó cũng sẽ phức tạp khi chúng ta đi lên trong không gian bởi vì chúng ta đang xây dựng bảng lập trình động của đất. Bây giờ hãy lấy một ví dụ khác để hiểu rõ hơn.

3506
00:10:48,590 --> 00:11:00,320
Giả sử chúng ta được cung cấp mảng này. Hãy tạo bảng lập trình động. Đây là bảng DB của chúng tôi lúc đầu. Vì vậy hãy chèn 20 vào, vì ở đây chúng ta chỉ có một lựa chọn.

3507
00:11:00,620 --> 00:11:14,360
Nếu chúng tôi loại bỏ tối đa vào giờ này, bạn có thể loại bỏ 29 cho việc này. Vì vậy, nếu chúng ta lăn vào ngôi nhà này số tiền tối đa chúng ta có thể lăn được năm. Nếu chúng tôi không cung cấp cho ngôi nhà này số tiền tối đa, chúng tôi có thể lái xe 20.

3508
00:11:14,690 --> 00:11:29,620
Vì vậy, cơ hội tối đa và năm là 20. Vì vậy, hãy chèn vào đây 20. Vì vậy, chúng tôi đã giải quyết vấn đề này cho bản tóm tắt này cho ngôi nhà này. Nếu chúng ta chạy vào ngôi nhà này, số tiền tối đa chúng ta có thể nhận được.

3509
00:11:30,020 --> 00:11:41,560
Hai mươi cộng một có hai mươi mốt. Nếu chúng ta không mua căn nhà này một, số tiền tối đa chúng ta có thể giảm là 20. Vậy tối đa là 21 và 2 và là 21. Vậy hãy chèn vào đây 21.

3510
00:11:42,440 --> 00:11:55,160
Vì vậy, chúng tôi đã giải quyết vấn đề này cho bản tóm tắt này vì điều này sẽ được cải thiện tại nhà cái này, nhắm mục tiêu số tiền tối đa mà chúng tôi có thể nhận được Tartine cộng với hai mươi, tức là ba mươi ba.

3511
00:11:55,670 --> 00:12:07,150
Nếu chúng ta không chạy ở nhà cái này thì số tiền tối đa bạn có thể bỏ ra. Hai mươi mốt là tối đa ba mươi ba và hai mươi mốt là ba mươi ba. Chúng tôi đã giải quyết vấn đề này cho mọi người.

3512
00:12:08,200 --> 00:12:24,680
Bây giờ chúng ta hãy tìm D.L.. Mỗi phòng ở ngôi nhà này là số tiền tối đa chúng ta có thể lăn lộn với giá sáu cộng hai mươi mốt hai mươi bảy, nếu chúng ta không đến ngôi nhà này, số tiền tối đa chúng ta có thể kiếm được là ba mươi ba.

3513
00:12:24,890 --> 00:12:41,480
Vậy tối đa của 27 và 33 là 33. Vậy hãy chèn vào đây ba mươi ba. Bây giờ, hãy điền vào thung lũng cho ô này. Nếu chúng ta đến ngôi nhà này, số tiền tối đa bạn có thể sống trong cộng với lãnh thổ là 44.

3514
00:12:41,960 --> 00:12:58,720
Nếu chúng ta không đến ngôi nhà này thì số tiền tối đa bạn có thể rút được là lãnh thổ, tối đa là 33 và 44 là bốn mươi. Bây giờ đây là lần bán hàng cuối cùng của chúng tôi ở đây để có câu trả lời cho ngôi nhà này, số tiền tối đa chúng tôi có thể rút được.

3515
00:12:59,210 --> 00:13:11,750
Bốn mươi cộng ba mươi ba. Đó là bảy mươi ba. Nếu chúng ta không dùng hết số tiền này, số tiền tối đa chúng ta có thể chạy bốn mươi cho tối đa bảy mươi ba và bốn mươi bốn là bảy mươi ba.

3516
00:13:12,350 --> 00:13:33,130
Và ở đây chúng ta thấy rằng chúng ta lăn ở nhà cái này 20 tại nhà cái này bắt đầu và tại nhà cái này 40. Vậy 40 cộng 13 cộng 20 bằng 273, và anh ta đã tinh chỉnh nó 73 và đây là những gì chúng ta có thể giải quyết vấn đề này, chúng ta hiểu rộng đến mức nào của giải pháp hoạt động.

3517
00:13:33,160 --> 00:13:41,670
Đây là cách tiếp cận từ dưới lên. Chúng tôi đang giải quyết vấn đề nhỏ nhất trước tiên và sau đó chúng tôi sẽ đi ra ngoài. Bây giờ, hãy xem cách chúng ta có thể giải quyết vấn đề này bằng mã giả.

3518
00:13:42,160 --> 00:13:55,540
Đây là mã giả để giải quyết vấn đề này. Đây là chức năng cần thiết để cung cấp đầu vào. Nếu bạn kiểm tra xem bây giờ có phải là số numskull hay không hoặc độ dài lỗi của con người có bằng 0 hay không thì tất cả đều trả về 0.

3519
00:13:55,930 --> 00:14:08,800
Leontes khi đó sẽ chỉ có một phần tử và giữ lại phần tử đó. Nếu độ dài lỗi của con người là hai thì chúng ta sẽ trả về giá trị tối đa là hai.

3520
00:14:09,430 --> 00:14:20,230
Nếu không, chúng ta đang tạo bảng lập trình động, sau đó chèn giá trị đầu tiên vào giá trị đầu tiên và giá trị thứ hai. Vì vậy, tối đa của thứ nhất và thứ hai.

3521
00:14:20,230 --> 00:14:35,170
Vì vậy, chúng tôi đang chạy Aluf bốn iframe hai với độ dài của lỗi trừ một. Điều đó có nghĩa là chúng ta đang bắt đầu từ phần phụ cho đến hết. Sau đó, chúng tôi đang điền giá trị tối đa cho bảng lập trình động ở đây.

3522
00:14:35,170 --> 00:14:51,750
Chúng tôi đã cải thiện tình trạng ở Namsan hiện tại cộng trừ hai. Chúng tôi đang thêm phần tử hiện tại và sau đó chúng tôi bỏ qua một phần tử ở bên trái. Nếu chúng tôi không cướp ở mức giữ hiện tại thì chúng tôi sẽ che giá trị từ bên trái ở cuối.

3523
00:14:51,760 --> 00:15:17,610
Chúng ta sẽ có câu trả lời ở ô cuối cùng trong bảng lập trình động. Bây giờ chúng ta hãy xem mọi chuyện là như thế nào. Cho mảng này và đây là bảng lập trình động của chúng ta trước tiên hoặc chèn hai, sau đó là tối đa của thứ nhất và thứ hai và có bảy rồi cho ô này ở đây hoặc áp dụng công thức này nums cộng trừ hai, chín cộng hai, tức là 11 và chỉ bảy .

3524
00:15:18,190 --> 00:15:34,050
Vậy tối đa của 11 và bảy ở đây là mười một. Những gì chúng tôi đang làm ở đây, chúng tôi đang xem xét nếu chúng tôi cải thiện ngôi nhà này thì chúng tôi sẽ cộng chín cộng bằng cách bỏ qua một phần tử ở hai phần bên trái.

3525
00:15:34,150 --> 00:15:45,780
Vì vậy, không có dây 11. Nếu chúng ta lăn vào ngôi nhà này, nhiều người có thể đánh rơi, ngay cả khi chúng ta không biết điều này đến từ đâu từ bên trái. Và đây là những gì chúng tôi đang làm ở đây vì điều này.

3526
00:15:45,780 --> 00:15:59,770
Vậy ba cộng 17 và đó là Ilorin, tối đa 10 và 11 là 11 thì đối với cái này. Vậy nếu quyết định cái nào cộng với mười một thì bằng mười hai. Và ở đây chúng ta có 11.

3527
00:15:59,950 --> 00:16:15,640
Vì vậy, ở đây trong trilled như vậy và đây là câu trả lời của chúng tôi. Đây là cách chúng ta có thể giải quyết vấn đề này. Đây là bảng bài toán lập trình động mà chúng ta có thể giải được. Vấn đề này là cách tiếp cận từ trên xuống, nhưng hiện tại chúng tôi đang giải quyết vấn đề này bằng cách sử dụng cách tiếp cận từ dưới lên.

3528
00:16:15,760 --> 00:16:28,450
Và đây là cách chúng tôi tiếp cận công việc. Giải pháp này cần thiết vì về mặt thời gian, độ phức tạp là độ dài của mảng đã cho và nó cũng giảm độ phức tạp về không gian để xây dựng bảng lập trình động.

3529
00:16:28,840 --> 00:16:37,900
Chúng tôi đã hiểu lời giải thích rộng hơn này. Nếu bạn gặp khó khăn khi hiểu lời giải thích của
video này, hãy cho chúng tôi biết. Cảm ơn đã xem. Tôi sẽ gặp bạn trong video tiếp theo. 

@@@



3530
00:00:01,390 --> 00:00:12,730
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ giải quyết một vấn đề về lập trình động, mức độ tối thiểu, đưa ra nó bằng bất kỳ số liệu nào chứa số âm.

3531
00:00:13,000 --> 00:00:26,440
Tìm một đường đi từ trên cùng bên trái đến dưới cùng bên phải ai đang giảm thiểu tổng tất cả các số dọc theo đường đi của nó? Không phải là bạn chỉ có thể di chuyển xuống hoặc sang phải bất kỳ lúc nào.

3532
00:00:26,980 --> 00:00:48,510
Bây giờ, hãy xem một số ví dụ. Ví dụ, bạn được cho ma trận này, bạn được cho ma trận này. Bạn phải bắt đầu từ ô trên cùng bên trái này và bạn phải truy cập vào ô dưới cùng bên phải để nó giảm thiểu số lượng tổng dọc theo đường đi của nó.

3533
00:00:49,150 --> 00:01:02,980
Chúng ta có thể đi sang phải hoặc xuống dưới từ bất kỳ ô nào. Được rồi, từ ô có thể đi sang phải và phần dưới cùng của ô bạn có thể đi xuống phần dưới cùng ngay từ ô. Chúng ta có thể đi thẳng tới đáy của mình.

3534
00:01:03,310 --> 00:01:18,610
Vì vậy, chúng tôi có hai hướng, chúng tôi có thể đi bên phải hoặc chúng tôi có thể đi Boerum và chúng tôi phải tìm ra con đường từ trên xuống dưới. Right nói rằng các con số dọc theo đường đi của nó có số tối thiểu.

3535
00:01:19,660 --> 00:01:32,840
Vậy điều này có nghĩa là gì nếu chúng ta truy cập cái này, cái gì đó giống như cái đầu tiên này, sau đó đến một một cộng một cộng bốn cộng hai, tám cộng hay chín?

3536
00:01:33,130 --> 00:01:50,950
Vì vậy, trong phần này, tổng các số dọc theo phần của nó là chín. Trong ma trận này, Pathum thu nhỏ là phần một cộng ba cộng một bốn cộng một năm cộng một sáu.

3537
00:01:51,280 --> 00:02:07,410
Và đây là phần mà chúng ta có số lượng patzer tối thiểu. Vì vậy, nếu chúng ta được cho ma trận này, chúng ta phải trả về sáu. Bây giờ hãy lấy một ví dụ khác. Ví dụ, nếu bạn được cho ma trận này, bạn phải bắt đầu từ việc lật ngược này.

3538
00:02:07,810 --> 00:02:24,040
Vì vậy, sau đó bạn phải truy cập vào phía dưới, phải. Vì vậy bây giờ chúng ta phải tìm ra một con thú cưng từ trên xuống dưới. Phải. Sao cho tổng các số dọc theo đường đi của nó là nhỏ nhất.

3539
00:02:24,880 --> 00:02:41,160
Vậy con đường tối thiểu là gì? Chúng ta có thể đi từ một đến ba, rồi hai, rồi hai, rồi ba, rồi một, rồi hai. Hoặc bạn có thể đi từ một đến ba đến năm đến bốn đến năm đến một đến hai.

3540
00:02:41,470 --> 00:02:58,330
Nhưng bạn phải tìm ra mô hình tối thiểu. Vậy Pathum tối thiểu cho ma trận này là gì? Vậy vật nuôi tối thiểu là gì? Vậy thú cưng có Pathum tối thiểu cho ma trận này là gì?

3541
00:02:58,600 --> 00:03:16,120
Pathum tối thiểu đó là thú cưng cho ma trận này, Pathum tối thiểu. Hãy cùng tìm hiểu chất béo nhé. Ở đây chúng ta có con vật cưng này một ba một, hai, ba, một, rồi hai và con vật cưng nào đó là 13.

3542
00:03:16,720 --> 00:03:29,060
Một cộng ba cộng một là năm cộng hai bảy. Prostratin cộng với một. Mười một cộng 230. Vì vậy, đối với ma trận đã cho này, chúng ta phải trả về Pathum tối thiểu 13.

3543
00:03:29,350 --> 00:03:41,320
Bây giờ làm thế nào chúng ta có thể giải quyết vấn đề này. Đây là một vấn đề lập trình động. Chúng ta có thể giải quyết vấn đề này bằng cách sử dụng cách tiếp cận từ trên xuống hoặc cách tiếp cận từ dưới lên. Trong video này, tôi sẽ giải quyết vấn đề này.

3544
00:03:41,560 --> 00:03:54,310
Sử dụng cách tiếp cận từ dưới lên trước sẽ giải quyết được vấn đề nhỏ nhất, sau đó mới thực hiện được. Một vấn đề nhỏ hơn sẽ dần dần đi vào vấn đề lớn hơn.

3545
00:03:54,850 --> 00:04:06,370
Bây giờ hãy xem cách chúng ta có thể giải quyết vấn đề này trước tiên bằng cách hiểu, giả sử chúng ta đang đưa ra ma trận này. Và đầu tiên, bạn sẽ làm gì? Đầu tiên chúng ta sẽ tạo một bảng lập trình động.

3546
00:04:06,390 --> 00:04:19,560
Bạn định làm gì? Chúng ta sẽ tìm ra mô hình cho quy tắc đầu tiên. Sau đó, đối với cột đầu tiên, chúng ta hãy tìm nó cho ô. Chúng ta sẽ chỉ sao chép giá trị từ ô này.

3547
00:04:19,630 --> 00:04:33,610
Vì vậy, hãy chèn đơn vị một sau đó. Ở đây chúng ta sẽ cộng một cộng ba. Vậy thì có bốn cho cái này cộng với bốn. Được rồi, đó là năm. Vì vậy, đối với ô, giá trị là năm.

3548
00:04:34,150 --> 00:04:47,230
Bây giờ hãy tìm hiểu mẫu cho cột đầu tiên. Vậy một cộng một là hai. Hai cộng bốn là sáu. Ở đây chúng ta có thể làm điều này là rơi ra và điều đó cực kỳ đơn giản.

3549
00:04:47,650 --> 00:05:05,200
Và bạn sẽ thấy cách chúng tôi có thể làm điều này khi xem qua mã giả của mình. Bây giờ chúng ta sẽ bắt đầu lặp lại từ đây. Chúng ta sẽ bắt đầu lặp lại từ đây. Vậy cho đến hết, nghĩa là từ ô này đến ô này, chúng ta sẽ bắt đầu từ ô này và sẽ kết thúc ở ô này.

3550
00:05:05,650 --> 00:05:15,640
Và đây sẽ là câu trả lời của chúng ta. Đây là phòng giam hiện tại của chúng tôi. Bây giờ, bạn định làm gì? Chúng ta sẽ tìm thấy nó. Giá trị tối thiểu ở phần cứng và bên trái là tối thiểu là mười hai.

3551
00:05:15,640 --> 00:05:26,760
Và hãy làm như vậy. Để nghe đúng, nên ở trên ba hoặc bốn bên trái, bạn phải lấy tối thiểu là hai, hai cộng năm bằng bảy. Vì vậy bây giờ chúng ta hãy chèn số bảy vào đây cho điều này.

3552
00:05:26,980 --> 00:05:39,280
Chúng tôi đã phát triển một đến mức tối thiểu muộn và mười hai là năm, năm cộng chỉ sáu. Hãy chèn sáu của bạn rồi ở đây tối thiểu là bảy và sáu mươi sáu.

3553
00:05:39,280 --> 00:05:54,390
Sáu cộng hai là tám ở mức tối thiểu của sáu và tám là sáu. Sáu cộng một là bảy. Đây là câu trả lời của chúng tôi. Nếu chúng ta đưa ma trận này cho vùng bảy và đây là điều chúng ta có thể giải quyết vấn đề này để hiểu rõ hơn.

3554
00:05:54,400 --> 00:06:04,630
Hãy lấy một ví dụ khác. Giả sử chúng ta được cung cấp ma trận này. Chúng ta phải tìm ra đường dẫn tối thiểu từ ô này đến ô này. Và đây là bảng lập trình động của chúng ta.

3555
00:06:04,720 --> 00:06:18,130
Đầu tiên, chúng ta hãy tìm hiểu mẫu cho cột đầu tiên và cột đầu tiên. Vì vậy, đối với ô này, một cho ba cộng một cho ô này. Bốn cộng năm là chín cho ô.

3556
00:06:18,400 --> 00:06:31,280
Chín cộng một bằng mười. Bây giờ đối với cột đầu tiên, một cộng ba là bốn cộng một là năm, sau đó năm cộng bốn là chín. Chúng ta có thể làm điều này bằng cách theo dõi bốn nhanh hơn và cho cột đầu tiên.

3557
00:06:31,450 --> 00:06:41,040
Bây giờ chúng ta sẽ bắt đầu lặp lại ma trận này từ ô này cho đến hết ma trận này. Nó sẽ có câu trả lời của chúng tôi.

3558
00:06:41,410 --> 00:06:53,590
Đây là yếu tố hiện tại của chúng tôi. Bây giờ chúng ta hãy tìm ra mức tối thiểu ở trên và bên trái. Tối thiểu bốn và bốn là bốn, bốn cộng ba sáu. Tối thiểu chín và sáu là sáu.

3559
00:06:53,590 --> 00:07:12,810
Và phần tử hiện tại là bốn hỗ trợ cộng với sáu là phần tử hiện tại của chúng ta là năm. Tối thiểu là mười hai và còn lại là mười. Mười cộng năm bằng mười lăm. Bây giờ ở đây bạn được yêu cầu phải truy cập vào ô này, ô cuối cùng trong số hai ô tính từ trên cùng bên trái.

3560
00:07:12,820 --> 00:07:25,280
Vậy Pathum tối thiểu là 15. Bây giờ, đây là phần tử hiện tại của chúng ta. Tối thiểu của Tufte và bên trái là năm năm cộng ba bảy. Tối thiểu là mười hai và còn lại là bảy.

3561
00:07:25,630 --> 00:07:37,810
Và ở đây chúng ta có ba hiện tại. Vậy bảy cộng ba là 10. Nhỏ nhất của 12 và bên trái là mười và hiện tại là một. Vậy một cộng mười là mười một. Và đây là yếu tố hiện tại của chúng tôi.

3562
00:07:38,440 --> 00:07:49,690
Tối thiểu là mười hai và còn lại là bảy. Bảy cộng ba bằng mười. Sau đó, đây là yếu tố hiện tại của bạn. Tối thiểu và còn lại vẫn là mười cộng năm là mười lăm.

3563
00:07:50,020 --> 00:08:02,830
Sau đó ô cuối cùng của chúng ta ở đây sẽ có câu trả lời. Tối thiểu là mười hai và bên trái là mười một và phần tử hiện tại là hai. Vậy là mười một cộng hai đang bắt đầu và đây là câu trả lời của chúng ta.

3564
00:08:02,860 --> 00:08:14,410
Vì vậy, nếu được cung cấp ma trận này, chúng tôi phải trả lại muộn. Giải pháp sẽ đưa Spiga of erm vào độ phức tạp về thời gian. Nó có nghĩa là số quy tắc và in là số cột của ma trận đã cho.

3565
00:08:14,770 --> 00:08:28,450
Và giải pháp cũng đòi hỏi độ phức tạp về không gian lớn hơn cho bảng lập trình động. Chúng tôi có thể giải quyết vấn đề này không hợp lệ. Sau đó, nó sẽ có độ phức tạp không gian không đổi và sẽ thêm mã cho giải pháp.

3566
00:08:28,720 --> 00:08:39,610
Nhưng để khám phá sẽ sử dụng bảng lập trình động, ma trận phụ trợ. Bây giờ hãy xem cách chúng ta có thể giải quyết vấn đề này bằng cách sử dụng mã giả. Đây cũng chính là tòa án giải quyết vấn đề này.

3567
00:08:39,820 --> 00:08:56,920
Đây là hàm Min Pathum. Hàm này lấy ma trận đã cho làm đầu vào. Sau đó chúng ta tính chiều cao và cân nặng. Sau đó, chúng tôi đang tạo bảng lập trình động và ở cấp độ đầu tiên, điều đó có nghĩa là ở cấp cao nhất, chúng tôi chỉ sao chép giá trị từ đỉnh ma trận.

3568
00:08:57,100 --> 00:09:12,190
Vì vậy, chúng ta sẽ điền vào cột đầu tiên bằng công thức này và sau đó chúng ta sẽ điền vào hàng đầu tiên. Sau đó, chúng ta bắt đầu lặp từ một đến chiều cao và ở đây chúng ta có số 0 từ một đến trọng lượng.

3569
00:09:12,670 --> 00:09:26,710
Và ở đây chúng ta đang áp dụng công thức tối thiểu là mười hai và môi và dòng điện và cuối cùng chúng ta sẽ có câu trả lời cho hầu hết bên phải của bảng lập trình động hoặc trong Ma trận.

3570
00:09:26,710 --> 00:09:35,260
Nếu chúng tôi cam kết, giả sử chúng tôi đang đưa ra ma trận này và ở đây chúng tôi sẽ tạo một bảng lập trình động. Đây là bảng lập trình động của chúng tôi.

3571
00:09:35,470 --> 00:09:50,160
Vì vậy, đầu tiên chúng ta sẽ đi đến cà phê, Avello đầu tiên, sau đó chúng ta sẽ điền vào cột đầu tiên bằng công thức này. Vì vậy, ở đây chúng ta bắt đầu từ trên, cộng ba là bốn, bốn cộng một là năm.

3572
00:09:50,730 --> 00:10:10,060
Năm cộng bốn là chín. Và đối với hàng đầu tiên, ba cộng một là bốn, rồi năm cộng bốn là chín, chín cộng một là 10. Vậy Maxo, ngoại lực cho bốn cộng ba sáu sử dụng công thức này.

3573
00:10:11,100 --> 00:10:25,110
Sau đó cho. Sáu cộng Foreston, rồi 10, cộng năm là 15, rồi năm cộng ba bảy, rồi bảy cộng ba, tối thiểu là 10 và bảy mươi bảy. Vậy bảy cộng ba bằng mười.

3574
00:10:25,560 --> 00:10:42,720
Khi đó tối thiểu 10 và 15 là 20 và cộng một là 11. Thế thì tối thiểu chín và bảy là bảy, bảy cộng ba. Estin bây giờ tối thiểu của Tenente trong Estin Suchin cộng năm là mười lăm, tối thiểu của mười một và mười lăm là mười một thậm chí cộng hai là mười ba.

3575
00:10:43,470 --> 00:10:58,800
Vì vậy, đối với ma trận đã cho này sẽ trả về số 13 này bằng câu lệnh viết này. Vì vậy, đối với ma trận đã cho này, chúng ta phải đổi 13 và giải pháp sẽ lớn hơn về thời gian.

3576
00:10:58,800 --> 00:11:07,460
Độ phức tạp, độ sừng, số lượng và đó là số cột. Và nó cũng đòi hỏi sự phức tạp về không gian của con người đối với bảng lập trình động này.

3577
00:11:07,620 --> 00:11:23,670
Hoặc chúng ta có thể giải quyết vấn đề này bằng cách sửa đổi mảng này, bằng cách sửa đổi chính ma trận, và sau đó cần có độ phức tạp không gian không đổi. Được rồi, các bạn, đây là phần cuối của cách tiếp cận lập trình động cho một số vấn đề.

3578
00:11:24,070 --> 00:11:32,550
Chúng tôi đã hiểu lời giải thích video này. Nếu bạn gặp khó khăn trong việc hiểu điều này cùng với
lời giải thích, hãy cho chúng tôi biết. Cảm ơn đã xem. Tôi sẽ gặp bạn trong video tiếp theo. 

@@@



3579
00:00:00,570 --> 00:00:13,860
Chào mừng bạn đến với câu hỏi phỏng vấn The Cording phổ biến dài nhất tiếp theo. Đây là báo cáo vấn đề mà bạn được cung cấp cho văn bản sự vật và nó cần trả về độ dài chung nhất dài nhất của chúng.

3580
00:00:13,860 --> 00:00:26,800
Chuỗi tiếp theo và chuỗi tiếp theo là một chuỗi mới được tạo từ chuỗi gốc, với một số ký tự bị xóa mà không thay đổi thứ tự tương đối của các ký tự còn lại.

3581
00:00:27,210 --> 00:00:37,830
Được rồi. Phần tiếp theo chung của hai chuỗi là phần tiếp theo chung cho cả hai điểm mạnh. Chuỗi đầu vào chỉ bao gồm các ký tự tiếng Anh viết thường.

3582
00:00:38,160 --> 00:00:53,310
Nếu không có số chung tiếp theo thì chúng ta phải trả về số 0. Được rồi. Và đây là tuyên bố vấn đề tổng thể của chúng tôi. Bây giờ chúng ta hãy xem một số ví dụ. Nếu bạn được giao cái này để xâu chuỗi ở đây, chúng ta sẽ thấy hai thứ này ở đây.

3583
00:00:53,310 --> 00:01:08,730
Nhân vật, a thenet ở đây, nhân vật B, rồi đến bản chất, nhân vật C, được rồi. Vì vậy, chuỗi chung dài nhất tiếp theo của chuỗi này là AVC. Và độ dài chung dài nhất tiếp theo là ba.

3584
00:01:09,420 --> 00:01:23,250
Khi bạn nhìn thấy từ tiếp theo, thì đó có thể là bất kỳ bí mật nào của nhân vật. Nó không nhất thiết phải liền kề nhau, nhưng nó có thể liền kề nhau. Ở đây chúng ta thấy nó liền kề ngay bây giờ.

3585
00:01:23,250 --> 00:01:35,970
Hãy xem thêm một số ví dụ. Nếu được cho hai sợi dây này thì chúng ta sẽ thấy sự xoắn này, đảm bảo nhân vật là như vậy. Rồi tôi thấy nó ở đây, ký tự D và rồi chúng ta thấy nó ở đây.

3586
00:01:35,970 --> 00:01:50,850
Ký tự trong trường hợp này, chúng ta thấy ký tự chung dài nhất tiếp theo là ba chữ DH và ở đây là 88. Vì vậy chúng ta thấy ở đây đây không phải là một tiếp giáp. Nếu chúng ta nói sự thật thì tôi thấy có hai điều.

3587
00:01:51,120 --> 00:02:06,330
Ký tự A thì nó ở đây, ký tự B này thì nó ở đây, ký tự E thì nó ở đây, ký tự F. Vậy ký tự tiếp theo dài nhất cho thứ này là a b e f.

3588
00:02:06,540 --> 00:02:18,000
Vì vậy, độ dài của phần tiếp theo chung dài nhất là hiện tại. Hãy xem làm thế nào chúng ta có thể tìm được điểm chung dài nhất tiếp theo để giải quyết vấn đề này. Chúng ta sẽ sử dụng một chương trình động.

3589
00:02:18,330 --> 00:02:30,900
Được rồi. Bây giờ hãy để tôi giải quyết vấn đề này bằng trực giác ở đây. Chúng tôi có một mã giả. Đầu tiên, tôi sẽ khai báo một hàm chung dài nhất tiếp theo có hai thứ.

3590
00:02:31,080 --> 00:02:46,170
Chuỗi một và chuỗi hai để kiểm tra bằng cách điều chỉnh chỉ đi đến A, B, C, D, E, F và các chuỗi bằng a, C, BFG. Được rồi, chúng ta sẽ chuyển hai chuỗi này thành một mảng ký tự.

3591
00:02:46,990 --> 00:03:11,470
Được rồi, chúng ta sẽ xây dựng một bảng lập trình động. Được rồi, đây là bảng lập trình động của chúng ta, sau đó chúng ta sẽ khởi tạo một con quay hồi chuyển có tốc độ thay đổi và biến này sẽ giữ câu trả lời của chúng ta, sau đó chúng ta có nó và vòng lặp này sẽ bắt đầu lặp lại từ hộp này và nó sẽ hoạt động khi nó được nâng lên tại hộp này.

3592
00:03:11,710 --> 00:03:24,760
Sau đó chúng ta có điều kiện này. Nếu chúng ta thấy hai ký tự trùng nhau thì chúng ta sẽ sao chép giá trị từ đường chéo. Nếu không, thì chúng ta sẽ lấy giá trị tối đa từ Tof hoặc từ bên trái.

3593
00:03:25,000 --> 00:03:36,340
Và sau đó nếu chúng tôi tìm thấy một giá trị ở chỉ mục hiện tại lớn hơn câu trả lời thì cuối cùng chúng tôi sẽ thay đổi câu trả lời thành giá trị đó. Chúng tôi sẽ trả lại câu trả lời.

3594
00:03:36,520 --> 00:03:47,200
Được rồi, bây giờ chúng ta hãy điền vào bảng lập trình động này và chúng ta sẽ điền vào bảng lập trình động này theo cách tiếp cận từ dưới lên. Được rồi. Vì vậy, chúng tôi có AMNESTYING và MDT của bạn.

3595
00:03:47,380 --> 00:03:57,730
Vì vậy, một chuỗi trống là một chuỗi trùng khớp, nhưng là phần cuối của bốn chuỗi chung dài nhất tiếp theo. Tôi chỉ đang nghĩ việc ân xá là con số không. Sau đó, chúng tôi có nhân vật của bạn trong chung dài nhất.

3596
00:03:57,730 --> 00:04:13,930
Bốn ký tự tiếp theo và Ejiro không rõ ràng, bây giờ là phần tiếp theo chung dài nhất cho V và Không rõ ràng, sau đó chúng ta có AVC và tranh thủ phần tiếp theo chung dài nhất của ABC và sau đó là bốn phần tiếp theo chung dài nhất.

3597
00:04:13,930 --> 00:04:45,790
ABCDE cũng dành cho quán Starbucks ở hàng này. OK, bây giờ chúng ta hãy điền giá trị cho cột này. Được rồi. Vì vậy, ở đây bạn có thú vị và a vì vậy độ dài của bốn thú vị tiếp theo dài nhất và là và bốn thú vị và được yêu cầu ân xá và HCB Jaroff cho thú vị và acbl Ejiro và thú vị và CBF Dero và cũng cho thú vị và ACBL 50 bằng không.

3598
00:04:45,910 --> 00:05:01,880
Được rồi, chúng ta điền vai trò đó và cột Juillet. Bây giờ hãy điền Vello cho phần còn lại của Vox. Bây giờ chúng ta thấy ở đây E và A và đó là sự trùng khớp. Vì vậy, điều kiện này sẽ chạy chéo mỗi cái và đó là một.

3599
00:05:01,900 --> 00:05:18,700
Vì vậy, ở đây nó phải là một. Sau đó chúng ta thấy chúng ta có A và B và đó không phải là sự trùng khớp. Vì vậy, chúng ta sẽ sao chép giá trị tối đa từ trên xuống hoặc bên trái. Vì vậy, trong trường hợp này, giá trị lớn nhất của 0 và 1 là giá trị mà chúng ta thấy A và C không khớp.

3600
00:05:18,880 --> 00:05:33,610
Vì vậy, Max Obdulio và một là một mà chúng ta thấy và đây không phải là một sự trùng khớp bằng 0 và một là một và không đối với hai cái này. Được rồi. Bây giờ chúng ta thấy ở đây và C không khớp.

3601
00:05:33,850 --> 00:05:47,340
Vậy max lên đỉnh này hoặc bên trái là 1 thì B và C không trùng nhau. Vì vậy, hãy tăng tối đa một và một là bật. Được rồi, I, C, C và C, đó là sự trùng khớp. Vậy giá trị đường chéo cộng một.

3602
00:05:47,350 --> 00:06:00,920
Vậy một cộng một là hai mà chúng ta thấy. DMC không phải là đối thủ trong cái lồng đó. Chúng tôi sẽ đạt được mức tối đa cho phía trên và bên trái. Vì vậy, trên cùng và để lại ở mức tối đa. Một và hai là hai.

3603
00:06:00,940 --> 00:06:11,770
Vì vậy, ở đây nó cũng phải là hai C và không khớp. Một số chấp nhận một và hai là để rồi ở đây chúng ta xem nếu và C không khớp nhau. Vì vậy, tối đa một và hai là hai.

3604
00:06:11,800 --> 00:06:25,330
Được rồi. Và B như vậy ta thấy và B không khớp. Vậy Max lên trên hoặc trái và có 1 thì ta thấy B và B trùng nhau. Vì vậy, giá trị đường chéo cộng một khi chúng ta có một cộng một thành hai thì C và B không khớp.

3605
00:06:25,390 --> 00:06:36,700
Vậy tối đa hai và hai là hai thì I, C, D và B không trùng nhau. Vậy Max của hai và hai là hai chúng ta thấy. Và B không khớp với max của hai và hai là hai, khi đó bạn có F và B.

3606
00:06:36,700 --> 00:06:47,770
Vậy đây không phải là sự so khớp Max của hai và hai là hai. Được rồi, ở đây chúng ta có E và đây không phải là một kết quả khớp. Vì vậy, năng lượng tối đa là một thì ECB và E không khớp.

3607
00:06:47,950 --> 00:06:58,360
Vì vậy, tối đa hai và một là hai, sau đó là C và nó không khớp. Tối đa hai mươi hai là hai. Chúng tôi thấy D và E không khớp với tối đa hai và hai là được.

3608
00:06:58,600 --> 00:07:18,370
Ở vị trí này chúng ta thấy và khớp. Vì vậy, giá trị đường chéo cộng với một và bằng ba thì nếu và không khớp. Một số chấp nhận hai và ba là ba. Bây giờ chúng tôi thấy nó và nếu nó không phải là một trận đấu để tăng tối đa và đồng euro là một, thì tôi thấy B và nếu nó không phải là một trận đấu, thì tối đa 21 là cho C và nó không phải là một trận đấu.

3609
00:07:18,370 --> 00:07:32,160
Tối đa hai mươi hai là hai. OK, trong trường hợp này, chúng ta thấy chúng ta có D và nếu vậy điều này không được đáp ứng nên Max của hai mươi hai là hai thì chúng ta thấy E và nếu không khớp Max của ba và hai là ba thì nếu và nếu là khớp.

3610
00:07:32,170 --> 00:07:46,120
Vậy chéo mỗi cái thành bốn ở đây là ta có nó. Và đây không phải là khớp để max trên số nguyên là một thì ta thấy xa hơn là không khớp với max của hai và một là hai thì bạn C và D không khớp.

3611
00:07:46,120 --> 00:08:02,170
Tối đa hai và hai là hai. Được rồi. Vì vậy, chúng tôi thấy kết thúc là một trận đấu. Vì vậy, chốt chéo vào hai. Sau đó chúng ta thấy và đây không phải là Mad Max của hai và ba là ba thì nếu và không phải là một kết quả phù hợp để tăng tối đa bốn và ba là bốn, phải không?

3612
00:08:02,170 --> 00:08:16,230
Và đây là câu trả lời của chúng tôi. Được rồi, chúng tôi có thể yêu cầu insta của bạn phản đối tòa án này để bạn trả lại sự mất giá trị. Được rồi, vì vậy nếu bạn sử dụng return ở đây thì bạn có thể xóa câu lệnh này và biến câu trả lời này.

3613
00:08:16,270 --> 00:08:29,880
Đừng lo lắng, bạn có thể sử dụng bất kỳ trong số họ. Vì vậy, chúng tôi đã tìm thấy câu trả lời. Đó là cách chúng ta có thể tìm được điểm chung dài nhất. Tiếp theo, chúng tôi tìm thấy ở đây độ dài mà chúng tôi có thể nhận được chuỗi con chung dài nhất từ ​​bảng lập trình động này.

3614
00:08:29,890 --> 00:08:40,050
Đầu tiên chúng ta thấy ở đây, bốn cái này xuất phát từ trên xuống. Khi bạn nhìn rõ nó, nó đang đến từ phía trên. Điều đó có nghĩa đây không phải là phần của chuỗi con chung dài nhất của chúng ta.

3615
00:08:40,090 --> 00:09:00,370
Vậy được rồi. Ở đây chúng ta thấy điều này vì nó đến từ cây này khi chúng ta nhận được một giá trị từ đường chéo, chuỗi chứa trong dãy con của chúng ta. Được rồi, chúng ta thấy cây này cũng đến từ đường chéo này bởi vì e này và đây cũng vậy trong trường hợp này, chữ E cũng nằm trong dãy con của chúng ta.

3616
00:09:00,370 --> 00:09:13,230
Được rồi, vậy chúng ta thấy hai cái này không đến từ đường chéo. Nó có thể là từ trái hoặc từ trên xuống. Vì vậy chúng ta hãy đi sang bên trái. Được rồi, chúng ta cũng thấy điều này rõ ràng là đến từ phía trên hoặc từ bên trái.

3617
00:09:13,420 --> 00:09:25,510
Vì vậy, vâng, chúng ta hãy đi đến đó. Được rồi. Và ở đây chúng ta cũng thấy điều này xuất phát từ đường chéo vì ký tự B và B giống nhau. Vậy ở đây có đường chéo, khi có đường chéo thì sẽ bao gồm miệng núi lửa đó.

3618
00:09:25,510 --> 00:09:39,030
Và có. Được rồi. Và ở đây chúng ta thấy hình ảnh này từ trên xuống. Phải. Và sau đó chúng ta thấy điều này. Nó đến từ đường chéo chéo sẽ có được một đó là cách chúng ta có thể có được SBF chung dài nhất tiếp theo.

3619
00:09:39,040 --> 00:09:50,340
Được rồi. Chúng ta thấy ở đây chúng ta có đoạn đường khác nhau nên có thể đi theo bất kỳ hướng nào. OK, tại nơi này, chúng ta đã kết thúc nhân vật. Thay vào đó, nếu chúng ta đi sang bên trái, nếu chúng ta đi lên trên cùng, hãy xem điều gì đã xảy ra.

3620
00:09:50,350 --> 00:10:00,500
Vì vậy, nếu chúng ta đi lên phía trên bên phải ở đây, chúng ta sẽ thấy khách du lịch này đến từ bên trái. Vì vậy, điều này cũng đến từ đường chéo vì nhân vật này, C.A.C. cùng một lúc.

3621
00:10:00,520 --> 00:10:12,580
Vì vậy, đây sẽ là câu trả lời của chúng tôi. Vì vậy, hãy thêm cái nhìn của bạn. Được rồi, chúng ta thấy ký tự này là một, và nó đến từ bên trái. Được rồi. Và chúng ta thấy cái này đến từ đường chéo.

3622
00:10:12,580 --> 00:10:24,520
Vì vậy, nó sẽ có trong câu trả lời của bạn. Vì vậy, trong trường hợp này, chúng ta nhận được FCF chung dài nhất tiếp theo. Vì vậy, chúng ta thấy ở học sinh, chúng ta có thể có chuỗi con dài nhất khác nhau, nhưng độ dài của một chuỗi con dài nhất là bốn.

3623
00:10:24,520 --> 00:10:36,040
Và ở đây chúng ta có thể có vài chuỗi con chung dài nhất mà chúng ta đã tìm kiếm. Được rồi, đó là cách chúng ta có thể giải quyết vấn đề này. Đây là trực giác cho vấn đề này và đó là cách chúng ta có thể giải quyết vấn đề này.

3624
00:10:36,040 --> 00:10:46,960
Sử dụng quy hoạch động theo cách tiếp cận từ dưới lên. OK, giải pháp này trong sách giáo khoa sẽ tăng phần tử thời gian, độ phức tạp hoặc hình ảnh, tuyến tính thứ đầu tiên và nó là phần cuối của chuỗi thứ hai.

3625
00:10:46,960 --> 00:10:57,700
Nó cũng chiếm không gian, độ phức tạp, lớn, nhằm mục đích xây dựng bảng lập trình động này hoặc hình ảnh của thứ đầu tiên và chuỗi thứ hai của khái niệm này là rõ ràng.

3626
00:10:57,970 --> 00:11:06,970
Nếu bạn có bất kỳ câu hỏi nào, nếu bạn có bất kỳ nghi ngờ nào về phần bổ sung trước đó, hãy cho tôi
biết. Cảm ơn đã xem video này. Tôi sẽ gặp bạn trong video tiếp theo. Telvin bảo trọng nhé. 

@@@



3627
00:00:00,910 --> 00:00:14,260
Chào mừng đến với video này. Trong video này chúng ta sẽ giải một câu hỏi phỏng vấn ghi âm, bạn có biết bài toán Navteq không? Đây là tuyên bố vấn đề. Bạn được tăng trọng lượng và giá trị trong các vật phẩm.

3628
00:00:14,590 --> 00:00:41,680
Hãy xếp những món đồ này vào hộp kiểm tra để có tổng giá trị lớn nhất trong ba lô. Được rồi. Nếu bạn được cung cấp bốn mục này với trọng lượng và giá trị và tổng cộng là bảy mục, thì bây giờ chúng ta phải chọn mục từ kích thước đã đặt này mà một số giá trị của chúng là tối đa và một số trọng lượng của chúng bằng hoặc nhỏ hơn tổng tỷ lệ.

3629
00:00:42,100 --> 00:01:03,100
Bây giờ, làm thế nào chúng ta có thể giải quyết vấn đề này để giải quyết vấn đề này, chúng ta sẽ sử dụng quy hoạch động. Được rồi, trước đó, điều này có nghĩa là gì? Bạn có muốn có nghĩa là bạn chọn đồ hoặc bạn không chọn đồ nhưng bạn có thể chia đồ, xác định là bạn không chọn đồ.

3630
00:01:03,250 --> 00:01:19,780
Một phút bạn chọn món hàng. Được rồi. Bây giờ, hãy để tôi cung cấp cho bạn trực giác bên trong về vấn đề này. OK, ở đây chúng ta có mã giả. Đầu tiên, bây giờ tôi sẽ khai báo một hàm lấy giá trị hợp lệ và tổng trọng số làm đầu vào.

3631
00:01:20,110 --> 00:01:33,130
Được rồi. Đối với phần thử nghiệm, chúng tôi phải sắp xếp thứ này cho tốt và cho nó. Và chúng tôi đang cho tổng trọng lượng bằng bảy. Được rồi, chúng ta sẽ xây dựng một bảng lập trình động.

3632
00:01:33,370 --> 00:01:45,730
Được rồi. Đây là bảng lập trình động của chúng tôi ở đây. Chúng tôi có cân nặng, sau đó bạn có cân nặng và ở đây chúng tôi có cân nặng từ 0 đến 7. Và đây là kích thước của một vật thể.

3633
00:01:46,030 --> 00:02:01,810
Chúng ta có thể lưu trữ bảy trọng lượng trong một vật thể. Vì vậy, ở đây chúng ta có từ 0 đến 7 và ở đây chúng ta có chỉ mục. Sau đó, chúng ta có hai vòng lặp này, lỗ hổng này lặp đi lặp lại từ hộp bắt đầu cho đến khi chạm tới hộp này.

3634
00:02:02,230 --> 00:02:13,200
Được rồi, vậy chúng ta có điều kiện này. Nếu tôi phải làm điều đó hoặc trang trí con quay hồi chuyển, thì chúng ta sẽ chỉ chèn số 0. Đầu tiên là chúng ta thích hàng này, được chứ?

3635
00:02:13,480 --> 00:02:26,920
Và trong này sẽ có giá trị bằng 0, vì nếu chúng ta có tổng trọng số trong Navteq bằng 0 thì nếu chúng ta có trọng số và giá trị bằng 0 thì chúng ta có thể chèn vào bên phải của bạn.

3636
00:02:27,040 --> 00:02:39,790
Nếu chúng ta có một tổng trọng lượng thì chúng ta có thể có giá trị bằng 0 ở đây bởi vì chúng ta có ở đây bạn biết điều đó hoặc bạn sẽ cảm thấy rằng khi đó chúng ta khó nắm bắt được tổng trọng lượng hiện tại.

3637
00:02:40,210 --> 00:02:52,800
Chúng ta hãy xem xét điều này và ba điều này. OK, khi rời khỏi ô này chúng ta thấy ở đây, điều kiện này đúng vì trọng lượng này nhỏ hơn hoặc bằng tổng trọng lượng trong trường hợp này.

3638
00:02:53,140 --> 00:03:10,660
Được rồi, vậy thì chúng ta phải thử nó. Người đầu tiên đã thử nó. Những gì chúng ta có thể làm tốt nhất bằng cách chọn trọng số này. Và lựa chọn thứ hai là những gì chúng ta có thể làm tốt nhất, chúng ta sẽ chọn ba điều này để những gì chúng ta đang làm ở đây, nếu không, chúng ta sẽ sao chép giá trị từ trên xuống.

3639
00:03:10,810 --> 00:03:25,240
Cuối cùng, chúng tôi sẽ trả về bất kỳ giá trị nào chúng tôi có ở vị trí này. Được rồi. Bây giờ chúng ta hãy xem chúng ta có thể cảm nhận bảng lập trình động này như thế nào nhé. Chúng ta sẽ sử dụng cách tiếp cận từ dưới lên để điền vào bảng lập trình động này.

3640
00:03:25,450 --> 00:03:39,340
Được rồi. Đầu tiên chúng ta có ở đây nó và ở đây cũng có trực tiếp và Villagra. Vì vậy, giá trị của tất cả các hộp dành cho việc này, Junod viết, sẽ là Dero. Được rồi, vậy bốn là sự lặp lại của cái này.

3641
00:03:39,340 --> 00:03:50,740
Tôi sẽ làm vậy nếu bạn yêu thích chuyên mục này. Phải. Để dễ hiểu tôi sẽ lấp đầy ngay bây giờ. Vì vậy ở đây cũng sẽ có số không. Nếu chúng ta phải đối phó với Obdulio thì chúng ta sẽ có mục số 0.

3642
00:03:50,740 --> 00:04:04,140
Vì vậy, chúng tôi có ở đây OK ở đây chúng tôi có cách toàn cảnh Saijo để làm như vậy sau đó chúng tôi không thể đặt thêm bất kỳ mục nào ở đây. Vì vậy giá trị sẽ bằng 0 ở đây. Được rồi. Bây giờ ở đây chúng ta thấy một đầu một.

3643
00:04:04,390 --> 00:04:17,440
Vậy là điều kiện này đã được đáp ứng nên chúng ta phải thử nó. Lựa chọn đầu tiên là vậy nên điều tôi có thể làm tốt nhất khi chọn cái nào. Phải? Vậy một cộng ở đây một là giá trị của cái tuyệt vời này.

3644
00:04:17,440 --> 00:04:32,190
Cộng với việc trừ đi cái này khỏi tổng trọng lượng, chúng ta còn lại bằng 0. Vì vậy, chúng tôi có Girot đứng đầu ở đây, chúng tôi có Yadu nên một Platero. Được rồi, lựa chọn thứ hai chúng ta có ở đây, chúng ta không chọn cái nào.

3645
00:04:32,380 --> 00:04:46,930
Vì vậy, chúng tôi đã chọn những gì chúng tôi có ở đây, số 0 ở trên cùng. Vì vậy, hãy ghép một đầu thành một. Vì vậy, ở đây chúng ta sẽ có một cái. Được rồi chúng ta có hai và một hai. Đừng chờ đợi là hai và điều này với mỗi một.

3646
00:04:47,140 --> 00:04:58,960
OK, ở đây chúng ta cũng phải thay đổi những gì chúng ta có thể làm tốt nhất ở đây bằng cách chọn một giá trị này. Chúng ta có một và bây giờ hãy trừ trọng lượng này khỏi tổng trọng lượng này.

3647
00:04:59,140 --> 00:05:11,860
Vì vậy, chúng tôi chỉ còn lại một. Vì vậy, tại một thời điểm chúng ta đã có một, Platero là một, và nếu chúng ta không chọn cái đó thì tốt nhất chúng ta có thể làm là số không. Vậy Max không và một là một.

3648
00:05:12,190 --> 00:05:30,100
Được rồi, vậy chúng ta có ba và một người có thể làm tốt nhất bằng cách chọn đúng, và đó là một cộng bằng cách trừ cái này khỏi cái này hoặc cái kia là hai. Vì vậy, ở đây chúng ta có 0 không cộng một và sau đó chúng ta bắt đầu chọn cái này, chúng ta có thể làm số 0 tốt nhất.

3649
00:05:30,310 --> 00:05:45,130
Vì vậy, trận đấu một là một. Được rồi, ở đây chúng ta có bốn và một. Vì vậy, điều kiện này được đáp ứng tốt nhất ở đây bằng cách chọn cái này và cái kia là một cộng bằng cách trừ từ này khỏi ba quân đội.

3650
00:05:45,430 --> 00:05:58,420
Vì vậy, trong ba, chúng tôi có bạn. Vì vậy, một là một và chúng tôi đang chọn cái này những gì chúng tôi có ở đây, hãy tăng tối đa một và có một. Được rồi, vậy chúng ta có năm và một.

3651
00:05:58,720 --> 00:06:12,910
Được rồi. Vì vậy, điều kiện này lại phù hợp thì những gì tôi có thể làm bằng cách chọn cái này đã là 1 trên 1 cộng với 5 phút là 4. Vì vậy, ở đây chúng ta có một cộng 0 và điều tốt nhất chúng ta có thể làm là chọn cái này bằng 0.

3652
00:06:13,210 --> 00:06:25,960
Vì vậy, hãy kết hợp và bạn là một. ĐƯỢC RỒI. Tương tự, giá trị của hai ô này sẽ là một. Được rồi, ở đây chúng ta có một và ba. Vì vậy tổng số nó nhỏ hơn trọng lượng này.

3653
00:06:26,620 --> 00:06:37,300
Nếu chúng ta có tổng trọng lượng sở hữu là một thì chúng ta không thể lưu trữ ba trọng lượng của chúng. Phải. Vậy điều kiện này là sai. Sau đó chúng ta sẽ sao chép nó từ trên xuống.

3654
00:06:37,540 --> 00:06:50,320
Được rồi, mọi chuyện sẽ tiếp tục từ đây. Được rồi. Sau đó chúng ta thấy hai và ba. Vì vậy, một lần nữa, chúng ta sẽ sao chép giá trị từ trên xuống. Được rồi. Bây giờ ta thấy ba và ba bằng thì điều kiện này là đúng.

3655
00:06:50,620 --> 00:07:01,380
Sau đó, điều chúng ta có thể làm tốt nhất bằng cách chọn số có ba, nghĩa là bây giờ chúng ta có giá trị cho ba là OK bằng cách trừ trọng số này khỏi tổng trọng lượng liên quan đến nó không có trọng số.

3656
00:07:01,570 --> 00:07:15,010
Vậy bạn có biết chúng tôi có gì ở đây không? Vì vậy, hỗ trợ cộng với số không. Và điều tôi có thể làm tốt nhất là chọn tám ba này và có một ẩn dụ và một là bốn và đây là cách nó hoạt động.

3657
00:07:15,220 --> 00:07:31,450
Được rồi, hãy chèn vào đây bây giờ chúng ta thấy 4 lớn hơn trọng lượng này. Vì vậy, ở đây chúng ta phải thử bằng cách chọn cả ba điều chúng ta có thể làm tốt nhất cho bludge sau đó liên hệ với nó ở đây một trọng số vì đối với phút thứ ba là một.

3658
00:07:31,570 --> 00:07:45,040
Vì vậy, ở đây chúng ta có một điểm hỗ trợ cộng một và đó là năm và chúng ta đang chọn tám điểm hỗ trợ này. Điều tốt nhất chúng ta có thể làm. Đó là một. Vậy tối đa bốn cộng một là năm, vậy tối đa năm và một là năm.

3659
00:07:45,400 --> 00:07:56,650
Sau đó chúng ta có ở đây năm và ba. Vì vậy, bằng cách chọn cái này với ba cái tốt nhất, chúng ta có thể tính giá trị ở đây là bốn và bằng cách trừ đi tám cái này từ tổng số là hai.

3660
00:07:56,860 --> 00:08:09,790
Vì vậy, đối với hai chúng tôi có một. Sau đó chúng ta sẽ chọn ba cái này. Điều tốt nhất chúng ta có thể làm. Đó là một. Vậy tối đa năm và một là một. Và đây là cách nó hoạt động. Vì vậy, hãy chèn vào đây năm.

3661
00:08:10,360 --> 00:08:24,270
Được rồi, bây giờ tổng cộng là sáu và ba. Nó lớn hơn trọng lượng này. Vậy điều kiện này đúng trong trường hợp này. Chúng ta phải thử trước bằng cách chọn ra ba điều tốt nhất chúng ta có thể làm cho Blatche.

3662
00:08:24,550 --> 00:08:35,320
Sáu trừ ba thì có ba hoặc bốn. Chúng tôi có một cái. Và bằng cách không chọn ba cái này, chúng ta có một. Vì vậy, tối đa năm và một là năm. Được rồi, vậy chúng tôi có bảy và ba của bạn.

3663
00:08:35,320 --> 00:08:44,710
Vậy điều kiện này một lần nữa đúng. Vậy thì chúng ta phải thử nó hoạt động tốt nhất bằng cách chọn cái này rồi. Ba tức là bốn và ba trừ bảy là bốn.

3664
00:08:44,730 --> 00:08:56,530
Vậy ở đây với bốn chúng ta có một cộng một bằng năm. Điều tốt nhất chúng ta có thể làm là chọn cái này với ba và cái kia là một. Vậy hãy ghép năm và một là năm. OK, bây giờ chúng ta thấy chúng ta có bốn và một.

3665
00:08:56,530 --> 00:09:08,400
Vì vậy, điều này sẽ chạy tình trạng sức khỏe này. Vì thế nó sẽ sao chép anh chàng này từ đây sang đây. Được rồi. Sau đó nó cũng sẽ sao chép cái này vào đây và cũng sẽ sao chép cái này từ đây sang đây.

3666
00:09:08,440 --> 00:09:23,500
Được rồi, bây giờ chúng ta thấy bốn và bốn. Đó là sự phù hợp. Vì vậy, điều tốt nhất chúng ta có thể làm bằng cách chọn cái này là 5 và chúng ta được dẫn đến nó bằng cách trừ 4 này từ 4 Ejiro này để 4 mà chúng ta có ở đây để làm 5 cộng 0.

3667
00:09:23,680 --> 00:09:32,890
Và điều tốt nhất chúng ta có thể làm với điều đó là gì. Lựa chọn quyền này. Bốn và đó cũng là năm. Vì vậy, năm và năm. Đó là năm và đây là cách nó hoạt động. Được rồi.

3668
00:09:32,890 --> 00:09:46,480
Vì vậy, nó được chèn ở đây năm. Được rồi, bây giờ chúng ta thấy năm và bốn. Điều kiện này là đúng. Vậy điều tốt nhất chúng ta có thể làm khi chọn cái này là gì? Có năm và sau đó bằng cách lấy năm này trừ đi cái này, chúng ta còn lại một hai.

3669
00:09:46,480 --> 00:09:57,880
Có một cái ở đây. Thêm vào đây một cái mà không chọn cái này. Những gì chúng ta có thể làm là năm. Vì vậy, tối đa là sáu và năm hoặc sáu. Hãy chèn sáu vào đây rồi chúng ta có bốn, sáu và bốn.

3670
00:09:58,000 --> 00:10:12,850
Được rồi. Vì vậy, trong trường hợp này. Bằng cách chọn giải thưởng này cho điều tốt nhất mà chúng tôi có thể làm, đó là năm cộng, sau đó trừ đi giải thưởng này từ sáu giải thưởng liên quan đến sự ủng hộ mà chúng tôi đã giành được cho đến nay, tôi chỉ cộng sáu và ở đây chúng tôi có năm.

3671
00:10:12,880 --> 00:10:28,960
Chúng tôi đang lựa chọn điều này tốt nhất chúng tôi có thể làm là năm. Vậy tối đa sáu và năm là sáu, bảy và bốn. Vậy điều kiện này là đúng. Sau đó, bạn phải thử xếp hạng đầu tiên bằng cách chọn cái này tốt nhất chúng ta có thể làm năm cộng trừ bốn này từ bảy, tức là ba.

3672
00:10:29,110 --> 00:10:41,070
Vì vậy, đã phát triển, chúng tôi có bốn ba, chúng tôi có bốn của bạn nên năm cộng bốn là chín và chúng tôi đang lựa chọn điều tốt nhất có thể làm. Đó là năm dấu chín và năm là chín để điền tên bạn vào.

3673
00:10:41,080 --> 00:10:52,270
Được rồi, bây giờ đối với hộp này chúng ta thấy tổng số này. Nó ít hơn trọng lượng này. Vì vậy, điều kiện này sẽ chạy. Vì vậy nó sẽ sao chép van từ trên xuống. Và ở đây điều kiện thứ tám này cũng đúng.

3674
00:10:52,480 --> 00:11:03,370
Vì vậy, hãy chèn vào đây một cái và nó cũng sẽ sao chép cái van này từ đây là bốn. Và nó cũng sẽ sao chép Rella năm này ở đây. Được rồi, bây giờ chúng ta có năm và năm.

3675
00:11:03,370 --> 00:11:15,400
Vì vậy, điều kiện này bây giờ là đúng. Rất vui được làm điều đó bằng cách chọn năm điều tốt nhất này, chúng ta có thể làm được bảy cộng năm trừ năm. Đó là vì vậy chúng tôi có autogyro bảy cộng không của bạn.

3676
00:11:15,760 --> 00:11:28,610
Chúng tôi đã làm vậy. Lựa chọn điều tốt nhất bạn có thể làm được là sáu. Vậy tối đa sáu và bảy là bảy. Sau đó chúng tôi có tổng số của bạn là sáu và tám năm. Vì vậy, bằng cách chọn cái này tốt nhất chúng ta có thể tính được bảy cộng hãy trừ năm này cho sáu.

3677
00:11:28,610 --> 00:11:37,900
Vì vậy, chúng tôi có một. Vậy bảy cộng một là tám và tốt nhất chúng ta có thể làm điều đó mà không cần chọn cái này. Chúng tôi có năm, tức là sáu tối đa là tám và sáu là tám. Ngay lập tức.

3678
00:11:37,930 --> 00:11:52,810
Chúng ta đang ở vị trí cuối cùng ở đây. Chúng ta sẽ có câu trả lời của mình. Được rồi, bây giờ chúng ta hãy tính toán nó. Chúng tôi có bảy và năm của bạn. Vậy điều kiện này đúng ở đây. Chúng ta phải chọn lại lần nữa ngay từ đầu là chúng ta chọn cái này ở mức tốt nhất là năm, chúng ta có thể làm được bảy cộng.

3679
00:11:52,900 --> 00:12:04,980
Bây giờ hãy trừ cuộc chiến này khỏi bảy. Đó là sự thật. Vậy tổng cộng chúng ta có một bốn hai. Được rồi, vậy ở đây chúng ta có bảy cộng một tức là tám và chúng ta đang chọn cái này bằng năm.

3680
00:12:04,990 --> 00:12:20,530
Điều tốt nhất chúng ta có thể làm là chín giờ. Vậy tối đa tám và chín là chín. OK, vậy ở đây câu trả lời của chúng ta sẽ là số 9 này và nó sẽ trả về số 9. Được rồi, đó là cách chúng ta có thể giải quyết vấn đề này bây giờ, cách chúng ta có thể tìm thấy các vật phẩm thực tế bằng cách đó.

3681
00:12:20,530 --> 00:12:32,770
Chúng tôi nhận được câu trả lời này ngay bây giờ. Hãy cùng tìm hiểu. Đầu tiên chúng ta thấy số chín này đang đến từ trên xuống. Khi chúng tôi thấy Avello đến từ trên cùng, điều đó có nghĩa là mục đó không có trong danh sách câu trả lời của chúng tôi.

3682
00:12:32,890 --> 00:12:46,120
Bây giờ chúng ta thấy số chín này không đến từ phía trên. Vì vậy, nó sẽ có trong danh sách câu trả lời của chúng tôi. Vì vậy, ở đây, chờ đã, và năm là giá trị. Được rồi, bây giờ trừ 4 cho 7, chúng ta được 3.

3683
00:12:46,270 --> 00:13:00,880
Phải. Vì vậy, đối với Aparo, một, hai, ba và đây là bốn. Và chúng tôi thấy điều này không đến từ phía trên. Vì vậy, điều này được bao gồm trong danh sách câu trả lời của chúng tôi. Vậy tám, ba và bốn, chúng ta thấy rõ rằng bốn này không đến từ trên xuống.

3684
00:13:00,880 --> 00:13:15,320
Được rồi, bây giờ, bằng cách tách câu chuyện ra khỏi tổng trọng lượng, chúng ta nhận được số 0. Vì vậy, đối với đồng euro, với tỷ giá này, chúng ta có con số 0. Phải. Vì vậy, đối với mục này, chúng ta không có mục nào được chọn vì ở đây chúng ta phải xử lý số 0.

3685
00:13:15,430 --> 00:13:28,240
Vì vậy, cuối cùng chúng ta có được hai mục này với bốn và năm và ba và phát triển thành bốn. Và chúng ta thấy rằng tổng giá trị của chúng là lớn nhất khi chúng ta có tổng trọng lượng.

3686
00:13:28,240 --> 00:13:48,310
Việc quan sát giải pháp đều tốn thời gian, độ phức tạp hoặc do độ dài của mảng giá trị và bất kỳ lệnh gọi nào đến trọng số tối đa. Việc xây dựng bảng lập trình động này cũng cần độ phức tạp về không gian vì để tìm hiểu về mảng giá trị và bất kỳ giá trị nào cần thoát, khái niệm này rất rõ ràng.

3687
00:13:48,340 --> 00:13:57,370
Nếu bạn có bất kỳ câu hỏi nào, nếu bạn có bất kỳ nghi ngờ nào về việc bổ sung cường điệu, hãy cho tôi
biết. Cảm ơn đã xem video này. Tôi sẽ gặp bạn trong video tiếp theo. Telvin bảo trọng nhé. 

@@@



3688
00:00:00,900 --> 00:00:16,350
Trong video này, tôi sẽ nói về một cuộc phỏng vấn hài hước, sự thận trọng, một biểu hiện thông thường, Marsing. Đây là tuyên bố vấn đề. Cho một đầu vào, xâu chuỗi nó và mẫu p triển khai một biểu thức chính quy.

3689
00:00:16,350 --> 00:00:46,400
Việc nói sẽ hỗ trợ dấu chấm và dấu hoa thị ở đây. Dấu chấm có nghĩa là. Thông báo, bất kỳ dấu hoa thị ký tự đơn nào có nghĩa là Masset bằng 0 hoặc nhiều ký tự trước đó, có nghĩa là khối lượng hoặc nhiều ký tự mà bạn có trước dấu hoa thị, dấu hoa thị phải bao phủ toàn bộ chuỗi đầu vào, không được để trống và chứa một phần chuỗi.

3690
00:00:46,430 --> 00:00:59,780
Chỉ có nhân vật Lorqess có tuổi PKP trống và chỉ chứa nhân vật Lorqess cho đến máy bay phản lực và các nhân vật như Dort hoặc Asterisk. Bây giờ chúng ta hãy xem xét một số ví dụ.

3691
00:01:00,620 --> 00:01:12,710
Chúng tôi đã thấy điều này đúng. Thông báo của Dortmund và một dấu hoa thị có ký tự đơn có nghĩa là một hoặc nhiều ký tự mà chúng tôi có trước mẫu ở đây.

3692
00:01:12,710 --> 00:01:33,800
Chúng ta có parathion ở bên trái và chuỗi bên phải và bốn mẫu trong thông báo của nó. Chỉ có chuỗi A và nó không khớp với A, A, B hoặc A và bốn chuỗi phải là Masset ACB, A, B, B, AXP.

3693
00:01:33,860 --> 00:02:08,450
Nhưng nó không khớp. Nó sẽ là a, b, y, b. Trận đấu này diễn ra thế nào đây. Nó có nghĩa là bất kỳ ký tự đơn nào chúng ta có ở giữa A và B vì vậy chúng ta có thể có bất kỳ ký tự đơn nào ở giữa A và B ở đây chúng ta thấy ở giữa A và B ở đây chúng ta đã bị đánh bại và B và ở đây chúng ta có X ở giữa A và B , vậy ba chuỗi này bây giờ tôi đặt mẫu cho mẫu này.

3694
00:02:08,590 --> 00:02:29,000
Dấu hoa thị B, có thể là a b a b a it b nhưng không khớp với a, r, b hoặc HDB. Cách thức hoạt động, dấu hoa thị có nghĩa là thông báo hoặc nhiều ký tự trước đó.

3695
00:02:29,860 --> 00:02:41,980
Chúng ta có nhân vật đi trước ở đây thì đúng khi nói rằng ở đây Messaggero hoặc nhiều hơn nhân vật này. Vậy ở đây chúng ta có B, ở đây bạn thấy nó xuất hiện ở những thời điểm khác nhau.

3696
00:02:42,010 --> 00:03:01,620
Vì vậy, nó là sự thật. Khi đó ta có A, B và B xuất hiện trở lên. Ở đây chúng ta thấy nó xuất hiện một lần. Vì vậy, nó là sự thật. Và đối với các huyện thì nó xuất hiện. Vì vậy, nó cũng xuất hiện bốn lần đối với chuỗi.

3697
00:03:01,720 --> 00:03:20,480
Như vậy cũng đúng, nhưng có bốn điều khác biệt. Mẫu này không khớp. Sau đó, chúng tôi có dấu chấm dấu hoa thị của bạn, dấu chấm dấu hoa thị phù hợp. Tất cả đều ổn. Mỗi chuỗi ở đây chúng ta có A, B, B, B, B, DCG, bất cứ thứ gì.

3698
00:03:20,830 --> 00:03:35,010
Bây giờ chúng ta phải kết hợp mọi thứ để xem nó hoạt động như thế nào. Chúng tôi biết rằng DOT có nghĩa là bất kỳ K đơn nào để viết và dấu hoa thị có nghĩa là không hoặc nhiều ký tự trước đó.

3699
00:03:35,020 --> 00:04:01,060
Ở đây chúng ta có dấu chấm vị ngữ nên dấu chấm có nghĩa là bất kỳ ký tự đơn và dấu chấm nào cũng có thể có thời gian khác nhau hoặc nhiều thời gian hơn. Ở đây chúng ta có dấu chấm dấu hoa thị và đối với sự kiện này và để trở thành sự kiện chúng ta phải dấu chấm vì nó có thể bằng 0 lần hoặc nhiều lần hơn bất cứ khi nào chúng ta nhìn thấy dấu hoa thị sau khi trời tối.

3700
00:04:01,240 --> 00:04:20,320
Bây giờ, cái này không khớp với dấu đầu tiên và các dấu chấm này khớp với B này, vì vậy nó là Emet B, vậy ở đây dấu chấm đầu tiên này khớp với B và dấu chấm thứ hai khớp với A và dấu chấm mint và một ký tự đơn.

3701
00:04:20,620 --> 00:04:45,930
Được rồi. Và chúng ta lấy ở đây sáu dấu chấm cho chuỗi này meby ddc và ý nghĩ đầu tiên có thể là dấu chấm thứ hai, có thể là một chút dấu chấm khớp với phép toán dấu chấm thứ tư này những người này dấu chấm khớp với phép toán dấu chấm C và sáu dấu chấm này trong năm nay.

3702
00:04:46,120 --> 00:05:13,780
Vì vậy, nó là một trận đấu. Phải. Thành thật mà nói chấm sau đó tất cả mọi thứ. Và đây là cách nó hoạt động. Phải. Và ở đây nhìn thấy dấu hoa thị. Dấu hoa thị có thể khớp với c.b vì lần xuất hiện thứ hai là số lần chúng có thể xuất hiện nhiều hơn do thời gian ở đây c c xuất hiện một lần và nó xuất hiện trong các khoảng thời gian.

3703
00:05:14,140 --> 00:05:46,900
Và để có mặt ở đây chúng ta đã đạt được mục tiêu cuối cùng. Vì vậy, nó khớp B cho chuỗi C và nó xuất hiện nhiều lần và ở đây C, A, B, C và nó xuất hiện một lần và đối với chuỗi này CIPA thẳng đứng và chúng ta phải có B ở cuối và nó khớp nhưng nó không khớp vì lẽ ra cuối cùng chúng ta phải là A, B, B nên nó không khớp.

3704
00:05:47,620 --> 00:06:05,360
Chúng ta phải có B ở cuối và ở đây chúng ta có A đúng. Nhưng đây không phải là một trận đấu vì bạn có B, C, X Ebbie ở đây. Nó thiếu chữ C ở cuối. Chúng ta có B nhưng ở giữa C và chúng ta có X và A.

3705
00:06:05,650 --> 00:06:26,820
Vì vậy, đây là Anne-Mette và trong tám dấu sao cuối cùng B dấu hoa thị y ở đây chúng ta có B hoặc là Emet Y ở đây trong chuỗi nó xuất hiện kiểu gen và B xuất hiện một lần và dấu chấm dấu hoa thị có nghĩa là có nhiều lần hoặc nhiều lần bắt cóc.

3706
00:06:26,980 --> 00:06:40,030
Vì vậy, trong trường hợp này 0 lần dấu chấm không có nghĩa gì cả. Cho nên nó gặp a b tại sao ở đây. Xuất hiện một lần thì ta có B không có cách và dấu hoa thị như các bạn đã biết dấu hoa thị chấm.

3707
00:06:40,300 --> 00:06:59,440
Nó có thể phù hợp với mọi thứ hoặc không có gì. Sau đó, chúng tôi có nó theo cách nó có vẻ như vậy. Sau đó, chúng tôi có nó ở đây. Chúng tôi có nó. Điều này chưa được đáp ứng vì chúng ta phải có B và hoặc ở cuối và cả B và cả cái này cho trận đấu.

3708
00:07:00,030 --> 00:07:16,360
Được rồi. Bây giờ, tôi nghĩ bạn đã hiểu trận đấu này diễn ra như thế nào. Được rồi. Bây giờ, đúng rồi. Hàm là kết quả khớp được gạch dưới, lấy một chuỗi và một mẫu làm đầu vào và hàm này sẽ trả về.

3709
00:07:16,360 --> 00:07:28,420
ĐÚNG VẬY. Hoặc nếu mẫu khớp với chuỗi thì hàm này sẽ trả về true. Nếu mẫu không khớp với chuỗi thì nó sẽ trả về sai.

3710
00:07:29,080 --> 00:07:53,050
Các lệnh gọi hàm này sẽ trả về true vì mẫu đã tạo khối cho chuỗi. Vì vậy, nó sẽ trở lại chức năng này. Các cuộc gọi sẽ trở về tự động vì mẫu này thông báo chuỗi và đối với lệnh gọi hàm này, chúng ta sẽ gặp lỗi mẫu vì mẫu này không khớp với chuỗi.

3711
00:07:53,290 --> 00:08:07,000
Được rồi. Bây giờ tôi sẽ giải quyết vấn đề này bằng lập trình động. Đây là cách giải pháp của tôi có thể trông như thế nào. Đầu tiên tôi sẽ khai báo một hàm là dấu gạch dưới, khớp văn bản, chuỗi và mẫu.

3712
00:08:07,420 --> 00:08:27,460
Sau đó chúng ta sẽ xây dựng một bảng lập trình động. Và ở đây chúng ta có Daudt Land cộng một và đất than bùn cộng một. Nếu chúng ta coi idot vì đây có thể là một mẫu và x y là chuỗi, thì bảng lập trình nhị phân sẽ trông như thế này.

3713
00:08:27,730 --> 00:08:44,190
OK, đây là bàn của chúng ta. Bây giờ ở đây chúng ta có chuỗi trống và ở đây chúng ta có chỗ ngồi trống bên phải. Mô hình trống rỗng và ngành công nghiệp là một sự kết hợp. Vì vậy, chúng tôi sẽ đặt T t của bạn theo mặc định khi bạn tạo.

3714
00:08:44,430 --> 00:09:00,930
Đối với khu vực này, chúng tôi có giá trị cho tất cả các lỗi trong hộp và tất cả đều biểu thị nếu là lỗi. Được rồi, và ở đây chúng tôi có hồ sơ phả hệ để ghi lại mọi thứ và mọi thứ đều trùng khớp.

3715
00:09:01,240 --> 00:09:18,840
Sau đó chúng ta sẽ lấy nó và thú vị. Vì vậy, và mọi thứ không được đáp ứng. Vì vậy, ở đây đặt F thì idot và chuỗi rỗng và idot và bí ẩn không khớp.

3716
00:09:18,990 --> 00:09:35,200
Vì vậy, ở đây chúng ta cũng sẽ chèn EBP, sau đó chúng ta sẽ chạy một vòng lặp và vòng lặp mà chúng ta chỉ sử dụng cho loại mẫu này. Chúng tôi có điều này dành cho, nếu chỉ dành cho các mẫu có thể gặp chuỗi trống.

3717
00:09:35,760 --> 00:09:47,760
Vì vậy, khi chúng tôi gặp Asterisk, chúng tôi sẽ kiểm tra xem trong trường hợp dự phòng này ở đây để tôi không muốn mở cửa cho vay. Và đây là chiều dài của cột, phải không.

3718
00:09:48,180 --> 00:10:06,840
Một, hai, ba, bốn, năm và năm. Vì vậy, nó sẽ chạy từ một đến bốn nếu tôi không thể. Một bằng hai dấu hoa thị cho lần lặp đầu tiên. Nó trỏ đến tỷ lệ lỗi chứ không phải dấu hoa thị và ở lần lặp thứ hai, nó sẽ trỏ tới dấu chấm.

3719
00:10:06,990 --> 00:10:20,150
Vì vậy dấu chấm không phải là dấu hoa thị, khi đó nó sẽ trỏ đến ba và ở đây ba trừ một bằng hai. Vì vậy, bạn không muốn. Và ở đây chúng ta thấy dấu hoa thị ngay lúc đó.

3720
00:10:20,160 --> 00:10:42,760
Điều kiện này đúng ở đây. T I t thì ra là thế này. Đây là quy tắc và tôi trích dẫn cả hai trong mạch. Vậy không, một, hai, ba. Và ở đây nó sẽ sao chép bất cứ thứ gì chúng ta có ở đây và đó là nếu và 0 T trừ hai một.

3721
00:10:43,200 --> 00:10:58,540
Đây là Ruggiero và T trừ hai một không một. Vì vậy, đó là nó. Thế là nó chép F qua đây rồi nó không có dấu hoa thị B và thú vị. Và đó không phải là một trận đấu.

3722
00:10:58,800 --> 00:11:26,680
Vì vậy ở đây sẽ có nếu OK. Và đối với cột này, chúng ta sẽ có nếu ở đây, nếu ở đây, nếu tất cả điều này diễn ra vì trong mẫu và nó sẽ không khớp. Vì vậy, đây là mẫu trống sai và nó sẽ không khớp với mẫu và nó sẽ không khớp với mẫu và X, Y, B sẽ không khớp.

3723
00:11:26,850 --> 00:11:43,680
Vì vậy, tất cả các lỗi bây giờ sẽ điền giá trị cho phần còn lại của hộp. Được rồi, chúng ta sẽ chạy Aluf vì tôi muốn trừ một và đây là điểm cuối của con đường.

3724
00:11:43,830 --> 00:12:01,190
Phải. Một, hai, ba, bốn. Và ở đây chúng ta đã để lại một, hai, ba, bốn, năm, trừ một cho phần này. Followill sẽ chạy từ một đến bốn. Sau đó chúng ta có một Frolov khác vì tôi muốn t trừ một.

3725
00:12:01,620 --> 00:12:21,110
Và đây là độ dài các cột của chúng ta và đó cũng là năm và năm phút trên bốn. Vì vậy, vòng lặp này cũng sẽ chạy từ một đến bốn. Được rồi, và điều này sẽ lặp đi lặp lại cho đến khi chúng ta đến hộp này.

3726
00:12:21,600 --> 00:12:42,030
Bây giờ hãy xem cách chúng ta có thể tính toán. Bây giờ hãy xem cách chúng ta có thể tính giá trị cho các hộp còn lại. Đầu tiên tôi bằng một và bằng một. Được rồi, vậy ở đây chúng ta có hạnh phúc một trừ một bằng 0 và tại 0 chúng ta không có Daudt.

3727
00:12:42,360 --> 00:12:57,570
Vậy điều này sai thì p Geminid kết thúc và một trừ trên 0. Vì vậy, nó chỉ vào nó. Và đây này, ý tôi là mỗi cái tôi đi tới một cái. Đúng, vậy nó bằng 0 và nó khớp.

3728
00:12:57,570 --> 00:13:12,660
Phải. Vì vậy, nếu chúng ta có một trận đấu giữa tám và thì chúng ta có E và A như thế này. Và đây là một mẫu và đây chỉ là một chuỗi. Vì vậy, chúng tôi thấy chúng tôi có sự trùng khớp ở đây và vì vậy chúng tôi có thể loại bỏ cả hai.

3729
00:13:12,810 --> 00:13:24,360
Sau đó chúng ta sẽ có chuỗi trống. Phải. Sau đó, chúng tôi sẽ sao chép những gì chúng tôi thấy thú vị so với chuỗi trống. Và ở đây chúng ta có chữ T và chúng ta sẽ sao chép con phố ngay ở đây.

3730
00:13:24,540 --> 00:13:37,320
Được rồi. Và đây là công thức chính xác để sao chép giá trị này từ đây sang đây. Vậy thì chúng ta đã đúng. Và đối với lần lặp tiếp theo được phát triển, sẽ có hai và bạn tập trung vào một và mỗi cái này.

3731
00:13:37,320 --> 00:13:55,970
Phải. Và trực tiếp một. Và đó là bằng để làm điều đó. Vậy điều kiện này đúng. Tất cả đều đi đến dòng này, T.J., Vậy hãy chuyển sang dòng này, và bạn không muốn nghe đi nghe lại giá trị mà chúng ta sẽ có nếu đúng và ở đây giá trị sẽ có nếu.

3732
00:13:56,270 --> 00:14:10,990
Bây giờ, hãy để tôi làm rõ điều này, nó thực sự hoạt động như thế nào. Được rồi, nó và đúng. Và điều này không phù hợp với nó. Vì vậy, chúng ta có thể loại bỏ dấu chấm này. Và đây là lúc chúng ta có E và ngành.

3733
00:14:11,240 --> 00:14:26,030
Vì vậy, ANTM đang kiểm tra mọi thứ chúng tôi có ở đây. Nếu vậy, chúng tôi vừa sao chép nó ngay tại đây. Được rồi, đối với lần lặp tiếp theo, giá trị từ hai đến ba và giá trị này không khớp và giá trị này không khớp.

3734
00:14:26,060 --> 00:14:38,480
Được rồi, vậy hãy chuyển sang phần Eltis này. Ở đây chúng ta có B trừ một và đó là T trừ một bằng hai và có dấu hoa thị. Vậy điều kiện này là đúng.

3735
00:14:39,020 --> 00:14:50,600
Điều kiện này đúng ở đây. Làm thế nào chúng ta có thể tính toán giá trị cho điều này ở đây. Chúng ta có thể nhận được giá trị, bất kỳ giá trị nào chúng ta có ngay tại đây t và chúng ta có thể sao chép giá trị đó ở đây.

3736
00:14:50,990 --> 00:15:04,940
Và đây là công thức chính xác để sao chép giá trị từ đây. Và hãy để tôi làm rõ điều này thực sự hoạt động như thế nào. Ở đây chúng ta có dấu chấm và ở đây chúng ta có chữ không không có dấu hoa thị.

3737
00:15:05,000 --> 00:15:18,600
OK, vậy ở đây nếu dấu chấm này là dấu hoa thị và có thể xuất hiện kép nên chúng ta có thể xóa nó, sau đó bất kỳ giá trị nào chúng ta có cho mục nhập ở đây cho mục nhập, chúng ta có t để có thể sao chép nó từ đây sang đây.

3738
00:15:18,620 --> 00:15:31,400
Được rồi. Nếu chúng ta có trừ hai bằng dấu chấm. Được rồi, vậy ở đây chúng ta đang trừ hai và ở đây chúng ta có ba trừ ba mã thành một. Phải. Một cho Peaden, một cho chúng tôi có dấu chấm.

3739
00:15:31,400 --> 00:15:47,540
Phải. Và điều kiện này là đúng. Vì điều kiện này đúng nên tòa án này sẽ viết, điều này sẽ được ghi đè ngay tại đây, chúng ta có hoặc bất cứ thứ gì chúng ta có, chúng ta có T và sau đó chúng ta có LTI trừ một.

3740
00:15:47,540 --> 00:16:00,980
Vì vậy, nó sẽ tắt và sẽ chỉ sao chép bất kỳ giá trị nào chúng ta có ở đây. Vậy t đúng hay sai và điều đó tương đương với đúng. Vì vậy, bây giờ chúng ta có hai cái cho lần lặp tiếp theo.

3741
00:16:01,310 --> 00:16:17,860
Giá trị sẽ là bốn. Phải. Đối với Jagels đến bốn điều này bằng và đây là những gì. Vì vậy nó sẽ trực tiếp chèn sai vào đây. Bây giờ, ở lần lặp tiếp theo của tệp này, giá trị của I sẽ là hai, khi đó nó sẽ trỏ đến hàng này.

3742
00:16:17,930 --> 00:16:36,890
OK, và rồi bất cứ khi nào chúng ta gặp khó khăn. Được rồi, vậy ở đây chúng ta thấy nó và x và đây không phải là một kết quả khớp. Nếu đây không phải là một kết quả phù hợp thì chúng ta sẽ có trực tiếp sai ở đây và trực tiếp ở đây nếu và phần này sẽ chạy cho điều đó.

3743
00:16:36,890 --> 00:16:50,780
Chúng ta có giá trị f này ở đây và sau đó đối với lần lặp tiếp theo của J, chúng ta có Dorte và X. Vì vậy, đây là một kết quả khớp và T tôi biết điều đó. Tính giá trị của hộp này.

3744
00:16:51,020 --> 00:17:05,560
OK, sắp có dầu rồi nên nó sẽ tắt. Vì vậy, nó sẽ tắt và yêu cầu một và nó sẽ chuyển sang hai. Vì vậy, nó phải là một không một. Bất cứ giá trị nào chúng tôi có ở đây, chúng tôi có nó.

3745
00:17:05,810 --> 00:17:24,530
Bây giờ hãy để tôi làm rõ cách thức này thực sự hoạt động. Chúng ta có hoa văn và dấu chấm, phải không? Và chúng ta có chuỗi E và X và ở đây Dot và X khớp nhau. Phải. Vì vậy, chúng tôi chỉ có thể loại bỏ điều này vì không tạo bất kỳ ký tự đơn lẻ nào và chúng tôi sẽ kết thúc.

3746
00:17:25,220 --> 00:17:38,330
Vì vậy, cuối cùng chúng ta có t để có thể sao chép bất kỳ giá trị nào chúng ta có trong hộp này. Vậy là chúng tôi đã có chìa khóa của bạn. Vì vậy chúng tôi đã sao chép Hirte. Được rồi. Và đối với lần lặp J tiếp theo, chúng ta có dấu hoa thị ở đây.

3747
00:17:38,330 --> 00:17:52,190
Phải. Và Asterisk và X đây nó đến dòng này đây. Bất cứ khi nào chúng tôi đặt điều kiện này thì bạn thực hiện, nó sẽ vẫn ở trên cùng một dòng và nó sẽ quay trở lại âm ba.

3748
00:17:52,190 --> 00:18:05,230
Vì vậy, một không một. Vì vậy, nó sẽ sao chép bất kỳ giá trị nào chúng ta có ở vị trí này. F Vì vậy, nếu bây giờ nhìn thấy điều này, điều kiện này là đúng, chúng ta có độ nguyên hai có nghĩa là trừ đi một.

3749
00:18:05,270 --> 00:18:26,610
Bạn có biết chi phí để làm những gì chúng tôi có ở đây không thì tình trạng này sẽ diễn ra. Phải. Vì vậy, chúng tôi đã có lỗi ở đây, nó sẽ tắt và sau đó chúng tôi trừ một nên nó tắt và Jaycox thành ba một, hai, ba rồi sai hoặc hai bằng hai.

3750
00:18:26,740 --> 00:18:38,540
ĐÚNG VẬY. Vì vậy, ở đây giá trị này phải đúng. Bây giờ đối với lần lặp tiếp theo của G thì chúng ta có V và X và đây không phải là kết quả khớp. Vì vậy, ở đây chúng ta nên có lỗi. Được rồi.

3751
00:18:38,660 --> 00:18:54,930
Vậy đối với lần lặp tiếp theo của I, nó, nó trỏ tới cái này và. Chỉ cần một điểm nhỏ ở đây, để ở đây chúng ta thấy rằng đó không phải là sự trùng khớp. Vì vậy, ở đây chúng ta có nếu vậy thì lần lặp tiếp theo chúng ta có phải làm điều đó ở đây không?

3752
00:18:54,930 --> 00:19:08,890
Ngay tại đây. Nhưng sau đó chúng ta cần sao chép bất kỳ giá trị nào chúng ta có. Vì vậy, hãy tính số đó ở mức âm một. Vậy đây là ba trừ hai. Vì vậy, nó tăng lên rồi trừ đi một.

3753
00:19:09,140 --> 00:19:23,300
Vì vậy, để quản lý một và ở đây không một trong 12 cái mà chúng ta có ở đây, nó chỉ sao chép ở đây cách nó thực sự hoạt động. Bây giờ hãy để tôi làm rõ nó. Chúng tôi có phần chèn và giải thích của bạn để nó có thể khớp.

3754
00:19:23,310 --> 00:19:34,030
Tại sao không nhận được kết quả trùng khớp để chúng tôi có thể xóa nó và sau đó chúng tôi cần khớp nó và X và bốn và X chúng tôi có của bạn. Nếu vậy, chúng ta có thể sao chép nó ngay tại đây.

3755
00:19:34,040 --> 00:19:47,030
Và đối với lần lặp tiếp theo của J, chúng tôi có dấu hoa thị của bạn. Và dấu hoa thị và sau đó chúng ta phải quay lại đây. Chúng tôi có bốn. Phải. Vì vậy, nó sẽ sao chép. Chỉ cảm thấy ở đây thôi, trừ hai.

3756
00:19:47,480 --> 00:20:12,840
Và đó là P một. Và đó là Chấm. Đây là Chấm. Sau đó chúng ta sẽ đi và nhận được giá trị. Dù chúng ta có giá trị gì ở đây, chúng ta vẫn chưa thấy ở đây. Giá trị phải là T vì nếu t, false hoặc true của chúng tôi bằng true cho lần lặp tiếp theo của git, thì chúng tôi có giá trị cho và nó sẽ trỏ vào đây và B và tại sao không khớp.

3757
00:20:12,860 --> 00:20:27,990
Vì vậy, ở đây chúng ta sẽ có nếu đối với lần lặp tiếp theo của AI và lần lặp tiếp theo, giá trị của X sẽ trỏ đến Lastra này. Vì vậy, đây là điểm đến hộp này và ở đây A và B không khớp.

3758
00:20:28,010 --> 00:20:41,450
Vì vậy, ở đây chúng ta có thể có trực tiếp F sau đó chúng ta có dấu chấm và B của bạn nên đây là một kết quả khớp. Vì vậy, hãy đi đến AF ở đây và ở đây. Chúng ta chỉ cần sao chép tệp . Sau đó, bạn có dấu hoa thị của bạn.

3759
00:20:41,450 --> 00:20:59,710
Phải. Nếu chúng tôi có dấu hoa thị của bạn thì chúng tôi sẽ quay lại đây và ở đây chúng tôi có nếu chỉ cần sao chép nó sang đây. Vì giá trị của trừ hai bằng DOT, vì giá trị này bằng DOT, nên nó sẽ sao chép giá trị.

3760
00:20:59,730 --> 00:21:14,350
Bất cứ thứ gì chúng ta có ở trên cùng ở đây thì nó sẽ sao chép t ngay ở đây. Bây giờ hãy để tôi làm rõ rằng điều này thực sự hoạt động như thế nào. Vì vậy, chúng tôi có dấu chấm dấu hoa thị của bạn và ở đây chúng tôi có X, Y, B, vì vậy đây là dấu chấm dấu hoa thị.

3761
00:21:14,660 --> 00:21:28,430
Vì vậy, nó khớp với B nên chúng ta có thể loại bỏ B khỏi phần của nó, khi đó chúng ta có X, Y và dấu hoa thị chấm. Vì vậy, để thêm dấu hoa thị và cho X, Y, chúng tôi đã phát triển.

3762
00:21:28,430 --> 00:21:39,780
Vậy chúng ta có thể sao chép nó ngay ở đây. Thật đơn giản làm sao khi ở lần lặp tiếp theo, B và B nặng hơn bằng nhau. Vì vậy phần này sẽ chạy nên nó sẽ chỉ sao chép bất kỳ giá trị nào chúng ta có ở đây.

3763
00:21:39,800 --> 00:21:52,700
Vì vậy, ở đây chúng ta phải có T và cuối cùng chúng ta sẽ quay lại là dấu chấm đất và đó là bốn và đó là bốn. Vậy là bốn và bốn. Vì vậy, giá trị này vì bạn có hai ở đây, dường như phải ở đây.

3764
00:21:52,970 --> 00:22:11,720
Điều đó có nghĩa là mẫu này khớp với các chuỗi và giải pháp này yêu cầu tốc độ, độ phức tạp lớn hơn tính bằng M hoặc là độ dài của chuỗi và phần giữa và một mẫu để xây dựng bảng lập trình động này và độ phức tạp về thời gian cho giải pháp.

3765
00:22:11,720 --> 00:22:23,060
Ở Imahara, nó lớn hơn ở độ dài của sợi dây và M là chiều dài của chiếc hộp cứng có hoa văn. Tôi nghĩ bạn có sự hiểu biết rõ ràng về vấn đề này.

3766
00:22:23,300 --> 00:22:34,620
Biểu thức chính quy, macing. Nếu bạn có bất kỳ nghi ngờ nào, nếu bạn có bất kỳ câu hỏi nào, hãy cho tôi biết. Tôi
sẽ rất vui khi giúp bạn thích video này. Nếu bạn muốn nhận được nhiều video như thế này, hãy nhớ đăng ký kênh. 

@@@



3767
00:00:00,520 --> 00:00:27,030
Này, cậu có vài người đấy. Chào mừng bạn quay lại với video này. Trong video này hoặc sẽ nói về nó, hãy vẽ đồ thị cấu trúc dữ liệu. Cấu trúc dữ liệu đồ thị là gì? Graph là một bác sĩ kỹ thuật số phi tuyến tính bao gồm những người mọt sách và những người mọt sách đôi khi được gọi là những người theo đảng phái và ISS là những đường kết nối hai người mọt sách bất kỳ trong biểu đồ đó.

3768
00:00:28,530 --> 00:01:02,330
Chúng ta có thể thấy Đồ thị G là một đối thủ có thứ tự đối diện với V của virus và một tập hợp các con át. Đây là một ví dụ về cấu trúc dữ liệu biểu đồ mà chúng ta có ở đây năm nút so với nút Vargas được gọi là nút, vì vậy chúng ta có thể nói rằng chúng ta có năm nút trong cấu trúc dữ liệu biểu đồ này và ở đây chúng ta có bảy nút là cái này được gọi so với cái được gọi.

3769
00:01:02,330 --> 00:01:25,130
Điều này còn được gọi là nút. Và ranh giới giữa hai loại virus này được gọi là con át chủ bài. Vì vậy, ở đây chúng tôi có bảy. Đây có phải là một hai ba bốn năm sáu bảy. Vì vậy, trong cấu trúc dữ liệu biểu đồ này, chúng ta có năm đỉnh và bảy con át.

3770
00:01:26,460 --> 00:01:50,640
Vậy SATA so với V1, v2, v3, v4, V5, và video V1, B2 v3 video v4, v2, v5, v3, v4, v4, V5 và wi fi V1 cũng vậy. Vậy chúng ta có năm thứ bảy là đồ thị này là đồ thị vô hướng.

3771
00:01:50,960 --> 00:02:04,230
Chúng ta sẽ xem đồ thị vô hướng là gì trong phần thuật ngữ đồ thị của video này, chúng ta sẽ xem đồ thị vô hướng là gì, đồ thị có hướng là gì và nhiều nội dung khác trong video tiếp theo.

3772
00:02:04,830 --> 00:02:20,460
Đây là một ví dụ về trọng lực đối với cấu trúc. Chúng tôi có ở đây năm nút. Các nút được gọi là Vargas và chúng tôi có bảy con át. Bây giờ, chúng ta hãy xem một số ứng dụng thực tế sử dụng một hoặc hai biểu đồ để cấu trúc.

3773
00:02:21,680 --> 00:02:36,500
Mạng xã hội sử dụng cấu trúc dữ liệu đồ thị. Facebook là một phương tiện truyền thông xã hội phổ biến. Facebook sử dụng trọng lực để cấu trúc Twitter, liên kết Instagram, v.v. sử dụng cấu trúc dữ liệu biểu đồ.

3774
00:02:37,070 --> 00:02:57,830
Bây giờ chúng ta sẽ nói về các số liệu của Facebook. Hãy nghe anh chàng này. Ông Chúng tôi sử dụng Facebook. Anh chàng này có một người bạn là anh B. Vậy anh B là bạn của anh B và anh B là bạn của anh B.

3775
00:02:59,220 --> 00:03:17,250
Ở đây chúng ta có Mr. Nếu anh chàng này là bạn của Mr. Vậy anh ta có thể nói, Mr F là bạn của Mr và Mr là bạn của họ. Được rồi, anh F, anh chàng này, anh If là bạn của anh B phải không?

3776
00:03:17,610 --> 00:03:31,470
Vì anh B là bạn của anh F. Anh F là bạn của họ nên anh B có thể nói anh B đó là bạn của anh F được không? Giả sử ở đây chúng ta có một anh chàng khác, anh C.

3777
00:03:32,130 --> 00:03:46,290
Anh chàng này là bạn của ông B. Ngoài ra, anh chàng này là bạn của ông B, nhưng ông C này không phải là bạn của ông này. Ông F, giả sử chúng ta có anh chàng này, ông M.

3778
00:03:46,710 --> 00:04:07,620
Ông E là bạn của ông C. Vậy ở đây có thể nói ông E là bạn của bạn của ông M. Ngoài ra ông E là bạn của bạn của ông B, ông và ông này không phải là bạn trực tiếp ở đây.

3779
00:04:07,620 --> 00:04:20,500
Chúng ta có anh chàng này. Ông I, ông I là bạn của ông C đây ông E là bạn của ông F. Ở đây chúng ta có anh chàng này. Ông Là. Giả sử anh chàng này là bạn của Mr.

3780
00:04:20,530 --> 00:04:38,450
I. Ông này ông Diễm, ông này là bạn của ông If Mr. Different của ông.. Ông G. Cũng là bạn của ông E. ông E, cũng là bạn của ông D. Đây ông D. .tám, là bạn của ông G.

3781
00:04:38,840 --> 00:04:51,950
Đây là một ví dụ về mạng xã hội nhỏ. Facebook sử dụng khái niệm tiên tiến nhưng nguyên tắc cốt lõi thì giống nhau. Tất cả các mạng xã hội đều sử dụng cấu trúc dữ liệu đồ thị.

3782
00:04:52,250 --> 00:05:16,550
Giả sử anh chàng này, anh B đăng lên Facebook hay gì đó và công khai thì mọi người trên Facebook đều có thể sắp xếp bài viết. Nếu bài viết của anh B đăng công khai, là bạn của bạn thì hai người này và bạn đó là bạn.

3783
00:05:16,910 --> 00:05:28,190
Thế là anh chàng này, anh chàng này và anh chàng này lại nhìn thấy bài đăng của anh chàng này, anh B. Đây là một ví dụ đơn giản về lực hấp dẫn để cấu trúc Mạng Facebook.

3784
00:05:28,200 --> 00:05:39,720
Một cái gì đó như thế này ở đây. Anh chàng này có liên quan đến anh chàng này. Anh chàng này có liên quan đến anh chàng này. Anh chàng này có liên quan đến anh chàng này. Anh chàng này là anh chàng này được kết nối với anh chàng này, vân vân và vân vân.

3785
00:05:40,160 --> 00:05:56,690
Đây là một ví dụ về mạng Facebook ở đây. Một ví dụ nữa. Bây giờ, mạng Facebook hoạt động giống như thế này. Trọng lực của cấu trúc cao hơn một chút so với các cấu trúc dữ liệu khác giống như một mối quan tâm thực sự là thuế cây.

3786
00:05:57,050 --> 00:06:09,140
Đây là một trong những cách sử dụng cấu trúc dữ liệu đồ thị. Google Map sử dụng trọng lực để cấu trúc trong Google Maps, nhờ đó bạn có thể tìm ra con đường ngắn nhất giữa hai thành phố.

3787
00:06:09,530 --> 00:06:21,640
Chúng ta hãy xem một phép toán đơn giản. Hãy làm đi, Adam. Đây là một biểu tượng đã nắm bắt được nó, một cấu trúc mà chúng ta có ở đây, một số nghiêm túc, rất dễ nhìn thấy, v.v. Thành phố được kết nối với CDC.

3788
00:06:21,670 --> 00:06:37,540
Ở đây chúng tôi có một pep. Ở đây chúng tôi có nó từ thành phố. Chúng ta có thể ghé thăm thành phố này từ thành phố này. Chúng tôi không thể trực tiếp đến thăm thành phố này vì điều đó. Đầu tiên chúng ta phải đến thăm thành phố này, thành phố Oregon.

3789
00:06:37,540 --> 00:06:53,470
Hãy ghé thăm thành phố này, rồi thành phố này, v.v. Biết làm thế nào chúng ta có thể tìm thấy nó. Con đường ngắn nhất giữa hai thành phố, thành phố và thành phố này là để tìm ra khoảng cách ngắn nhất giữa hai thành phố này.

3790
00:06:54,160 --> 00:07:09,080
Chúng ta có thể áp dụng một số thuật toán đồ thị để tìm đường đi ngắn nhất giữa hai thành phố. Chà, bạn sẽ thấy cách tìm con đường ngắn nhất giữa hai thành phố trong phần diễn ngôn này.

3791
00:07:09,590 --> 00:07:21,640
Chúng ta sẽ nói chi tiết hơn nếu có thể. Đây là một đại diện đồ họa đơn giản. Đây là một ví dụ về toán học đơn giản. Google Maps sử dụng trọng lực để cấu trúc.

3792
00:07:21,850 --> 00:07:47,350
Google Math có thể sử dụng một số chiến lược kỹ thuật nâng cao nhưng nguyên tắc cốt lõi thì giống nhau. Họ đang sử dụng cấu trúc dữ liệu đồ thị theo nhiều cách khác nhau. Vì vậy, đây là hai cách sử dụng trọng lực để cấu trúc mạng xã hội sử dụng cấu trúc trọng lực Google Maps sử dụng nó làm cấu trúc và có rất nhiều ứng dụng của trọng lực đối với các cấu trúc.

3793
00:07:47,860 --> 00:08:01,030
Bây giờ chúng ta hãy xem một số ứng dụng của trọng lực vào cấu trúc. Google Maps sử dụng cấu trúc dữ liệu biểu đồ này. Phương tiện truyền thông xã hội như Facebook, Lincoln, Twitter, Instagram, v.v. sử dụng trọng lực để cấu trúc.

3794
00:08:01,030 --> 00:08:15,420
Hệ điều hành sử dụng các cấu trúc cứng nhắc, công cụ đề xuất, thuật toán tối ưu hóa bộ phận và các tính toán khoa học hơn. Chúng tôi sử dụng cấu trúc bên trong đồ thị trong phần diễn ngôn này.

3795
00:08:15,440 --> 00:08:32,980
Chúng ta sẽ nói về rất nhiều đồ thị, thuật toán và cách tìm đường đi ngắn nhất giữa hai thành phố. Và có một số thuật toán phổ
biến được nhóm lại. Có một số kỹ thuật, trực giác về trọng lực và rất nhiều nội dung sẽ được trình bày trong phần này. 

@@@



3796
00:00:01,110 --> 00:00:14,950
Đây nè hai anh em. Chào mừng bạn quay trở lại với video này, chúng ta sẽ nói về các thuật ngữ đồ họa. Virus. Đầu tiên, hãy nói về cái này là cái gì, cái này là gì?

3797
00:00:15,130 --> 00:00:34,750
Là các nút của đồ thị? Nếu bạn được cung cấp biểu đồ này trong biểu đồ này, chúng tôi thấy chúng tôi có bảy loại vi-rút. Điều đó có nghĩa là chúng tôi có bảy nút, cũng như không có V1, v2, V3, v4 v, năm V6 và V7.

3798
00:00:34,960 --> 00:00:49,750
Vậy ở đây chúng ta có bảy đỉnh. Đây là các đỉnh, được chứ? Vì vậy, virus là các nút của đồ thị. Bây giờ chúng ta hãy nói về việc đây có phải là ranh giới giữa hai loại virus bất kỳ hay không.

3799
00:00:50,290 --> 00:01:01,900
Vì vậy, trong biểu đồ này, đây là một cạnh. Đây là một sự trợ giúp. Đây là một cạnh. Đây là một cạnh. Đây là một cạnh. Đây là một cạnh. Đây là bạn đang ở rìa. Đây là một cạnh.

3800
00:01:02,410 --> 00:01:18,940
Và đây chỉ là một cạnh. Vì vậy, trong biểu đồ và cấu trúc dữ liệu này, chúng ta có tổng cộng một hai ba bốn năm sáu bảy tám chín 10. Vậy trong biểu đồ này chúng ta phải làm 10 là đây có phải là các đường giữa hai loại virus bất kỳ không?

3801
00:01:19,240 --> 00:01:32,680
Chúng tôi đã thấy điều đó. Nhanh lên xem đây là cái gì? Và đây là một dòng và dòng này được gọi là. Bây giờ hãy nói về biểu đồ có chú thích. Không có trọng lượng liên quan đến bất kỳ cái gì.

3802
00:01:32,680 --> 00:01:45,850
Đây được gọi là đồ thị không có trọng số. Trong biểu đồ này, chúng ta có một số đỉnh và một số is-is, nhưng chúng ta thấy rằng không có cách nào nó liên kết với bất kỳ is-is nào.

3803
00:01:46,240 --> 00:02:02,080
Vậy đồ thị này là đồ thị không có trọng số. Vậy đồ thị này là đồ thị không có trọng số. Bây giờ chúng ta hãy nói về đồ thị ited. Có nó liên quan đến ACS được gọi là biểu đồ có trọng số.

3804
00:02:02,590 --> 00:02:18,280
Đây là một ví dụ về biểu đồ có trọng số. Trong biểu đồ này, chúng ta có trí thông minh gắn liền với lứa tuổi. Vậy đồ thị này là đồ thị có trọng số. Vậy đồ thị này là đồ thị có trọng số.

3805
00:02:18,580 --> 00:02:35,800
Chúng ta đã thấy rằng trong điều này, trọng lượng được liên kết ở đây, một được liên kết, v.v. Vì vậy, chúng tôi thấy rằng đây là một biểu đồ có trọng số. Chúng ta thấy rằng trong biểu đồ này, chúng ta thấy rằng cái này được liên kết với cái này thì cái kia được liên kết với cái này.

3806
00:02:35,800 --> 00:02:52,390
Nó là hai được liên kết với cái này là và vân vân. Vì vậy chúng ta có thể nói đây là một biểu đồ có trọng số. Bây giờ hãy nói về đồ thị vô hướng. Đây là biểu đồ không có bất kỳ hướng nào liên quan đến chúng.

3807
00:02:52,810 --> 00:03:08,620
Đây là một ví dụ về đồ thị có hướng. Chúng tôi thấy rằng trong biểu đồ này, không có hướng nào liên quan đến bất kỳ mục đích sử dụng nào. Vì vậy, đây là một biểu đồ được đánh giá thấp. Bây giờ hãy nói về đồ thị có hướng.

3808
00:03:09,250 --> 00:03:23,290
Đó là một biểu đồ. Đây là cái gì? Có hướng liên quan đến họ? Đây là một ví dụ về đồ thị có hướng. Ngoài ra, chúng ta có thể nói cạnh này là biểu đồ có trọng số vì nó được liên kết.

3809
00:03:24,010 --> 00:03:39,100
Vì vậy, chúng ta có thể thấy đây là một đồ thị có hướng có trọng số ở đây. Chúng tôi thấy chúng tôi có hướng đi với điều này ở đây. Chúng ta có một hướng mà chúng ta đang có và chúng ta đã thấy rằng chúng ta có hướng gắn liền với ss.

3810
00:03:39,430 --> 00:03:53,950
Vậy có thể nói đây là đồ thị có hướng. Bây giờ hãy nói về đồ thị vô hướng, không có trọng số. Đó là một biểu đồ trong đó ISS không có bất kỳ hướng nào và không có bất kỳ trọng lượng nào liên quan đến chúng.

3811
00:03:54,340 --> 00:04:13,030
Đây là một ví dụ về biểu đồ không có trọng số, bị đánh giá thấp bởi vì trong biểu đồ này, chúng ta thấy rằng không có trọng số nào liên quan đến bất kỳ sự dư thừa nào. Vì vậy, đây là một biểu đồ hoạt hình và không có hướng nào liên quan đến ISS.

3812
00:04:13,150 --> 00:04:26,410
Vậy đây không phải là đồ thị có hướng. Vậy đây là đồ thị vô hướng. Vì vậy, bạn có thể thấy biểu đồ này là biểu đồ không có trọng số và có hướng. Bây giờ hãy nói về đồ thị có hướng và đồ thị có hướng.

3813
00:04:27,130 --> 00:04:44,770
Đó là một biểu đồ. Điều này không có bất kỳ phương hướng nào nhưng có sức nặng gắn liền với chúng. Trong biểu đồ này, chúng ta thấy rằng không có hướng nào được liên kết với các cạnh này, nhưng nó được liên kết với ISS.

3814
00:04:44,770 --> 00:04:59,890
Vì vậy chúng ta có thể thấy điều này. Đây là đồ thị có trọng số, vô hướng. Bây giờ hãy nói về đồ thị có hướng không trọng số. Đó là một biểu đồ trong đó ISS không có bất kỳ hướng nào và không có bất kỳ loại gỗ nào liên quan đến chúng.

3815
00:05:00,220 --> 00:05:16,060
Đây là một ví dụ về đồ thị có hướng không có trọng số. Chúng ta có phương hướng, nhưng chúng ta không có bất kỳ trọng số nào liên quan đến chúng ta. Vì vậy, chúng tôi có hướng liên quan đến độ tuổi.

3816
00:05:16,060 --> 00:05:33,280
Vì vậy đây là một. Đồ thị có hướng, nhưng không có trọng số, vì vậy bạn có thể nói đây là đồ thị có hướng, không có trọng số. Bây giờ chúng ta hãy nói về đồ thị có hướng, oited. Đó là một biểu đồ trong đó các cạnh không có hướng nào nhưng có trọng số liên quan đến chúng.

3817
00:05:33,580 --> 00:05:48,220
Đây là một ví dụ về biểu đồ có hướng có trọng số trong biểu đồ này. Chúng tôi thấy rằng cuộc thi này có một hướng đi. Đây là khoảng thời gian được liên kết với chúng trong biểu đồ này.

3818
00:05:48,250 --> 00:06:03,880
Chúng ta thấy rằng cái này có phương hướng và trọng lượng. Vì vậy, chúng ta có thể nói đây là đồ thị có hướng có trọng số. Bây giờ hãy nói về đồ thị tuần hoàn. Đồ thị tuần hoàn là đồ thị có ít nhất một đồ thị trực tiếp.

3819
00:06:04,270 --> 00:06:29,820
Đồ thị tuần hoàn là đồ thị có ít nhất một đồ thị trực tiếp. Đây là một ví dụ về tăng trưởng theo chu kỳ trong biểu đồ này. Chúng tôi thấy rằng chúng tôi có một vòng lặp ở đây. Chúng ta có thể phát triển từ loại virus này để phá vỡ V2 của nó, từ cơn lốc V6 này từ những vùng nước này là B7, từ loại virus này, V7 đến V1 của Vargas này.

3820
00:06:30,870 --> 00:06:43,170
Vì vậy, nếu chúng ta bắt đầu từ những cơn lốc này, chúng ta có thể đến thăm dược sĩ này. Vì vậy, nếu chúng ta bắt đầu từ những nghệ sĩ này, chúng ta có thể ghé thăm những nghệ sĩ này, vì vậy chúng ta tìm thấy nó một chút ở đây.

3821
00:06:43,800 --> 00:07:05,520
Vì vậy, đây là một đồ thị tuần hoàn. Nếu chúng ta thấy ít nhất tất cả đều tồn tại trong một biểu đồ, thì ngược lại, đó là một biểu đồ tuần hoàn ở đây. Một động thái khác mà chúng ta có thể bắt đầu từ chế độ xem không này cho đến khi chúng ta thực hiện từ v2 đến V3, từ V3 đến v4 v năm V6 v bảy V1.

3822
00:07:06,000 --> 00:07:26,610
Cũng từ đây chúng ta có thể di chuyển đến nút V5 này từ P5 đến V6, từ P6 đến tiếp nhận đến V1. Vậy chúng ta có ba vòng lặp, đây là đồ thị tuần hoàn. Bây giờ chúng ta hãy nói về một biểu đồ nhỏ và biểu đồ tuần hoàn là một biểu đồ không có vòng lặp trong đó.

3823
00:07:27,150 --> 00:07:40,200
Đây là một ví dụ về biểu đồ tuần hoàn ở đây. Nếu chúng ta bắt đầu từ loại virus này, chúng ta không thể truy cập những loại virus này. Nếu chúng ta bắt đầu từ những vi-rút này, chúng ta không thể truy cập vi-rút này, v.v.

3824
00:07:40,560 --> 00:07:55,470
Chúng ta không có vòng lặp nào trong biểu đồ này nên có thể nói đây là biểu đồ tuần hoàn. Chà, hãy nói về một cấu trúc dữ liệu đồ thị thú vị. Cây ba là trường hợp đặc biệt của đồ thị chu trình có hướng.

3825
00:07:55,950 --> 00:08:08,160
Đây là một cái cây. Tất cả chúng ta đều biết rằng đây là một cái cây. Cây này là một biểu đồ. Chúng ta có ghi chú thứ năm từ đây, nhưng chúng ta không thể chuyển sang ghi chú này từ nút này. Chúng ta có thể truy cập nút này.

3826
00:08:08,430 --> 00:08:20,430
Chúng ta không thể đi đến máng. Chúng ta chỉ có thể đi xuống phía dưới, sang trái hoặc sang phải. Và đây là dầu. Từ năm chúng ta có thể đến thăm bảy. Từ bảy chúng ta có thể đến thăm một từ bảy.

3827
00:08:20,440 --> 00:08:40,290
Chúng ta có thể đến thăm sáu. Vì vậy chúng ta thấy rằng trong cấu trúc dữ liệu này không có tình yêu. Chúng tôi không thể xem lại một ghi chú. Vì vậy, một lần nữa cho biết Đây là biểu đồ chu kỳ có hướng. Ở đây chúng ta có phương hướng vì chúng ta chỉ có thể di chuyển đến phần dưới của anh ta.

3828
00:08:40,500 --> 00:08:54,420
Chúng ta không thể di chuyển đến máng. Chúng ta chỉ có thể di chuyển xuống phía dưới. Vì vậy, bạn có thể nói đây là đồ thị không theo chu kỳ có hướng. Đây không phải là ROI. Tất cả các loại cây là một đồ thị tuần hoàn.

3829
00:08:54,900 --> 00:09:07,730
Đây là lý do tại sao tất cả các loại cây đều là một loại trọng lực đặc biệt đối với cấu trúc và có biểu đồ chu kỳ có hướng. Hy vọng bạn đã hiểu các thuật ngữ đồ họa.

3830
00:09:08,340 --> 00:09:24,840
Đây là những thuật ngữ phổ biến mà chúng tôi đã nói đến trong video này. Hy vọng đã hiểu tất cả các tương tự thời gian. Nếu
bạn gặp khó khăn trong việc hiểu bất kỳ vấn đề nào trong số đó, tôi yêu cầu bạn đăng câu hỏi của mình lên diễn đàn Hỏi đáp. 

@@@



3831
00:00:00,630 --> 00:00:13,550
Này hai bạn, hoặc quay lại video này trong video này hoặc sẽ nói về các loại biểu đồ. Đây là hình ảnh, một biểu diễn của cấu trúc dữ liệu đồ thị.

3832
00:00:14,030 --> 00:00:35,670
Đầu tiên, chúng tôi đã phân loại Graph. Đồ thị có hướng và không có hướng được chia thành hai loại cũng được phân thành hai loại là chờ và chờ và chờ lấy.

3833
00:00:35,880 --> 00:01:01,410
Chúng tôi phân loại thành hai phần tích cực và tiêu cực. Bây giờ chúng ta hãy xem tất cả chúng. Nói chung, chúng ta có sáu loại nhóm này và chúng ta đã tạo ra đồ thị vô hướng không có trọng số, đồ thị có hướng dương, đồ thị có hướng và có thứ tự dương, oited, đồ thị có hướng âm, đồ thị tránh và có hướng và đồ thị âm hoặc có hướng.

3834
00:01:01,830 --> 00:01:22,560
Bây giờ chúng ta hãy xem tất cả chúng từng cái một. Đây là biểu đồ có hướng không có trọng số vì không có ý nghĩa gì liên quan đến ISS. Chúng tôi có hướng với tất cả ISS, vì vậy đây là biểu đồ có hướng và không có trọng số với ISS.

3835
00:01:22,740 --> 00:01:44,030
Vì vậy, đây là đồ thị không có trọng số. Một lần nữa, đây là đồ thị có hướng không có trọng số. Đây là một ví dụ về đồ thị vô hướng, không có trọng số. Chúng tôi thấy rằng không có trọng lượng nào liên quan đến ISS và không có phương hướng nào liên quan đến ISS.

3836
00:01:44,240 --> 00:01:57,080
Vậy đây là đồ thị vô hướng, không có trọng số. Đây là đồ thị dương, có trọng số, vô hướng. Đầu tiên, biểu đồ này có trọng số. Chúng tôi có trọng lượng liên quan đến ISS.

3837
00:01:57,200 --> 00:02:11,330
Vì vậy, đây là biểu đồ có trọng số và chúng ta thấy tất cả các trọng số đều có giá trị dương. Vì vậy, đây là biểu đồ có trọng số dương và chúng ta thấy rằng không có hướng nào liên quan đến ISS.

3838
00:02:11,330 --> 00:02:27,260
Vậy đây là đồ thị vô hướng. Vậy có thể nói đây là đồ thị vô hướng, có hướng dương. Đây là đồ thị dương hoặc đồ thị có hướng. Chúng tôi có trọng lượng liên quan đến tất cả ISS và trọng lượng là dương.

3839
00:02:27,350 --> 00:02:38,360
Vì vậy, đây là biểu đồ có thứ tự dương và chúng ta thấy rằng với tất cả ISS, chúng ta có hướng. Đây là đồ thị có hướng, nên bạn có thể thấy đây là đồ thị có hướng dương, có trọng số.

3840
00:02:39,050 --> 00:02:51,650
Đây là đồ thị âm hoặc đồ thị vô hướng. Đầu tiên, chúng ta thấy không có sự suy giảm nào liên quan đến ISS, vì vậy đây là biểu đồ vô hướng và chúng ta thấy chúng ta có trọng số đối với tất cả ISS.

3841
00:02:52,010 --> 00:03:03,260
Đây là đồ thị có trọng số, nhưng chúng ta thấy rằng chúng ta có các điểm âm trong đồ thị này. Vì vậy, đây là đồ thị vô hướng âm nếu chúng ta thấy ít nhất một âm.

3842
00:03:03,260 --> 00:03:16,850
Nhưng một lần nữa, hãy xem, đây là đồ thị có trọng số âm vì không có hướng, nên chúng ta có thể nói đây là đồ thị có trọng số âm, vô hướng. Đây là đồ thị có hướng, có trọng số âm.

3843
00:03:17,000 --> 00:03:34,340
Chúng tôi thấy rằng chúng tôi có ít nhất một trí thông minh tiêu cực. Vì vậy, đây là biểu đồ có trọng số âm và chúng ta thấy hướng liên quan đến ISS. Vì vậy, đây là đồ thị có hướng, vì vậy chúng ta có thể thấy đây là đồ thị có hướng có trọng số âm.

3844
00:03:34,610 --> 00:03:50,480
Đây là những loại biểu đồ nói chung đã hiểu được điều này đối với các loại nhóm. Đây là cách trình bày tương tự đỉnh cao, vì vậy chúng tôi đã thấy tất cả các kiểu nắm bắt nói chung, hy vọng bạn đã hiểu được lời giải thích này.

3845
00:03:50,840 --> 00:04:02,510
Trong vài video tiếp theo, chúng ta sẽ nói về cách áp dụng trọng lực vào cấu trúc và bạn
sẽ thấy các kỹ thuật biểu diễn đồ thị. Hẹn gặp lại các bạn trong video tiếp theo. 

@@@



3846
00:00:00,930 --> 00:00:13,470
Này các bạn. Chào mừng bạn quay trở lại với video này, chúng ta sẽ nói về cách trình bày đồ họa. Biểu diễn đồ thị là một kỹ thuật lưu trữ đồ thị vào bộ nhớ máy tính.

3847
00:00:14,670 --> 00:00:27,030
Có nhiều cách khác nhau để lưu đồ thị vào bộ nhớ máy tính. Nhưng trong khóa học này, chúng ta sẽ nói về hai cách biểu diễn đồ thị phổ biến.

3848
00:00:28,430 --> 00:00:48,080
Một cái được gọi là Số liệu Ad Jacinta và cái còn lại được gọi là Danh sách Ad Jacinta. Bây giờ hãy nói về ma trận kề. Đây là một ví dụ về ma trận kề, nhóm ma trận này là biểu đồ này.

3849
00:00:49,170 --> 00:01:08,710
Trong biểu đồ này, chúng ta có năm phán quyết và bảy con át. Chúng tôi đang biểu diễn biểu đồ này trong cấu trúc dữ liệu bằng ma trận kề này. Đây là một đại diện hợp lý của điều này.

3850
00:01:09,040 --> 00:01:24,420
Tôi Jacinta số liệu. Chúng tôi đang đại diện cho điều này. Ghép cấu trúc của anh ấy bằng ma trận này, cái này được gọi là thêm vào Ma trận. Chúng ta sẽ thấy nó thực sự hoạt động như thế nào trong video này.

3851
00:01:24,480 --> 00:01:40,970
Chúng tôi chỉ cho bạn thấy biểu đồ này đang thể hiện. Chúng tôi quyết định điều này vào danh sách Ma trận bốn kề. Biểu đồ này sẽ được thể hiện giống như thế này khi Hoa Kỳ.

3852
00:01:41,360 --> 00:02:21,430
Tôi chỉ không nhìn thấy danh sách. Đây chỉ là sự thể hiện hợp lý của quảng cáo này vào danh sách. Chúng ta sẽ xem nó thực sự hoạt động như thế nào. Chúng ta sẽ nói về từng thông tin mà bạn cần để hiểu cách biểu diễn đồ họa đó và bạn sẽ xem từng dòng mã trong video tiếp theo, chúng ta sẽ biểu diễn đồ thị không có trọng số, vô hướng bằng ma trận kề và đồ thị vô hướng có trọng số bằng ma trận kề ma trận.

3853
00:02:22,700 --> 00:02:35,030
Sau đó bạn sẽ nhìn thấy biểu đồ biểu diễn cho Addison vào danh sách. Đầu tiên, hãy nói
về cách biểu diễn đồ thị cho ma trận kề, sau đó nói về for tại danh sách Jacinta. 

@@@



3854
00:00:00,610 --> 00:00:09,540
Này, cậu có vài người đấy. Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về người phỏng vấn đại diện trong phần thảo luận này.

3855
00:00:09,580 --> 00:00:26,270
Chúng ta đã biết cách biểu diễn các loại nhóm khác nhau bằng cách biểu diễn mà bạn nên chọn, trong trường hợp đó. Bây giờ chúng ta hãy nói về điều đó. Nếu biểu đồ là một biểu đồ dày đặc thì chúng ta nên sử dụng số liệu thêm vào giữa.

3856
00:00:28,050 --> 00:00:48,750
Ở đây chúng ta có định nghĩa về đồ thị dày đặc tăng trưởng dày đặc là đồ thị trong đó số lượng quân Át gần với số lượng quân Át tối đa. Điều đó có nghĩa là số quân Át mà chúng ta có trong một biểu đồ hoàn chỉnh trong một biểu đồ hoàn chỉnh sẽ có số lượng quân Át tối đa ở mọi lứa tuổi.

3857
00:00:49,800 --> 00:01:04,410
Và nếu đồ thị là đồ thị thưa thớt thì chúng ta nên sử dụng danh sách kề. Ở đây chúng ta có định nghĩa để Spurs vẽ đồ thị chỉ có một vài cạnh. Đây có phải là biểu đồ đầu tiên?

3858
00:01:05,820 --> 00:01:21,660
Đây là ví dụ về AD gửi số liệu cho anh ấy và đây là ví dụ về danh sách kề. Điều đầu tiên, bạn phải làm gì? Đầu tiên, chúng ta phải kiểm tra số lượng con át trong một biểu đồ nhất định.

3859
00:01:22,140 --> 00:01:41,920
Nếu chúng ta thấy con số này gần với số trường hợp tối đa có thể có trong biểu đồ đã cho mà bạn coi là ma trận kề. Chúng tôi đang sử dụng số liệu ở đây, nếu chúng tôi có ít trường hợp hơn thì chúng tôi sẽ thực hiện một số thao tác ở đây.

3860
00:01:42,040 --> 00:01:57,980
Phần lớn tế bào sẽ không được sử dụng. Đúng vậy. Trong trường hợp đó, chúng ta phải sử dụng danh sách Jacinta +2% và vị trí của ma trận kề được cố định. Vì vậy, số lượng trang gần bằng số lượng tối đa mà chúng tôi sẽ sử dụng.

3861
00:01:58,000 --> 00:02:15,160
Thêm vào để cảm nhận ma trận nếu chúng ta thấy trong chính phủ nhất định có một số ít mà chúng ta sẽ sử dụng +210 để liệt kê và điều đó tiết kiệm không gian. Chúng ta sẽ có rất nhiều ô chưa được sử dụng trong phép cộng này ngay bên trong ma trận nếu chúng ta chia cổ tức cho các chuyên gia lập biểu đồ bằng cách sử dụng số liệu Thêm Jacinta.

3862
00:02:15,280 --> 00:02:28,360
Bạn sẽ có một biểu đồ Spetzel khổng lồ sử dụng ma trận kề. Bạn sẽ có rất nhiều ô chưa sử dụng trong ma trận này. Và đó không phải là không gian hiệu quả. Đó là tất cả những gì chúng ta phải xem xét, nhà bản chất luận cho biết thêm.

3863
00:02:28,660 --> 00:02:41,650
Và nếu chúng ta có số lượng is, con số này gần với số lượng ISS tối đa, thì chúng ta không nên chỉ sử dụng danh sách. Chúng ta nên sử dụng ma trận kề cho các loại đồ thị này.

3864
00:02:41,890 --> 00:02:54,910
Chúng ta có thể xem xét ma trận kề. Và đối với các loại đồ thị này chúng ta nên sử dụng danh sách kề để biểu diễn đồ thị. Đối với đồ thị phức hợp, chúng ta nên xét ma trận kề.

3865
00:02:55,360 --> 00:03:06,530
Đồ thị tổng hợp là gì? Nếu chúng ta có số ISS trong đồ thị đã cho là tối đa thì đồ thị đó được gọi là đồ thị tổng hợp. Biểu đồ này có phải là biểu đồ hoàn chỉnh không?

3866
00:03:06,580 --> 00:03:19,900
Không, biểu đồ này không phải là biểu đồ tổng hợp. Trong biểu đồ hoàn chỉnh, bạn sẽ có số lần trừ đi một phần do virus. Nhưng trong biểu đồ này, chúng ta thấy rằng chúng ta có bảy đỉnh.

3867
00:03:20,710 --> 00:03:32,320
Chúng tôi đây. Năm là vậy nên năm nhân bốn bằng với năm 2020, dành cho hai số 10 đó. Và ở đây chúng ta có bảy. Đây có phải là nhưng chúng ta nên có số lượng ISS nhân với âm một.

3868
00:03:32,320 --> 00:03:44,620
Hai người còn lại. Ở đây chúng ta thấy rằng vitesses này được kết nối với ba loại virus này nhưng biểu đồ không đầy đủ. Bất kỳ đỉnh nào cũng được kết nối với tất cả các xoáy trong biểu đồ đã cho ở đây.

3869
00:03:44,680 --> 00:03:56,770
Số không được kết nối với hai. Hai được kết nối với hai bốn và cái này được kết nối với bốn. Nếu chúng ta có kết nối này hoặc loại ACS này, chúng ta có thể thấy đây là biểu đồ tổng hợp.

3870
00:03:56,980 --> 00:04:12,700
Ở đây chúng tôi có hai ISS được tích hợp sẵn và nó tuân theo công thức này với số lần trừ một 2.2. Vì vậy có thể nói đây là một biểu đồ hoàn
chỉnh cho đồ thị tính toán. Chúng ta nên xem xét nhà nghiên cứu ma trận kề hy vọng chúng ta đã hiểu khi nào nên sử dụng với biểu diễn. 

@@@



3871
00:00:00,570 --> 00:00:18,410
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này, chúng ta sẽ nói về cách trình bày đồ họa bằng cách sử dụng số liệu quảng cáo Jacinta. Trong video này, chúng ta sẽ xem cách biểu diễn cho đồ thị không được xếp hạng, đồ thị vô hướng và đồ thị có trọng số và đồ thị có hướng.

3872
00:00:18,750 --> 00:00:30,110
Đầu tiên, hãy nói về đồ thị không có trọng số, vô hướng, sau đó chúng ta sẽ nói về đồ thị có trọng số và đồ thị có hướng. Bây giờ chúng ta sẽ nói về đồ thị vô hướng, không có trọng số.

3873
00:00:31,070 --> 00:00:52,280
Bây giờ chúng ta phải biểu diễn đồ thị không có trọng số này và có hướng bằng ma trận kề mà chúng ta có ở đây. 2,5 bằng 0 một hai ba bốn. Vì vậy, chúng ta sẽ tạo một ma trận có năm hàng và năm cột.

3874
00:00:52,640 --> 00:01:11,260
Ở đây chúng ta có năm hàng và năm cột. Bây giờ hãy xem cách chúng ta có thể biểu diễn biểu đồ này bằng cách sử dụng ma trận cộng vào Cincy này. Đầu tiên, chúng tôi có cái này ở đây nên chương trình này trống.

3875
00:01:12,530 --> 00:01:28,580
Trong ma trận này, bạn biết đấy, nó đúng bởi một và. Sai bằng 0. Vì vậy, chúng tôi sẽ lưu trữ trong quảng cáo này, Ma trận Jacinta Jacinta bằng 0 hoặc một. Giá trị mặc định là 0.

3876
00:01:28,820 --> 00:01:42,560
Ban đầu, ma trận này được điền bằng 0 ở đây cho lần bán hàng đầu tiên này với giá 0 và 0. Chúng ta thấy ở đây chúng ta có số 0 và chúng ta không có bất kỳ cái nhìn nào ở đây. Vì vậy, ở đây bạn có số không.

3877
00:01:42,950 --> 00:02:02,390
Ở đây chúng tôi không có lông tơ từ 0 đến 0. Vì vậy ở đây cửa hàng cũ số 0, không có cạnh nào cho ghi chú này. Không hai không. Ngoài ra, bạn có thể thấy đây là giá trị so với giá trị mặc định ở mức 0 để hiểu hoặc chèn số 0 khi bạn chèn số 0, điều đó có nghĩa là giá trị đã bằng 0.

3878
00:02:02,510 --> 00:02:19,040
Chúng tôi chỉ làm điều đó chỉ vì muốn hiểu không cho số 0 và một ở giữa số không và một. Chúng ta thấy chúng ta có số tám. Vì vậy, ở đây bạn sẽ chèn một. Một nghĩa là chúng tôi có ID ở giữa.

3879
00:02:19,040 --> 00:02:30,380
Hai bên này bằng 0 và một bên được chèn vào đây. Một cho biết chúng ta có và ở giữa hai giai đoạn 0 và 1 này. Vì vậy, ở đây chúng ta có số không và một.

3880
00:02:30,500 --> 00:02:42,920
Vì đây là đồ thị vô hướng nên chúng tôi cũng sẽ chèn vào đây một đồ thị. Chúng ta có cạnh từ 1 tới 0 thay đổi từ 0 thành 1. Đúng vậy, chúng tôi đã chèn vào đây một cái và ở đây nữa.

3881
00:02:43,340 --> 00:02:56,660
Một đầu bây giờ bằng 0 cho số 0 và hai cho số 0 và hai. Chúng ta thấy không có cái gì ở giữa số 0 và số 2. Vì vậy bây giờ chúng ta hãy chèn số 0 vào giữa số 0 và ba.

3882
00:02:57,080 --> 00:03:08,000
Chúng ta thấy ở giữa số 0 và số 3, chúng ta có lợi thế. Vì vậy hãy chèn vào đây một cái ở đây. Nó có nghĩa là chúng ta có số tám từ 0 đến 3 và cả từ 3.0.

3883
00:03:08,300 --> 00:03:21,770
Và đây là lý do tại sao chúng tôi sẽ chèn một cái vào đây. Điều đó có nghĩa là chúng ta có một cạnh từ ba đến 0 bây giờ là bốn, hai và bốn, bốn không và bốn ở giữa hai đỉnh này.

3884
00:03:22,370 --> 00:03:36,380
Chúng ta thấy chúng ta có số tám. Vì vậy, hãy chèn vào đây một cái ở đây chúng ta có từ 0 đến 4 và chúng ta có cái từ 4 đến 0. Vì vậy, chúng tôi cũng sẽ chèn vào đây một biểu đồ vì đây là biểu đồ được đánh giá thấp.

3885
00:03:36,740 --> 00:03:49,940
Bây giờ cho một, và ở đây chúng ta có một cho một và một không? Không có vòng lặp từ nút này đến ghi chú này ở đây. Đôi khi tôi đang nói các nút và đôi khi tôi đang nói, Đây là cái gì?

3886
00:03:50,540 --> 00:04:02,930
Đừng nhầm lẫn rằng các đỉnh không phải là nút DCIM. Vì vậy, ở đây bạn đã chèn của riêng mình vì chúng tôi không có bất kỳ cạnh nào ở giữa nút này chứ không phải nút này ở đầu này.

3887
00:04:03,290 --> 00:04:11,330
Không, với một và hai, chúng ta thấy một và hai, chúng ta có tám. Vì vậy, hãy chèn vào đây một ở đây chúng ta có thể đi từ một đến hai và bạn cũng có thể đi từ hai đến một.

3888
00:04:11,330 --> 00:04:24,920
Vì vậy chúng ta hãy chèn vào đây một cái nữa. Bây giờ, đối với một và ba, chúng ta thấy bốn nút, một và ba. Chúng tôi có một sự dễ dàng. Vì vậy, hãy chèn vào đây một, chúng ta có thể đi từ một đến ba và bạn có thể đi từ hai đến một.

3889
00:04:25,250 --> 00:04:33,770
Vì vậy chúng ta hãy chèn vào đây một cái nữa. Chúng ta có thể phát triển từ cái này, không phải ba cái này, không phải một cái. Chúng ta sẽ đi từ nút một đến ba, bây giờ là bốn, một và bốn.

3890
00:04:34,070 --> 00:04:45,770
Chúng tôi thấy chúng tôi không có bất kỳ cái nào ở khu vực một và bốn. Vì vậy, hãy chèn số 0 vào đây bây giờ là bốn, hai và không. Chúng ta thấy có số Tám. Vì vậy, ở đây bạn chèn số không.

3891
00:04:46,100 --> 00:05:01,720
Ở đây chúng ta có một, bốn, hai và một vì bây giờ chúng ta có thể chuyển từ hai sang một cho hai và hai. Không có tình yêu trong nút này. Chúng ta không thể đi từ đây. Không phải thế này, không phải vì chúng ta không có ở đây và tình yêu.

3892
00:05:02,120 --> 00:05:15,590
Vì vậy, hãy chèn số 0 bây giờ là hai và ba. Chúng tôi có một chữ s. Hãy chèn một. Chúng ta có thể đi từ hai lên ba và cũng có thể đi từ hai lên hai. Vì vậy, đối với ba đến hai ở đây bạn sẽ chèn một cho hai đến bốn.

3893
00:05:15,740 --> 00:05:29,860
Bạn không thể đi từ hai đến bốn. Chúng tôi không có cái nào cả. Vì vậy hãy chèn số không vào đây. Ở đây chúng ta đã có sẵn ba giá trị cho ba. Ghi chú ba và ba này bạn không có ID nên hãy chèn vào đây số 0, rồi bốn, ba và bốn.

3894
00:05:29,870 --> 00:05:43,280
Chúng tôi có một là. Hãy chèn vào đây. Một, chúng ta có thể đi từ ba đến bốn và bốn đến ba. Vì vậy hãy chèn vào đây một cái. Bây giờ cho việc này. Vì vậy, đối với nước ngoài, bạn không có gì thì hãy chèn số 0.

3895
00:05:43,550 --> 00:05:56,720
Không, đối với bốn và hai vùng Đông Bắc, chúng tôi không có cái nào cả. Vì vậy hãy chèn số không vào đây. Cuối cùng, bốn và bốn, không có tổn thất nào trong các nút này. Chúng ta không thể di chuyển từ nút này đến ghi chú này.

3896
00:05:56,720 --> 00:06:10,280
Không có nó ở giữa nút này và chính nút này. Vì vậy chúng ta sẽ chèn số 0 vào đây. Chúng tôi đã xây dựng điều này ở ma trận trung tâm. Đây là sự thể hiện của cấu trúc dữ liệu đồ thị này.

3897
00:06:10,730 --> 00:06:29,550
Đây chỉ là cách biểu diễn logic và ma trận này sẽ được lưu trữ trong bộ nhớ máy tính của chúng ta. Nó đang lưu trữ cấu trúc dữ liệu này hoặc thứ gì đó tương tự như thế này hoặc lưu trữ ma trận này và ma trận này được biểu diễn một cách logic, đại loại như thế này và đây là cấu trúc dữ liệu biểu đồ.

3898
00:06:29,970 --> 00:06:41,490
Như vậy, chúng ta đã hiểu cách biểu diễn đồ thị vô hướng, không có trọng số bằng ma trận kề. Ở đây chúng tôi đang lưu trữ một. Một cho biết chúng tôi đã và đang nhúng hai nút.

3899
00:06:41,880 --> 00:06:59,850
Số 0 cho biết chúng tôi không có ranh giới giữa hai nút thuê chuỗi một. Nếu là biểu đồ, chúng tôi đã vẽ biểu đồ, thì chúng tôi sẽ lưu trữ trọng số. Cái liên quan đến hiện tại là và bạn sẽ thấy điều đó trong video này.

3900
00:07:00,090 --> 00:07:12,750
Bây giờ hãy xem thuật toán. Đây là thuật toán cho đồ thị vô hướng, không có trọng số. Chúng tôi có biểu đồ lớp bên trong đây. Chúng tôi có quyết định. Ma trận là ma trận lịch sử.

3901
00:07:13,020 --> 00:07:28,170
Và ở đây bạn có một đỉnh thay đổi. Sau đó, ở đây bạn có hàm tạo. Nó tấn công các đỉnh làm đầu vào. Và bên trong đây, chúng ta đang chèn các đỉnh vào các đỉnh biến đổi này và chúng ta đang tạo vào ma trận có các đỉnh.

3902
00:07:28,170 --> 00:07:43,560
Và số hàng và số cột là bao nhiêu? Sau đó ở đây chúng ta có chức năng này. Cộng là toàn bộ số nguyên và chèn vào đây một để chèn một và bốn hoặc chèn một vì chúng ta phải định hướng.

3903
00:07:43,710 --> 00:08:01,230
Chúng ta có thể đi từ nút ở đây đến không tồn tại và cũng có thể từ Nút B2 Nút E. Đây là lý do tại sao chúng ta chèn một và một. Có phải nó là một thực thể, một thực thể mà chúng ta có ở đây? Chức năng xóa này là chức năng này sẽ loại bỏ IS thực sự ở hai nút bất kỳ.

3904
00:08:01,710 --> 00:08:14,130
Tôi giải mã thành 0 và bằng 0. Và ở đây chúng ta có hàm này để hàm chuỗi sẽ trả về. Biểu đồ dưới dạng chuỗi ở đây đã phản đối người xây dựng.

3905
00:08:14,130 --> 00:08:27,420
Sau đó, ở đây ra lệnh chạy một vòng lặp cho AI từ 0 đến trừ một của Horace. Sau đó, ở đây chúng tôi đang chèn AI, chỉ mục hiện tại, cộng với dấu chấm phẩy chỉ để in nội dung ở đây hoặc sắp hết mức này cho G.

3906
00:08:27,750 --> 00:08:45,090
Tôi vừa vào Matrix, tôi đang in. Nếu họ đi đến một hoặc chèn một R thì có hoặc chèn số 0 và ở cuối hoặc chèn dấu ngắt dòng và ở cuối hoặc trả về chuỗi, chúng ta đang chuyển đổi trình tạo chuỗi thành cuối chuỗi hoặc trả về chuỗi.

3907
00:08:45,660 --> 00:08:58,380
Không, hãy xem nó thực sự hoạt động như thế nào. Bạn sẽ khởi tạo biểu đồ bằng Vertices 5. Điều đó có nghĩa là chúng tôi đang tạo và tôi chỉ thấy Ma trận với Quy tắc năm và Cột năm.

3908
00:08:58,710 --> 00:09:10,020
Đây là ma trận kề. Chúng tôi làm năm và cột năm. Và chúng tôi ở đây, đại diện cho sự phá hủy hình vẽ bậy. Đây chỉ là sự trình bày hợp lý của các số liệu về thanh thiếu niên.

3909
00:09:10,710 --> 00:09:25,450
Bây giờ, nếu chúng ta gọi biểu đồ được thêm bằng 0, nó sẽ kết nối hai nút này hoặc chúng ta có thể thấy nhóm sẽ có một nút ở đây. Và chúng ta có thể di chuyển từ số 0 đến một đầu từ một đến số không.

3910
00:09:26,380 --> 00:09:46,090
Vì vậy, chúng ta sẽ chèn vào đây một hai số không ở đây một năm chèn một cột băng vào một và không hai vào một để biết hướng chúng ta có thể đi từ 0 đến một. Và từ những gì bạn biết nếu chúng ta gọi phương pháp này, thêm AIDS bằng 0 bốn, thì ở đây chúng ta đang kết nối những vi rút này với những vi rút này.

3911
00:09:46,090 --> 00:10:01,390
Bốn. Và ở đây bạn chèn một. Vì vậy, ở đây chúng tôi có một nó. Bạn biết đấy, những gì chúng ta có thể đi từ 0 đến 4 và từ Portage, vì vậy ở đây cũng sẽ chèn một cái vào đây. Sử dụng công thức này ở đây, bây giờ nó khá đơn giản.

3912
00:10:01,400 --> 00:10:15,470
Hãy gọi lại phương thức này với số 0 ba. Nó sẽ gọi, rồi nó sẽ kết nối ghi chú này với ghi chú này. Và ở ma trận trung tâm này, bạn sẽ làm gì?

3913
00:10:16,160 --> 00:10:29,240
Chúng ta sẽ chèn vào đây một không ba và bốn ba không. Chúng ta có thể đi từ hai Juno. Vì vậy, ở đây cũng sẽ chèn một cái. Vì vậy, đây là biểu diễn của ma trận kề này.

3914
00:10:29,810 --> 00:10:43,040
Đây là cấu trúc Gravity hai của chúng tôi. Bây giờ hãy gọi phương thức cộng tuổi một hai. Ở đây chúng ta có một và hai. Vì vậy ở đây nó sẽ có một cái, và chúng ta sẽ kết nối nút này với nút này.

3915
00:10:43,640 --> 00:10:56,030
Chúng ta có thể phát triển từ một lên hai và từ hai lên một. Vậy từ hai thành một, ở đây chúng ta sẽ chèn một. Bây giờ hãy gọi đây là phép cộng cạnh bằng một ba. Nếu bạn gọi nó là một ba, chúng tôi sẽ thành lập một.

3916
00:10:56,300 --> 00:11:07,190
Điều đó có nghĩa là chúng ta có tám nút ở giữa hai nút một và ba này. Ở đây chúng ta thấy chúng ta có thể di chuyển từ một đến ba, từ một đến ba và từ ba đến một.

3917
00:11:07,550 --> 00:11:20,630
Vì vậy, ở đây bạn chèn một. Bây giờ hãy gọi đây là phép cộng với hai ba. Ở đây nó sẽ nói số tám này. Vì vậy, chúng ta có thể đi từ hai đến ba. Từ hai đến ba. Và từ ba đến hai.

3918
00:11:21,200 --> 00:11:34,280
Hãy gọi phương thức này thêm là ba hay bốn? Vì vậy, nó sẽ kết nối cái này với Nút ba bốn. Vì vậy, từ nút này, không phải ba, chúng ta có thể chuyển sang nút này vì nút đó được chèn vào một.

3919
00:11:34,700 --> 00:11:48,260
Ngoài ra, bạn có thể di chuyển từ bốn đến ba. Vì vậy, từ bốn đến ba và tất cả các ô trống đều được điền bằng 0 vì giá trị mặc định là 0. Chúng tôi đã điền giá trị mặc định bằng 0.

3920
00:11:48,700 --> 00:12:00,000
Bây giờ chúng ta gọi phương thức này thành một chuỗi. Sau đó nó sẽ trở lại. Chuỗi này bằng câu lệnh viết này là chúng ta đã có chuỗi. Ở đây chúng ta thấy rằng đây là biểu đồ này.

3921
00:12:00,020 --> 00:12:11,270
ĐƯỢC RỒI. Đây là sự thể hiện của biểu đồ này. Bạn vừa hiểu rõ về cấu trúc cách biểu diễn đồ thị không có trọng số, vô hướng bằng ma trận kề.

3922
00:12:11,570 --> 00:12:20,510
Chúng tôi đã triển khai biểu đồ có hướng và không có trọng số, đồng thời chúng tôi đã giải thích nó theo từng dòng mã. Bây giờ hãy nói về biểu đồ được đánh giá thấp có trọng số.

3923
00:12:21,080 --> 00:12:34,760
Đây là một biểu đồ có trọng số. Biểu đồ này có trọng số và chúng tôi thấy không có khoảng thời gian nào liên quan đến bất kỳ ISS nào. Đây là đồ thị có hướng, bạn có thể thấy điều này.

3924
00:12:34,760 --> 00:12:45,020
Đây có phải là đồ thị có trọng số và có hướng không? Bây giờ, hãy xem làm thế nào anh ta có thể biểu diễn biểu đồ này bằng ma trận kề. Hãy lấy cái này làm ma trận kề mà chúng ta có ở đây.

3925
00:12:45,020 --> 00:12:57,440
Năm là cái này. Vì vậy, chúng tôi đã tạo ma trận này như thế này trong hai ma trận có năm hàng và năm cột. Bây giờ cho việc này. Bạn cũng không biết không có luf trong ghi chú này.

3926
00:12:57,770 --> 00:13:14,270
Không có tình yêu từ đây, không phải số không đến nút số không này. Vì vậy, ở đây hãy chèn số 0, rồi bốn, 0 và một. Chúng ta có a ở đây và ở đây gần như là 2,1 trong thời gian này vì đây là biểu đồ có trọng số sẽ lưu trữ từ đó vào.

3927
00:13:14,270 --> 00:13:27,500
Vì vậy hãy lưu trữ ở đây trọng lượng và trọng lượng. Ở đây chúng ta thấy hai. Vì vậy hãy chèn vào đây. Thứ hai, chúng ta có thể đi từ 0 đến 1 và từ 1 đến 0. Vì vậy, ở đây cũng sẽ chèn hai cái nào.

3928
00:13:27,500 --> 00:13:39,540
Bây giờ chúng ta có thể chuyển từ một về không cho số không và số hai. Không có kết nối nào, vì vậy hãy thiết lập số không. Vẫn chưa có. ĐƯỢC RỒI. Sau đó từ 0 đến 3, chúng ta thấy mình có số 8.

3929
00:13:39,560 --> 00:13:52,340
Vì vậy, hãy chèn trọng lượng vào đây là giá trị ở đây là 5. Hãy chèn vào đây. Năm. Chúng ta cũng có thể chuyển từ ba về không. Vì vậy, ở đây hãy chèn năm từ 0 đến 4.

3930
00:13:52,700 --> 00:14:04,260
Chúng ta có thể di chuyển từ số 0 đến số 4. Và nó đây. Ba. Hãy chèn từ ba vào đây. Và ngoài ra, chúng ta có thể chuyển từ Portwood Euro sang. Vì vậy, hãy chèn vào đây ba từ một đến một.

3931
00:14:04,280 --> 00:14:17,720
Không có tình yêu trong ghi chú này. Chúng ta không thể di chuyển từ cái này sang cái khác. Vì vậy, tất cả đều ở tâm số 0 bây giờ từ một đến hai, chúng ta thấy chúng ta có một cạnh có trọng số là bốn để chúng ta chèn vào đây.

3932
00:14:17,720 --> 00:14:30,530
Bốn. Chúng ta có thể chuyển từ hai sang một. Vì vậy, chúng ta hãy chèn vào đây. Bây giờ, với một và ba, chúng ta có số tám với trọng số là ba. Vậy hãy chèn vào đây ba từ ba hai một.

3933
00:14:31,310 --> 00:14:40,820
Chúng ta có thể chuyển từ ba sang một. Vì vậy, hãy chèn vào đây ba. Bây giờ, từ một đến bốn, chúng ta không có trọng lượng nào cả, nên không có trọng lượng nào đi kèm.

3934
00:14:40,820 --> 00:14:53,760
Vì vậy, chúng tôi sẽ chèn số không. Và từ hai đến không, từ 2.0, không có. Vì vậy chúng ta sẽ chèn số 0 vào đây. Giá trị mặc định bây giờ là 0 từ hai đến ba.

3935
00:14:53,940 --> 00:15:03,750
Chúng tôi đã có giá trị của bạn từ hai lên một, bây giờ từ hai lên hai. Chúng tôi không có bất kỳ sự trợ giúp nào từ việc này, không phải hai đến hai. Vì vậy, bây giờ chúng ta sẽ chèn số 0 vào đây từ hai đến ba.

3936
00:15:03,780 --> 00:15:14,610
Chúng ta có 8,8, hãy chèn vào đây 4. Chúng ta cũng có thể chuyển từ hai lên hai. Vì vậy, ở đây chúng ta sẽ chèn bốn từ hai lên bốn, từ hai lên bốn.

3937
00:15:14,760 --> 00:15:27,090
Chúng tôi không có viện trợ. Vì vậy, bây giờ hãy chèn số 0 vào đây từ ba đến ba. Chúng tôi không có bất kỳ tình yêu nào từ điều này. Không xử lý nút này ba. Vì vậy bây giờ chúng ta hãy chèn số 0 vào đây từ ba đến bốn.

3938
00:15:27,240 --> 00:15:43,530
Chúng tôi cũng có tám công cụ được chèn vào đây. Chúng ta có thể di chuyển từ bốn đến ba. Vì vậy bây giờ chúng ta hãy chèn vào đây H2 từ bốn đến một. Chúng tôi không có. Hãy chèn nhật ký của bạn bây giờ từ bốn đến hai.

3939
00:15:43,920 --> 00:16:01,260
Chúng tôi không có cái nào cả. Vì vậy bây giờ hãy chèn số 0 vào đây từ 4 đến 4. Chúng ta không có tuổi từ 44. Vậy hãy lấy số 0 tại chỗ. Nếu chúng ta có một vòng lặp như thế này, chỉ khi đó nó mới giữ được trọng lượng của cạnh này vì chúng ta không có tình yêu ở đây.

3940
00:16:01,830 --> 00:16:13,680
Vì vậy, trong tạp chí của bạn như vậy? Như vậy chúng ta đã xây dựng được ma trận kề cho đồ thị vô hướng này hoặc đã làm và đây là cách biểu diễn đồ thị vô hướng rối loạn bằng ma trận kề.

3941
00:16:14,250 --> 00:16:23,970
Bây giờ hãy xem thuật toán. Đây là thuật toán cho đồ thị có trọng số, vô hướng. Chúng tôi có lớp học. Ở đây chúng tôi có. Thêm cái này vào ma trận và chúng ta có ở đây.

3942
00:16:23,970 --> 00:16:41,670
Biến này là gì? Ở đây chúng ta có biểu đồ hàm tạo. Nó lấy các đỉnh làm đầu vào và trường đại học Novartis cho biến này và tuyển dụng theo số liệu giảm dần với một số hàng và số cột khác nhau.

3943
00:16:42,090 --> 00:17:00,570
Và ở đây chúng tôi đang thêm việc sử dụng chức năng này. Thêm vào đó là cần có ba tham số Isaiah và nó và chúng tôi đang đặt trọng số cho ISS hiện tại. Chúng ta có thể di chuyển từ A đến B và từ B đến E, và đó là lý do tại sao chúng ta thiết lập giống hệt nó.

3944
00:17:00,570 --> 00:17:10,560
Và thế là xong. Hãy làm điều đó. Và ở đây chúng tôi đang loại bỏ IS bằng cách đặt về 0. Và ở đây chúng ta chỉ trả về biểu đồ hướng lên trên biểu diễn chuỗi.

3945
00:17:11,070 --> 00:17:24,180
Chúng tôi có trình tạo chuỗi của bạn ở đây. Chúng tôi đang chạy biểu mẫu cho IE từ số 0 đến số trừ một chèn ở đây hoặc nối thêm chỉ mục, cộng với dấu hai chấm. Và ở đây chúng ta đang chạy một vòng lặp tới hàng hiện tại này.

3946
00:17:24,630 --> 00:17:41,800
Đây là việc kiểm tra xem không có kết quả nào về 0, sau đó chúng tôi sẽ thêm Android 0 vắng mặt ở đây hoặc thêm Dòng mới và ở đây hoặc trả lại. String, chúng tôi đang chuyển đổi Dustin Builder thành chuỗi và chúng tôi đang giữ lại chuỗi, đây là cách biểu diễn chuỗi.

3947
00:17:41,980 --> 00:17:52,170
Hàm này sẽ trả về chuỗi biểu diễn trọng lực của chúng ta cho cấu trúc ở đây. Khởi đối tượng này đi tới đồ thị mới có năm năm là câu kệ.

3948
00:17:52,180 --> 00:18:06,370
Vì vậy, chúng ta sẽ tạo ma trận kề với năm hàng và năm cột. Và đây, hãy vẽ năm nốt nhạc. Nếu bạn gọi phương thức này bằng 0 một hai hai thì nó đã đi từ 0 đến một.

3949
00:18:06,670 --> 00:18:18,860
Chúng ta có một cạnh, và ở đây chúng ta sẽ chèn hai từ 0 vào một, từ 0 đến một ở đây. Chúng tôi sẽ chèn hai. Và chúng ta cũng có hướng từ 1 tới 0.

3950
00:18:18,970 --> 00:18:32,440
Vì điều này được đánh giá thấp. Vì vậy, chúng tôi cũng sẽ chèn vào đây hai. Nếu bạn gọi lại hàm này, số 0 cho ba sẽ có kết nối từ 0 đến bốn với ba.

3951
00:18:32,830 --> 00:18:46,120
Vì vậy, ở đây, từ 0 đến 4, chúng ta sẽ chèn vào đây ba và từ 4 đến 0, chúng ta sẽ có từ ba. Bây giờ hãy gọi phương thức này bằng 0 ba năm từ 0 đến 3.

3952
00:18:46,660 --> 00:18:58,150
Ở đây từ này là năm. Từ này là năm. Vì vậy, từ 0 đến 3, oId là 5. Vì vậy, hãy chèn vào đây năm. Và chúng ta có hướng từ ba đến không.

3953
00:18:58,330 --> 00:19:13,540
Vì vậy, ở đây bạn sẽ có năm. Có thể gọi hàm này bằng một, hai và bốn ở đây ở giữa hai nốt một và hai này. Cái chúng ta chưa có là bốn à? Vậy hãy chèn số tám này vào đây một và hai ngay tại đây.

3954
00:19:13,540 --> 00:19:25,360
Vậy hãy chờ ở đây. Bạn có thể chuyển từ hai sang một. Vì vậy, ở đây chúng ta cũng sẽ chèn bốn. Nếu bạn gọi lại phương thức này, một ba ba từ một đến ba.

3955
00:19:25,390 --> 00:19:38,560
Ở đây chúng ta có một là nó với ba? Hãy chèn số ba vào đây. Một, ba ba. Và chúng ta có hướng từ hai đến một, từ ba đến một. Đây, hãy chèn vào đây.

3956
00:19:38,570 --> 00:19:55,390
Ba. Bây giờ, hãy gọi phương thức này là hai ba bốn. Vì vậy, từ hai đến ba, chúng tôi có một sự chờ đợi. Hãy chèn thức ăn vào đây. Hai, hai, ba bốn.

3957
00:19:55,870 --> 00:20:09,660
Chúng ta có phương hướng từ hai đến hai, từ ba đến hai. Vì vậy ở đây chúng ta sẽ chèn bốn. Hãy gọi chức năng này đúng. Ba, bốn hai. Bây giờ chúng ta có một cách dễ dàng ở đây với trí thông minh.

3958
00:20:09,670 --> 00:20:29,170
Hai. Vì vậy, hãy chèn trí thông minh. Bốn, bốn, hai ba. Đây. Cách nó chấm dứt từ ba đến bốn, từ ba đến bốn là đến. Bây giờ chúng ta đã hoàn tất. Và ô trống hoặc phần cuối, trường có số 0 cũng vậy.

3959
00:20:29,560 --> 00:20:48,160
Giá trị mặc định là 0. Chúng tôi thấy rằng chúng tôi sử dụng các ô tiền trong ma trận này. Nếu có nhiều ISS hơn ở giữa các nút, nếu biểu đồ này là một biểu đồ hoàn chỉnh thì bạn sẽ có nhiều ô được sử dụng hơn trong ma trận này.

3960
00:20:48,760 --> 00:21:07,810
Nếu chúng tôi thấy số lượng ISS trong biểu đồ gần với ISS tối đa đó, chúng tôi sẽ sử dụng địa chỉ ma trận kề này mà bạn sẽ sử dụng ở nhà bản chất. Và đây là và đây là biểu diễn của đồ thị vô hướng, được định hướng ở đây.

3961
00:21:07,810 --> 00:21:22,000
Hãy điền vào ô cựu chiến binh bằng số không. Được rồi, chúng ta đã lấp đầy ô chân không bằng số 0 trong bộ nhớ máy tính. Ma trận kề này và ma trận này sẽ coi cấu trúc dữ liệu là biểu đồ.

3962
00:21:22,510 --> 00:21:45,100
Ma trận này sẽ đại diện một cách hợp lý, hợp lý như thế này trong đời thực. Thay vào đó, không một hai ba bốn, chúng tôi sẽ sử dụng việc gieo mầm hoặc chuyển chúng hoặc chúng tôi sẽ lưu trữ thông tin chi tiết về một thành phố hoặc một người hiện nay để hiểu về trọng lực của cấu trúc.

3963
00:21:45,340 --> 00:21:56,890
Chúng tôi đang cố gắng hiểu nguyên tắc cốt lõi của trọng lực đối với cấu trúc. Đó là những gì chúng tôi đang sử dụng ở đây, bút danh hoặc chuyển chúng, hoặc cảm thấy tội lỗi về thành phố hoặc thông tin chi tiết về con người.

3964
00:21:57,040 --> 00:22:08,830
Chúng tôi chỉ sử dụng một số số nguyên làm đỉnh hoặc nút để hiểu cách biểu diễn đồ thị vô hướng được xức và đồ thị vô hướng có thứ tự bằng ma trận kề.

3965
00:22:09,320 --> 00:22:25,360
Bây giờ, nếu bạn gọi phương thức này để xâu chuỗi phương thức này, bạn sẽ viết chuỗi này. Đây là văn bản thể hiện sức hút của chúng tôi đối với cấu trúc. Hy vọng bạn đã hiểu cách biểu diễn đồ thị bằng ma trận kề.

3966
00:22:25,780 --> 00:22:40,120
Trong video tiếp theo, chúng ta sẽ thấy cách trình bày biểu đồ có hướng chưa được xếp hạng và chúng tôi đã trình bày biểu đồ có
hướng bằng cách sử dụng AdSense, một ma trận sẽ xem Biểu đồ nếu trực giác của anh ấy sử dụng AdSense sẽ kiện video tiếp theo. 

@@@



3967
00:00:00,660 --> 00:00:14,850
Này, các bạn cũng vậy, chào mừng các bạn quay lại với video này. Trong video này, chúng ta sẽ xem cách thể hiện đồ họa bằng cách sử dụng quảng cáo như những thủ thuật thân mật, đồ thị có hướng chưa được xếp hạng và đồ thị có hướng được oited.

3968
00:00:15,090 --> 00:00:27,270
Đầu tiên, hãy nói về đồ thị có hướng, không trọng số. Bây giờ chúng ta sẽ nói về cách biểu diễn đồ thị có hướng không trọng số, hãy đến với Adam. Đây là biểu đồ của chúng tôi.

3969
00:00:27,810 --> 00:00:44,220
Trong biểu đồ này, chúng tôi có 2,5 điểm hỗ trợ hoặc nút VAR và chúng tôi có bảy con át và chúng tôi nói rằng hướng đó có liên quan đến kỷ băng hà. Vậy đây là đồ thị có hướng.

3970
00:00:44,430 --> 00:00:56,880
Không có từ nào liên quan đến con át. Vì vậy, đây là một biểu đồ có trọng số. Bây giờ chúng ta hãy xem. Hogan biểu diễn biểu đồ này bằng cách sử dụng số liệu kề mà chúng tôi có ở đây năm đỉnh.

3971
00:00:57,360 --> 00:01:12,930
Vì vậy, chúng tôi đã tạo một ma trận có năm số 0 và với năm cột, tôi đã tạo ra số 0. Chúng tôi sẽ chèn số không. Ở đây chúng tôi không có tình yêu. Không có cạnh nào từ nút 0 này tới nút 0 này.

3972
00:01:13,290 --> 00:01:25,770
Đó là lý do tại sao chúng tôi chèn số không vào đây. Bây giờ bốn không một, chúng ta thấy ở giữa không một, chúng ta có số tám. Đây là đi từ số không đến một. Vì vậy, ở đây chúng tôi sẽ chèn một.

3973
00:01:26,270 --> 00:01:39,720
Một nghĩa là chúng ta có số tám từ 0 đến 1 ở đây. Chúng ta không thể đi từ một đến không vì chúng ta không có phương hướng từ một đến không. Xin lỗi, chúng ta không thể đi từ một đến không.

3974
00:01:40,050 --> 00:01:54,180
Bây giờ là bốn, không và hai. Chúng tôi thấy không có cạnh. Vì vậy hãy chèn vào đây. Không bây giờ bốn không ba. Chúng ta có số 8 và nó đi từ nút 0 này từ 0 đến 3.

3975
00:01:54,510 --> 00:02:04,920
Vì vậy, ở đây chúng tôi sẽ chèn một. Chúng ta không có phương hướng từ ba đến 0 bây giờ là bốn không hai bốn từ 0 đến bốn. Chúng ta có một hướng đi, vì vậy hãy chèn vào đây một hướng đi.

3976
00:02:05,310 --> 00:02:18,060
Chúng ta không thể đi từ bốn đến không. Chúng tôi có một hướng từ nút này. Không hai bốn Bây giờ với một không, chúng ta không thể chuyển từ một sang không. Vì vậy bây giờ chúng ta hãy chèn số 0 vào đây từ một đến một.

3977
00:02:18,750 --> 00:02:31,760
Chúng tôi không có đủ ở nút này từ nút này đến nút này. Vì vậy, bây giờ chúng ta sẽ chèn số 0 vào đây từ một đến hai. Chúng tôi có một khoảng thời gian. Hãy chèn vào đây lúc một từ dưới ba.

3978
00:02:31,770 --> 00:02:44,040
Chúng tôi có một khoảng thời gian. Bây giờ hãy chèn vào đây một từ một đến bốn. Chúng tôi không có cái nào cả. Vì vậy bây giờ chúng ta hãy chèn số 0 vào đây từ hai đến 0. Chúng tôi chưa có cái nào cả.

3979
00:02:44,070 --> 00:02:58,040
Vì vậy bây giờ chúng ta hãy chèn số 0 vào đây từ hai đến một. Chúng tôi không có cái nào cả. Chúng ta có số 8, nhưng đây là số 1 tăng từ 1 lên 2. Nó không thể đi từ hai đến một.

3980
00:02:58,050 --> 00:03:08,490
Vì vậy chúng ta sẽ chèn số 0 vào đây. Đây là đồ thị có hướng chứ không phải đồ thị vô hướng. Bây giờ, từ 2 lên 2, chúng ta sẽ chèn số 0 vào đây, bây giờ từ 2 lên 3.

3981
00:03:08,520 --> 00:03:21,120
Chúng ta có chữ H. Và số này tăng từ 2 lên 3. Vì vậy, hãy chèn vào đây một từ hai đến bốn. Chúng tôi không có quân Át từ hai đến bốn. Vì vậy bây giờ chúng ta hãy chèn số 0 vào đây từ ba đến 0.

3982
00:03:21,150 --> 00:03:32,640
Chúng ta có chữ h, nhưng hướng đi từ 0 đến 3. Chúng ta không thể đi từ ba về không. Vậy bây giờ hãy giới thiệu số 0 từ ba xuống một. Chúng tôi có lợi thế, nhưng chúng tôi có hướng đi từ một đến ba.

3983
00:03:32,970 --> 00:03:43,680
Hãy thiết lập số không. Nó không thể đi từ ba đến một. Bây giờ, từ Typekit đến những gì chúng ta thấy, chúng ta có chữ h, nhưng hướng đi từ hai đến ba. Chúng ta không thể đi từ ba xuống hai.

3984
00:03:43,920 --> 00:03:56,190
Vì vậy bây giờ chúng ta hãy đặt số 0 không an toàn từ ba xuống còn ba. Chúng ta không có tình yêu nào ở đây, vì vậy chúng ta sẽ chèn số 0 vào đây từ ba đến bốn. Chúng ta thấy mình có lợi thế và hướng từ ba đến bốn.

3985
00:03:56,430 --> 00:04:07,410
Đó là chèn vào đây một bây giờ từ bốn đến không. Chúng ta có một cạnh, nhưng hướng đi từ 0 đến 4. Vậy bây giờ chúng ta hãy đặt số 0 từ 4 xuống 1. Chúng tôi không có lợi thế.

3986
00:04:07,410 --> 00:04:20,200
Bây giờ hãy chèn số 0 bốn bốn hai hai. Bây giờ chúng tôi không có lợi thế từ bốn đến hai. Chúng tôi thấy không có nút này cho +2. Vậy bây giờ chúng ta hãy thiết lập số 0 từ 4 xuống 3.

3987
00:04:20,220 --> 00:04:31,200
Chúng ta có lợi thế, nhưng hướng đi từ ba đến bốn. Vì vậy bây giờ hãy chèn số 0 vào đây, không chuyển tiếp tới số này, không phải số 4. Chúng ta không có cạnh, vì vậy hãy chèn số 0.

3988
00:04:31,420 --> 00:04:44,790
Chúng ta đã xong. Chúng tôi đã xây dựng ma trận kề cho đồ thị có hướng không trọng số này. Và đây là cách biểu đồ có hướng không có trọng số này được biểu thị bằng cách sử dụng các số liệu ở giữa.

3989
00:04:45,090 --> 00:04:55,860
Đây là cách biểu đồ có hướng không có trọng số này được thể hiện bằng cách sử dụng hai biểu đồ của chúng tôi kể từ Ma trận. Bây giờ hãy xem thuật toán. Đây là thuật toán biểu diễn đồ thị có hướng, không có trọng số.

3990
00:04:56,040 --> 00:05:08,010
Chúng tôi có biểu đồ lớp này ở đây. Chúng tôi đã thêm phần này vào ma trận Ma trận 2D vào khu vực. Ở đây chúng ta có biến Vargas. Đây là một hàm tạo. Phải mất một tham số của các nghệ sĩ.

3991
00:05:08,030 --> 00:05:18,960
Và phần thú vị chỉ là cái gì đây? Đây là biến. Và chúng ta đang tạo ma trận kiểu số nguyên với số ưu điểm, số cột và số lượng.

3992
00:05:19,400 --> 00:05:40,180
So với Rose, chúng ta có ở đây, rối loạn chức năng quảng cáo đã thêm tham số bổ sung cho thị trường này, và ở đây chúng ta có phòng chức năng của nó. Isaac cho biết: Rối loạn chức năng đánh dấu AMG bên trong rối loạn chức năng hoặc chỉ ngồi yên trước một cú đánh hoặc chỉ ngồi đá lạnh vì đây là biểu đồ có hướng ở đây tại rạp chiếu phim.

3993
00:05:40,190 --> 00:05:54,650
Bạn biết đấy, chúng ta chỉ xóa quân át khi đọc hai nốt bằng phương pháp này của ACE. Ở đây, chúng tôi có dự án này để phát trực tiếp trước tiên hoặc tuyên bố rằng việc xây dựng hơi nước đang khiến tình yêu của bạn dành cho AI từ con số 0 đến điểm trừ của Hardesty.

3994
00:05:54,660 --> 00:06:08,180
Bạn đang thêm AI cộng với cột này và chúng tôi đang lặp lại hàng hiện tại và thêm một hoặc không. Và ở đây chúng tôi đang chèn dòng mới và chúng tôi chỉ trả về biểu diễn chuỗi của biểu đồ.

3995
00:06:08,450 --> 00:06:24,990
Giả sử chúng ta khởi tạo lớp biểu đồ. Điều đó có nghĩa là chúng tôi đã tạo một đối tượng của biểu đồ này với năm nghệ sĩ. Vì vậy, chúng ta sẽ tạo I just vào Ma trận với năm cột và năm hàng.

3996
00:06:25,010 --> 00:06:36,050
Giả sử đây là biểu diễn logic của ma trận kề này. Nếu bạn gọi phương thức này, cộng là tám không một. Sau đó, từ số 0, chúng ta sẽ chèn một.

3997
00:06:36,380 --> 00:06:53,240
Vậy từ 0 đến 1, chúng ta có lợi thế. Vì vậy, hãy cộng vào đây và 8, giá trị mặc định cho ma trận này bằng 0. Ô trống có nghĩa là chúng ta có giá trị mặc định là 0 nếu chúng ta gọi phương thức này bằng 0 ở đây thay vì một.

3998
00:06:53,390 --> 00:07:06,200
Vậy hãy cộng vào đây, và nó từ 0 đến 4. Bây giờ, Đồ thị và cạnh số 0 ba sẽ thêm AIDS từ 0 lên 3. Vì vậy hãy chèn vào đây một cái. Vậy chúng ta có số 8 từ 0 đến 3.

3999
00:07:06,500 --> 00:07:17,540
Có lẽ chúng ta gọi phương pháp này với một hai ở đây trong một như vậy, chúng ta sẽ có bệnh AIDS từ một đến hai ở đây. Bạn có thể gọi phương thức này bằng cách thêm một ba. Chúng tôi sẽ chèn vào đây một cái.

4000
00:07:17,870 --> 00:07:33,860
Chúng ta sẽ có một hai ba xuất sắc nếu bạn gọi phương pháp này là hai ba. Chúng ta sẽ có ở đây. Một điều sẽ xảy ra. Là từ đây làm ba điều này. Nếu chúng ta gọi phương thức này là ba hoặc bốn, chúng ta sẽ chèn vào đây một và chúng ta sẽ có quân Át từ ba đến bốn.

4001
00:07:34,520 --> 00:07:48,170
Và nếu chúng ta gọi phương thức này để xâu chuỗi phương thức này thì nó sẽ trả về chuỗi này. Đây là cách biểu diễn đồ thị của chúng ta trong ma trận này cho ô phía sau hoặc đối với ô trống, chúng ta sẽ có số 0.

4002
00:07:48,320 --> 00:08:03,530
Vì vậy, hãy điền vào số 0 Sellwood còn trống. Vì vậy, chúng tôi đã lấp đầy giá, và do đó nó bằng không. Đây là sự thể hiện của biểu đồ này. Ma trận này được lưu trữ trong bộ nhớ máy tính của chúng ta và đây là biểu diễn logic của ma trận kề này.

4003
00:08:04,040 --> 00:08:16,220
Hy vọng chúng ta đã hiểu cách biểu diễn đồ thị có hướng không trọng số. Bây giờ hãy nói về đồ thị có hướng trong đồ thị này. Chúng tôi thấy rằng chiều rộng và thời gian có liên quan đến kỷ băng hà.

4004
00:08:16,460 --> 00:08:25,070
Vì vậy, đây là một đồ thị có hướng có trọng số. Bây giờ hãy xem cách chúng ta có thể biểu diễn đồ thị này bằng ma trận kề bốn không không. Chúng tôi sẽ chèn số không.

4005
00:08:25,220 --> 00:08:41,630
Không có cạnh nào từ nút này vẽ đến nút 0 này nếu chúng ta có một vòng lặp ở đây. Chỉ khi đó chúng ta mới chèn giá trị khác 0 từ 0 vào một. Chúng ta có số tám và ý định là chèn vào đây để chạy nó theo kiểu một ở đây, bây giờ chúng ta chỉ chèn hai từ 0 đến 2.

4006
00:08:41,720 --> 00:08:53,300
Chúng tôi không có ID, vì vậy bây giờ hãy tính số 0 như vậy từ 0 đến 3. Chúng ta có tám với năm. Vì vậy, hãy chèn vào đây số năm từ 0 đến 4. Chúng tôi có tám người chờ đợi.

4007
00:08:53,300 --> 00:09:03,790
Ba. Vì vậy, hãy chèn vào đây ba từ một đến không. Chúng ta có số tám, nhưng chúng ta không thể rời xa điều này. Không một nút nào ở nút này. Vì vậy bây giờ chúng ta hãy chèn số 0 vào đây từ một đến một.

4008
00:09:03,800 --> 00:09:13,200
Chúng tôi không có bất kỳ vòng lặp nào cho việc này, không phải từ cái này sang cái khác. Vì vậy bây giờ chúng ta hãy chèn số 0 vào đây từ một đến hai. Chúng ta có một lợi thế mà chúng ta đang chờ đợi. Chúng tôi có hướng từ một đến hai.

4009
00:09:13,250 --> 00:09:22,160
Vì vậy, bây giờ hãy chèn vào đây từ một đến ba. Chúng ta có cạnh bằng ba và chúng ta có hướng từ một đến ba. Vì vậy, hãy chèn vào đây ba bây giờ từ một đến bốn.

4010
00:09:22,580 --> 00:09:35,040
Chúng ta không có số 8, vậy bây giờ chúng ta hãy đặt số 0 từ 2.0. Chúng ta không có lợi thế, vì vậy bây giờ chúng ta hãy bất an bằng 0 từ hai xuống một. Chúng ta có số tám, nhưng chúng ta không thể chuyển từ hai sang một.

4011
00:09:35,060 --> 00:09:46,130
Vì vậy, hãy chèn số 0 của bạn vì đây là hướng đồ thị có hướng ở đây. Một cái gì đó như thế này. Sau đó chúng ta nên chèn vào đây bốn. Nhưng ở đây chúng ta không có chiều hướng từ hai đến một, từ hai đến hai.

4012
00:09:46,340 --> 00:09:57,890
Chúng ta không có tình yêu từ hai đến hai. Vì vậy, hãy chèn số 0 vào đây bây giờ từ 2 đến 3, chúng ta có chữ h với hướng từ 2 đến 3 và đợi nó. Vì vậy, bây giờ hãy chèn vào đây từ hai đến bốn.

4013
00:09:58,040 --> 00:10:07,940
Chúng tôi không có ID, vì vậy bây giờ hãy chèn số 0 vào đây từ ba đến 0. Chúng ta có h, nhưng chúng ta không thể di chuyển từ hai đến không. Vì vậy bây giờ chúng ta hãy chèn số 0 vào đây từ ba đến một.

4014
00:10:08,060 --> 00:10:15,320
Chúng tôi có ID, nhưng chúng tôi không thể chuyển từ ba sang một. Vậy bây giờ chúng ta hãy thiết lập số 0 từ ba thành hai. Chúng ta có lợi thế, nhưng chúng ta không thể chuyển từ ba lên hai.

4015
00:10:15,500 --> 00:10:28,220
Vì vậy bây giờ chúng ta hãy chèn số 0 vào đây từ hai đến ba. Chúng tôi không có cái nào cả. Hãy tìm cái này, không phải ba. Vì vậy, hãy viện số không. Bây giờ, từ ba lên bốn, chúng ta có độ tuổi có thời lượng từ kỹ thuật số bây giờ là từ ba lên bốn.

4016
00:10:28,240 --> 00:10:38,710
Ở đây chúng tôi có độ tuổi là hai tuổi và chúng tôi có định hướng từ ba đến bốn tuổi. Vì vậy, hãy khởi tạo sự thôi thúc đến bây giờ từ 4.0 mà chúng ta có, nhưng thời lượng là từ 0 đến 4.

4017
00:10:39,010 --> 00:10:49,970
Bây giờ chúng ta không thể chuyển từ bốn về 0 từ bốn sang một. Chúng ta không có độ tuổi không an toàn bằng 0 từ 42. Chúng ta không có độ tuổi, vì vậy hãy đặt số 0 không an toàn từ bốn đến ba.

4018
00:10:49,970 --> 00:11:03,580
Bạn có một tuổi, nhưng hướng từ hai đến bốn. Bây giờ chúng ta hãy nghe từ bốn đến bốn. Chúng tôi không có bất kỳ tình yêu nào trong ghi chú này. Nếu chúng ta có niềm đam mê văn học từ bốn đến bốn, hãy chèn vào đây sự hóm hỉnh gắn liền với thời đại này.

4019
00:11:03,850 --> 00:11:14,530
Nhưng ở đây bạn không có chút tình yêu nào nên hãy viện số 0. Chúng ta đã xong. Chúng tôi đã giải quyết được vấn đề này. Bây giờ hãy xem thuật toán. Đây là thuật toán cho đồ thị có hướng có trọng số.

4020
00:11:14,740 --> 00:11:24,220
Chúng tôi có những số liệu này. Sau đó chúng ta có biến juarez ở đây. Người xây dựng ở đây đang tuyển dụng làm chỉ số trung tâm và chúng tôi đang đặt mức trung bình cho nơi này có thể thay đổi.

4021
00:11:24,610 --> 00:11:35,650
Ở đây chúng ta có phương pháp này là nó bám vào tham số trí thông minh, ý tưởng và sự thông minh của kẻ ngốc. Ở đây chúng ta đang chèn trọng số vào nó và chỉ số Z. Ở đây chúng tôi đang loại bỏ is.

4022
00:11:35,830 --> 00:11:47,200
Chúng tôi đang đặt thành 0 và ở đây bằng hàm này, thành một chuỗi hoặc trả về biểu diễn văn bản của biểu đồ. Giả sử chúng ta khởi tạo lớp này với năm.

4023
00:11:47,290 --> 00:12:02,950
Vì vậy, chúng ta sẽ tạo một ma trận với Quy tắc năm và cột năm. Đây là ma trận và đây là biểu diễn đồ thị của ma trận này. Bây giờ chúng ta gọi phương thức này là thêm vào, nó sẽ thêm vào chỉ số 0, một ở 0 và một ở đây vào nhưng hai.

4024
00:12:03,100 --> 00:12:19,350
Vì vậy, ở đây chúng ta sẽ có tám từ 0 đến một với hai nếu bạn gọi phương thức này là 0 bốn ba không bốn ba. Vì vậy, ở đây bạn chèn ba sẽ có quân Át từ 0 đến 4 với thời lượng từ 0 đến 4 với trọng số là 3.

4025
00:12:19,510 --> 00:12:28,810
Nếu chúng ta gọi phương thức này bằng 0 ba là năm, thì ở đây bạn sẽ chèn năm từ 0 vào ba. Chúng ta sẽ có số tám với thời lượng từ 0 đến 3.

4026
00:12:29,290 --> 00:12:40,600
Năm. Nếu bạn gọi phương thức này lúc tám giờ là một hai bốn từ một đến hai, bạn sẽ có bốn. Vì vậy, bạn sẽ có h từ một đến hai ở đây với Trọng lượng bốn.

4027
00:12:41,200 --> 00:12:54,160
Nếu chúng ta gọi phương pháp này là một ba ba từ một đến ba ở đây bạn sẽ có từ ba ở đây sẽ có tám phẩy một hai với trọng số ba. Có thể gọi phương thức này là hai ba bốn hai ba.

4028
00:12:54,490 --> 00:13:04,450
Vì vậy, ở đây bạn sẽ có bốn và bạn sẽ có chữ H từ hai đến ba với trọng số dành cho bạn. Chúng ta gọi lại phương pháp này là ba bốn hai từ ba đến bốn.

4029
00:13:04,480 --> 00:13:15,880
Ở đây chúng ta cũng sẽ chèn hai cái được chèn vào đây. Vì thế từ ba thành hai, chúng ta sẽ dễ dàng dung hòa hai điều đó ở đây. Giá trị mặc định là 0, vì vậy hãy điền vào trường phía sau.

4030
00:13:15,880 --> 00:13:32,680
Vì vậy, nó bằng không. Trong ma trận này, chúng ta thấy rằng chúng ta có tổng cộng 4,5 bằng 2,5 ô, nhưng chúng ta chỉ sử dụng 7 ô. Vì thế. Vì vậy, đối với kiểu lấy này, danh sách kề là lựa chọn tốt nhất.

4031
00:13:33,010 --> 00:13:45,400
Trong video tiếp theo, chúng ta sẽ nói về danh sách kề. Bây giờ, nếu chúng ta gọi phương thức này để xâu chuỗi thì tất cả đều được viết dưới dạng văn bản của biểu đồ này, đây là cách biểu thị văn bản của biểu đồ này.

4032
00:13:45,640 --> 00:14:07,420
Đây là những gì chúng tôi sẽ trình bày và thực hiện. Đồ thị có hướng xấu đã hiểu cách biểu diễn đồ thị bằng ma trận kề. Ma trận này phải được lưu trữ trong bộ nhớ máy tính của bạn và đây chỉ là cách biểu diễn logic của ma trận này, người hiểu đây là video giải thích bất kỳ câu hỏi nào, nếu có vấn đề.

4033
00:14:07,420 --> 00:14:17,110
Hiểu được điều này cùng với lời giải thích, Howley khuyến khích bạn đăng vấn đề của mình
lên diễn đàn Hỏi đáp. Cảm ơn đã xem video này. Tôi sẽ gặp bạn trong video tiếp theo. 

@@@



4034
00:00:00,610 --> 00:00:14,980
Này, các bạn cũng vậy, chào mừng bạn quay trở lại với video này trong video này, các bạn sẽ nói về cách biểu diễn đồ họa bằng cách sử dụng danh sách Ad Jacintha trong video này hoặc sẽ xem cách biểu diễn đồ thị không có trọng số, vô hướng và đồ thị có hướng không có trọng số.

4035
00:00:15,760 --> 00:00:27,250
Bây giờ hãy xem cách chúng ta có thể biểu diễn đồ thị không có trọng số, đồ thị vô hướng và đồ thị có hướng không có trọng số bằng cách sử dụng danh sách kề. Đầu tiên, hãy nói về đồ thị vô hướng, không có trọng số.

4036
00:00:27,580 --> 00:00:40,000
Sau đó, bạn sẽ nói về đồ thị có hướng không trọng số. Bây giờ chúng ta hãy nói về đồ thị vô hướng, không có trọng số. Cuộc bao vây. Một ví dụ về đồ thị vô hướng, không có trọng số.

4037
00:00:41,410 --> 00:00:58,390
Trong biểu đồ này, chúng ta thấy rằng chúng ta có năm loại vi-rút và chúng ta có 2,7, điều này chúng ta không có hướng và trọng số liên quan đến bất kỳ trường hợp nào. Vậy đây là đồ thị vô hướng, không có trọng số.

4038
00:00:58,960 --> 00:01:14,350
Bây giờ làm thế nào chúng ta có thể biểu diễn đồ họa này bằng cách sử dụng danh sách I just. Đầu tiên, chúng ta sẽ làm gì? Chúng ta sẽ tạo ra một mảng Lindquist. Chúng ta sẽ tạo một mảng gồm năm mặt vì ở đây chúng ta có năm loại virus.

4039
00:01:15,380 --> 00:01:32,120
Quyết định đi, Ari, Ari này sẽ giữ Lindquist ở giữa các tiếp viên hàng không và một. Chúng tôi có số tám. Vì vậy, hãy tạo ra nó, không phải với cái đó. Và chúng ta sẽ kết nối nó với chỉ số 0 này.

4040
00:01:33,140 --> 00:01:45,500
Sau đó nó sẽ được đại diện như thế này. Ở đây chúng ta thấy chúng ta có hướng từ 0 tới 1 và từ 0 mong muốn. Và chúng ta sẽ thêm ghi chú có giá trị 0 từ chỉ mục này.

4041
00:01:45,500 --> 00:01:58,580
Một cái gì đó như thế này. Vậy là chúng ta có hai loại virus ở đây. Từ không đến một và từ một đến không. Bây giờ chúng ta có 2, 246, 0 và 4. Ở đây chúng ta có một con át chủ bài.

4042
00:01:58,940 --> 00:02:12,620
Bây giờ chúng ta sẽ tạo A. Lưu ý với quy tắc bốn này và chúng ta sẽ thêm nút đó làm nút tiếp theo của nút này. Vì vậy, hãy thêm vào đây bốn. Vì vậy, chúng ta phải cạnh từ 0 đến 1 và từ 0 đến 4.

4043
00:02:13,250 --> 00:02:24,890
Vì điều này là vô hướng nên chúng ta sẽ có thời lượng từ 4 đến 0. Vì vậy, hãy thêm vào đây một ghi chú khác có giá trị bằng 0, đại loại như thế này. Bây giờ, từ 0 đến 3, chúng ta thấy mình có lợi thế.

4044
00:02:25,190 --> 00:02:38,240
Vì vậy, hãy thêm vào đây một nút tiết lộ khác. Chúng tôi cũng có định hướng từ 2.0, vì vậy hãy thêm vào đây một lưu ý, chúng tôi đã phát triển không thứ gì đó như thế này từ một đến hai, chúng tôi thấy.

4045
00:02:38,300 --> 00:02:52,550
Chúng tôi có lợi thế. Vì vậy, hãy thêm vào, không phải ở chỉ số một ở đây. Chúng tôi muốn thêm nút có giá trị hai làm nút tiếp theo của nút này, vì chúng tôi không có nó ở đây.

4046
00:02:52,640 --> 00:03:03,240
Vì vậy, hãy cộng theo thứ tự ở đây, vì đây là phép cộng vô hướng, bạn sẽ có chiều từ hai đến một. Vậy chúng ta hãy thêm vào đây một cái khác từ cái này cái này với cái này là gì?

4047
00:03:03,260 --> 00:03:17,960
Nó là gì? Ba. Chúng tôi có số tám. Vì vậy hãy thêm theo thứ tự. Ba ngay đây. Và không phải một ở đây, chúng ta có thể đi từ ba lên một, và bây giờ chúng ta có thể đi từ một đến ba từ hai lên ba.

4048
00:03:17,980 --> 00:03:33,850
Chúng tôi thấy chúng tôi có lợi thế. Chúng tôi không có bất kỳ phương hướng nào. Chúng ta có thể đi từ hai đến ba và hai đến hai. Vì vậy, hãy thêm vào đây trong Nút ba và ngay tại đây theo thứ tự INORDERTO để bạn có thể đi từ hai lên ba và sẽ đi từ hai lên hai.

4049
00:03:34,570 --> 00:03:44,680
Cuối cùng, chúng ta có hai loại virus này và ở đây chúng ta có tám loại. Ở đây chúng ta xem liệu chúng ta có thể đi từ ba đến bốn hay không. Vì vậy, hãy thêm vào đây trong Nút bốn, chúng ta sẽ đi từ bốn lên ba.

4050
00:03:44,860 --> 00:03:57,220
Vì vậy, hãy thêm một nút khác. Chúng tôi phát triển ba ở đây. Chúng ta thấy rằng chúng ta có thể đi từ ba lên bốn và chúng ta có thể đi từ bốn lên ba. Và đây là cách biểu diễn cấu trúc trọng lực này là danh sách kề không đủ năng lực.

4051
00:03:57,220 --> 00:04:09,460
Có nghĩa là những gì sẽ lưu trữ danh sách kề này? Đây là sự biểu diễn logic của danh sách kề này. Bây giờ hãy xem thuật toán. Đây là thuật toán cho đồ thị có chú thích, vô hướng.

4052
00:04:09,820 --> 00:04:33,520
Chúng tôi có Vargas và ở đây chúng tôi có rất nhiều nhà ngôn ngữ học. Nhà ngôn ngữ học, tác giả, số nguyên. Đây là danh sách kề. Ở đây chúng ta có hàm tạo. Đó là hai x Vargas làm đầu vào và chúng tôi đang ngồi đây xem nó là gì đối với kẻ nổi loạn này và chúng tôi đang tạo ra nhà ngôn ngữ học và chúng tôi đang chèn nhà ngôn ngữ học vào khu vực này bằng cách sử dụng phần theo dõi từ chỉ số 0 hai so với trừ một.

4053
00:04:33,700 --> 00:04:42,940
Và ở đây chúng ta có phương thức, và chính phương thức này lấy hai tham số nguồn và đích, và ở đây chúng ta đang chèn ghi chú đó thêm hai chỉ mục hiện tại.

4054
00:04:43,300 --> 00:04:56,710
Và ở đây chúng ta có phương pháp in đồ thị. Phương pháp này tất cả in biểu đồ. Bây giờ hãy xem nó thực sự hoạt động như thế nào. Giả sử chúng ta khởi tạo biểu đồ lớp này với giá trị năm ở đây.

4055
00:04:56,710 --> 00:05:08,260
Năm phút. Chúng tôi có năm nghệ sĩ, vì vậy hãy bỏ ở đây và Eric với năm yếu tố. Và ở đây bạn sẽ lưu trữ danh sách liên kết. Đây không phải là một mảng số nguyên. Đây là lỗi danh sách liên kết.

4056
00:05:08,650 --> 00:05:22,270
Và đây là cách biểu diễn logic. Bây giờ, nếu chúng ta gọi phương thức này, thì add bằng 0, chúng ta sẽ tạo một nút có giá trị bằng 1. Và ở đây nó sẽ tạo một nút có giá trị bằng 0 và chèn vào đây.

4057
00:05:22,480 --> 00:05:39,040
Nó có nghĩa là mọi hướng từ 0 đến một và từ một kỹ thuật số. Vậy hãy cộng thêm, ở đây là giữa hai nghệ sĩ này. Không và một. Bây giờ, nếu chúng ta gọi phương thức này, cộng bằng 0 và bốn sẽ cộng bốn ở đây và chúng ta sẽ cộng số 0 ngay tại đây.

4058
00:05:39,070 --> 00:05:50,770
Nó có nghĩa là chúng ta có thể đi từ 0 đến 4 và chúng ta có thể đi từ 4 đến Juneau. Vì vậy hãy thêm một is vào đây. Nếu chúng ta gọi phương thức này bằng 0 và 3 sẽ cộng 3 ngay ở đây và chúng ta sẽ cộng 0 ngay ở đây.

4059
00:05:51,310 --> 00:06:08,170
Nó có nghĩa là chúng ta có thể đi từ 0 đến 3 và chúng ta có thể đi từ 2 đến 0. Vậy hãy thêm chữ h ở Anh nhé, khó quá. Đây là số không và ba. Có thể gọi phương thức này bằng một và hai sẽ tạo một nút có giá trị để chèn vào đây và nó sẽ tạo một nút có một.

4060
00:06:08,170 --> 00:06:20,050
Và ở đây như vậy. Vậy chúng ta có thể đi từ một đến hai và từ hai đến một. Vì vậy, hãy thêm một ID để đọc cái này vào cái cuối cùng của cái gì đó như thế này nếu bạn gọi phương thức này bằng một và ba.

4061
00:06:20,530 --> 00:06:29,290
Bây giờ hãy tạo một ghi chú có ba. Và hãy chèn vào đây, hãy chuyển sang một và hãy chèn vào đây để chúng ta có thể đi từ một đến ba và từ ba đến một.

4062
00:06:29,530 --> 00:06:43,120
Vì vậy, hãy thêm một cạnh ở đây từ hai lên ba, bởi vì bây giờ chúng ta gọi phương thức này là hai và ba. Đó là lưới và nút có giá trị ba. Và hãy chèn vào đây và tạo một nút có hai giá trị hợp lệ và hãy chèn vào đây.

4063
00:06:43,150 --> 00:06:52,210
ĐƯỢC RỒI. Vậy bạn có thể đi từ hai lên ba và chúng ta sẽ đi từ hai lên hai. Vì vậy, chúng ta hãy thêm một là trong việc đọc này để có nghệ sĩ. Bây giờ chúng ta gọi phương thức này là ba và bốn.

4064
00:06:52,520 --> 00:07:01,960
Hãy nối lưới vào. Chúng ta phát triển bốn, và hãy thêm nó vào đây và hãy thoát chứ không phải ba. Và hãy cộng nó vào đây để chúng ta có thể tăng từ ba lên bốn và tôi sẽ tăng từ bốn lên ba.

4065
00:07:01,970 --> 00:07:18,940
Hãy thêm một chữ vào giữa hai nghệ sĩ này. Vậy hãy thêm một thành phần quá khó nhé. Đây có phải là để vào không? Bây giờ chúng ta gọi phương pháp này là in đồ thị. Phương pháp này sẽ in biểu đồ đó do cấu trúc danh sách kề này và đây là đầu ra của hàm in biểu đồ này.

4066
00:07:19,510 --> 00:07:34,300
Vì vậy, mỗi lần gọi phương thức này, nó sẽ in. Đầu ra này sẽ hiểu rõ cách biểu diễn đồ thị có chú thích, vô hướng bằng danh sách kề. Bây giờ hãy nói về cách biểu diễn đồ thị có hướng không trọng số.

4067
00:07:34,720 --> 00:07:46,330
Đây là một ví dụ về đồ thị có hướng không có trọng số mà chúng tôi chưa liên kết đến. Đây có phải là hướng gắn liền với Đông Á nên đây là biểu đồ có định hướng, tiết chế.

4068
00:07:46,900 --> 00:07:59,290
Vì vậy, đây là một đồ thị có hướng được chú thích. Hãy xem. Biểu đồ này bắt đầu như thế nào? Ở đây chúng tôi có năm nghệ sĩ, vì vậy chúng tôi sẽ tạo một danh sách liên kết RF của năm trang web vì ở đây chúng tôi có năm đỉnh.

4069
00:07:59,860 --> 00:08:14,000
Ở đây chúng ta có chỉ số từ 0 đến 4, bây giờ từ 0 đến 1, chúng ta có h. Vùng này đi từ 0 đến một. Vì vậy, hãy tạo một nút. Một và hãy cộng vào đây, điều đó có nghĩa là chúng ta có thể đi từ khác không này đến không một.

4070
00:08:14,390 --> 00:08:26,410
Chúng ta không thể đi từ một đến không, vì vậy bây giờ chúng ta sẽ không tuân theo nốt số 0 từ số 0 và số 4. Chúng ta có thể đi từ số 0 đến số 4. Vì vậy, hãy cộng vào đây để chúng ta có thể đi từ 0 đến 3, vì vậy hãy tuân thủ nó.

4071
00:08:26,420 --> 00:08:36,880
Không có giá trị ba. Bây giờ, từ một đến hai, chúng ta có thể đi từ một đến hai. Vì vậy, hãy thêm vào đây một ghi chú mà chúng tôi đã phát triển cho bạn từ một đến ba, chúng ta có thể đi từ một đến ba.

4072
00:08:36,890 --> 00:08:46,160
Vì vậy, hãy thêm một ghi chú ở đây. Bây giờ chúng tôi đã phát triển ba từ hai lên ba. Chúng tôi thấy nó. Chúng ta có thể đi từ hai đến ba. Vậy hãy thêm vào đây một gã mọt sách có giá trị. Ba.

4073
00:08:46,670 --> 00:08:57,770
Bây giờ chúng ta có cái này là chúng ta có thể đi từ hai lên bốn và bạn cũng có thể đi từ bốn lên ba. Vì vậy, trước tiên, chúng ta sẽ tạo một ghi chú có Giá trị 4 và hãy chèn ghi chú đó ngay tại đây.

4074
00:08:58,190 --> 00:09:05,720
Và hãy tạo một ghi chú khác mà chúng tôi đã phát triển ba và chèn ngay vào đây. Nó có nghĩa là chúng ta có thể đi từ ba lên bốn và chúng ta có thể đi từ bốn lên ba.

4075
00:09:06,740 --> 00:09:16,430
Đây là sự thể hiện của biểu đồ có hướng dẫn, có chú thích này. Chúng tôi đã hiểu cách đến Virginia và chúng tôi đã lập biểu đồ có hướng bằng cách sử dụng danh sách AdSense. Bây giờ hãy xem thuật toán.

4076
00:09:16,910 --> 00:09:30,030
Đây là thuật toán cho đồ thị có hướng có chú thích và thuật toán này tương tự như đồ thị chưa được xếp hạng, bị đánh giá thấp. Ở đây chúng ta có một dòng thay vì hai dòng trong các thuật toán trước đó mà chúng ta đã thấy.

4077
00:09:30,050 --> 00:09:44,470
Chúng tôi yêu cầu bạn nhập dòng tại dấu chấm đích của danh sách kể từ nguồn ở đây ngay bên dưới dòng này. Vì đây là biểu đồ có hướng mà chúng tôi có ở đây trực tuyến bây giờ, hãy xem nó hoạt động như thế nào.

4078
00:09:44,480 --> 00:09:56,870
Giả sử chúng ta tạo biểu đồ này cộng với 5 là các đỉnh, vì vậy chúng ta sẽ tạo một khu vực ngôn ngữ học có kích thước 5. Và đây là sự đại diện.

4079
00:09:56,870 --> 00:10:09,140
Đây là cách trình bày hợp lý của ý tưởng này, vì ít nhất bây giờ chúng ta gọi phương thức này bằng số 0. Chúng tôi sẽ thêm một đơn đặt hàng ở đây. Nếu chúng ta gọi phương thức này, add bằng 0, chúng ta sẽ thêm một nút ở đây có giá trị một.

4080
00:10:09,680 --> 00:10:23,660
Vì vậy, ở đây chúng ta có hướng từ 0 đến 1. Hãy thêm vào đây một h từ 0 đến một. Bây giờ, nếu chúng ta gọi phương thức này là số 0 bốn, chúng ta sẽ thêm vào đây để phát triển số 4 và chúng ta có hướng từ 0 đến 4, và ở đây chúng ta có s với thời lượng.

4081
00:10:24,900 --> 00:10:34,250
Bây giờ, nếu bạn gọi phương thức này bằng 0 ba, chúng ta sẽ tuân theo một tiết lộ nút và hãy thêm tám từ 0 đến 3 đại loại như thế này.

4082
00:10:34,880 --> 00:10:46,100
Có thể gọi phương thức này bằng một hai. Bây giờ chúng ta sẽ thêm một ghi chú ở đây. Chúng ta có thể đi từ một đến hai. Vì vậy, hãy thêm một nút ở đây và hãy thêm một cạnh đi từ một đến hai.

4083
00:10:46,610 --> 00:10:56,440
Bây giờ, hãy gọi phương thức này là cộng cạnh bằng một ba. Hãy thêm vào đây một nút ba. Vì vậy, chúng ta có một đến ba điểm xuất sắc, hãy thêm vào đây một cạnh có phản ứng từ một đến ba.

4084
00:10:57,610 --> 00:11:10,210
Nếu bạn gọi phương thức này là hai và ba, thì chúng ta sẽ thêm một cạnh từ hai vào ba ở đây. Và hãy thêm một ghi chú ở đây chúng tôi đã phát triển ba. Nếu gọi đây là không giỏi thì là ba hoặc bốn.

4085
00:11:10,270 --> 00:11:22,180
Và với add là thứ ba sẽ thêm ghi chú. Ở đây, chúng tôi phát triển bốn và chúng tôi sẽ thêm một nốt nhấn với sự hào hứng để chúng tôi có thể đi từ ba lên bốn và từ bốn lên ba.

4086
00:11:22,300 --> 00:11:35,710
Vì vậy, bạn sẽ có hướng từ bốn đến ba và cả từ hai đến bốn. Đây là cách biểu diễn đồ thị có hướng hoạt hình này và đây là cách chúng ta có thể biểu diễn và triển khai đồ thị có hướng năng lượng.

4087
00:11:36,400 --> 00:11:53,200
Nếu bạn gọi phương thức này là in biểu đồ, phương thức này sẽ in kết quả này. Đây là sự thể hiện của danh sách kề của chúng tôi. Đây là một. là danh sách được lưu trữ trong bộ nhớ máy tính của chúng tôi và danh sách kề này biểu thị một biểu đồ.

4088
00:11:53,590 --> 00:12:03,670
Đây là sự biểu diễn logic của danh sách kề này. Hy vọng chúng ta đã hiểu cách tạo ra
một biểu đồ có hướng xuất sắc, có chú thích và được định hướng và có chú thích. 

@@@



4089
00:00:00,720 --> 00:00:15,540
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này, chúng ta sẽ nói về cách biểu diễn một biểu đồ chỉ bằng cách sử dụng danh sách trong video này hoặc sẽ biểu diễn biểu đồ có hướng của tiện ích biểu đồ và biểu đồ được đánh giá thấp có trọng số.

4090
00:00:15,720 --> 00:00:24,390
Bây giờ hãy nói về cách biểu diễn đồ thị có hướng có trọng số. Sau đó chúng ta sẽ nói về đồ thị có thứ tự và có hướng. Bây giờ chúng ta sẽ nói về việc ngân sách hoặc biểu đồ vô hướng đã thực hiện điều này như thế nào?

4091
00:00:24,390 --> 00:00:34,470
Đó là một ví dụ về biểu đồ được đánh giá thấp. Trong biểu đồ này, chúng ta có 2,5 nhà chế tạo robot và bảy độ tuổi. Chúng tôi thấy những gì liên quan đến Ethan ở mọi lứa tuổi.

4092
00:00:34,560 --> 00:00:42,680
Vì vậy, đây là một biểu đồ có trọng số, nhưng không có sự giảm bớt nào đi kèm. Đây có phải là biểu đồ bị đánh giá thấp không? Bây giờ chúng ta hãy xem. Làm thế nào bạn hình dung được biểu đồ này?

4093
00:00:42,690 --> 00:00:54,180
Đầu tiên, hãy tạo một mảng ngôn ngữ học ở đây. Chúng tôi có chỉ số từ 0 đến 4. Đầu tiên, chúng ta có hai cái này. Bây giờ nó là số không và một ở giữa những gì chúng ta có và hiện tại.

4094
00:00:54,180 --> 00:01:05,640
Chúng ta sẽ làm gì? Chúng tôi sẽ tạo trong node. Nút sẽ có ba thuộc tính. Bây giờ chúng ta sẽ tạo và node. Nút này sẽ có ba thuộc tính trọng số đích và con trỏ hỗn hợp.

4095
00:01:05,700 --> 00:01:16,410
Điều đó thật tuyệt vời và không có ở đây với giá trị một và trọng số hai. Và hãy chèn nó vào đây. Nó có nghĩa là chúng ta có thể đi từ nút 0 này đến một nút có nghĩa đây là gì?

4096
00:01:16,500 --> 00:01:25,170
Vì vậy, chúng ta có thể đi từ đây. Cái này là cái gì vậy? Đây là cái gì? Và ở đây chúng ta có hai cái nào khi đọc cái này? Đây là cái gì? Chúng tôi không có bất kỳ định hướng nào nên chúng tôi có thể đi từ một kỹ thuật số.

4097
00:01:25,410 --> 00:01:40,350
Vì vậy, hãy chèn vào đây và ở đó, không phải với giá trị 0 và chúng ta có hai đỉnh nào ở giữa hai đỉnh này và nó có phải là ba không? Vì vậy, hãy chèn vào đây nút bốn và nút ba và ở đây cũng như nút 0 và nút nào?

4098
00:01:40,500 --> 00:01:50,160
Bây giờ ở giữa hai nút này, đôi khi tôi đang nói các nút và đôi khi tôi đang nói các đỉnh. Đừng nhầm lẫn. Các xoáy và nút ở đây giống nhau.

4099
00:01:50,190 --> 00:02:00,090
Zero và một cái cây trong việc làm lại điều này. Hãy làm những gì chúng tôi có. Và có phải là năm không? Hãy tạo lưới chứ không phải với ba. Và chúng tôi làm điều đó năm. Và hãy bắt đầu ngay tại đây.

4100
00:02:00,210 --> 00:02:09,090
Vì vậy, chúng ta có thể đi từ 0 đến 3 và chúng ta có thể đi từ 3 đến 0. Vì vậy, hãy nghe một lưu ý khác ở đây. Chúng ta có một số không và bây giờ từ một đến hai là năm.

4101
00:02:09,160 --> 00:02:20,110
Ở đây chúng ta có một số bằng bốn. Vì vậy, hãy chèn. Vì vậy, bây giờ chúng ta hãy chèn nút vào ngay tại đây chứ không phải nút ở ngay đây cho cả hai nút này. Đây là cái gì?

4102
00:02:20,130 --> 00:02:31,020
Chúng ta có một cách hai ba. Vì vậy, hãy chèn một nút ngay tại đây. Ba ba ba mà những người máy và cây cối đang chờ đợi. Và hãy chèn vào đây nút 1.3.

4103
00:02:31,230 --> 00:02:43,980
Bây giờ chúng ta có hai nghệ sĩ thứ hai và thứ ba. Vì vậy, hãy chèn Nút ba ở đây với từ cho và nút ở đây để thực hiện điều đó. Chúng ta có thể đi từ hai lên ba và chúng ta có thể đi từ hai lên hai.

4104
00:02:44,010 --> 00:02:56,550
Và bây giờ chúng ta có nó ở đây, từ ba đến bốn và bốn đến ba. Vì vậy, hãy đặt nút cho hai và ở đây là nút ba hai. Đối với điều này, nó là sự thể hiện của cấu trúc cấu trúc dữ liệu đồ thị này.

4105
00:02:56,550 --> 00:03:04,980
Đây chỉ là một biểu diễn logic và OB danh sách kề này được lưu trữ trong bộ nhớ máy tính. Bây giờ hãy xem thuật toán. Đây là thuật toán cho việc này.

4106
00:03:05,160 --> 00:03:16,890
Chúng tôi đã vẽ đồ thị vô hướng, chúng tôi có nút vẽ ở đây. Nút này có ba giá trị thuộc tính, trọng số và một con trỏ hỗn hợp. Và ở đây chúng ta có vitesses và ở đây chúng ta có khu vực Blinkist.

4107
00:03:16,920 --> 00:03:24,810
Điều này liền kề với danh sách. Và ở đây chúng ta có hàm tạo mà nó đảm nhận trên các đỉnh thuộc tính. Đây là những người ủng hộ biến này. Đây là cái gì?

4108
00:03:25,020 --> 00:03:36,630
Và chúng tôi đang tạo danh sách liên kết ở đây và hoặc chèn danh sách liên kết vào danh sách AdSense. Ở đây chúng tôi đã thêm, là phương pháp. Phương pháp này cần để quảng bá điểm đến nguồn và trí thông minh của bạn.

4109
00:03:36,960 --> 00:03:50,910
Và đây là cách chèn dữ liệu vào danh sách AdSense của chúng tôi và phương pháp chạy nước rút này sẽ in cấu trúc dữ liệu biểu đồ của chúng tôi. Khởi tạo lớp này với năm sẽ tạo ra một mảng có độ dài.

4110
00:03:50,910 --> 00:04:03,530
Năm. Cái này và nó sẽ lưu trữ cái tôi ngay từ danh sách. Đây là một khu vực của danh sách liên kết và đây là cách biểu diễn logic của cấu trúc dữ liệu lấy. Nếu bạn gọi phương thức này, hãy thêm nó vào số 0 một hai.

4111
00:04:03,540 --> 00:04:17,590
Tuy nhiên, có khi nào là đích và số không là nguồn. Vì vậy, ở đây chúng ta sẽ thêm một nút có giá trị một và chúng ta chờ xem liệu nút này có được đánh giá thấp ở đây và cả hai dòng này hay không.

4112
00:04:17,610 --> 00:04:31,200
ĐƯỢC RỒI. Ở đây chúng ta thấy rằng chúng ta có thể đi từ 0 đến 1 và từ 1 đến 0. Vì vậy, hãy cộng thêm tám năm chờ đợi để có thể gọi phương thức này. Chúng tôi đã thực hiện bốn và ba sẽ thêm một nút ở đây và ở đây với ba.

4113
00:04:31,350 --> 00:04:45,540
Vì vậy, hãy thêm vào đây một lợi thế với sự chờ đợi. Vì vậy, hãy cộng ở đây và cạnh với ba. Nếu bạn gọi phương thức này là 0 ba 5 ở đây, hãy thêm một cạnh. Và hãy thêm hai ghi chú ở đây và ở đây.

4114
00:04:45,930 --> 00:04:56,580
Vì vậy, hãy thêm một cạnh ở đây bằng trọng lượng. Năm. Có lẽ bạn gọi phương pháp này là một hai bốn. Ở đây chúng ta sẽ có cạnh có bốn, vì vậy chúng ta có thể di chuyển từ một đến hai.

4115
00:04:56,610 --> 00:05:05,310
Hãy thêm vào đây trong Node và thêm vào đây. Trong không, chúng ta có thể đi từ một đến hai và từ hai đến một với bốn. Vì vậy, bạn có thể đi từ một đến hai và từ hai đến một.

4116
00:05:05,610 --> 00:05:20,160
Và chúng tôi đã làm việc cho. Vì vậy, hãy tuân theo và chờ đợi có thể gọi phương thức này bằng một ba ba và hãy tạo A. Và hãy thêm vào đây hai nút này và hãy thêm vào đây một cạnh bằng ba.

4117
00:05:20,400 --> 00:05:30,290
Nếu bạn gọi câu ngạn ngữ này là hai, ba hoặc bốn, hãy thêm A. Chúng tôi phát triển ba. Và ở đây, hãy nói thêm rằng chúng tôi đã phát triển hai. Và ở đây chúng ta có bốn.

4118
00:05:30,300 --> 00:05:45,870
Vì vậy, hãy thêm vào đây và từ tuổi để có thể gọi lại phương thức này với ba bốn hai, chúng ta sẽ thêm Nút bốn ở đây và Nút ba ở đây với hai. Vì vậy, hãy thêm vào đây một công cụ lâu đời và đây là cách nó hoạt động.

4119
00:05:46,440 --> 00:06:02,730
Hy vọng bạn đã hiểu cách biểu diễn đồ thị được đánh giá thấp có trọng số. Bây giờ, nếu chúng ta gọi phương thức này là in biểu đồ, phương thức này sẽ in danh sách bổ sung và đây là đầu ra của mọi cách biểu diễn hoặc thực hiện đồ thị vô hướng đã hiểu.

4120
00:06:03,300 --> 00:06:13,200
Bây giờ chúng ta hãy nói về những gì đã làm cho biểu đồ có hướng bằng cách sử dụng danh sách AdSense. Bây giờ chúng ta sẽ nói về lý do tại sao trực giác lại bị tổn hại một cách vô hướng khi sử dụng AdSense?

4121
00:06:14,300 --> 00:06:31,460
Đây là biểu đồ của chúng tôi ở đây. Và gió gắn liền với những thời đại này. Và ở đây chúng tôi có AdSense. Danh sách được cho mượn này là danh sách AdSense. Bây giờ, ở giữa hai nút này, chúng ta có một cạnh để chèn ghi chú vào đây.

4122
00:06:31,940 --> 00:06:41,900
Bây giờ chúng tôi đã phát triển một và hai từ 0 đến 4. Ở đây chúng tôi có lợi thế với nó. Ba. Vì vậy, hãy cộng ở đây và không làm điều đó với ba và phát triển bốn.

4123
00:06:42,560 --> 00:06:55,880
Bây giờ ở đây chúng ta có một cạnh có trọng số là 5. Hãy thêm vào đây một lưu ý, chúng tôi thực hiện năm và phát triển ba bây giờ từ một thành hai. Ở đây chúng ta thấy chúng ta có trọng số cạnh cho Hãy tạo A. Chúng tôi phát triển hai.

4124
00:06:55,880 --> 00:07:12,860
Và hãy thêm nó vào đây. Ở đây chúng tôi hiện có nó từ những dây nịt này đến cái này. Đây là cái gì? Chúng ta có một h nặng ba. Vì vậy, hãy thêm vào đây A. Chúng tôi phát triển ba và với ba bây giờ từ hai lên ba, chúng tôi phải chờ đợi tám năm.

4125
00:07:13,040 --> 00:07:25,250
Hãy thêm vào đây trong nút có bốn và ba. Bây giờ, từ đây đến đây, chúng ta thấy chúng ta có hướng từ ba đến bốn và bốn hai ba và chúng ta có ở đây với hai.

4126
00:07:25,670 --> 00:07:36,770
Vì vậy hãy thêm vào đây để lưu ý. Ba đến bốn và bốn đến ba chúng ta có ở đây là hai. Và đây là biểu diễn của biểu đồ này theo cấu trúc sử dụng danh sách AdSense.

4127
00:07:37,070 --> 00:07:45,800
Bây giờ hãy xem thuật toán. Đây là thuật toán biểu diễn đồ thị có hướng. Ở đây chúng tôi có rất ít sự khác biệt. Ở đây chúng tôi chỉ có một dòng mã.

4128
00:07:46,100 --> 00:08:00,140
Nhưng trong thuật toán trước đó để tránh biểu đồ bị đánh giá thấp, chúng ta đã thấy ở đây một dòng khác. Nhưng ở đây chúng ta có trực tuyến vì một đồ thị có hướng. Hãy khởi tạo biểu đồ lớp này với giá trị.

4129
00:08:00,140 --> 00:08:11,480
Năm. Vì vậy, hãy tạo ra một nhà ngôn ngữ học Ả Rập. Và đây là sự biểu diễn của đồ thị. Nếu chúng tôi gọi phương thức này là ad age, tức là bạn không muốn nghe thấy bạn thêm vào node.

4130
00:08:11,720 --> 00:08:24,980
Và ở đây, hãy thêm một cạnh. Nếu bạn gọi, phương thức này sẽ thêm một nút ở đây và hãy thêm một cạnh vào đây hoặc ba. Nếu bạn gọi phương thức này bằng 0 ba năm, bạn thêm theo thứ tự ở đây.

4131
00:08:25,340 --> 00:08:39,860
Và hãy thêm một cạnh ở đây với năm. Nếu bạn gọi phương thức này, một hai bốn sẽ thêm vào các nút ở đây. Và hãy thêm một đứa trẻ tám tuổi vì nếu bạn gọi phương thức này bằng một ba ba thì ở đây sẽ thêm một cạnh.

4132
00:08:40,070 --> 00:08:54,140
Và hãy thêm vào đây một nút có ba và giá trị ba. Hãy cộng vào đây và mỗi cái bằng 0,3. Bây giờ từ hai lên ba. Bây giờ nếu bạn gọi, nếu bạn gọi phương thức này bằng hai ba bốn, ở đây bạn thêm một cạnh.

4133
00:08:54,140 --> 00:09:04,070
Và hãy thêm vào đây trong node. Nếu bạn gọi phương thức này bằng ba hoặc bốn, thì hai sẽ được cộng theo thứ tự ở đây. Và nếu bạn gọi phương thức này thì 42 sẽ thêm nút vào đây.

4134
00:09:04,730 --> 00:09:14,370
Ở đây chúng ta thấy rằng chúng ta có thể đi từ ba đến bốn và từ bốn đến ba. Vì vậy, ở đây bạn sẽ có hướng từ ba đến bốn và từ bốn đến ba. Một cái gì đó như thế này với hai.

4135
00:09:14,990 --> 00:09:31,430
Và đây là sự biểu diễn, và đây là cách thuật toán này hoạt động. Nếu bạn gọi phương pháp này là in biểu đồ, phương pháp này sẽ in danh sách AdSense
vào và đây là kết quả đầu ra, hy vọng bạn hiểu cách biểu diễn biểu đồ có hướng và biểu đồ được đánh giá thấp có trọng số bằng danh sách AdSense. 

@@@



4136
00:00:00,660 --> 00:00:12,860
Xin chào, rất nhiều bạn đã quay lại video này trong video này, chúng ta sẽ nói về lực hấp dẫn của thằn lằn bay là gì, ám chỉ quá trình xem các phán đoán của nó trong biểu đồ.

4137
00:00:13,740 --> 00:00:31,950
Bạn được cung cấp biểu đồ này làm đầu vào. Đầu tiên, nếu chọn một nút nguồn và từ nút không phải nguồn, bạn phải truy cập tất cả các đỉnh trong biểu đồ này. Và quá trình này được gọi là truyền tải đồ thị trong các kỹ thuật khủng bố đồ thị để truy cập tất cả các đỉnh trong đồ thị.

4138
00:00:32,730 --> 00:00:44,190
Bây giờ hãy nói về biểu đồ. Có một số kỹ thuật dành cho những kẻ khủng bố trong biểu đồ. Chúng tôi có hai phương pháp phổ biến là Bet Soldiers và Depth Foster's Office và DFS.

4139
00:00:45,000 --> 00:01:05,090
Bây giờ chúng ta hãy nói về Brett Forrester Brett Forster's là gì? Beerfest là một thuật toán giúp Java nhìn thấy trọng lực của cấu trúc. Nó bắt đầu từ một số ghi chú tùy ý trên biểu đồ và khám phá các vùng lân cận cho thuật toán quyết định năm đầu tiên dành cho những kẻ khủng bố và tóm lấy một công trình kiến ​​​​trúc.

4140
00:01:05,110 --> 00:01:18,370
Nó bắt đầu từ một số ghi chú tùy ý của biểu đồ và khám phá càng xa càng tốt. Cùng là tuổi trước khi quay lại. Đây là định nghĩa của văn học, và đây là định nghĩa của tìm kiếm theo chiều sâu.

4141
00:01:18,670 --> 00:01:31,150
Bây giờ hãy xem bit so với tìm kiếm đầu tiên hoạt động như thế nào. Vì vậy, chúng ta sẽ lấy một vài ví dụ để hiểu điều đó. Đầu tiên, hãy lấy ví dụ này.

4142
00:01:31,240 --> 00:01:41,960
Giả sử chúng ta đang đưa ra biểu đồ này. Chúng ta phải truy cập tất cả các đỉnh trong biểu đồ này để tìm cấu trúc. Chúng ta phải đánh dấu vào bất kỳ một đỉnh nào. Chúng ta có thể bắt đầu từ bất kỳ đỉnh nào.

4143
00:01:41,980 --> 00:01:59,220
Hãy bắt đầu từ đỉnh số 0 này. Bây giờ ở đây tôi sẽ xem câu đầu tiên, vậy chúng ta hãy xem thịt bò là Traverso. Đầu tiên, chúng ta phải chọn một cơn lốc. Chúng ta có thể chọn bất kỳ phán quyết nào làm loại phán quyết ở đây.

4144
00:01:59,240 --> 00:02:10,070
Tôi sẽ chọn những phán quyết này bằng không. Vì vậy, hãy phát triển những phán quyết này bằng không. Bây giờ điều tôi sắp làm là trước tiên tôi sẽ khám phá tất cả các phán quyết liền kề.

4145
00:02:10,910 --> 00:02:29,450
Bây giờ ở đây, tôi sẽ khám phá tất cả các phán quyết liền kề với phán quyết 0, một, ba và bốn này. Chúng ta có thể sửa các phán quyết liền kề này theo bất kỳ thứ tự nào mà chúng ta có thể chọn trong bốn ba một thứ tự hoặc chúng ta có thể tìm kiếm một, ba hoặc bốn, hoặc chúng ta có thể tìm kiếm một cho ba hoặc bốn một ba.

4146
00:02:30,260 --> 00:02:45,140
Chúng ta có thể chọn bất kỳ thứ tự nào, nhưng đó là cách bảo vệ việc thực hiện trọng lực đối với cấu trúc và thực hiện thuật toán B của mình. Nếu chúng tôi chọn cái của bạn cho phần còn lại, chúng tôi phải tuân theo một khuôn mẫu.

4147
00:02:45,620 --> 00:03:01,100
Bây giờ tôi sẽ chọn một. Hãy chọn ở đây một. Vì vậy hãy in ở đây một cái. Bây giờ tôi sẽ chọn bốn và tôi sẽ chọn ba. Vì vậy tôi chọn ba phán quyết liền kề theo thứ tự một bốn ba.

4148
00:03:01,760 --> 00:03:14,960
Vì chúng ta có những phán quyết này là những phán quyết đầu tiên. Vì vậy chúng ta phải khám phá hết cái cuối cùng. Tôi chỉ kết thúc với số không, ba và hai. Chúng ta thấy chúng ta đã khám phá số không và số ba.

4149
00:03:15,740 --> 00:03:26,900
Vì vậy, hãy chọn Vertex hai này. Vì vậy chúng ta sẽ chọn đỉnh này. Vì vậy, hãy in hai. Bây giờ chúng ta thấy rằng chúng ta đã khám phá tất cả các phán quyết trong biểu đồ này về cấu trúc.

4150
00:03:27,110 --> 00:03:45,310
Vậy là chúng ta đã hoàn thành việc này, mỗi một Beerfest hợp lệ từng thiết lập cấu trúc dữ liệu này nếu chúng ta chọn nút này như chúng ta chọn ở đây, đỉnh này là nút nguồn ở đây, đôi khi tôi nói là đỉnh và đôi khi nói nút vô nghĩa và Vertex là cùng một nhóm đây.

4151
00:03:45,320 --> 00:03:58,040
Chúng tôi sẽ in một cái đầu tiên vì chúng tôi đã chọn một cái làm đỉnh nguồn. Bây giờ điều tôi sắp làm là tôi sẽ chọn con số 0. Phán quyết này là không, rồi hai, rồi ba.

4152
00:03:58,490 --> 00:04:09,700
Vì vậy chúng tôi đã khám phá số không, ba và hai. Bây giờ chúng ta hãy ghé thăm tất cả các argentino liền kề, các cơ hội liền kề một, ba và bốn. Ở đây chúng tôi thấy chúng tôi đã truy cập một và ba.

4153
00:04:09,710 --> 00:04:25,820
Vậy chúng ta hãy chọn phán quyết này. Vì vậy, hãy mang đến đây vì đây là một cơ sở hợp lệ khác cho biểu đồ này. Bây giờ, nếu chúng ta lấy bốn nút làm nút nguồn, bây giờ điều tôi sắp làm là tôi sẽ nghĩ đến điều này trước tiên.

4154
00:04:26,120 --> 00:04:38,420
Tôi chỉ nghĩ Vertex, sau đó là ba, bạn có thể khám phá một đỉnh phù hợp theo bất kỳ thứ tự nào, nhưng điều đó phụ thuộc vào việc triển khai cấu trúc trọng lực và việc triển khai thuật toán này.

4155
00:04:38,720 --> 00:04:48,440
Chúng tôi chọn số 0 ở đây làm đỉnh đầu tiên. Vì vậy, hãy khám phá tất cả các số 0 liền kề. Chúng tôi thấy tôi chỉ bằng không, ba hoặc bốn người đã ghé thăm. Vì vậy hãy in ở đây một cái.

4156
00:04:48,830 --> 00:05:01,070
Bây giờ chúng ta hãy khám phá tất cả các liền kề của ba. AI không có ba là một không bốn và hai. Chúng tôi thấy hai là chưa được truy cập, vì vậy hãy khám phá hai và chúng tôi đã in ở đây hai.

4157
00:05:01,280 --> 00:05:12,500
Đây là một giá trị khác là lần đầu tiên. Vì vậy, trong cấu trúc chi tiết này, chúng ta có thể có nhiều giá trị, v.v. Vì vậy, ba lần truyền tải này có giá trị là một giờ đầu tiên.

4158
00:05:12,980 --> 00:05:26,870
Bây giờ chúng ta hãy xem tháp phòng thủ. Vì vậy, trước tiên, chúng ta phải chọn một nút làm nút nguồn. Hãy chọn nút này. Vì vậy, trước tiên, hãy chạy nước rút về số 0. Bây giờ, điều đầu tiên tôi sẽ làm là tìm các nút liền kề và bạn muốn A.. liền kề.

4159
00:05:27,110 --> 00:05:38,270
Chúng ta có thể đi đây hoặc chúng ta có thể đi đây và chúng ta có thể đi đây. Nó khác. Về việc thực hiện lấy. Cấu trúc và thuật toán DFS sẽ không truy cập tất cả các phán quyết liền kề.

4160
00:05:38,570 --> 00:05:49,310
Thay vào đó, chúng ta sẽ đi tới một đỉnh bất kỳ. Bây giờ tôi sẽ chuyển sang Vertex 3 này. Bây giờ tôi sẽ khám phá Vertex ba này. Sau đó tôi sẽ khám phá Vertex 4 này.

4161
00:05:49,610 --> 00:05:59,390
Chúng tôi thấy rằng chúng tôi có hai Vertex Direct ba và đã truy cập. Vì vậy, hãy quay lại ở đây lúc ba giờ. Bây giờ ở đây chúng tôi quay lại. Từ đây chúng ta có thể đi đến một hoặc chúng ta có thể đi đến hai.

4162
00:05:59,630 --> 00:06:09,500
Nhưng ở đây tôi sẽ chuyển sang số hai, và từ hai chúng ta có thể chuyển sang một vì ba đã được viếng thăm. Vì vậy, hãy chuyển sang một cái, và chúng ta đã in ở đây một cái, thế là xong.

4163
00:06:09,560 --> 00:06:27,410
Đây là một trình điều khiển phòng thủ hợp lệ. Vì vậy bây giờ hãy chọn một đỉnh làm đỉnh nguồn từ một đỉnh. Hãy chuyển đến ba từ ba đến bốn từ bốn đến không. Và ở đây chúng tôi thấy những gì bạn làm là bạn có ba liền kề, nhưng tất cả đều được truy cập.

4164
00:06:27,620 --> 00:06:38,000
Vì vậy, hãy quay lại ở đây. Ở đây chúng tôi thấy tất cả đều được thăm khám mà không cần kháng thể ở đây cho ba người. Chúng tôi thấy một cái do lượng người truy cập kém, nhưng cái này không được truy cập.

4165
00:06:38,180 --> 00:06:55,120
Vì vậy, hãy khám phá đỉnh này. Vậy là chúng ta đã hoàn tất. Bất cứ đỉnh nào trong đây đều là đỉnh. Nắm bắt một cấu trúc. Bây giờ hãy nói như là phán quyết nguồn của chúng tôi. Bây giờ điều tôi sắp làm, tôi sẽ bùng nổ ba, sau đó tôi sẽ khám phá hai, sau đó tôi sẽ khám phá một.

4166
00:06:55,510 --> 00:07:13,840
Sau đó tôi sẽ giải thích số không. Chúng ta có thể di chuyển nó theo hướng. Và đây được gọi là lần đầu tiên. Vì vậy, đối với BP ​​Stomatal, mà tôi được biết, trước tiên tôi chỉ gửi Vortex cho Bénéfice, tất cả các xoáy lân cận, nhưng đối với văn phòng mà chúng tôi đang cố gắng di chuyển theo bất kỳ hướng nào.

4167
00:07:14,110 --> 00:07:24,340
Nếu chúng ta thấy không còn đường nào để đi thì tất cả đều quay lại. Và đây được gọi là thuật toán Jefferson. Bây giờ hãy lấy một ví dụ khác để hiểu rõ hơn ở đây.

4168
00:07:24,400 --> 00:07:37,690
Đây là một cái cây. Cây là cấu trúc dữ liệu đồ thị hợp lệ. Đầu tiên, chúng ta hãy xem Lễ hội bia. Các tiền tố đầu tiên là 0, sau đó là một hai, rồi đến cấp độ ba bốn năm sáu.

4169
00:07:38,170 --> 00:07:53,790
Đây là lần đầu tiên hợp lệ nên chúng ta có thể đi theo hướng này ở đây. Đầu tiên là số 0, sau đó là hai một, rồi sáu năm bốn ba. Hai cái này đều hợp lệ và xuất sắc, vì vậy cái đầu tiên này phổ biến trước Stellar.

4170
00:07:53,800 --> 00:08:04,840
Vì vậy bây giờ chúng ta hãy xem sự khác biệt giữa hai giờ và bốn sự khác biệt trong hai giờ. Vì vậy, đầu tiên chúng ta di chuyển sang trái ở đây, sau đó chúng ta di chuyển sang trái ở đây và ở đây là bên trái, bây giờ chúng ta có ở bên phải.

4171
00:08:04,840 --> 00:08:17,050
Bạn chưa có nên nó sẽ quay ngược lại. Hãy đi đây. Và ở đây chúng ta thấy bốn là không được thăm viếng. Chúng ta hãy đi đến bốn. Vì vậy, ở đây không có cách nào để tham quan. Vì vậy, lần đầu tiên truy cập số 0, sau đó là một, rồi ba, rồi bốn.

4172
00:08:17,530 --> 00:08:30,820
Vì vậy, ở đây chúng ta hãy quay lại. Ở đây chúng tôi không có liền kề của một. Vậy chúng ta hãy quay trở lại đây. Chúng ta hãy đi đến thứ tự này. Bây giờ chúng ta hãy di chuyển tới đây. Đây là liền kề bên trái của năm không phải là bên phải là không.

4173
00:08:31,420 --> 00:08:43,000
Vì vậy, hãy mang theo năm. Và hãy quay lại đây và chúng ta thấy ở đây. Sáu người chưa được thăm viếng. Vì vậy, chúng ta hãy ghé thăm sáu. Vì vậy, đây là một câu chuyện khác. Vì vậy bây giờ chúng ta hãy xem một tế bào sao khác ở đây.

4174
00:08:43,360 --> 00:08:58,120
Đầu tiên, bạn chuyển đến nút thứ hai thay vì ở đây. Được rồi, vậy chúng ta hãy chuyển tới đây. Vì vậy, đầu tiên là số 0, sau đó là hai, rồi sáu, rồi không, không khám phá ở đây. Vậy hãy quay lại đây và di chuyển đến đây.

4175
00:08:58,660 --> 00:09:08,470
Vì vậy không có nút nào để khám phá ở đây. Hãy quay lại việc quay lại ở đây. Ở đây chúng ta thấy một cái chưa được truy cập, vì vậy hãy ghé thăm một cái. Bây giờ hãy chọn cái này. Chúng tôi đang chọn từ bên phải.

4176
00:09:08,980 --> 00:09:20,690
Đây là mẫu thuật toán của chúng tôi vì trước tiên chúng tôi chọn thay thế. Một. Vì vậy, hãy khám phá bốn, rồi ba. Đây cũng là một ngôi sao phòng thủ hợp lệ. Chúng tôi rất cởi mở.

4177
00:09:20,800 --> 00:09:37,360
Chúng tôi đã hiểu cả cách tấn công và phòng thủ đối với cấu trúc trọng lực. Bây giờ, hãy lấy một ví dụ khác cho biểu đồ này. Nếu chúng tôi chọn số 0 được đánh dấu là số 0 tuần X làm nguồn của X, thì Vertex của chúng tôi bây giờ chỉ cần điều chỉnh số 0 là một mục nhập.

4178
00:09:37,360 --> 00:09:47,320
Chúng ta có thể chọn bất kỳ trong số họ. Chúng ta hãy có mặt ở đây vào lúc một giờ. Bây giờ hãy kết thúc lúc ba vì chúng ta đã chọn một cái đầu tiên. Vì vậy, hãy khám phá và đi xuống. Lên một là hai và bốn.

4179
00:09:47,320 --> 00:09:58,960
Bạn có thể chọn bốn hoặc hai. Vậy hãy chọn ở đây hai, rồi bốn. Vì vậy, chúng tôi đã khám phá hai và bốn. Bây giờ ở đây, chúng ta hãy khám phá sự giảm dần của ba ở mức ba bảy.

4180
00:09:59,440 --> 00:10:14,320
Hãy in bảy. Rồi đi xuống lên đến đi xuống hai là sáu và năm. Hãy nói chuyện trước. Năm. Vì vậy, chúng tôi đã khám phá năm, rồi sáu. Bây giờ chúng ta hãy đến thăm dòng dõi của bốn.

4181
00:10:14,440 --> 00:10:26,180
Chúng tôi thấy ở trung tâm có một và tám một đã được truy cập. Vì vậy hãy in ở đây. Tám bây giờ bảy, chúng ta thấy bốn bảy chỉ trong ba và tám đã viếng thăm bốn năm bốn năm.

4182
00:10:26,200 --> 00:10:41,890
Chúng ta thấy đây là chín và hai chín là chưa được thăm, vì vậy hãy in chín cho sáu. Chúng tôi thấy tôi vừa gửi hai và chín đã ghé thăm bốn tám. Việc điều chỉnh tám chín bốn bảy đã đến thăm chín bốn chín.

4183
00:10:42,220 --> 00:11:00,250
Tôi vừa gửi năm sáu tám có thăm. Vậy là chúng ta đã hoàn tất. Đây là BÉNÉFICE hợp lệ trong giờ đầu tiên, vì vậy trước tiên hãy khám phá tất cả các đỉnh liền kề. Ở đây chúng tôi chọn một nguồn làm nguồn X.

4184
00:11:00,700 --> 00:11:12,760
Sau đó chúng ta sẽ chọn cái này ở cạnh đây. Không. Thế thì tôi sẽ chọn hai, rồi tôi sẽ chọn bốn. Đây là thứ tự vì chúng ta chọn số 0 làm đỉnh đầu tiên.

4185
00:11:12,970 --> 00:11:26,710
Vì vậy, hãy khám phá đỉnh liền kề của số 0 ở đây. Ba. Hãy cùng khám phá ba. Bây giờ bốn hai bốn hai. Năm và sáu đàng hoàng. Đầu tiên, hãy khám phá năm, sau đó là sáu.

4186
00:11:27,250 --> 00:11:39,460
Bây giờ bốn bốn bốn bốn. Liền kề là tám. Vì vậy, hãy thăm tám, sau đó bốn ba ở mức đàng hoàng là bảy và số không không đã được thăm. Vậy hãy in bảy bây giờ là bốn.

4187
00:11:39,460 --> 00:11:58,450
Năm liền kề là ba và bốn. Năm đàng hoàng là hai sáu. Chín đến sáu giờ đã ghé thăm rồi, nên chúng ta hãy ghé thăm chín giờ, vậy chúng ta hãy mang đến đây lúc chín giờ sáu giờ. Người liền kề đã thăm liền kề của tám, đã thăm bốn, bảy và chín liền kề đã đến thăm.

4188
00:11:58,630 --> 00:12:07,120
Vì vậy, chúng tôi có được sự truyền tải này. Đây là lần đầu tiên nên đây là băng chuyền trước đó hợp lệ. Bây giờ chúng ta hãy xem sản phẩm đầu tiên được bán với sự khác biệt so với đỉnh cao danh tiếng của chúng ta.

4189
00:12:07,840 --> 00:12:19,870
Các phán quyết không có câu trả lời sẽ đi về hướng nào hoặc Kim nếu chúng ta không còn đường nào để đi rồi sẽ quay lại. Nhanh lên. Số không bây giờ mắt không đưa ra số không, một và ba.

4190
00:12:20,050 --> 00:12:33,430
Bây giờ chúng ta hãy đi theo hướng này. Đầu tiên là ba, rồi bảy, sau đó tôi sẽ chuyển sang tám, rồi chín, rồi sáu từ chín. Chúng ta có thể khám phá năm, nhưng ở đây chúng ta đang khám phá sáu.

4191
00:12:33,730 --> 00:12:44,590
Bây giờ chúng ta có nhiều Explorer hai hơn từ hai. Một lần nữa, chúng tôi có tới năm nơi tôi có thể chuyển sang một. Từ đây, tôi sẽ chuyển sang số năm và chúng tôi thấy chúng tôi có hai địa điểm liền kề và chúng đã được truy cập.

4192
00:12:44,620 --> 00:12:56,110
Vì vậy, hãy quay lại. Ở đây chúng ta thấy chúng ta có ba liền kề liền kề đã được truy cập. Vì vậy, chúng ta hãy ghé thăm liền kề này. Bây giờ ở đây chúng ta thấy chúng ta có ba liền kề bốn cái chưa được thăm, vậy chúng ta hãy ghé thăm.

4193
00:12:56,110 --> 00:13:10,210
Bây giờ, hãy quay lại một. Không có gì chưa được xem xét sau đó. Hai Không có người chưa được thăm viếng đến năm. Chúng tôi thấy không có lượt truy cập nào từ một bản quay lại đến năm từ năm, hãy beta hai hai.

4194
00:13:10,210 --> 00:13:21,670
Không có khách nào chưa được thăm từ hai đến sáu. Không có gì chưa được ghé thăm ở đây. Chín Không ai đến thăm bốn tám cũng không thăm viếng trong bảy và đến thăm và trong ba. Không có người không được thăm viếng và bốn số không.

4195
00:13:21,670 --> 00:13:33,820
Không có một chuyến viếng thăm. Vì vậy, chúng tôi đã khám phá bộ phận đánh lạc hướng trọng lực này và nó được gọi là Phòng thủ. Chúng tôi đang cố gắng khám phá theo một hướng nào đó. Vâng, biết nơi để đi.

4196
00:13:34,120 --> 00:13:46,510
Nếu chúng tôi thấy không có nút nào để khám phá thì quay lại. Và đây được gọi là DFS Carousel. Bây giờ chúng ta chọn đỉnh này làm đỉnh nguồn. Chúng ta có ba đỉnh liền kề.

4197
00:13:46,510 --> 00:13:57,340
Chúng ta có thể di chuyển theo bất kỳ hướng nào. Chúng ta có ba đỉnh liền kề. Chúng ta có thể khám phá bất kỳ một đỉnh nào. Vậy hãy cùng khám phá đỉnh bốn từ bốn này. Hãy cùng khám phá tám từ tám.

4198
00:13:57,550 --> 00:14:08,440
Chúng ta có thể đi đến chín. Hoặc bạn có thể đi đến bảy. Vậy hãy cùng khám phá tại đây nhé. Chín. Từ chín giờ, hãy cùng khám phá. Sáu từ sáu. Hãy cùng khám phá hai. Từ hai. Hãy cùng khám phá năm.

4199
00:14:08,800 --> 00:14:19,720
Bây giờ chúng ta thấy không có liền kề nào chưa được xem xét. Hãy di chuyển đến đây. Đây là sự quay lại. Vậy thì hãy quay lại đây. Vậy thì hãy quay lại lúc chín giờ. Hãy quay lại lúc tám giờ.

4200
00:14:20,020 --> 00:14:29,340
Bây giờ là tám, chúng tôi thấy chúng tôi đã có ba tiện ích bổ sung liền kề và đã truy cập hai tiện ích bổ sung. Hãy ghé thăm bảy giờ bảy. Chúng tôi có hai liền kề. Một là không liên quan. Hãy ghé thăm ba trong ba.

4201
00:14:29,460 --> 00:14:38,170
Chúng ta có một cái ở Jacintha số 0 và đã ghé thăm, vì vậy hãy ghé thăm số 0. Không có số 0 liền kề nào chưa được thăm, vì vậy hãy quay lại. Không có và thăm một phong nha của ba.

4202
00:14:38,170 --> 00:14:47,170
Hãy quay lại. Không có. Tôi đã được ghé thăm ở nhóm bảy người, vì vậy hãy quay lại. Hãy quay lại ở đây và hãy quay lại ở đây. Vì vậy, chúng tôi đã quay lại nút nguồn của mình.

4203
00:14:47,200 --> 00:14:58,710
Vậy là chúng ta đã hoàn thành bất cứ điều gì được nhập vào một cấu trúc và cái này được gọi và cái này được gọi. Điều này được gọi là khác nhau. Vậy hy vọng bạn đã hiểu sự khác biệt ở đó là gì và B của một ngôi sao là gì?

4204
00:14:58,720 --> 00:15:09,070
Vậy bây giờ hãy lấy thêm một ví dụ nữa. Bây giờ chúng ta hãy lấy một ví dụ khác để hiểu rõ hơn và làm sáng tỏ sự nghi ngờ của bạn về Beavis và DFS mà tất cả chúng ta đưa ra ở đây.

4205
00:15:09,430 --> 00:15:22,540
2.6 ví dụ. Bây giờ chúng ta hãy xem. Ví dụ số bốn. Ở đây chúng ta có cấu trúc dữ liệu đồ thị này. Đây là một biểu đồ do cấu trúc. Bây giờ chúng ta hãy xem BFS. Hãy bằng 0 khi nguồn Vertex zero tấn công Smart X.

4206
00:15:22,810 --> 00:15:36,190
Từ đây, chúng ta phải khám phá hết khu rừng lân cận. R0 liền kề là ba ăn một. Hãy khám phá một, rồi ba, rồi bốn. Vì vậy, chúng tôi đã khám phá một, ba và bốn.

4207
00:15:36,820 --> 00:15:50,920
Bây giờ đối với một, chúng ta hãy khám phá tất cả các liền kề liền kề là sáu, năm và hai. Đầu tiên, chúng ta hãy khám phá hai, rồi năm, rồi sáu và chúng ta thấy không có đỉnh nào được thăm.

4208
00:15:51,040 --> 00:16:05,020
Vì vậy, đây là một hợp lệ để được cán bộ. Có lẽ hình một là đỉnh nguồn của chúng tôi. Bạn sẽ làm gì? Chúng ta sẽ chọn số không, rồi hai. Vì vậy, chúng ta có gốc của một không hai sáu năm.

4209
00:16:05,170 --> 00:16:15,250
Vì vậy, không hai. Sau đó chúng ta sẽ đến thăm năm, rồi sáu. Vậy không hai năm sáu. Bây giờ chúng ta hãy ghé thăm. Số 0 số 0 liền kề là ba bốn và bạn có thể nói theo bất kỳ thứ tự nào.

4210
00:16:15,280 --> 00:16:28,840
Ba bốn bốn ba. Nhưng nó khác ở cách thực hiện cấu trúc và thuật toán lấy. Ở đây chúng ta hãy chọn ba. Đã bốn rồi. Vì vậy, đây là một sự truyền tải rõ ràng hợp lệ.

4211
00:16:29,290 --> 00:16:41,350
Chúng ta hãy xem thêm một số tháp của anh ấy. Vì vậy, chúng tôi chọn năm loại nghệ sĩ. Sau đó chúng ta sẽ ghé thăm một nơi. Sau đó, nếu chúng ta chọn năm Vertex, chúng ta sẽ ghé thăm một. Rồi không, rồi hai.

4212
00:16:41,440 --> 00:16:53,920
Bạn có biết, có thể chọn? Là một loại xoáy nước sẽ có loại sức mạnh này nên điều này được gọi là vô lý, và hãy xem cơn thịnh nộ xuyên qua của anh ta.

4213
00:16:54,160 --> 00:17:12,070
Tôi sẽ không đi qua là Estefania. Sự cảnh giác sẽ được tăng lên. Vì vậy tôi sẽ chỉ cho bạn xem tập giấy này. Đây là một bình xịt có giá trị bằng nắm tay năm một, rồi sáu, rồi hai, rồi không, rồi ba, rồi bốn.

4214
00:17:13,150 --> 00:17:26,450
OK, bây giờ chúng ta hãy xem đường truyền phòng thủ của biểu đồ này. Hãy chọn đỉnh nguồn của bạn. Vì vậy, trước tiên, điều tôi sẽ làm, tôi sẽ chuyển sang số bốn. Vì vậy không có cách nào để đi đến đây.

4215
00:17:26,470 --> 00:17:41,980
Chúng tôi thấy không có Vertex 4 nào chưa được truy cập, chỉ là không có 4. Vì vậy, hãy quay lại số 0 và đã truy cập. Hãy ghé thăm ba. Bây giờ chúng ta hãy quay lại đây. Không có và đã thăm Vertex được kết nối với đỉnh này.

4216
00:17:42,250 --> 00:17:56,800
Vì vậy, hãy quay lại ở đây. Chúng ta có đỉnh này. Hãy in một cái. Bây giờ chúng ta hãy đến đây tới nút sáu này, sau đó đến nút này năm là hai. Đây là một tháp phòng thủ hợp lệ, vì vậy hãy xem.

4217
00:17:57,860 --> 00:18:16,330
Nếu chúng ta chọn một nguồn không phải thì đây là sự khác biệt khủng bố. Đây là một cuộc khủng bố phòng thủ hợp lệ. Nếu chúng tôi chọn năm làm nguồn của thùng RDX, thì đây là biện pháp bảo vệ hợp lệ cho chúng tôi và tôi sẽ không tiến hành thiết lập.

4218
00:18:16,340 --> 00:18:30,710
Vì vậy, bằng cách chọn những lợi thế khác nhau tại nguồn, chứ không phải nếu tôi làm vậy, thì sự cảnh giác sẽ được tăng lên. Bây giờ hãy xem làm thế nào chúng ta có thể vượt qua cái bị tóm này tại một công trình bằng cách sử dụng thịt bò, phải không?

4219
00:18:31,430 --> 00:18:42,170
Bây giờ hãy xem cách chúng ta có thể mô tả nó để cấu trúc nó bằng Beavis và các thuật toán văn phòng. Trước tiên, hãy xem Beavis và hãy lấy số 0 làm phán quyết nguồn.

4220
00:18:42,620 --> 00:18:54,170
Bây giờ chúng ta có số 0 từ số 0, chúng ta có thể chuyển sang một và ba. Vì vậy, đầu tiên là một, sau đó là ba. Đối với một, chúng tôi có ba liền kề. Đầu tiên, chúng ta hãy khám phá. Đầu tiên, chúng ta hãy khám phá.

4221
00:18:54,170 --> 00:19:06,820
Hai là bây giờ cho ba. Bây giờ không có phán quyết nào chưa được xem xét cho cả hai. Chúng tôi có hai. Chưa được ghé thăm. Vậy chúng ta hãy đến đây trước. Tám. Chín bây giờ bốn bốn bốn bốn.

4222
00:19:06,830 --> 00:19:21,430
Chúng tôi có ba bản án chưa được xem xét ở đây. Được rồi, vậy hãy nói chuyện trước. Năm, rồi sáu, rồi bảy. Vì vậy, chúng tôi đã khám phá năm, sáu và bảy cho tám. Không có bản án nào chưa được xem xét.

4223
00:19:21,440 --> 00:19:32,300
Được kết nối với sản phẩm này. Tám bây giờ là bốn. Chín. Hiện tại không có cơn lốc nào chưa được ghé thăm ở đây. Bốn năm. Có một phán quyết chưa được giải quyết là khoảng cách. Vậy hãy mang nó về giá sáu.

4224
00:19:32,300 --> 00:19:40,730
Không có bản án nào chưa được xem xét. Đối với bảy, không có bản án nào chưa được xem xét. Và 14, không có phán quyết nào chưa được xem xét. Vậy là chúng ta đã hoàn tất. Đây là tòa tháp văn phòng hợp lệ.

4225
00:19:40,730 --> 00:19:53,330
Vì vậy, nếu chúng ta nghe Nút ba này dưới dạng phán quyết nguồn, thì lời kêu gọi ban đầu mà chúng ta đưa ra là gì? Vì vậy, tôi sẽ cho bạn thấy kết quả. Tôi sẽ không đi qua đây.

4226
00:19:53,360 --> 00:20:06,890
Kết quả là tôi sẽ không thực hiện bằng cách đưa ra các phán quyết khác nhau. Vậy hãy xem chúng ta đã thiết lập được ba không hai một tám chín bốn năm, sáu, bảy và 10.

4227
00:20:07,370 --> 00:20:27,440
Đây là một sự đảo ngược kinh doanh hợp lệ. Bây giờ, hãy lấy một đỉnh khác làm nút nguồn năm, sau đó chúng ta đã thiết lập sớm là bốn sáu bảy bốn sáu bảy, rồi 10, rồi một, rồi không hai ba tám chín.

4228
00:20:27,980 --> 00:20:38,610
Bây giờ chúng ta hãy xem Ngôi sao phòng thủ. Vì vậy, để mô tả nó theo cấu trúc, trước tiên hãy lấy số 0 làm đỉnh nguồn. Những gì tôi sắp làm, tôi sẽ chuyển đến nút thứ ba này.

4229
00:20:38,930 --> 00:20:56,810
Vì vậy, chúng tôi đã khám phá Nút ba này. Đây là liền kề. Ngoài ra, một là liền kề. Chúng ta cũng có thể chuyển sang một cái. Nhưng ở đây tôi đang chuyển sang ba. Bạn có thể chọn bất kỳ hướng nào, nhưng việc triển khai cấu trúc trọng lực và việc triển khai thuật toán Divis mà tôi sắp khám phá sẽ khác.

4230
00:20:57,290 --> 00:21:10,130
Tôi không đùa ở đây. Bên cạnh, tôi đang cố gắng đi về một hướng. Nếu chúng tôi thấy không có đỉnh nào để truy cập, chúng tôi sẽ quay lại. Từ đây, tôi sẽ đến thăm chín giờ chín.

4231
00:21:10,130 --> 00:21:20,830
Không có đỉnh. Không có đỉnh bốn chín nào xứng đáng cả. Không có đỉnh liền kề nào chưa được thăm, vì vậy hãy quay lại từ tới. Cái này chưa được truy cập và cái này chưa được truy cập ở đây.

4232
00:21:20,840 --> 00:21:29,360
Tôi sẽ khám phá nó. Bây giờ chúng ta hãy quay lại một lần nữa. Ở đây chúng tôi có một cái ở đây. Chưa ghé thăm, chúng ta hãy ghé thăm từng người một. Chúng ta chỉ có một hướng. Chúng ta hãy đi đến bốn.

4233
00:21:29,660 --> 00:21:46,930
Chúng ta hãy khám phá bốn ở đây cho bốn, chúng ta có thể chuyển sang ba hướng đến năm đến sáu hoặc bảy. Ở đây tôi sẽ khám phá bảy đầu tiên bốn bảy. Chúng tôi thấy chúng tôi có hai và đã đến thăm vitesses năm và sáu ở đây và muốn khám phá sáu bốn sáu.

4234
00:21:46,940 --> 00:21:59,090
Chúng ta có một người chưa được thăm là năm bốn, năm một người chưa được thăm, 10 và 14. Chúng ta thấy không có người nào chưa được thăm. Hãy quay lại đây, sau đó hãy quay lại đây. Vậy thì hãy quay lại đây.

4235
00:21:59,420 --> 00:22:15,920
Vậy thì hãy quay lại đây. Vậy thì hãy quay lại đây. Rồi ở đây, rồi ở đây. Sau đó cộng phần này vào số 3, rồi bằng 0. Đây chính là điểm khác biệt của chúng ta khi khám phá tất cả các đỉnh liền kề.

4236
00:22:16,100 --> 00:22:29,890
Chúng tôi đang cố gắng di chuyển cả hai theo một hướng và nếu chúng tôi tìm thấy nó, thì không có và đã truy cập vào ma trận tử tế. Nếu chúng ta chọn một nút nguồn đỉnh khác thì hãy xem điều gì sẽ xảy ra ở đây.

4237
00:22:29,960 --> 00:22:45,460
Đỉnh khác nhau. Hãy chọn loại đỉnh này thì đây sẽ là tháp thiết bị không hợp lệ. Vì vậy, bạn sẽ cảm thấy năm là một loại đỉnh. Vậy thì đây sẽ là Tháp Davis số 2 hợp lệ.

4238
00:22:45,500 --> 00:22:54,680
Tôi thực sự khuyến khích bạn cố gắng đi qua lực hấp dẫn này để cấu trúc để tìm ra hai đường truyền này. Bây giờ hãy lấy thêm một ví dụ nữa để hiểu rõ hơn.

4239
00:22:55,070 --> 00:23:04,440
Bây giờ chúng ta hãy xem lần bán đầu tiên cho sản phẩm này. Richard Graf, hãy chọn các phán quyết bằng 0 + nguồn, nó sẽ bằng 0 nếu coi nguồn thông minh. Tôi chỉ kết thúc bằng 0 là hai.

4240
00:23:04,590 --> 00:23:17,820
Chúng ta không thể di chuyển đến một. Chúng tôi có một dự đoán ở đây. Abjure liền kề là hai và ba, vì vậy chúng ta có thể mong đợi hai hoặc ba. Đầu tiên, hãy khám phá số 0, sau đó là hai, rồi ba bây giờ là hai.

4241
00:23:17,940 --> 00:23:30,660
Chúng ta đã khám phá Vargas được ba người rồi. Chúng ta có hai đỉnh một và bốn. Sau đây chúng ta hãy cùng khám phá một điều. Và sau đó hãy khám phá bốn. Và chúng ta thấy chúng ta đã khám phá hết tất cả các đỉnh.

4242
00:23:30,660 --> 00:23:43,140
Chúng ta đã xong việc ở đây. Bạn thấy rằng đây là một hậu thế hợp lệ. Vì vậy, bây giờ chúng ta hãy chọn các loại virus khác nhau và hãy xem điều đó giữa các loại virus sao. Vì vậy, chúng tôi chọn một đỉnh nguồn lớn nhất từ ​​trước đến nay.

4243
00:23:43,140 --> 00:24:04,290
Vậy là không, rồi hai, rồi ba, rồi bốn. Điều này là tốt nhất bao giờ hết. Vì vậy, nếu chúng ta chọn Vertex làm nguồn, thì đó sẽ là Mr. Marsalis ba một bốn không hoàn hảo ba với tư cách là loại nghệ sĩ, thì đó là người giỏi nhất từ ​​trước đến nay.

4244
00:24:04,290 --> 00:24:20,820
Vì vậy, mỗi một đến bốn số không hoàn hảo ở đây trong thời gian ngắn nhất mà Vertex sẽ ghé thăm một không hai ba. Ở đây chúng ta thấy rằng chúng ta có năm Tháp Beavis khác nhau. Vâng, hãy nói về khủng bố quốc phòng.

4245
00:24:20,820 --> 00:24:31,800
Vì vậy, bây giờ hãy chọn số 0, Vertex khẳng định lại từ đây, chuyên gia về R3. Hãy cùng khám phá ở đây ba. Từ ba chúng ta có thể khám phá hai hoặc bốn. Hãy cùng khám phá bốn.

4246
00:24:32,190 --> 00:24:46,920
Sau đó chúng ta hãy khám phá một. Không cần phải đến thăm. Vì vậy, hãy quay lại. Hãy quay lại các trường đại học và ghé thăm nó. Vậy chúng ta hãy ghé thăm. Chúng ta đã xong. Đây là một nhân vật lịch sử tương đối.

4247
00:24:46,920 --> 00:25:01,490
Các nút khác nhau. Và chúng ta hãy xem sự khác biệt. Khủng bố ở đây. Tôi sẽ không duyệt qua các thú cưng khác nhau bằng cách lấy các đỉnh khác nhau làm đỉnh nguồn. Nếu chúng ta lấy một đỉnh làm đỉnh nguồn thì đây lại là một câu chuyện khác.

4248
00:25:01,500 --> 00:25:14,550
Vì vậy, nếu chúng ta đưa nó tới đỉnh nguồn thì đây là một quá trình truyền tải thiết bị hợp lệ. Nó sẽ lấy ba làm đỉnh nguồn. Đây là một lần truyền tải thiết bị hợp lệ mà chúng tôi thực hiện cho một đỉnh nguồn và đây là một nhà hoạt động hợp lệ.

4249
00:25:14,550 --> 00:25:27,330
Vì vậy, bây giờ chúng ta đi đến phần cuối của video này, chúng ta đã giải thích rằng Dave sẽ trở thành thuật toán của anh ấy
với hy vọng rất chi tiết. Bạn đã hiểu thuật toán của Barry là gì, thuật toán của nó là gì và nó hoạt động như thế nào rồi? 

@@@



4250
00:00:00,390 --> 00:00:09,240
Có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này trong video này hoặc sẽ nói về các kỹ thuật khủng bố bằng đồ họa. Brett, một nguồn tin. Vậy hãy nói về thịt bò là thuật toán.

4251
00:00:10,740 --> 00:00:22,080
Đây là một thuật toán để cấu trúc hình vẽ graffiti của Jefferson. Nó bắt đầu tại một số ghi chú tùy ý của biểu đồ và khám phá các vùng lân cận. Hãy xem thuật toán này hoạt động như thế nào.

4252
00:00:22,560 --> 00:00:35,490
Bạn lấy biểu đồ này làm ví dụ. Bây giờ hãy xem nó hoạt động như thế nào. Đây là thuật toán của chúng tôi. Thuật toán này lấy loại hình nghệ thuật làm đầu vào. Ở đây chúng ta có một mảng Boolean.

4253
00:00:35,980 --> 00:00:55,380
Sau đó, chúng tôi có cấu trúc bạn không có để giải quyết vấn đề này. Chúng tôi sử dụng Cube đã làm một cấu trúc. Và chúng ta ở đây, đánh dấu nguồn gốc của nghệ thuật là sự thật. Và sau đó chúng ta thêm xoáy nguồn vào Q và ở đây kiểm tra xem kích thước của Q có bằng 0 hay không thì chúng ta sẽ kéo mục đầu tiên.

4254
00:00:56,010 --> 00:01:16,410
Điều đó có nghĩa là mặt hàng từ phía trước và in ghi chú. Mục đầu tiên ở đây là. Và ở đây chúng ta có iterator. Làm thế nào điều này hoạt động, bạn sẽ thấy. Và chúng tôi đang lấy danh sách từ việc lấy cấu trúc từ chỉ mục của nó và chúng tôi đang khám phá tất cả các vị trí thuận lợi được kết nối với các đỉnh.

4255
00:01:16,680 --> 00:01:27,090
Và ở đây chúng ta đang khám phá tất cả các loại lợi thế có thể tồn tại. Điều đó được kết nối với nguồn nghệ thuật này. Và hãy xem điều này thực sự hoạt động như thế nào. Giả sử đây là thứ chúng ta đã lấy được tại một công trình.

4256
00:01:27,300 --> 00:01:40,800
Và đây là cấu trúc dữ liệu biểu đồ và chúng tôi đang trình bày biểu đồ này bằng danh sách kề. Danh sách liền kề này tại danh sách kề này sẽ được lưu trữ trong bộ nhớ máy tính và đây chỉ là cách biểu diễn logic.

4257
00:01:41,160 --> 00:01:50,970
Ở đây, chúng ta đã xếp hàng tại một cấu trúc có mặt trước và mặt sau và chúng ta có một mảng gồm 5 sợi vải vì chúng ta có các đỉnh thống nhất từ ​​0 đến 4. Bây giờ hãy xem nó hoạt động như thế nào.

4258
00:01:51,270 --> 00:02:03,180
Bây giờ tôi sẽ lấy số 0 làm đỉnh nguồn. Vì vậy, ở đây đã truy cập bằng hai. Ở đây bạn đang chèn hai ở chỉ số 0. Hãy chèn vào đây hai vi phân.

4259
00:02:03,390 --> 00:02:15,180
Bây giờ chúng tôi đang thêm đỉnh nguồn này, bạn biết đấy, hãy tìm đến bộ phân tâm. Vì vậy chúng tôi đã thêm giá trị này vào đây. Bây giờ chúng ta sẽ lấy chìa khóa này để vào cấu trúc. Vâng, cạnh của Q không bằng nhau.

4260
00:02:15,180 --> 00:02:25,830
Cejudo, chúng tôi đang lấy mục đầu tiên từ điểm. Và mục đầu tiên bằng 0 ở đây. Hãy kéo nó đi. Nếu chúng ta kéo thì nó sẽ bị xóa khỏi đây. Vì vậy, chúng tôi đã rút về số 0.

4261
00:02:26,160 --> 00:02:35,400
Bây giờ chúng ta sẽ in nó bằng 0. Vì vậy hãy in số 0 ở đây. Bây giờ chúng ta có một iterator ở đây từ chỉ mục IS hoặc đi tìm danh sách. Ở đây chúng tôi có danh sách này.

4262
00:02:35,400 --> 00:02:45,300
Một bốn hai ba. Hãy cùng khám phá. Bây giờ, hãy khám phá tất cả các cạnh để biết số 0 một bốn ba này là gì. Đầu tiên, chúng ta sẽ khám phá một, rồi bốn, rồi ba.

4263
00:02:45,600 --> 00:03:06,630
Hãy xem làm thế nào. Vì vậy, trong lần lặp tiếp theo của điều này? Chà, nếu chúng ta có giá trị ở đây, được chứ? Vì vậy, ở đây tôi sẽ chèn một cái và tôi sẽ thực hiện trong hai năm như đã truy cập, chèn giá trị nút ở đây, điều đó có nghĩa là chúng tôi đã truy cập nút đó sẽ kéo từ phía trước Q và sẽ in.

4264
00:03:06,990 --> 00:03:25,920
Tiếp theo là bốn. Vì vậy, hãy chèn vào đây bốn. Và ở đây hãy thêm hai ở chỉ số bốn. Vì vậy, nó có nghĩa là chúng ta đã đến thăm một và chúng ta đã đến thăm bốn và chúng ta có phép cộng cho 0 là một, bốn và ba.

4265
00:03:26,130 --> 00:03:36,410
Vì vậy bây giờ hãy thêm vào đây ba. Và ở đây chúng tôi đã đến thăm ba nơi này. Vậy hãy biến nó thành sự thật. Vì vậy, chúng tôi đã đến thăm. Ở đây chúng ta thấy số không một hai ba bốn. Vậy là chúng ta đã hoàn tất.

4266
00:03:36,420 --> 00:03:52,200
Chúng tôi đã nhận được vào cuối. Vì vậy, bằng cách sử dụng toàn bộ giao diện này, chúng tôi sẽ thêm ba giá trị một bốn ba này và ở đây sẽ đánh dấu chuỗi đã truy cập. Vì vậy, ở đây tôi sẽ kéo bạn ra khỏi đây và hãy in lên anh ấy.

4267
00:03:52,470 --> 00:04:05,610
Chúng tôi có iterator ở chỉ mục một. Đi xuống một là ba đỉnh. Việc cộng một bằng 0, hai và ba, và chúng ta đã gieo hạt bằng 0. Và ba đã đến thăm.

4268
00:04:05,970 --> 00:04:21,210
Vì vậy, đây là điều tôi sắp làm, tôi cũng sẽ chèn ghi chú này ngay tại đây và chúng ta cũng sẽ chèn vào đây. Vì vậy, nó đánh dấu hai được truy cập. Bây giờ chúng ta đã hoàn thành sau cái này sẽ có ở đây.

4269
00:04:21,480 --> 00:04:36,780
ĐÚNG VẬY. Và đây là giá trị này. Bây giờ, hãy kéo cái này trước và đưa nó đến đây ở chỉ số bốn sẽ không thêm bất cứ thứ gì vào. Điều này sẽ không thêm bất cứ thứ gì vào hàng đợi và bạn sẽ sửa đổi khu vực đã truy cập này vì tất cả các nghệ sĩ đã truy cập.

4270
00:04:36,780 --> 00:04:49,710
Chúng tôi thấy điều đó. Vì vậy, ở đây, hãy chọn giá trị này. Ba. Hãy mang đến đây. Đỉnh ba. Chúng tôi có kết nối chuyển tiếp. Đó là tất cả đều được truy cập, vì vậy tình trạng này sẽ được đánh giá tất cả các lỗi của nó.

4271
00:04:50,100 --> 00:05:00,870
Sau đó ghi chú tiếp theo là hai. Vậy hãy mang tới đây. Hai. Bây giờ chúng ta thấy hàng đợi đó trống. Vậy là chúng ta đã hoàn tất. Và đây là một thiết bị khủng bố hợp lệ. Vì thế. Vậy là chúng ta đã tìm thấy tòa tháp này.

4272
00:05:00,870 --> 00:05:22,290
Vậy không một bốn ba hai. Đây là cách thuật toán này hoạt động. Độ phức tạp về thời gian của thuật toán này là V cộng e trong đó so với số lượng virus và là số pha và độ phức tạp về không gian thường là V hoặc V là số đỉnh của khóa này đối với cấu trúc và đối với khu vực này.

4273
00:05:22,740 --> 00:05:32,100
Hy vọng bạn hiểu điều này? Xem thuật toán này. Cảm ơn đã xem video này. Tôi sẽ gặp bạn
trong video tiếp theo. Trong video tiếp theo, chúng ta sẽ nói về thuật toán Divis. 

@@@



4274
00:00:00,600 --> 00:00:08,730
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này, chúng ta sẽ nói về các thuật toán nguồn đầu tiên chuyên sâu. Thuật toán của David là gì?

4275
00:00:09,120 --> 00:00:21,180
Đây là một thuật toán để mua cấu trúc dữ liệu đồ thị. Nó bắt đầu từ lúc đó nên tôi muốn có một ghi chú về biểu đồ và các chuyên gia càng nhiều càng tốt. Elon đã già trước khi quay lại.

4276
00:00:22,310 --> 00:00:40,550
Hãy xem thuật toán này hoạt động như thế nào với mã giả. Và chúng ta sẽ lấy biểu đồ này làm ví dụ. Đây là thuật toán cho độ sâu này so với hàm này lấy một tham số là xoáy nguồn làm đầu vào mà chúng tôi đã ghé thăm ở đây, các bên đã ghé thăm đã được đánh dấu.

4277
00:00:40,550 --> 00:00:50,570
Điều này ở đây đã so le một cổ phiếu cho thuật toán này hoặc sử dụng cấu trúc tiêu chuẩn cho Beerfest sử dụng Q cho cấu trúc. Ở đây trước tiên, chúng tôi đẩy nguồn qua ngăn xếp và làm giàu.

4278
00:00:50,570 --> 00:01:01,850
Nếu ngăn xếp không trống, chúng tôi đang chọn phần tử trên cùng và chúng tôi sẽ xóa phần tử trên cùng ở đây, kiểm tra xem đỉnh hiện tại có được truy cập hay không. Chúng tôi đang in đỉnh và khi đánh dấu nó là đã truy cập.

4279
00:01:01,850 --> 00:01:13,490
Và ở đây chúng ta có danh sách ở chỉ mục và ở đây chúng ta đang chạy xa. Vâng, chúng ta có đỉnh liền kề. Chúng tôi sẽ kiểm tra xem Vertex đó có được truy cập hay không. Thêm nó vào ngăn xếp.

4280
00:01:13,520 --> 00:01:25,700
Hãy xem nó hoạt động như thế nào. Giả sử đây là biểu đồ đã cho của chúng tôi và đây là biểu diễn của biểu đồ này. Đây là một khu vực này được ghé thăm xung quanh. Mảng này sẽ theo dõi các đỉnh đã truy cập và đây là chiến lược cấu trúc của chúng tôi.

4281
00:01:26,000 --> 00:01:38,450
Đầu tiên, chúng tôi chèn đỉnh nguồn. Hãy lấy số 0 làm loại đỉnh, vì vậy hãy chèn số 0 vào đây. Bây giờ, hãy chọn số 0 này từ ngăn xếp này. Vì Stack không trống nên hãy xóa nó đi và kiểm tra, phải không?

4282
00:01:38,450 --> 00:01:49,350
Vertex được truy cập, thêm vào đây chúng ta phải tuân theo giá trị mặc định là thứ đã lấy anh ta. Vì vậy, hãy tiếp thị thành hai và hãy in. Hãy in ở đây. Giá trị 0 ở đây tăng dần lên 0.

4283
00:01:49,400 --> 00:01:56,930
Bây giờ chúng ta có cái này, nó là một danh sách và ở đây chúng ta có danh sách này. Một bốn ba. Bây giờ bạn định làm gì? Chúng tôi sẽ kiểm tra. Có ai đã root chưa?

4284
00:01:56,930 --> 00:02:07,010
Không. Vì vậy hãy thêm vào đây nào. Bốn là thực sự không. Hãy thêm vào đây ba có liên quan. Không, bây giờ chúng ta hãy thêm vào đây những gì tôi sắp làm. Tôi sẽ chứng minh ba điều này.

4285
00:02:07,490 --> 00:02:25,670
Hãy chứng minh và hãy lưu trữ nó trong s khủng khiếp này. Bây giờ chúng ta thấy ba chưa được truy cập, vì vậy hãy in ba và lập chỉ mục thị trường ba. Hiện tại tại Chỉ số ba, chúng ta thấy rằng chúng ta có 0 một hai bốn và ở đây chúng ta thấy số 0 được truy cập.

4286
00:02:25,790 --> 00:02:34,940
Vì vậy, bạn sẽ đẩy một. Hãy đẩy vào đây. Một cái đã có trên ngăn xếp của chúng tôi. Đừng lo lắng về điều đó. Sau đó chúng ta hãy đẩy ở đây sang trái đẩy ở đây. Bốn.

4287
00:02:35,060 --> 00:02:43,370
Đừng lo lắng, chúng tôi đã có chính phủ trùng lặp trên ngăn xếp này. Đừng lo lắng về điều đó. Bây giờ điều tôi sắp làm bây giờ là tôi sẽ nhìn trộm từ trên xuống và bật ra.

4288
00:02:43,490 --> 00:02:52,760
Vậy hãy chọn bốn và hãy bật cho bốn người không ghé thăm. Hãy tiếp thị thành hai và in nó ở chỉ số bốn. Chúng tôi có số không và ba số không đã được truy cập.

4289
00:02:52,760 --> 00:03:03,260
3'S đã được truy cập, vì vậy không cần thêm gì vào ngăn xếp bằng cách sử dụng cái này. Trong khi bạn biết, hãy chuyển sang và thêm vào phần này vì chúng ta thấy hai cái không được truy cập, vì vậy hãy in hai cái.

4290
00:03:03,530 --> 00:03:15,530
Và hãy cộng ở đây thông qua chỉ số hai, chúng ta có một ba. Chúng tôi thấy một người không được truy cập. Vì vậy, hãy thêm vào đây một và chúng ta có ba phần ba được truy cập, do đó sẽ không đẩy ba vào ngăn xếp.

4291
00:03:15,530 --> 00:03:26,180
Trong lần lặp tiếp theo, tôi sẽ chọn một và tôi sẽ thu được lợi nhuận. Được rồi, hãy thực hiện điều đó với biến s này và chúng ta thấy một biến chưa được truy cập. Hãy chèn vào đây hai cái và mang đến đây một cái.

4292
00:03:26,330 --> 00:03:38,120
Và chúng tôi đã hoàn tất khi thấy thông báo được kết nối số 0, ba và hai và chúng đã được truy cập, vì vậy không cần phải làm gì ở đây. Hãy bật một cái ở đây, OK, vì chỉ có chúng tôi có một cái ở đây.

4293
00:03:38,420 --> 00:03:47,720
Chúng tôi thấy nó đã được truy cập nên sẽ không in. Và nó đây, ngay đây, ngay đây. Chúng ta thấy rằng đây sẽ luôn là mặc định và một lần nữa, bốn bốn lại là một.

4294
00:03:48,050 --> 00:04:16,310
Vậy là chúng ta đã hoàn tất. Chúng tôi nhận được danh sách này. Và đây là giờ đầu tiên của biểu đồ này do cấu trúc được hiểu rõ về cách hoạt động của thuật toán phòng thủ, hiểu cách chúng tăng nó, xem qua một ví dụ và cố gắng làm việc bằng cách chọn các đỉnh khác nhau như loại R X, thuật toán này chỉ lấy V lớn hơn cộng với độ phức tạp về thời gian và độ phức tạp về không gian v lớn hơn đối với khu vực đã ghé thăm này và cả đối với khu vực này là công nghệ.

4295
00:04:16,550 --> 00:04:27,160
Vì vậy, chúng tôi không mong đợi một chữ V. Nó có thể đưa tôi đến V, nhưng nó tương đương với V lớn hơn và ở đây nó sẽ lớn hơn gấp đôi nếu chúng tôi cộng với độ phức tạp của vật phẩm Harvey là số lượng vi-rút.

4296
00:04:27,190 --> 00:04:35,270
Điều đó có nghĩa số nút là số cạnh với hy vọng bạn hiểu thuật toán này.
Cảm ơn đã xem video này. Tôi sẽ gặp bạn trong video tiếp theo. 

@@@



4297
00:00:00,450 --> 00:00:11,930
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này, chúng ta sẽ nói về thuật toán sắp xếp tôpô. Nhiều tình huống trong thế giới thực có thể được mô hình hóa dưới dạng đồ thị có hướng.

4298
00:00:11,940 --> 00:00:28,020
Đây có phải là nơi một số sự kiện phải xảy ra trước khi những sự kiện khác được dự đoán chẳng hạn? Giả sử bạn là sinh viên của trường đại học. Muốn học lớp B thì phải học lớp E.

4299
00:00:28,110 --> 00:00:42,870
Đây là tín dụng mà chúng ta có thể giải quyết loại vấn đề này bằng cách sử dụng sự cố. Chương trình kém tư duy logic chỉ trong một chương trình sẽ được thực thi nếu tất cả chương trình bị cáo đều được thực thi.

4300
00:00:43,650 --> 00:01:01,950
Chương trình thần thánh sử dụng tư duy logic, mạnh mẽ. Nếu một chương trình có một số phần phụ thuộc thì bị cáo phải được thực thi để thực thi chương trình đó. Bị cáo Chương trình sử dụng chứng chỉ tôpô thậm chí để lập lịch trình đồng đều.

4301
00:01:02,730 --> 00:01:15,900
Chúng ta có thể sử dụng một suy nghĩ hợp lý để xảy ra. Một sự kiện, một số sự kiện phải xảy ra trước những sự kiện khác nếu một sự kiện khác với sự kiện khác mà chúng ta không thể sử dụng.

4302
00:01:16,440 --> 00:01:28,980
Rắc rối gặp phải đối với loại vấn đề này. Hỗ trợ Bạn là sinh viên đại học và bạn muốn học lớp 8. Sau đó bạn phải tham gia các lớp học.

4303
00:01:29,280 --> 00:01:44,970
Và nếu, khi PD tốt nghiệp, đây là lực hấp dẫn đối với cấu trúc ở đây. Giả sử đó là Lớp B, lớp này là lớp, v.v. Ở đây, giả sử chúng ta muốn học lớp 8 này.

4304
00:01:44,970 --> 00:02:05,130
Muốn học lớp 8 này thì phải học lớp 8. Nếu D và E để học lớp này thì bạn phải học lớp E này để học lớp E này, chúng ta phải học lớp D và B này để học lớp B này, chúng ta phải học lớp này E đến đây để tham gia lớp học này.

4305
00:02:05,140 --> 00:02:16,580
Nếu chúng tôi phải học Lớp C và D này để được học lớp này thì bạn phải học Lớp tám này. Vậy ở đây chúng ta thấy chúng ta có bị cáo, ở đây chúng ta thấy chúng ta có Peter tham lam nhất.

4306
00:02:17,330 --> 00:02:34,530
Vì vậy trước khi học lớp này chúng ta phải học những lớp đã được ghi sẵn. Đây là một ví dụ về chương trình của bên thứ ba tôpô. Việc xây dựng một chương trình không thể được xây dựng trừ khi bị cáo buộc phải xây dựng.

4307
00:02:35,400 --> 00:02:49,650
Giả sử ở đây chúng ta muốn xây dựng chương trình này h. Để xây dựng chương trình này, chúng tôi phải xây dựng chương trình INSISTE khác nhau gồm 8 chương trình. Bị cáo thuộc E là phụ thuộc EDF của if là DC.

4308
00:02:49,980 --> 00:03:05,080
Các phụ thuộc của E là các phụ thuộc của BD là các phụ thuộc của Abdi là b và các phụ thuộc của see là a. Vì vậy, để. Xây dựng chương trình này. Trước tiên chúng ta phải xây dựng tất cả các trung tâm khác nhau.

4309
00:03:05,680 --> 00:03:24,400
Đây là một ví dụ về sắp xếp logic Sắp xếp tôpô chỉ hoạt động đối với biểu đồ tuần hoàn có hướng. Từ DSG có hướng đồ thị theo chu kỳ. Nếu biểu đồ có chu trình của nó thì việc sắp xếp tôpô sẽ không hoạt động.

4310
00:03:24,910 --> 00:03:38,870
Bây giờ chúng ta hãy xem. Định nghĩa chính thức của suy nghĩ logic đó là sự sắp xếp logic không phải là thứ tự của các nút trong biểu đồ tuần hoàn có hướng trong đó được hướng từ không đến không.

4311
00:03:38,890 --> 00:04:01,300
Nó xuất hiện trước và không theo thứ tự. Đây là một định nghĩa chính thức về tư duy tôpô. Giả sử chúng ta có biểu đồ này trong biểu đồ này, chúng ta thấy rằng chúng ta có một chu trình trong đó từ nút này đến nút này, chúng ta có thể di chuyển đến nút này bốn từ bốn đến sáu từ sáu đến ba từ sáu đến hai.

4312
00:04:01,540 --> 00:04:22,600
Vì thế chúng tôi thấy ở đây thật xa cách. Đây không phải là một biểu đồ tuần hoàn. Đây là một đồ thị tuần hoàn. Vì vậy, sắp xếp tôpô có thể được áp dụng cho biểu đồ này. Loại bài viết kép chính trị chỉ hoạt động đối với biểu đồ tuần hoàn có hướng, vì vậy nó chỉ hoạt động đối với biểu đồ tuần hoàn có hướng.

4313
00:04:23,560 --> 00:04:36,970
Nếu bạn được cung cấp biểu đồ này ở đây, chúng tôi có thể xuất bản Got Cert một cách khéo léo. Ở đây chúng tôi không có chu kỳ. Bây giờ hãy xem cách sắp xếp tôpô thực sự hoạt động như thế nào. Đối với điều đó, tôi sẽ lấy một số ví dụ cho ví dụ.

4314
00:04:38,440 --> 00:04:57,730
Nếu bạn được cung cấp biểu đồ này, thì chúng ta phải tìm cấu trúc liên kết được nói từ biểu đồ này. Đầu tiên, chúng ta phải hiểu biểu đồ này được xây dựng như thế nào. Biểu đồ này được xây dựng bằng cách thêm, Đây có phải là ở đây chúng tôi có phương thức thêm vào anh ấy.

4315
00:04:58,030 --> 00:05:13,480
Bạn biết đấy, chúng tôi vừa chỉ cho bạn cách xây dựng biểu đồ này và nó là năm hai năm hai hai, rồi năm hai không bốn hai không, rồi bốn hai một, rồi hai hai ba rồi ba phần một.

4316
00:05:14,470 --> 00:05:33,150
Bây giờ hãy giả sử chúng ta có năm cổ điển ở đây. Giả sử chúng ta có ở đây năm chiếc tủ số 0 là Klotz, một chiếc là ví cầm tay. Hai là a. Và vân vân. Lớp chúng ta có Juno một hai ba, được rồi.

4317
00:05:34,210 --> 00:05:51,040
Bốn. Hãy hiểu biết. Chúng tôi giả định trong lớp một trong Lớp ba, bộ ly hợp, v.v. Vì vậy, ở đây chúng tôi có tổng cộng sáu lớp ở đây. Chúng ta phải lấy ly hợp này trước ly hợp khác làm điều kiện tiên quyết.

4318
00:05:51,640 --> 00:06:03,040
Ở đây chúng ta có năm hai. Nghĩa là muốn học được lớp hai thì phải học lớp năm. Ở đây chúng tôi có một danh sách để đăng ký lớp học này.

4319
00:06:03,530 --> 00:06:19,140
Chúng ta có phải ghi danh lớp năm này trước không? Chỉ khi đó chúng ta mới có thể đăng ký lớp hai này để đăng ký lớp 0 này. Lớp 5 chỉ có thể đăng ký Lớp 0 để đăng ký lớp này, bạn biết đấy, nhanh hơn để đăng ký tại đây.

4320
00:06:19,150 --> 00:06:29,620
Để đăng ký lớp này, tôi phải xử lý Lớp bốn để đăng ký lớp này vào Lớp hai trước để xử lý lớp một hai trong Lớp ba trước.

4321
00:06:30,400 --> 00:06:43,720
Vì vậy, ở đây chúng ta có một số vị từ và ở đây bằng biểu đồ, chúng ta thấy rằng để tham gia lớp học này, chúng ta không có điều kiện tiên quyết nào, được chứ? Vì vậy, chúng ta có thể tham gia lớp học này mà không cần ghi trước ở đây.

4322
00:06:43,750 --> 00:06:52,350
Ngoài ra, chúng tôi có lớp bốn này. Chúng tôi không có điều kiện tiên quyết. Để tham gia lớp học này, chúng tôi có hai học sinh năm và bốn khá cứng nhắc. Vì vậy, để tham gia lớp học này, bạn không.

4323
00:06:52,360 --> 00:07:02,200
Chúng ta phải học Lớp năm và Lớp bốn để học lớp này phải học lớp năm này để học lớp này để tạo ra Lớp hai để học lớp này.

4324
00:07:02,200 --> 00:07:13,090
Bạn muốn học lớp ba và lớp bốn này? Bây giờ chúng ta phải tìm ra thứ tự tôpô của trọng lực này đối với cấu trúc. Đây là biểu đồ Insightly có hướng.

4325
00:07:13,120 --> 00:07:24,260
Chúng tôi không có chu trình trong biểu đồ này, vì vậy chúng tôi có thể áp dụng ở đây. Chứng chỉ tôpô Các hạt đầu tiên trong phân loại tôpô luôn là một đỉnh không có đỉnh đi đến.

4326
00:07:24,970 --> 00:07:36,160
Ở đây chúng ta thấy bốn năm. Chúng tôi không có đến là điều này và bốn bốn. Chúng tôi không có đến là điều này. Vì vậy, năm có thể là đỉnh đầu tiên trong thứ tự tôpô.

4327
00:07:36,760 --> 00:07:47,800
Ngoài ra, bốn có thể là hai hạt đầu tiên trong trật tự tôpô. Đây là một trật tự logic hợp lệ năm bốn hai ba một không và bốn năm hai ba một không.

4328
00:07:48,100 --> 00:08:02,700
Hai cái này là thứ tự tôpô hợp lệ. Bây giờ chúng ta hãy xem thứ tự tôpô này hoạt động như thế nào. Đầu tiên chúng ta có năm, sau đó chúng ta có bốn. Ở đây chúng ta thấy bốn năm.

4329
00:08:02,730 --> 00:08:17,700
Chúng tôi không có dự đoán bốn bốn. Chúng tôi không có điều kiện tiên quyết, vì vậy chúng tôi có thể có bốn và năm ở đây theo bất kỳ thứ tự nào vì chúng không có bất kỳ điều kiện tiên quyết nào. Đó là ở đây chúng ta có hai cho hai.

4330
00:08:17,910 --> 00:08:38,730
Chúng tôi thấy nó. Chúng tôi vẫn khá tốt. Năm. Để học được lớp này, chúng ta phải học lớp năm trước. Sau đó, chúng tôi có cây của bạn để chọn lớp này trước tiên chúng tôi đến lớp hai, sau đó một để chọn lớp này, một thứ tự cho lớp bốn và ba và bốn và ba xuất hiện ở bên trái.

4331
00:08:38,760 --> 00:08:52,470
Điều đó có nghĩa là bốn và ba xuất hiện trước một. Bây giờ với số không, chúng tôi xem bạn làm gì. Chúng tôi có hai chiếc Peter Gadget năm và bốn. Và chúng ta thấy ở đây năm và bốn xuất hiện trước số không.

4332
00:08:53,010 --> 00:09:05,850
Vì vậy, đây là một trật tự tôpô hợp lệ. Bây giờ chúng ta hãy xem thứ tự tôpô này. Đầu tiên, chúng tôi có bốn. Và sau đó chúng tôi có năm đàn anh, chúng tôi không có máy bay phản lực Beluga, bốn hoặc năm và bốn.

4333
00:09:05,870 --> 00:09:17,930
Chúng ta sẽ có, chúng ta có thể có bốn và năm theo thứ tự bất kỳ. Vì vậy, ở đây chúng tôi chỉ cần tiến nhanh về phía trước và chiến đấu. Nó khác nhau về việc triển khai cấu trúc dữ liệu và triển khai thuật toán.

4334
00:09:18,530 --> 00:09:30,560
Bây giờ chúng tôi cũng có mặt ở đây để có thể tham gia lớp học này. Chúng ta phải học lớp năm năm xuất hiện trên LIPPED, rồi bốn ba. Chúng tôi cũng có những khoản nợ lớn hơn.

4335
00:09:30,980 --> 00:09:43,430
Chúng ta thấy hai bên trái, một đối một, chúng ta phải làm khá tốt điều này bốn và ba. Vì thế bốn và ba xuất hiện ở bên trái, nên bốn và ba xuất hiện trước một.

4336
00:09:43,820 --> 00:10:00,320
Sau đó phải làm gì? Chúng tôi có hai khoản nợ khá tốt và chúng tôi thấy bốn và năm khoản nợ xuất hiện trước đó, bạn biết đấy. Vì vậy, đây là một trật tự chính trị hợp lệ. Hy vọng bạn đã hiểu thứ tự chính trị hàng đầu trong ba phần tiếp theo là gì để tìm ra cách kiểm tra tôpô của đồ thị chu kỳ có hướng?

4337
00:10:00,800 --> 00:10:19,690
Bây giờ hãy lấy một ví dụ khác. Ví dụ: nếu bạn được cung cấp biểu đồ này và ở đây chúng ta phải thực hiện năm lớp, giả sử ở đây chúng ta có bốn lớp 0, một, hai hoặc ba, và ở đây chúng ta có một số điều kiện để tham gia lớp học về Abdoul trước tiên hãy học lớp không.

4338
00:10:20,090 --> 00:10:32,060
Để thi được năm ngoái thì phải thi lớp 0 để thi lớp một lên làm hai môn cuối trước, để thi được lớp một trong hai thì phải thi lớp ba trước theo thứ tự lớp phải học lớp ba trước.

4339
00:10:32,450 --> 00:10:45,830
Đây là nó. Đây là biểu đồ Insightly có hướng. Thứ tự tôpô hợp lệ của biểu đồ này là thứ tự hai cấu trúc liên kết này. Được rồi, bây giờ hãy xem nó hoạt động như thế nào.

4340
00:10:46,220 --> 00:11:02,360
Đầu tiên, chúng tôi có số 0 dành cho bạn. Chúng tôi không có điều kiện tiên quyết. Và đối với ba, chúng tôi không có vị ngữ đó. Vì vậy, nó có thể có số 0 và số 3 theo thứ tự bất kỳ. Chúng tôi có thể lấy số 0 đầu tiên hoặc bạn có thể lấy số 0 đầu tiên, nhưng việc triển khai các chữ số, cấu trúc và thuật toán của bạn sẽ khác.

4341
00:11:02,600 --> 00:11:14,630
Đầu tiên, chúng tôi có bộ gen của bạn. Sau đó chúng tôi có ba. Bây giờ chúng tôi vẫn chưa nghe bạn nói rằng bạn có thể. Nó lên đến số không và ba. Và ở bên trái phía trên chúng ta không có mục nhập nào, vì vậy mục nhập không xuất hiện trước hai.

4342
00:11:15,020 --> 00:11:25,820
Bây giờ chúng tôi có ở đây một. Ở đây chúng ta thấy điều kiện tiên quyết của một là không hai ba và không ba hai xuất hiện bên trái của một. Vì vậy, không ba hai xuất hiện trước một.

4343
00:11:25,910 --> 00:11:36,800
Vì vậy, đây là một thứ tự tôpô hợp lệ. Bây giờ hãy xem thứ tự này hoạt động như thế nào. Đầu tiên, chúng ta có 3 và 0 cho 3 và chúng ta không có điều kiện tiên quyết nào. Chúng ta có thể vào lớp theo thứ tự bất kỳ.

4344
00:11:36,870 --> 00:11:48,370
Ba. Do thứ tự hai ba không hai ba, rồi 0, nên chúng tôi có hai bạn. Ở đây chúng ta thấy hai có hai điều kiện tiên quyết và ba điều kiện khác nhau có vẻ là hai, rồi một đối một.

4345
00:11:48,380 --> 00:11:59,960
Chúng ta có ba Brigitte và thấy rằng ba không hai dường như là bốn một. Vì vậy, đây là một
thứ tự tôpô hợp lệ. Đã hiểu. Cách sắp xếp hợp lý nhất trong video tiếp theo là gì? 

@@@



4346
00:00:00,390 --> 00:00:09,870
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này, chúng ta sẽ nói về cách tìm thứ tự tôpô của đồ thị chu kỳ có hướng.

4347
00:00:10,320 --> 00:00:21,690
Đầu tiên chúng ta hãy xem thuật toán, sau đó chúng ta sẽ xem thuật toán này hoạt động như thế nào. Đây là thuật toán sắp xếp topo. Thuật toán này hoạt động theo kiểu DFS.

4348
00:00:22,140 --> 00:00:36,570
Đầu tiên, chúng ta sẽ khám phá càng sâu càng tốt. Chúng tôi biết DFI hoạt động như thế nào. Chúng ta đã nói chi tiết về DFS trong phần thảo luận này. Bây giờ, trước tiên hãy xem lại thuật toán này, sau đó chúng ta sẽ xem nó thực sự hoạt động như thế nào.

4349
00:00:36,840 --> 00:00:50,280
Đầu tiên, chúng ta có chức năng sắp xếp cấu trúc liên kết này. Hàm này không có tham số bên trong. Ở đây chúng ta đang tạo một ngăn xếp trong ngăn xếp. Chúng ta sẽ có thứ tự tôpô mà chúng ta có ở đây có thể giải mã được.

4350
00:00:50,520 --> 00:01:06,000
Sau đó, chúng tôi có ở đây mảng lỗi của chúng tôi trong lĩnh vực này. Chúng tôi sẽ theo dõi các đỉnh đã truy cập. Thế rồi ở đây chúng ta có tình yêu này. Tình yêu này sẽ chạy từ 0 đến từ 0 đến các điểm trừ một i đỉnh Lisbon.

4351
00:01:06,570 --> 00:01:34,290
Ở đây chúng ta có câu lệnh if này. Nếu các biểu tượng được truy cập mặc định thì chúng tôi sẽ gọi loại biểu tượng hàng đầu này là lý tưởng trong chức năng tiện ích này. Chúng tôi đang gọi Vertex zero hiện tại với mảng đã truy cập và chúng tôi chỉ kiểm tra xem hàm này sẽ xây dựng ngăn xếp mà chúng tôi cần thực hiện với điều này, phần dự phòng sẽ có thứ tự tôpô trong ngăn xếp của chúng tôi có thể sẽ chạy từ đầu ngăn xếp của chúng tôi và nó sẽ in ID này, nhưng bạn thực hiện chức năng.

4352
00:01:34,650 --> 00:01:47,040
Hàm này lấy ba tham số là đỉnh hiện tại, mảng đã truy cập và một ngăn xếp. Ở đây chúng ta đánh dấu đỉnh hiện tại là đỉnh đã thăm, đỉnh V đã thăm được gọi là cấu trúc đứng.

4353
00:01:47,580 --> 00:01:59,290
Sau đó, chúng tôi có dòng số nguyên mong muốn mà chúng tôi có ở đây. Trình lặp này ở đây sẽ có tất cả các đỉnh liền kề cho đỉnh hiện tại của chúng ta. Ở đây chúng tôi có người tôi sống ở Israel này.

4354
00:01:59,400 --> 00:02:13,920
Chúng tôi sẽ kiểm tra xem chúng tôi đã trộn chưa. Điều đó có nghĩa là nếu chúng ta có bit liền kề, chúng ta sẽ kiểm tra xem nó có được truy cập hay không. Cuộc gọi mới này sẽ sắp xếp bạn udu theo cách đệ quy với nút liền kề.

4355
00:02:14,340 --> 00:02:30,180
Khi bạn tìm thấy nó, nút phòng thủ sẽ chèn Vertex hai hiện tại. Đây là công nghệ. Điều này hoạt động theo cách DFS. Đầu tiên, tất cả di chuyển càng xa càng tốt. OK, bây giờ hãy xem thuật toán này hoạt động như thế nào.

4356
00:02:30,760 --> 00:02:40,920
Hãy để bạn được cung cấp biểu đồ này cho cấu trúc. Điều này được thể hiện bằng cách sử dụng liền kề để liệt kê một cái gì đó giống như số 0 này được kết nối với một. Zero hướng dẫn đến hai.

4357
00:02:41,430 --> 00:02:51,780
Chúng ta có thể di chuyển từ 0 đến 1, từ 0 đến 2, rồi từ 1. Chúng tôi không thể di chuyển đi đâu cả. Sau đó chúng ta có năm thứ hai. Từ hai, chúng ta có thể chuyển sang một. Sau đó chúng ta có ba từ ba.

4358
00:02:51,780 --> 00:03:02,490
Chúng ta sẽ chuyển sang một. Từ ba, chúng ta có thể di chuyển hai hai. Vì vậy, đây là cách biểu diễn logic của danh sách kề này để giải quyết vấn đề này bằng DFS.

4359
00:03:02,850 --> 00:03:16,560
Chúng tôi sẽ sử dụng cấu trúc tiêu chuẩn cho vấn đề phòng thủ mà tất cả chúng tôi đều điều chỉnh. Nó là ngăn xếp và đây là mảng để theo dõi các đỉnh đã truy cập. Hãy thêm vào chúng tôi có các lớp học đầy đủ ở đây.

4360
00:03:16,640 --> 00:03:30,300
Ở đây, chúng tôi giả sử các đỉnh là cổ điển và chúng tôi có một số điều kiện tiên quyết để tham gia lớp hoặc để kích hoạt lớp một trong lớp 0 trước, v.v.

4361
00:03:31,200 --> 00:03:44,410
Bây giờ chúng ta hãy xem làm thế nào để tìm thấy nó. Cặp thứ tự logic từ biểu đồ đã cho này. Đây là một đồ thị chu kỳ có hướng. Bạn biết đấy, chúng tôi có chu kỳ và chúng tôi có hướng đi liên quan đến ACIS.

4362
00:03:44,910 --> 00:03:57,020
Đầu tiên, bạn sẽ lấy nút 0. Ở đây chúng ta có bức tường IndiaGlitz bằng không. Chúng ta sẽ có nút đầu tiên bằng 0. Vì vậy, chúng tôi thấy điều này không được truy cập ở chỉ số 0.

4363
00:03:57,030 --> 00:04:06,870
Chúng tôi có lỗi ban đầu. Khu vực này chứa đầy những gì ở đây. Chúng tôi không hiển thị cho bạn giá trị sai. Theo mặc định, chúng tôi có sai của bạn. Vì vậy, ở chỉ số 0, chúng ta có lỗi.

4364
00:04:07,140 --> 00:04:18,330
Vì vậy, chúng tôi sẽ gọi đây là loại hàng đầu. Bạn xử lý số 0 của Vertex hiện tại bằng khu vực đã truy cập và chúng tôi đã xếp chồng lên nhau. Ngăn xếp ban đầu trống. Bây giờ hãy xem thuật toán này hoạt động như thế nào.

4365
00:04:18,840 --> 00:04:30,600
Đầu tiên, tôi sẽ làm gì. Tôi sẽ di chuyển theo bất kỳ hướng nào. Chúng ta có tối đa hai và chúng ta có thể chuyển sang một vì hai và một là liền kề của nút kỹ thuật số này.

4366
00:04:31,050 --> 00:04:44,400
Nhưng bạn không thể di chuyển theo bất kỳ hướng nào. Nó khác về thuật toán của bạn và nó khác về việc triển khai công cụ phân tâm mà bạn đã nắm bắt ở đây. Đối với thuật toán này và cách triển khai này, tôi sẽ chuyển sang thuật toán đó.

4367
00:04:44,610 --> 00:04:56,760
Thế là từ con số 0, tôi chuyển từ một sang một. Chúng tôi thấy nó. Chúng tôi không thể di chuyển đến bất kỳ nút nào. Vì vậy, trước tiên hãy quay lại. Chúng tôi đã đến thăm số không. Vì vậy, hãy bên trong sự thật của bạn.

4368
00:04:57,270 --> 00:05:11,560
ĐƯỢC RỒI. Chúng tôi đã đến thăm số không. Bây giờ đây là của chúng tôi. Nút hiện tại, chúng ta nhìn thấy nó từ đây, không phải chúng ta không thể đi đâu cả. Chúng tôi bị mắc kẹt ở đây. Vì vậy, chúng tôi tìm thấy nó ở đây. Nút sâu nhất vì ở đây đang làm tháp đầu tiên.

4369
00:05:12,160 --> 00:05:23,890
Bây giờ tôi sẽ làm gì đây. Tôi sẽ chèn nút này vào ngăn xếp này ở đây. Điều này có nghĩa là gì? Nó có nghĩa là chúng tôi không cần phải gửi một cái.

4370
00:05:24,250 --> 00:05:37,090
Và ở đây chúng ta thấy đối với nút này, chúng ta không có nút liền kề và ở đây chúng ta đang gọi đệ quy. Được rồi, chúng ta đang gọi đệ quy. Vì vậy, đối với một, chúng tôi không có liền kề.

4371
00:05:37,720 --> 00:05:49,330
Nó có nghĩa là nút này không phải là puka, nó nằm ngoài bất kỳ nút nào khác. Vì vậy điều tôi sắp làm là tôi sẽ chèn ghi chú này vào ngăn xếp. Bây giờ chúng ta hãy quay lại ở đây.

4372
00:05:50,080 --> 00:06:04,480
Chúng ta thấy chúng ta đang ở mức 0. Bây giờ ở đây, được rồi, chúng ta quay lại đây. Vì vậy, chúng ta đã chuyển sang lệnh gọi hàm đệ quy trước đó khi bạn gọi nó là đỉnh 0. Bây giờ chúng ta thấy rằng chúng ta có cách để di chuyển.

4373
00:06:04,720 --> 00:06:16,030
Vì vậy, chúng ta sẽ chuyển sang nút này ở đây thành hai. Vì vậy, chúng tôi đã chuyển đến nút thứ hai này. Ở đây chúng tôi có bộ công cụ này bên cạnh bồi thẩm đoàn số hai. Vì vậy bây giờ chúng tôi đã chuyển đến đây cho hai người.

4374
00:06:16,060 --> 00:06:28,930
Chúng tôi có một cái và chúng tôi thấy một cái đã được truy cập khi anh ấy đến thăm một cái. Chúng ta phải đánh dấu điều này bằng hai. Bây giờ chúng ta sẽ quay lại và từ đây nó sẽ chuyển từ nút này sang nút này.

4375
00:06:28,930 --> 00:06:40,390
Liền kề là objeto bây giờ cho hai người. Chúng tôi thấy rằng chúng tôi có một cái khác. Vì vậy, đối với tôi, chúng ta có thể chuyển sang một địa điểm, nhưng một địa điểm đã được truy cập. Vì vậy chúng ta không thể di chuyển đến một.

4376
00:06:40,930 --> 00:06:56,970
Bây giờ tôi sẽ làm gì đây. Tôi sẽ đánh dấu hai nơi này là đã ghé thăm vì hiện tại chúng tôi đã ghé thăm hai nơi. Không có nơi nào để đi từ nút này đến. Vì vậy, hãy chèn nút này vào ngăn xếp này ở đây.

4377
00:06:56,980 --> 00:07:09,460
Nó có nghĩa là chúng ta có các nút liền kề của nút này ở đây. Nó có nghĩa là chúng ta có thể di chuyển đến nút đó ở đây để có thể chuyển từ hai sang một. Nhưng một người đã được viếng thăm.

4378
00:07:09,680 --> 00:07:23,830
Vì vậy, chúng tôi đã truy cập nút thứ hai này và chúng tôi đã đánh dấu và chúng tôi đã đánh dấu nút này. Điều này rất đúng. Vì vậy từ đây, chúng ta không thể di chuyển sang bất kỳ hướng nào. Vì vậy, hãy quay lại.

4379
00:07:24,100 --> 00:07:35,440
Bây giờ đây là hiện tại của chúng tôi. Bây giờ đây là những gì tôi sẽ làm. Tôi sẽ xử lý nút này. OK, điều này đã được truy cập. Vì vậy, hãy xử lý ghi chú này và chèn số 0 vào đây vào ngăn xếp.

4380
00:07:35,450 --> 00:07:45,730
Chúng ta có một, hai Arduino ở cuối ngăn xếp này, chúng ta có một. Điều này có nghĩa là gì? Điều đó có nghĩa là một nút không phải là điều kiện tiên quyết thuần túy cho bất kỳ nút nào khác.

4381
00:07:46,420 --> 00:07:58,600
Và để có được ly hợp này, chúng ta phải chọn lớp mà chúng ta có ở trên cùng của ngăn xếp này. ĐƯỢC RỒI. Ở đây có hai nghĩa là để học lớp này, chúng ta phải học lớp chúng ta có ở trên cùng của ngăn xếp.

4382
00:07:58,810 --> 00:08:06,160
Bạn biết đấy, không được tham gia lớp học này. Chúng ta phải học lớp, bất kể lớp nào chúng ta có ở trên cùng, Dilnot, chúng ta không có lớp nào ở trên cùng.

4383
00:08:06,790 --> 00:08:18,850
Bây giờ chúng tôi đã làm kỹ thuật số. Bây giờ chúng ta sẽ chuyển sang các đỉnh tiếp theo. Tiếp theo là một. Đầu tiên, chúng ta duyệt đồ thị bằng cách lấy số 0 làm gốc của.

4384
00:08:19,870 --> 00:08:30,820
Chúng ta có kẻ khủng bố. Biểu đồ đó cho Vertex zero là các sĩ quan Ấn Độ. Bây giờ hãy lấy phần tiếp theo của phần tiếp theo của chúng ta. Chúng tôi thấy khi nào anh ấy đã được thăm. Bây giờ chúng ta hãy chuyển sang phần tiếp theo.

4385
00:08:30,850 --> 00:08:39,710
Nhưng đó là hai anh em sinh đôi đã đến thăm. Bây giờ hãy lấy đỉnh tiếp theo có ba ba chưa được thăm. OK, vậy hãy gọi đây là bạn thực hiện chức năng ở đây.

4386
00:08:39,730 --> 00:08:51,520
Chúng tôi gọi đây là hàm udu và chèn hai hàm vào đây. Bây giờ với ba, chúng ta thấy chúng ta có một. Một đã được truy cập. Chúng tôi phải làm đã đến thăm. Đầu tiên, chúng ta sẽ di chuyển theo hướng này.

4387
00:08:51,530 --> 00:09:00,850
Chúng tôi thấy khi nào được truy cập. Vì vậy, hãy quay lại. Hãy di chuyển theo hướng này. Hai đã được truy cập. Vì vậy, hãy xử lý nút này. Hãy chèn cái này không vào ngăn xếp.

4388
00:09:01,120 --> 00:09:12,850
Vì vậy chúng tôi đã chèn vào đây ba. Vì vậy, chúng ta phải truy cập lực hấp dẫn để cấu trúc cho lần lặp tiếp theo I đến bốn và các đỉnh của nó bằng bốn. Vì vậy, với ít hơn bốn, chúng tôi không có lỗi.

4389
00:09:12,860 --> 00:09:25,810
Vì vậy, việc theo dõi này sẽ dừng lại và chúng tôi có cho bạn cái này trong khi bạn đang sử dụng cái này một thời gian sẽ bật ra top 11 từ ngăn xếp và in lại. Vì vậy, trước hết, ba, hãy in ba, sau đó đổi chỗ số 0.

4390
00:09:25,810 --> 00:09:38,170
Hãy in số không. Bây giờ chúng ta hãy bật cho hai người. Hãy in hai. Hãy bật một cái. Hãy in ở đây một cái. Vì vậy chúng tôi sẽ loại bỏ ở đây. Nhưng điều đó sẽ loại bỏ phần tử khỏi ngăn xếp.

4391
00:09:38,560 --> 00:09:52,420
Vì vậy, chúng tôi nhận được thứ tự tôpô này. Vì vậy, đây là một thứ tự tôpô hợp lệ. Để vào được hạng một, chúng ta phải lấy ly hợp ba, hai và không.

4392
00:09:52,450 --> 00:10:06,790
Ở đây chúng ta thấy rằng để có được cái cuối cùng đó thì phải làm số 0, hai và ba để đưa lớp đến mọi thứ vốn có. Ba và không. Để làm được điều đó, bạn biết đấy, chúng tôi không có phần ghi công video để làm điều đó vào năm ngoái, chúng tôi không có vé.

4393
00:10:06,970 --> 00:10:18,890
Vì vậy, đây là một trật tự tôpô hợp lệ. Đây là cách phân loại địa chính trị hoạt động. Chà, chúng tôi đã hiểu thuật toán này ở mức rất cao. Bây giờ hãy lấy một ví dụ khác để hiểu rõ hơn.

4394
00:10:19,330 --> 00:10:30,640
Chúng ta hãy xem điều gì đã đưa ra rằng đây là biểu đồ Insightly trực tiếp và đây là sự thể hiện của cấu trúc trọng lực này. Hãy sử dụng công nghệ này và vùng Boolean để giải quyết vấn đề này.

4395
00:10:30,940 --> 00:10:43,270
Vì vậy, trước tiên, hãy bắt đầu từ chỉ số 0. Từ Index 0, chúng ta không thể di chuyển sang bất kỳ hướng nào từ 0. Chúng ta không thể di chuyển đến bất kỳ đỉnh nào. Vì vậy, hãy đánh dấu số 0 bằng hai.

4396
00:10:43,810 --> 00:10:58,360
Vì vậy hãy để dấu 0 rút khỏi số x 0 thông minh. Chúng ta không thể khám phá bất kỳ đỉnh nào. Chúng ta không có mối liên hệ nào giữa đỉnh này với đỉnh khác. Vì vậy, hãy chèn số đúng của bạn và xử lý nốt số 0 này vì chúng ta không thể di chuyển đến bất kỳ đỉnh nào.

4397
00:10:59,080 --> 00:11:16,680
Bây giờ chúng ta hãy lấy đỉnh tiếp theo ở đây, được chứ? Một cái chúng ta thấy. Thứ nhất, chúng ta không thể chuyển sang bất kỳ phán quyết nào. Vì vậy, hãy tiếp thị là đúng và hãy chèn vào đây một kết quả từ vòng xoáy này, chúng tôi không thể chuyển sang bất kỳ phán quyết nào, vì vậy chúng tôi đã xử lý nó.

4398
00:11:17,250 --> 00:11:29,100
Bây giờ chúng ta hãy chuyển sang hai. Sử dụng di động này đến từ hai. Chúng ta có thể chuyển sang ba. ĐƯỢC RỒI. Vì vậy, hãy đánh dấu hai là đã truy cập. Bây giờ hãy đánh dấu ba là đã truy cập. Đây là sự thật.

4399
00:11:29,490 --> 00:11:45,750
Bây giờ chúng ta thấy từ ba, chúng ta có thể đi đến một, nhưng một đã được truy cập. Vì vậy, hãy chèn ba vào ngăn xếp. Bây giờ chúng ta hãy quay lại đây. Chúng tôi có hai. Bây giờ ở đây chúng ta thấy không có cách nào để đi từ hai vì ba đã được thăm rồi.

4400
00:11:45,930 --> 00:11:57,900
Vì vậy hãy chèn vào đây. Hai. Bây giờ chúng ta hãy chuyển sang hai phán quyết tiếp theo. Đỉnh tiếp theo là ba. Ở đây chúng ta thấy từ ba, chúng ta có thể chuyển sang một. Nhưng một người đã được viếng thăm cho ba người.

4401
00:11:57,920 --> 00:12:08,130
Chúng tôi thấy cái cây đó đã được ghé thăm. Hãy chuyển sang đỉnh tiếp theo có giá trị bằng bốn từ bốn. Chúng ta thấy rằng chúng ta có thể di chuyển về 0 và chúng ta có thể di chuyển đến một. Đầu tiên, hãy chuyển về số 0.

4402
00:12:08,430 --> 00:12:18,690
Di chuyển về không. Và chúng tôi đã đến thăm. Vì vậy hãy quay lại từ đây. Chúng tôi thấy rằng một cái đã được truy cập. Từ đây, chúng ta thấy rằng chúng ta có một. Một đã được truy cập.

4403
00:12:18,720 --> 00:12:31,140
Vì vậy, hãy xử lý việc này. Không phải bốn. Chúng tôi đã truy cập nút này. Vậy hãy biến nó thành sự thật. Chúng ta phải tiếp thị như một công cụ khi dự tính có nút lần đầu tiên, hãy chèn bốn nút vào ngăn xếp.

4404
00:12:31,470 --> 00:12:42,870
Vậy là chúng ta đã hoàn tất. Bây giờ chúng ta hãy chuyển sang đỉnh tiếp theo. Đó là. Năm. ĐƯỢC RỒI. Ở đây, chúng ta thấy từ năm, chúng ta có thể chuyển sang hai giờ sáng cho đến 0 các chẩn đoán đã được truy cập và hai đã được truy cập.

4405
00:12:43,290 --> 00:12:57,910
Hãy đánh dấu năm điểm là đúng ở đây khi đến thăm lần đầu tiên. Vậy từ năm, chúng ta không thể tiến tới số 0 và chúng ta không thể tiến lên hai bởi vì. 012 đã được truy cập, vì vậy hãy chèn năm vào đây trên thanh này.

4406
00:12:58,840 --> 00:13:13,450
Bây giờ chúng ta đã hoàn tất. Bây giờ chúng ta sẽ làm gì? Chúng tôi sẽ bật phần tử từ ngăn xếp nạp tiền đó. Năm đầu tiên. Hãy ra ngoài hãy bật ra rồi hãy bật ra hai, rồi ba.

4407
00:13:14,390 --> 00:13:31,840
Hãy bật ra ba, rồi một cái, hãy bật ra một từ đây và cuối cùng là số không. Vì vậy hãy ghim số 0 ở đây. Vì vậy, chúng tôi nhận được thứ tự tôpô này. Chúng tôi có sáu tủ quần áo của bạn và chúng tôi có các điều kiện của bạn để học lớp hai.

4408
00:13:32,210 --> 00:13:42,770
Bạn phải học lớp năm và lớp bốn để làm được điều đó, ít hơn 0. Chúng tôi thấy chúng tôi có năm người ở bên trái để vào lớp. Bạn không cần phải làm điều đó lần cuối với bốn trên máy tính xách tay, tăng lên không.

4409
00:13:43,580 --> 00:13:59,750
Để lấy lớp 0 làm được bốn lớp cuối cùng để đưa lớp một lên học lớp bốn để lấy lớp làm lớp hai, chúng ta có hai người bên trái và lấy lớp một trong lớp thậm chí ở bên trái của anh ấy.

4410
00:14:00,020 --> 00:14:23,060
Vì vậy, chúng tôi thấy đây là một thứ tự tôpô hợp lệ của đồ thị tuần hoàn có hướng này. Chỉ có Tiến sĩ Hope mới hiểu cách thức hoạt động của cấu trúc liên kết vào thời điểm đó. Độ phức tạp của ảo giác này lớn hơn chính sách e và độ phức tạp của không gian lớn hơn f v hoặc V số đỉnh và số đỉnh này có nằm trong đồ thị tuần hoàn có hướng đã cho không?

4411
00:14:23,540 --> 00:14:42,500
Vì vậy độ phức tạp thời gian a V cộng e lớn hơn và độ phức tạp không gian nhỏ hơn f v lớn hơn. Chúng ta đã hiểu cách giải thích này. Ngay cả sự hiểu biết 'Owhali cũng
khuyến khích bạn cố gắng vẽ mọi thứ trên một tờ giấy, người hiểu cách hoạt động của loại cấu trúc liên kết ở mức rất cao, thậm chí bất kỳ câu hỏi nào còn nghi ngờ. 

@@@



4412
00:00:00,540 --> 00:00:26,910
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này, chúng ta sẽ nói về vấn đề nguồn đơn, đường đi ngắn nhất. Vì vậy, bài toán nguồn đơn, đường đi ngắn nhất, nguồn đơn, đường đi ngắn nhất là gì về việc tìm đường dẫn giữa một cơn lốc nhất định được gọi là nguồn tới tất cả những người tham gia khác trong biểu đồ cho thấy tổng khoảng cách giữa chúng.

4413
00:00:27,830 --> 00:00:39,590
Điều đó có nghĩa là nguồn và đích là tối thiểu. Vì vậy chúng tôi đang cung cấp nguồn Ortex. Chúng ta phải tìm khoảng cách tối thiểu cho tất cả các từ khác chỉ từ nguồn RDX.

4414
00:00:40,520 --> 00:00:57,650
Đây được gọi là bài toán đường đi ngắn nhất từ ​​nguồn đơn. Giả sử bạn được tặng một vật đánh lạc hướng grafitti ở đây. Chúng tôi có một số trọng lượng. Chúng ta thấy biểu đồ này là một biểu đồ có trọng số, vô hướng, được liên kết với độ dễ acis.

4415
00:00:57,740 --> 00:01:08,660
Vì vậy, đây là một đồ thị có trọng số, vô hướng, giả sử là đỉnh nguồn từ đỉnh này, nếu chúng ta đã xác định khoảng cách tối thiểu đến tất cả các đỉnh khác.

4416
00:01:09,260 --> 00:01:24,290
Vì vậy, từ năm này sang năm khác, khoảng cách tối thiểu bằng 0 đến từ nó. Chúng tôi không có động lực. Vì vậy, bây giờ chúng tôi có số 0 ở đây từ E2EE. Chúng ta thấy khoảng cách tối thiểu là thế này.

4417
00:01:24,830 --> 00:01:41,600
Nếu chúng ta đi theo hướng này cho chúng ta. Sáu thì lấy nếu chúng ta b và chúng ta thấy giá ở đây, sáu cộng hai là tám. Vì vậy, ở đây khoảng cách tối thiểu là một. Vì vậy, từ đỉnh tám này, chúng ta có thể nâng đỉnh e này lên giá một.

4418
00:01:41,840 --> 00:01:54,590
Bây giờ từ đỉnh tám này đến đỉnh B này, chúng ta thấy khoảng cách đó là sáu. Chúng ta di chuyển từ A đến B. Nếu trước tiên chúng ta di chuyển từ đây đến E, sau đó từ E đến đó, chúng ta thấy một cộng hai bằng ba.

4419
00:01:55,040 --> 00:02:06,680
Và nó sẽ di chuyển theo hướng này đầu tiên một, sau đó một, rồi hai. Và đó là với một cộng một cộng chúng ta có hai đến bốn. Vì vậy, ở đây chúng ta thấy rằng chúng ta có thể nâng cao đỉnh này từ nguồn hạt này trên đường đi này.

4420
00:02:06,920 --> 00:02:18,740
Và chi phí trong phần này là ba. Bây giờ chúng ta hãy tìm khoảng cách tối thiểu để đi đến đỉnh này từ đỉnh a này, chúng ta thấy rõ rằng khoảng cách tối thiểu để nâng đỉnh này lên là một cộng một.

4421
00:02:19,160 --> 00:02:32,750
Vì vậy đây là hướng đi. Vậy ở đây chúng ta sẽ có khoảng cách, khoảng cách tối thiểu. Bây giờ, hãy tìm khoảng cách tối thiểu tới đỉnh này, đó là một cộng một cộng năm và có bảy.

4422
00:02:32,930 --> 00:02:43,580
Vì vậy, ở đây chúng ta có thể nâng thanh này lên để nhìn từ đây. Vì vậy, nếu chúng ta muốn ghé thăm thanh này để xem từ đỉnh này, giá sẽ là bảy một cộng một là hai hai cộng năm là bảy.

4423
00:02:44,240 --> 00:02:56,540
ĐƯỢC RỒI. Đây được gọi là bài toán đường đi ngắn nhất từ ​​nguồn đơn. Chúng ta có thể giải quyết vấn đề đường đi ngắn nhất nguồn đơn này bằng thuật toán bổ sung này và sử dụng thuật toán chuyển tiếp Billman.

4424
00:02:56,900 --> 00:03:11,300
Nhưng ở đây, thuật toán bổ sung này không hoạt động đối với chu kỳ âm. Nếu chúng ta có một chu trình âm trong đồ thị đã cho thì thuật toán này sẽ không hoạt động. Vậy chu kỳ tiêu cực là gì?

4425
00:03:11,900 --> 00:03:25,730
Ở đây chúng ta thấy đây là một đồ thị vô hướng. Vì vậy, trong biểu đồ này, chúng ta có chu trình nếu chúng ta có âm bảy ở giai đoạn hai, nếu nó bằng âm bảy và nếu chúng ta thêm nó vào chu trình này, chúng ta sẽ bằng không.

4426
00:03:25,970 --> 00:03:41,300
Vì vậy, ở đây chúng ta không có chu kỳ âm, điều kiện để có một chu kỳ âm ở xa. Chúng ta nên có tổng của nó nhỏ hơn 0. Nhưng ở đây chúng ta thấy chúng ta có elu trong vòng lặp này.

4427
00:03:41,300 --> 00:03:55,040
Chúng ta thấy bảy trừ bảy cộng một cộng hai và có trừ bốn. Vậy chúng ta thấy từ trong chu kỳ này là âm bốn. Đó là tiêu cực. Vì vậy, đây là một chu kỳ tiêu cực.

4428
00:03:55,280 --> 00:04:06,110
Một điều kiện khác cho chu kỳ âm là chúng ta phải vỗ nhẹ để truy cập chu kỳ âm đó từ nguồn ngoài x. Nguồn của chúng tôi ở đây là từ đây.

4429
00:04:06,350 --> 00:04:16,610
Chúng tôi không thể truy cập vào chu kỳ này. Được rồi, đây là một chu kỳ âm trong biểu đồ này. Vì vậy, đối với chu kỳ âm, đơn vị thuật toán bổ sung này hoạt động cho chu kỳ âm.

4430
00:04:16,910 --> 00:04:29,330
Thuật toán chuyển tiếp Billman hoạt động trong video tiếp theo. Chúng ta sẽ xem thuật toán bổ sung này hoạt động như thế
nào, sau đó ở video tiếp theo hoặc xem thuật toán chuyển tiếp Billman hoạt động như thế nào, kiện video tiếp theo. 

@@@



4431
00:00:00,390 --> 00:00:14,800
Trước khi chuyển sang thuật toán bổ sung này, trước tiên, hãy nói về VFS trắng và nếu thuật toán này không hoạt động đối với đường dẫn ngắn nhất một nguồn, thì vấn đề ở đây là đây là trước một danh sách rút gọn nguồn duy nhất.

4432
00:00:14,970 --> 00:00:32,100
Nhưng trước tiên, hãy nói về lý do tại sao nếu điều này không hiệu quả đối với bài toán đường đi ngắn nhất từ ​​một nguồn, chúng ta biết rằng vì việc khám phá một biểu đồ nhất định chỉ đọc theo cách, nhưng chỉ có thể có một tuyến đường tốt hơn, không mất nhiều thời gian.

4433
00:00:33,270 --> 00:00:43,350
Đây là cách hoạt động kinh doanh. Đây là cách hoạt động của năng lượng mặt trời Beerfest. Hãy thêm anh ta tranh luận về lực hấp dẫn này đối với cấu trúc. Điều này đúng với cấu trúc.

4434
00:00:43,470 --> 00:00:55,440
Chúng ta biết rằng cây là một loại trọng lực đặc biệt để cấu tạo nên trọng lực này. Chỉ cần nói chuyện với Adam. Hoặc với đỉnh này, bạn biết đấy, chúng ta phải tìm ra con đường ngắn nhất.

4435
00:00:55,740 --> 00:01:08,220
Chúng ta phải tìm đường đi ngắn nhất từ ​​đỉnh 0 này đến tất cả các đỉnh khác, nếu chúng ta làm ở đây. B, nếu điều này đầu tiên điều khiển cấp độ này, thì cấp độ này ở đây chúng ta thấy rằng khoảng cách giữa cái này khác 0 và một là mười.

4436
00:01:08,760 --> 00:01:28,410
Và ở đây chúng ta chuyển sang cấp độ này. Chúng ta thấy rằng khoảng cách từ đỉnh này đến đỉnh ba này là 10 cộng 30. Tức là 40. Nhưng chúng ta thấy rằng khoảng cách tối thiểu từ đỉnh này đến đỉnh X ba thông minh là mười cộng năm cộng sáu.

4437
00:01:28,680 --> 00:01:47,010
Đó không phải là 40. Có 21. Vậy chúng ta thấy điều đó ở đây. Chúng tôi thấy đó là một câu trả lời sai cho vấn đề. Nguồn duy nhất, thú cưng ngắn nhất. Vì vậy, chúng ta có thể vào đây vì điều đó sẽ xảy ra với Beavis, khi đó chúng ta sẽ nhận được câu trả lời sai.

4438
00:01:47,730 --> 00:02:00,160
Bây giờ hãy nói về lý do tại sao việc phòng thủ không có tác dụng đối với bài toán đường đi ngắn nhất từ ​​một nguồn. Chúng tôi biết rằng phòng thủ có xu hướng đi xa nhất có thể từ tay nguồn.

4439
00:02:00,240 --> 00:02:14,670
Nó không bao giờ có thể tìm thấy thú cưng ngắn nhất. Hãy xem tại sao. Giả sử bạn được giao cho một vật gây xao lãng, và hãy giả sử điều này. Đây là đỉnh nguồn của chúng tôi. Được rồi, vậy chúng ta hãy tìm khoảng cách từ đỉnh này đến đỉnh này.

4440
00:02:15,810 --> 00:02:29,840
Nếu, OK, vậy khoảng cách tối thiểu từ phán quyết này là bao nhiêu? Điều đáng giá là ngoại trừ việc nếu chúng ta nghe thấy lời bào chữa thì trước tiên chúng ta sẽ khám phá B, sau đó là C, sau đó quay lại D, rồi đến f.

4441
00:02:30,080 --> 00:02:42,290
Ở đây chúng ta thấy rằng nếu chúng ta thực hiện khoảng một giờ đầu tiên từ vòng xoáy này đến vòng xoáy này, nếu chúng ta thấy rằng đây không phải là khoảng cách tối thiểu, thì chúng ta thấy rõ rằng khoảng cách tối thiểu là khoảng cách này của anh ta.

4442
00:02:43,280 --> 00:02:57,800
Nhưng chúng ta có Pat này, và chúng ta tìm thấy nó ở đây. Câu trả lời sai. Và đây là lý do tại sao việc phòng thủ không có tác dụng
đối với một nguồn duy nhất. Người ta hiểu tại sao chúng ta tập trung vào phòng thủ không có tác dụng đối với một nguồn duy nhất. 

@@@



4443
00:00:00,990 --> 00:00:16,070
Xin chào các bạn, chào mừng các bạn quay lại với video này, chúng ta sẽ nói về những thuật toán bổ sung này. Nào, Adam, chúng ta sẽ đưa ra cấu trúc dữ liệu đồ họa này và nguồn của xoáy là đỉnh 0 này.

4444
00:00:17,060 --> 00:00:32,990
Bây giờ chúng ta phải tìm cho cô ấy khoảng cách tối thiểu từ nguồn Vertex này đến tất cả các đỉnh trong biểu đồ này. Vì vậy, hãy xem cách tìm khoảng cách tối thiểu từ đỉnh 0 này đến tất cả các đỉnh khác trong biểu đồ này.

4445
00:00:34,010 --> 00:00:50,660
Hãy xem thuật toán bổ sung này hoạt động như thế nào. Đầu tiên, nó giả định rằng để đi đến bất kỳ đỉnh nào thì chi phí là vô cùng. Vì vậy, hãy giả sử để đi đến đỉnh này thì chi phí là vô cùng.

4446
00:00:51,830 --> 00:01:09,540
Vì vậy chi phí ban đầu là vô cùng. Vì vậy, hãy thêm vào đây Vô cực, Vô cực và vô cực. Đây là đỉnh nguồn. Vì vậy, từ vật thể 0 này đến đỉnh 0 này, hãy thăm đỉnh 0 này từ các hạt 0 này.

4447
00:01:09,560 --> 00:01:21,290
Chi phí tối thiểu bằng 0 vì chúng tôi giúp bạn biết những gì liên quan. Chúng tôi không có tình yêu ở đỉnh này. Được rồi, vậy chi phí ở đây bằng 0 và 0 nhỏ hơn vô cùng.

4448
00:01:21,440 --> 00:01:37,010
Vì vậy, hãy thay thế vô cực bằng số không. Bây giờ chúng ta sẽ làm gì? Chúng ta sẽ tìm ra đỉnh có chi phí tối thiểu. ĐƯỢC RỒI. Vì vậy, ở đây chúng ta thấy rằng chúng ta có những sản phẩm này và đỉnh này có chi phí tối thiểu.

4449
00:01:37,250 --> 00:01:50,180
Bây giờ điều tôi sắp làm là tìm khoảng cách tối thiểu từ đỉnh này tới đỉnh này, khoảng cách tối thiểu, chi phí tối thiểu của Oregon.

4450
00:01:50,840 --> 00:02:02,130
Hãy thêm khoảng cách, được chứ? Khoảng cách tối thiểu từ đỉnh này đến đỉnh này là 0,6. Đó là sáu, và đây là sáu nhỏ hơn vô cùng. Vì vậy, hãy cho chiều rộng vô cực này.

4451
00:02:02,150 --> 00:02:18,170
Sáu. Bây giờ chúng ta hãy khám phá vùng lân cận tiếp theo. Chúng tôi có quá trình liền kề này. Bây giờ chúng ta hãy khám phá điều này liền kề. Bây giờ đối với đỉnh này, chúng ta thấy rằng phần gỗ ở giữa hai hạt này là một.

4452
00:02:18,350 --> 00:02:31,340
Chi phí để truy cập x thông minh này là 0 cộng một. Vì vậy, hãy cập nhật giá trị vô cùng này bằng một vì một nhỏ hơn vô cùng. Vậy khoảng cách tối thiểu ở đây là một.

4453
00:02:31,580 --> 00:02:47,780
Vì vậy, từ đỉnh 0 này, khoảng cách tối thiểu đến đỉnh 4 này là một. Vì vậy chúng ta nhấn nút này Vertex zero sẽ không truy cập phán quyết này. Không. Dù sao, chúng tôi đã xử lý đỉnh này.

4454
00:02:48,620 --> 00:03:03,620
Bây giờ hãy tìm khoảng cách tối thiểu cho đỉnh. ĐƯỢC RỒI. Vì vậy, chúng ta thấy rằng khoảng cách tối thiểu ở đây là dành cho đỉnh này. Hãy nhìn cái này ở đây, khoảng cách tối thiểu một ở đây chúng ta có sáu.

4455
00:03:03,620 --> 00:03:21,740
Ở đây chúng ta có vô cực và ở đây chúng ta có vô cực. Vì vậy, đây là đỉnh đó, nơi chúng ta có chi phí tối thiểu hoặc khoảng cách tối thiểu từ đỉnh nguồn. Bây giờ điều tôi sắp làm là cập nhật giá trị cho AdSense.

4456
00:03:21,980 --> 00:03:37,850
Nếu có, hãy coi đây là bạn. Và hãy điều chỉnh góc nhìn này, được chứ? Vì vậy, hãy tìm ra chi phí tối thiểu ở đây nếu chúng ta đi theo hướng này. Vậy ta thấy một cộng hai bằng hai ba ba nhỏ hơn sáu.

4457
00:03:38,000 --> 00:03:55,760
Vậy hãy cập nhật sáu thành ba. Bây giờ đối với quảng cáo này thì không phải bây giờ nữa phải không? Đây có phải là đỉnh không? Ở đây chúng ta thấy rằng chi phí tối thiểu hoặc khoảng cách tối thiểu để đến đỉnh này là một cộng một tức là hai hai nhỏ hơn tám.

4458
00:03:55,940 --> 00:04:10,190
Vì vậy, hãy cập nhật tốt điều này với hai. Như vậy chúng ta đã xử lý được đỉnh này. Bây giờ hãy tìm đỉnh nhỏ nhất của nó. ĐƯỢC RỒI. Vì vậy, ở đây chúng ta thấy 4 đã được truy cập và 0 đã được truy cập.

4459
00:04:10,670 --> 00:04:24,140
Bây giờ chúng ta hãy tìm khoảng cách tối thiểu ở đây. Chúng tôi thấy khoảng cách tối thiểu chúng tôi có cho VORTEX2 này. Ở đây chúng ta thấy rằng khoảng cách tối thiểu mà chúng ta có đối với Vertex ba, có hai cách từ đỉnh này.

4460
00:04:24,950 --> 00:04:38,960
Hãy thử tìm khoảng cách tối thiểu cho đỉnh này. Nếu chúng ta coi đây là bạn và đây là V, thì từ hai bạn v, chi phí tối thiểu là ở đây. Chúng tôi đã có ba, nhưng chi phí từ sản phẩm này đến đỉnh này là hai cộng hai.

4461
00:04:38,960 --> 00:04:51,480
Đó là bốn. Bốn không nhỏ hơn ba. Vì vậy, Ueland cập nhật số quy định này, tức là nằm trên khoảng cách tối thiểu đối với các hạt này và đó là hai cộng năm, bảy và bảy nhỏ hơn vô cực.

4462
00:04:51,560 --> 00:05:07,020
Vì vậy, hãy thừa nhận đỉnh này có bảy. Như vậy là chúng ta đã xử lý được đỉnh này rồi. Hãy tìm hiểu mức tối thiểu. Ở đây chúng ta thấy mức tối thiểu là ba. Khoảng cách tối thiểu cho phán quyết này là ba.

4463
00:05:07,380 --> 00:05:16,950
Bây giờ từ những bản án này, chúng tôi chỉ có một bản án tử tế và được truy cập và chúng tôi đã nghe thấy hai, bốn ba. Và ở đó tôi bất đồng quan điểm, nhưng họ đã được viếng thăm.

4464
00:05:17,220 --> 00:05:26,490
Bây giờ điều tôi sắp làm là tìm ra khoảng cách từ những phán quyết này đến những phán quyết này. Được rồi, bạn có ba. Tôi tám tuổi, nhưng ở đây chúng tôi có bảy.

4465
00:05:26,640 --> 00:05:38,420
Vì vậy, chúng tôi không cập nhật số này thành bảy với tám vì nó không nhỏ hơn bảy. Vì vậy, bản án này được truy cập. Bây giờ chúng ta hãy tìm hiểu những phán quyết tối thiểu mà chúng ta thấy chưa được xem xét.

4466
00:05:38,430 --> 00:05:50,550
Đây là bản án trong bản án này. Chúng tôi thấy khoảng cách tối thiểu là bảy. Nhưng ở đây chúng tôi không có và đến thăm liền kề. Vì vậy, không có gì để làm ở đây. Chúng ta đã xong.

4467
00:05:50,880 --> 00:06:00,990
Không có cái nào chưa được ghé thăm. Tôi bất đồng quan điểm với đảng này. Vì vậy bạn sẽ không nghĩ ở đây phải không? Chúng ta đã xong. Chúng tôi tìm thấy nó là khoảng cách tối thiểu từ nút này, cũng như số 0 đến tất cả các nút khác.

4468
00:06:01,350 --> 00:06:09,600
Đây là thuật toán bổ sung. Đây là cách thuật toán này từ số 0 đến nút một này, khoảng cách tối thiểu là ba từ số 0 đến bốn triệu.

4469
00:06:09,600 --> 00:06:20,430
Dựa trên điều này, một từ 0 đến ba khoảng cách tối thiểu đến từ 0 hai đến khoảng cách tối thiểu là bảy. Đã hiểu. Thuật toán của nó hoạt động như thế nào? Bây giờ chúng ta hãy xem.

4470
00:06:20,430 --> 00:06:33,000
Đó là thuật toán bổ sung. Đây là thuật toán bổ sung này. Chức năng này rất thông minh như đầu vào. Ở đây chúng tôi được thăm viếng. Ari ở đây sẽ theo dõi. Các virus ghé thăm ở đây đều có khoảng cách xa trong khu vực này.

4471
00:06:33,030 --> 00:06:46,260
Chúng tôi sẽ theo dõi khoảng cách tối thiểu. Sau đó, bạn đang chạy một vòng lặp ở đây từ chỉ số 0, hai đỉnh trừ một. Và ở đây chúng ta đang chèn giá trị tối đa và thêm ý nghĩa rằng cái giếng này là vô cùng.

4472
00:06:46,410 --> 00:07:03,000
Ở đây chúng tôi đang chỉ định giá trị tối đa mà chúng tôi có thể lưu trữ trong 32 bit và giá trị tối đa mà chúng tôi có thể xâu thành chuỗi. Chúng tôi đang xem xét vô cùng rằng chúng tôi đang chèn một nguồn hạt bằng 0 vì từ Vertex, từ đỉnh nguồn đến Vertex nguồn, không có khoảng cách.

4473
00:07:03,080 --> 00:07:16,860
Được rồi, hạn chế tối thiểu là bằng không. Bây giờ chúng tôi có bạn động thái này. Chúng tôi đang chạy vòng lặp này từ tôi và Islas. Thế thì tôi chia cái gì ở đây? Chúng tôi yêu cầu bạn tìm khoảng cách tối thiểu, tìm khoảng cách tối thiểu trong biểu đồ.

4474
00:07:17,040 --> 00:07:30,960
Nếu chúng ta thấy nó ở khoảng cách tối thiểu, tất cả đều đặt điều đó là đúng bởi vì đỉnh đó sẽ là các hạt và dù thế nào thì các hạt cũng sẽ không quay trở lại. Ở đây chúng tôi có loại phương tiện cá nhân này.

4475
00:07:31,090 --> 00:07:44,910
Bạn biết đấy, Villazon, đây là gì vậy? Và ở đây chúng tôi đang kiểm tra xem tiện ích bổ sung vừa vào Vertex có được truy cập hay không. Và nếu chúng ta có kết nối, nếu nó ở liền kề, Hilbert đang kiểm tra bằng kết nối này ở đây, tôi chỉ là của Reddick.

4476
00:07:44,940 --> 00:07:57,570
Bạn đã có hai số không. Nếu bạn có giá trị, hãy về 0. Điều đó có nghĩa là đỉnh không phải là đỉnh liền kề với Vertex của bạn. Ở đây chúng tôi có cốt lõi này. Được rồi, đây là để thư giãn, được chứ?

4477
00:07:57,840 --> 00:08:11,190
Ở đây chúng tôi đang thêm khoảng cách. Bạn kết thúc và trọng số được thêm vào giữa hai đỉnh này mà bạn ghen tị và bạn đang kiểm tra xem nó có nhỏ hơn khoảng cách đó hay không, chúng tôi đang cập nhật khoảng cách đó ở mức V.

4478
00:08:11,580 --> 00:08:25,830
Và ở đây chúng tôi chỉ in sự kiện từ khu vực khoảng cách này. OK tại chỉ số 0 sẽ có khoảng cách từ 0 đến 0 tại chỉ số trên tất cả khoảng cách của chúng ta từ 0 đến 1 và khoảng cách sẽ được lưu trữ trong khoảng cách.

4479
00:08:26,280 --> 00:08:37,260
Và có một khoảng cách tối thiểu. Vì vậy hãy xem lại chức năng này. Tìm khoảng cách trung bình trong hàm này, chúng ta gọi khoảng cách và đã truy cập, đồng thời chúng ta giả sử tích phân này thành giá trị lớn nhất của dấu chấm nguyên.

4480
00:08:37,470 --> 00:08:51,840
Và sau đó chúng ta giả sử khoảng cách tối thiểu của đỉnh bằng trừ một. Biến này sẽ có một giá trị cáo buộc. Được rồi, vậy chúng ta có thể có năm trừ một. Chúng ta không phải lo lắng về chỉ số gửi đi mà chúng ta có ở đây cho các góc bằng 0.

4481
00:08:51,890 --> 00:09:00,240
Tôi sống ở Vertex và ở đây kiểm tra xem đỉnh hiện tại có được truy cập hay không, sau đó chúng tôi sẽ kiểm tra điều kiện này. Đó là một sự cô lập xa xôi, khoảng cách trung bình.

4482
00:09:00,360 --> 00:09:14,060
Chúng tôi sẽ cập nhật thông tin này rõ ràng và sau đó là khoảng cách trung bình của Vertex. Được rồi, đây. Chức năng này tất cả các khu vực, đỉnh. Chúng tôi có khoảng cách tối thiểu nơi bạn quay trở lại vì chúng tôi sẽ không xem lại các hạt nữa.

4483
00:09:14,200 --> 00:09:27,450
Giả sử chúng ta được cung cấp cấu trúc dữ liệu biểu đồ này để giải quyết vấn đề này. Được sử dụng để sắp xếp mảng đã truy cập và khoảng cách của các đỉnh mềm biểu thị cấu trúc trọng lực này bằng cách sử dụng ma trận kề này.

4484
00:09:27,810 --> 00:09:41,400
Bây giờ hãy xem thuật toán này hoạt động như thế nào. Ở khoảng cách này, Ari sẽ lấp đầy giá trị vô cực. Thêm giá trị tối đa có nghĩa là chúng tôi có thể lưu trữ hai bit có quyền thêm vô cùng.

4485
00:09:41,730 --> 00:09:55,290
Vì vậy hãy chèn vào đây. Vô cực ở đây là vô cùng. Vì vậy hãy chèn vô cùng vào đây. Đây đây. Vô cực, vô cực. Vì vậy, lập chỉ mục hai thuật toán đầu tiên.

4486
00:09:55,410 --> 00:10:11,590
Nó giả định rằng để truy cập bất kỳ đỉnh nào trong đó. Đồ thị từ nguồn của chi phí đó là khoảng cách tối thiểu là vô cùng. Bây giờ chúng ta sẽ đặt xoáy nguồn bằng 0 vì khoảng cách giữa đỉnh 0 hai này, đỉnh 0 này bằng 0.

4487
00:10:11,590 --> 00:10:25,690
Vì vậy, hãy cập nhật tốt giá trị này bằng 0, hãy thay đổi giá trị này thành 0. Bây giờ chúng ta sẽ chạy dự phòng này. Ở đây bạn sẽ tìm thấy nó khoảng cách tối thiểu. Khoảng cách tối thiểu ở đây làm như vậy ở Anh sẽ trở lại đây, khoảng cách trung bình của nghệ thuật.

4488
00:10:25,840 --> 00:10:35,320
Vì vậy, trong biểu đồ này, chúng ta thấy rằng khoảng cách trung bình của X bằng 0. Vì vậy, ảo tưởng bằng không và tất cả đều đúng như vậy bởi tuyên bố này. OK, bây giờ chúng ta có vòng lặp này ở đây.

4489
00:10:35,590 --> 00:10:46,900
Bây giờ chúng ta hãy tìm tất cả ở tâm của đỉnh này trong cuộc chiến này và một trong bốn số 0 liền kề, chúng ta đang lấy đỉnh liền kề ở đây bằng cách sử dụng công thức này.

4490
00:10:46,910 --> 00:11:01,960
Nếu chúng ta thấy nó là một ma trận, bạn biết đấy, bằng 0. Nó có nghĩa là đỉnh bạn và chúng tôi liền kề nhau. Vì vậy, từ đỉnh 0 này đến đỉnh này trở đi, chúng ta có thể tăng giá 6.

4491
00:11:02,230 --> 00:11:12,970
Tôi thấy một chút ở đây, OK, nếu chúng ta đi theo hướng này và sẽ kiểm tra điều kiện này, khoảng cách của bạn cộng với ma trận trung tâm, bạn đã sống trong chiếc lều này.

4492
00:11:13,690 --> 00:11:25,930
Đây là điều kiện để thư giãn. Vì vậy, hãy cập nhật giá trị này bằng 6, vì điều kiện này bằng 0. Sáu nhỏ hơn vô cùng. Không cộng sáu nhỏ hơn vô cùng.

4493
00:11:26,200 --> 00:11:41,410
Ở đây, tin học này cho thấy giữa bạn và Vertex, bạn là 0 và 1. Vì vậy, hãy cập nhật điều này thật tốt với sáu. Vì vậy, tại Index, Abdi đã phát triển nó từ 0 lên 4.

4494
00:11:41,890 --> 00:11:52,540
Hyrule Kiểm tra từ 0 đến 2 không 0 hai hai. Chúng ta có giá trị bằng 0, vì vậy chúng ta không có cạnh nào từ 0 đến 3. Chúng tôi không có. Đó là từ số không đến bốn. Chúng tôi có một ID và chúng tôi thấy rằng nó liền kề.

4495
00:11:52,870 --> 00:12:03,400
Vì vậy, ở đây chúng ta sẽ cộng một và hai không một hai không một một nhỏ hơn vô cùng. Vì vậy, hãy cập nhật giá trị ở chỉ số bốn bằng một. Chúng ta đã xong. Chúng tôi đã xử lý nút này.

4496
00:12:03,850 --> 00:12:14,860
Bây giờ, hãy chuyển sang bước lặp tiếp theo của vòng lặp này và hãy tìm khoảng cách trung bình của Vertex đối với đỉnh chưa được thăm và đã ghé thăm Vertex 142. Ở đây bạn có giá trị trung bình đi xuống.

4497
00:12:14,860 --> 00:12:26,890
Đỉnh là bốn. Vì vậy, chức năng này sẽ được thực hiện bốn và bốn cho liền kề là chúng ta thấy ở đây không một và ba không một và ba không đã được truy cập.

4498
00:12:27,220 --> 00:12:41,770
Vì vậy, chúng ta sẽ không xem lại số 0 ở đây, tìm ra khoảng cách trung bình của X bởi vì chúng ta chỉ tìm thấy nó khoảng cách tối thiểu. Vì vậy, ở đây chúng ta thấy bốn cảnh bắt nguồn từ đỉnh bốn này sẽ chèn vào chỉ mục cho hai.

4499
00:12:41,890 --> 00:12:51,640
Bây giờ ở đây một cộng hai là ba. Ba nhỏ hơn sáu. Vì vậy, chúng ta sẽ quay quanh đây sáu với ba bây giờ từ bốn lên ba. Ta thấy một và một tức là hai một cộng một nhỏ hơn vô cùng.

4500
00:12:51,790 --> 00:13:07,900
Vì vậy, hãy lấy chỉ số ba giá trị hai. Vì vậy ở đây hai và đây hai, bây giờ chúng ta thấy rằng bốn và số không đã được thăm. Những người không được thăm viếng là một, hai và ba. Bây giờ chúng ta hãy tìm ra mức tối thiểu trong phần chưa được xem này cho lần lặp tiếp theo.

4501
00:13:08,320 --> 00:13:28,820
Đỉnh tối thiểu, đỉnh khoảng cách tối thiểu là ba. Ở đây chúng ta có hai ở đây có ba và vô cùng. Vì vậy, hai là tối thiểu. Vậy Vertex 3 là đỉnh có khoảng cách trung bình mà chúng ta đang nghe ở đây có nghĩa là các hạt đi xuống vì chúng ta muốn tìm nó ở khoảng cách tối thiểu mà bạn có thể tìm thấy ở khoảng cách tối thiểu từ khoảng cách tối thiểu.

4502
00:13:28,840 --> 00:13:37,750
Chúng ta sẽ cố gắng tìm khoảng cách tối thiểu đến đỉnh khác, vì vậy chúng ta sẽ có khoảng cách tối thiểu. Đây là khái niệm của thuật toán bổ sung này. Dù sao thì chúng tôi cũng sẽ xem lại điều này.

4503
00:13:37,900 --> 00:13:51,580
Nếu chúng ta có chu kỳ phủ định thì chúng ta có thể tìm thấy câu trả lời sai. Vậy từ ba đến một, ta thấy hai cộng hai là bốn. Bốn không nhỏ hơn ba. Vì vậy, chúng tôi cần phán quyết này.

4504
00:13:52,060 --> 00:14:03,850
Nó sẽ tiếp thị như đã truy cập ngay bây giờ ở đây từ 3,2 đến cộng năm bảy. Vì vậy, nó nhỏ hơn vô cùng. Vì vậy, hãy tính RBD với 7 và cho đến số này, à, vô cùng với 7.

4505
00:14:04,180 --> 00:14:17,800
Vì vậy, tôi đã truy cập tất cả các đỉnh liền kề ở đây vì đã được truy cập. Bây giờ chúng ta hãy tìm khoảng cách tối thiểu của X của chúng ta và đã truy cập và truy cập Vertex một và hai, và chúng ta có khoảng cách tối thiểu mà đỉnh được rút ra khỏi cơ thể này.

4506
00:14:17,800 --> 00:14:25,780
Đỉnh này, khoảng cách tối thiểu là năm cộng ba. Đó là tám tám không ít hơn bảy đến oolleot. Abdou Diallo sẽ đánh dấu cái này là đã truy cập.

4507
00:14:26,440 --> 00:14:39,790
Điều này là do đây là một đỉnh có khoảng cách trung bình, vì vậy hãy tiếp thị khi đã ghé thăm. Bây giờ hãy tìm khoảng cách tối thiểu của đỉnh mà chúng ta có ở đây chỉ có một đỉnh.

4508
00:14:40,220 --> 00:14:54,970
Chúng ta chỉ còn lại một đỉnh. Vì vậy, đây là khoảng cách trung bình mà Vertex sẽ chạy tới tại điểm tới tất cả. Vì vậy, ở đây nó được truy cập và chúng tôi thấy không có và truy cập khá lên.

4509
00:14:55,240 --> 00:15:13,530
Vậy là chúng ta đã xong việc. Chúng ta thấy rằng liền kề là một đầu ở đây. Ba. Và họ đã được viếng thăm. Vậy là chúng ta đã hoàn tất. Đây là thuật toán thảm họa. Đây là tất cả những gì thuật toán bổ sung này hoạt động khoảng cách tối thiểu từ phán quyết này đến phán quyết này là 0 0. Khoảng cách tối thiểu của một số 0 này đến một là ba.

4510
00:15:13,860 --> 00:15:25,440
Khoảng cách tối thiểu của đỉnh này từ 0 đến 4 là một từ 0 đến 3 là 2 từ 0 đến 2 là 7. Điều này được biết là thuật toán bổ sung này hoạt động. Thuật toán này hoạt động một chu kỳ âm.

4511
00:15:25,860 --> 00:15:42,900
Độ phức tạp về thời gian của thuật toán này sẽ lớn hơn nếu chúng ta bình phương vị trí với số đỉnh đó trong cấu trúc dữ liệu biểu đồ đã cho và tất cả điều này xảy ra do độ phức tạp về không gian cho khoảng cách và số lượt truy cập.

4512
00:15:43,710 --> 00:15:59,090
Nó thực sự sẽ phụ thuộc vào độ phức tạp về thời gian và điều đó tương đương với V lớn vì chúng ta bỏ qua phần không đổi đó để phân tích độ phức tạp về thời gian. Đây là số đỉnh trong cấu trúc dữ liệu đồ họa nhất định.

4513
00:15:59,330 --> 00:16:07,620
Hy vọng bạn đã hiểu thuật toán bổ sung này. Cảm ơn bạn đã xem video này Trong video
tiếp theo, chúng ta sẽ nói về thuật toán Billman Ford kiện video tiếp theo. 

@@@



4514
00:00:01,050 --> 00:00:11,220
Đây nè hai anh em. Chào mừng bạn quay trở lại với video này trong video này, chúng ta sẽ nói về lý do tại sao thuật toán bổ sung này sẽ không hoạt động đối với chu kỳ âm.

4515
00:00:12,540 --> 00:00:29,460
Nếu một biểu đồ nhất định chứa chu trình âm thì thuật toán bổ sung này sẽ không chạy. Nó sẽ trả về kết quả không chính xác. Trước tiên, hãy xem thuật toán bổ sung hoạt động như thế nào cho biểu đồ này.

4516
00:00:29,490 --> 00:00:44,860
Giả sử số 0 này là đỉnh nguồn của chúng ta. Trong video trước, chúng tôi đã nói chi tiết về các thuật toán bổ sung này trong video này. Chúng ta sẽ nói về lý do tại sao thuật toán bổ sung này không hoạt động trong chu kỳ âm.

4517
00:00:45,690 --> 00:01:01,110
Đầu tiên, hãy lấy ví dụ này trong biểu đồ này, chúng ta không có chu kỳ âm. Đầu tiên, hãy giải quyết vấn đề này. Ban đầu, khoảng cách tối thiểu để tới bất kỳ đỉnh nào là vô hạn từ đỉnh nguồn.

4518
00:01:01,620 --> 00:01:17,630
Vì vậy, vô hạn, vô hạn, vô hạn và vô hạn. Đây là đỉnh nguồn của bạn. Khoảng cách từ đỉnh 0 này đến đỉnh 0 0 này. Vì vậy, hãy làm theo Israel số 0.

4519
00:01:18,030 --> 00:01:31,530
Bây giờ chúng ta thấy liền kề của số 0 là một. Và đỉnh hai này. Vì vậy, hãy tìm khoảng cách, khoảng cách tối thiểu để đi tới đỉnh này và có 0 cộng 5 không cộng 5 là 5.

4520
00:01:31,530 --> 00:01:43,930
Năm nhỏ hơn vô cùng. Vì vậy, hãy Abd Infinity với năm bây giờ từ 0 lên 2 lần nữa. Anh ta nhận được khoảng cách bằng 0 cộng vì có Lisbon Infinity.

4521
00:01:44,010 --> 00:01:58,440
Vì vậy, hãy cập nhật Israel với bốn. Vì vậy, chúng tôi đã xử lý nút này bằng 0. Bây giờ chúng ta hãy tìm ra đỉnh có khoảng cách tối thiểu. Đỉnh khoảng cách tối thiểu là đỉnh này.

4522
00:01:58,740 --> 00:02:13,350
Vì vậy, từ đây, chúng ta thấy chúng ta có thể truy cập đỉnh này với chi phí tối thiểu là +6. Đó là stent và lớn hơn năm bản cập nhật giải quyết. Và chúng ta có thể đi theo hướng này và hướng này.

4523
00:02:13,800 --> 00:02:29,440
Vậy là chúng ta đã hoàn tất. Chúng tôi đã xử lý đỉnh hai này. Bây giờ chúng ta hãy tìm nó. Khoảng cách trung bình của Vertex, khoảng cách trung bình của đỉnh là một. Chúng ta có thể thăm đỉnh ba này từ đỉnh một này và xu hướng tối thiểu này là năm cộng ba tám.

4524
00:02:29,460 --> 00:02:46,230
Vì vậy, hãy cập nhật vô hạn này với tám. Vì thế. Vậy là chúng ta đã xử lý xong nút này. Bây giờ đỉnh khoảng cách trung bình là đỉnh này. Bởi vì đây là đỉnh chưa được thăm nên đỉnh xa trung bình là ba, không bao gồm đỉnh đã thăm.

4525
00:02:46,530 --> 00:02:57,000
Và chúng ta thấy từ đây chúng ta chỉ có thể di chuyển theo hướng này. Nhưng ở đây chúng ta thấy đỉnh này đã được xử lý. Nhưng ở đây chúng ta thấy những đỉnh này đã được xử lý rồi sẽ không có tác dụng gì ở đây.

4526
00:02:57,150 --> 00:03:07,590
Vì vậy, chúng tôi tìm thấy khoảng cách tối thiểu ở đây. Khoảng cách tối thiểu để ghé thăm đỉnh này là năm. Thăm đỉnh này là thăm đỉnh này. Vertex là bốn đến thăm này.

4527
00:03:07,590 --> 00:03:22,320
Vertex là tám. Đây là cách thuật toán bổ sung này hoạt động. Bây giờ hãy xem liệu chúng ta có một chu kỳ âm hay không. Ở đây chúng ta thấy chúng ta có một chu kỳ âm. Tổng trọng lượng của chu kỳ này là âm.

4528
00:03:22,380 --> 00:03:37,760
Được rồi, trừ sáu cộng ba cộng hai bằng hai trừ một. Vì vậy, chúng tôi tìm thấy ở đây một chu kỳ tiêu cực. Nếu chúng ta có chu trình âm trong một biểu đồ nhất định thì bài toán đường đi ngắn nhất từ ​​một nguồn sẽ không hoạt động ngay bây giờ.

4529
00:03:37,770 --> 00:03:49,050
Chà, hãy xem tại sao phần bổ sung này sẽ không hoạt động đối với biểu đồ này. Biểu đồ này chứa chu kỳ âm. Ban đầu, chi phí tối thiểu để đi qua bất kỳ đỉnh nào là vô cùng.

4530
00:03:49,560 --> 00:04:00,690
Đây là đỉnh nguồn của chúng tôi. ĐƯỢC RỒI. Giả sử số 0 là đỉnh nguồn của chúng ta. Vì vậy, hãy cập nhật kết quả này bằng 0, bởi vì từ phán quyết 0 này đến phán quyết 0 này, khoảng cách bằng 0.

4531
00:04:01,230 --> 00:04:15,810
Bây giờ ở giữa, chúng ta có nút một và nốt hai. Đôi khi chúng ta thấy Vertex hoặc một nút duy nhất và Vertex đang mổ xẻ khoảng cách tối thiểu để đến đỉnh này, trong đó cộng bằng 0.

4532
00:04:16,230 --> 00:04:28,920
Vậy năm ở đây là khoảng cách tối thiểu để tới đỉnh bốn không bốn này. Như vậy chúng ta đã xử lý được đỉnh này. Bây giờ là Trung Đông, đỉnh là những phán quyết từ đỉnh này.

4533
00:04:28,920 --> 00:04:41,100
Bạn có thể đến thăm đỉnh này với chi phí tối thiểu là âm sáu tức là trừ hai tu viện, ít hơn năm. Vì vậy, hãy cập nhật giá trị này với âm hai để chúng ta có thể đạt tới đỉnh này.

4534
00:04:41,100 --> 00:04:50,190
Một trong các đỉnh nguồn bằng 0 có khoảng cách tối thiểu trừ hai. Vì vậy, chúng tôi đã xử lý nút thứ hai này. Chúng ta không thể di chuyển theo hướng này và theo hướng này.

4535
00:04:50,190 --> 00:05:02,400
Chúng tôi sẽ chỉ di chuyển theo hướng này. Bây giờ chúng ta hãy tìm xem quãng đường trung bình mà Vertex đã đi và ghé thăm Vertex. Chúng ta vẫn chưa thăm được đỉnh nào và đỉnh có khoảng cách tối thiểu là đỉnh này.

4536
00:05:02,760 --> 00:05:13,630
Từ đỉnh này, chúng ta có thể nâng đỉnh này lên ba trong khoảng cách tối thiểu trừ hai cộng ba. Đó là một. Vậy hãy thừa nhận cái vô cực này bởi vì. Bởi vì nó lớn hơn một.

4537
00:05:14,080 --> 00:05:26,710
Vì vậy, chúng tôi đã xử lý việc này không phải bây giờ cho nút này. Chúng tôi thấy điều đó từ nút này. Chúng tôi thấy rằng chúng tôi không thể truy cập nút này vì nút này đã được truy cập.

4538
00:05:26,980 --> 00:05:41,230
Nhưng ta thấy hai cộng một bằng ba sẽ có khoảng cách nhỏ nhất cho phần này. ĐƯỢC RỒI. Nhưng ở đây chúng ta thấy rằng chúng ta có bốn và khoảng cách tối thiểu phải là hai cộng một.

4539
00:05:41,230 --> 00:05:59,020
Đó là ba. Nhưng chúng tôi có bốn người ở đây kể từ khi nơi này được ghé thăm. Vì vậy, chúng tôi không thể tìm thấy khoảng cách thực tế ở đây. ĐƯỢC RỒI. Vì vậy, bạn tìm thấy nó. Khoảng cách tối thiểu từ 0 đến một là trừ hai từ 0 đến ba một và từ 0 đến hai là bốn.

4540
00:05:59,560 --> 00:06:10,840
Nó sẽ di chuyển trong chu kỳ này nhiều lần. Chúng tôi thấy giá trị cơ hội phát triển sẽ giảm đi. Giá trị sẽ giảm đi. Và ở đây chúng tôi tìm thấy câu trả lời.

4541
00:06:11,350 --> 00:06:22,590
Ba. Khoảng cách tối thiểu từ 0 đến đỉnh này là ba. Và đỉnh này đã được truy cập. Vì vậy, ở đây chúng tôi tìm ra một chu kỳ tiêu cực. Bạn có thể tìm thấy nó một chu kỳ tiêu cực.

4542
00:06:22,870 --> 00:06:36,670
Trên thực tế, thuật toán bổ sung Ueland hoạt động khi bạn tìm thấy nó trong chu kỳ âm, vấn đề đường đi ngắn nhất nguồn duy nhất mà rừng sẽ đi trong vé. Chúng tôi sẽ in hoặc khu vực.

4543
00:06:36,970 --> 00:06:53,380
Không. Hoặc chúng ta có thể in ra cho hội đồng. Biểu đồ chứa một chu trình tiếng Anh, vì vậy bạn không thể tìm thấy bản đồ ngắn nhất. Nhưng thuật toán bổ sung này không có cơ chế phát hiện chu kỳ âm trong một biểu đồ nhất định.

4544
00:06:53,890 --> 00:07:05,740
Để làm được điều đó, chúng ta phải học một thuật toán mới được gọi là thuật toán thiếu sót
Billman và sẽ nói về thuật toán trường Billman trong video tiếp theo kiện video tiếp theo. 

@@@



4545
00:00:00,570 --> 00:00:15,330
Chúng tôi rất hoan nghênh bạn quay lại với video này, chúng ta sẽ nói về sự thư giãn. Hãy nói về sự thư giãn. Giả sử bạn được cung cấp biểu đồ này trong biểu đồ này, chúng ta có tổng cộng năm độ tuổi.

4546
00:00:16,440 --> 00:00:30,780
Chúng tôi thư giãn ở mọi lứa tuổi một lần. Hãy xem, thư giãn hoạt động như thế nào? Và đây chính là điều kiện để bạn có được khoảng cách thư giãn cộng với sức nặng của tuổi hiện tại.

4547
00:00:31,260 --> 00:00:43,590
Nếu khoảng cách cộng hoặc dòng điện nhỏ hơn khoảng cách V thì chúng tôi sẽ thay đổi khoảng cách tối thiểu cho nút bằng cách thêm khoảng cách của bạn cộng với trọng lượng.

4548
00:00:44,220 --> 00:01:00,420
Hãy xem. Bây giờ việc thư giãn diễn ra như thế nào? Chúng tôi sẽ làm việc thông qua các nhóm này bằng cách sử dụng các thuật toán bổ sung này. Ban đầu, khoảng cách tối thiểu để tới bất kỳ đỉnh nào của nhà sản xuất Vertex là vô cùng.

4549
00:01:00,930 --> 00:01:13,650
Giả sử số 0 là đỉnh nguồn của chúng ta. Bây giờ, khoảng cách tối thiểu để đến đỉnh này từ đỉnh này là bằng không. Bây giờ chúng ta hãy chỉ con quay tương đối này từ đỉnh số 0 hai này.

4550
00:01:13,650 --> 00:01:27,570
Đỉnh này ở khoảng cách tối thiểu là cộng năm của bạn. Đó là năm. Hãy cập nhật vô số này với năm. Bây giờ chúng ta thấy rằng chúng ta đã áp dụng công thức này ở đây, vì vậy đây là lợi thế hiện tại của chúng ta.

4551
00:01:27,990 --> 00:01:43,470
Chúng tôi đã áp dụng công thức này cho tám người này. Vì thế tuổi này bây giờ đã được thảnh thơi. Điều này được gọi là thư giãn. Bây giờ điều này là thư giãn. Chúng ta sẽ không đến thăm lứa tuổi này nữa, được chứ?

4552
00:01:43,830 --> 00:01:56,100
Đây được gọi là nỗ lực của Israel. Bây giờ chúng ta hãy chuyển sang mối quan hệ này với lò cao của Let's Update Israel. Hiện tại, chúng tôi đã áp dụng công thức này ở đây. Vì vậy, bây giờ điều này giống như mọi thứ.

4553
00:01:56,100 --> 00:02:10,460
Được rồi, giờ thì thoải mái rồi. Điều này được gọi là thư giãn. Bây giờ mức tối thiểu là Vertex hai ở đây. Khoảng cách tối thiểu để đi từ đỉnh này đến ngôi sao Vertex này, bốn cộng một là năm và đây là năm.

4554
00:02:10,470 --> 00:02:20,580
Vì vậy, không cần phải làm gì ở đây. Chúng ta không thể đi theo hướng này và chúng ta không thể đi theo hướng này bởi vì đây không phải là sự thư giãn, sẽ không quay trở lại những tiện nghi thư giãn.

4555
00:02:21,180 --> 00:02:32,820
Bây giờ đây là, không có gì thư giãn. OK, chúng tôi đang thực hiện điều kiện này. Tình trạng này đều là lỗi ở đây, bây giờ chúng ta có thể nói rằng điều này không được nới lỏng ở đây.

4556
00:02:32,820 --> 00:02:43,890
Vertex tối thiểu là một để ghé thăm đỉnh này ba từ một mà chúng ta đã biết. Xu hướng này là năm cộng 3 là tám. Vì vậy, hãy cập nhật điều này tốt với tám. Bây giờ chúng ta có thể nói điều này không được thoải mái.

4557
00:02:44,130 --> 00:02:55,800
Bây giờ tôi đang xử lý khoảng cách tối thiểu là tám cộng hai khoảng cách, nhưng chúng ta thấy rằng đỉnh này đã đi qua nên chúng ta không thể di chuyển từ đỉnh này sang đỉnh này.

4558
00:02:56,130 --> 00:03:10,740
Vì vậy, cuối cùng, chúng ta có thể nói rằng điều này không hề thư giãn. Đây gọi là thư giãn phải không? Vì vậy, chúng tôi đã thư giãn tất cả các cạnh khi điều này được gọi là thư giãn. Chúng ta đã hiểu thư giãn là gì.

4559
00:03:10,980 --> 00:03:25,650
Hãy lấy một ví dụ khác. Hãy xem bạn đã được cung cấp biểu đồ này. Hãy áp dụng thuật toán bổ sung này để tìm ra con đường ngắn nhất. Vì vậy, ban đầu, chi phí hoặc khoảng cách tối thiểu để đi đến bất kỳ đỉnh nào từ đỉnh nguồn là vô cùng.

4560
00:03:25,950 --> 00:03:33,810
Giả sử đây là một loại đỉnh. Vì vậy, chúng ta hãy theo dõi cái giếng này, với số 0 từ 0 hai 0, khoảng cách bây giờ là 0 từ 0 đến một nhà máy điện.

4561
00:03:33,810 --> 00:03:43,860
Số 0 là ít hơn năm khả năng, với năm khả năng. Vì vậy chúng tôi đã áp dụng công thức này. Vì vậy, bây giờ không có gì thư giãn. Từ một đến hai, khoảng cách theo thuyết Darwin là năm cộng một.

4562
00:03:43,860 --> 00:03:54,210
Đó là sáu. Hãy nộp đơn ở đây. Hãy làm điều này với sáu. Bây giờ đây là nó đang thư giãn hay là tám con vật này bây giờ từ một hai ba năm cộng ba bảy?

4563
00:03:54,210 --> 00:04:06,660
Hãy nhân đôi số này với bảy. Được rồi, bây giờ không có gì thư giãn cả. Tối thiểu là sáu này tám. Vậy từ sáu đến từ, đây là hai. Đây là nơi chúng ta có thể ghé thăm với giá 9.

4564
00:04:06,660 --> 00:04:16,020
OK, hãy cập nhật điều này tốt với chín. Vì vậy, đây không phải là thư giãn. Chúng tôi sẽ không xem lại tám điều này nữa. Bây giờ mức tối thiểu ở đây là bảy. Vì vậy, từ bảy lần nữa, hãy truy cập ghi chú này.

4565
00:04:16,260 --> 00:04:26,070
Bảy cộng một là tám, nhưng cũng gần rồi nên thế này mới nhàn nhã. Cuối cùng, chúng
ta có đỉnh này và không có cách nào để đi từ đỉnh này. Chúng ta đã xong. 

@@@



4566
00:00:00,480 --> 00:00:09,110
Chào mừng các bạn quay trở lại với video này trong video này, các bạn sẽ nói về thuật toán Billman Ford trong video trước, chúng ta đã nói chi tiết về thuật toán bổ sung.

4567
00:00:10,410 --> 00:00:25,650
Chúng ta biết rằng đó là tôi hoặc nó có tác dụng với các từ phủ định, và phần bổ sung này không thể phát hiện ra các chu kỳ tiêu cực. Chúng tôi biết đối với chu kỳ âm, nguồn đơn, vấn đề đường dẫn ngắn nhất sẽ không hoạt động.

4568
00:00:26,400 --> 00:00:36,030
Bây giờ hãy nói về Billman về thuật toán. Trong video và thông tin chi tiết này, hãy nói thêm rằng bạn đã được cung cấp biểu đồ này và chúng tôi thấy rằng trong biểu đồ này, chúng tôi có 2,5 trang và bốn đỉnh.

4569
00:00:37,110 --> 00:00:47,040
Bốn tỷ bốn thuật toán sẽ làm thư giãn tất cả các cạnh. Nếu muốn học trong thời gian, thì các đỉnh của đồ thị này là bốn bốn trừ một cạn ba.

4570
00:00:47,040 --> 00:00:57,810
Vì vậy, nó sẽ thư giãn tất cả chỉ ba lần. Đối với thuật toán bổ sung này, chúng tôi đã nới lỏng tất cả các cạnh một lần. Đầu tiên, đó là thuật toán bổ sung. Những thuật toán bổ sung này sẽ thất bại trên biểu đồ này.

4571
00:00:58,050 --> 00:01:11,590
Hãy xem làm thế nào. Vì vậy, ở đây ban đầu bạn có khoảng cách, vô cực, vô cực, vô cực và vô cực. Giả sử đây là đỉnh nguồn của bạn. Vì vậy, hãy RBD Israel với số 0 bây giờ bằng 0 cộng hoặc bằng một.

4572
00:01:11,610 --> 00:01:21,300
Hãy cập nhật cốt truyện này bằng một, vì khi nào nhỏ hơn vô cùng? Vì vậy, hãy thư giãn ở tuổi không hai bốn không hai không cộng một là một. Một là nhỏ hơn vô cùng.

4573
00:01:21,300 --> 00:01:35,550
Hãy để Ari phát triển với một. Sau đó ở đây chúng ta sẽ lấy đỉnh tối thiểu. Hãy thêm một số vào đây nhé, rất nhiều bạn quay lại video này trong video này, chúng ta sẽ để Adam tranh luận trong biểu đồ này.

4574
00:01:35,670 --> 00:01:47,630
Trong biểu đồ này, chúng ta thấy rằng chúng ta có tổng cộng năm cạnh và các đỉnh kém vì thuật toán bổ sung này sẽ nới lỏng tất cả các cạnh một lần, nhưng với hàng tỷ, Ford sẽ nới lỏng tuổi già.

4575
00:01:47,880 --> 00:01:58,500
Nếu bạn muốn chúng tôi một lần hoặc so với số lượng virus trong một biểu đồ nhất định. Trong biểu đồ này, chúng ta phải tìm hiểu xem nó là gì để nó sẽ giãn ra ở mọi độ tuổi ba lần.

4576
00:01:58,920 --> 00:02:13,020
Trước tiên, hãy xem cảm giác bổ sung này như thế nào trên biểu đồ này. ĐƯỢC RỒI? Vì vậy, ở đây hãy chèn Vô cực, Vô cực và vô cực. Ở đây chúng ta sẽ có 0 không cộng một bằng một.

4577
00:02:13,020 --> 00:02:26,580
Chúng ta hãy quan sát sự vô tận này với một không không không. Vậy hãy giải quyết vấn đề này bằng con số 0. Bây giờ ở đây chúng ta thấy rằng chúng ta xử lý nút này và đây là và đây không phải là điều thư giãn.

4578
00:02:26,580 --> 00:02:39,300
Tối thiểu ở đây. Không một không. Vì vậy, không cộng hai bằng hai để bỏ qua sự phát triển bằng hai, và không có cách nào đi theo hướng này. Vì vậy, đây không phải là thư giãn.

4579
00:02:39,300 --> 00:02:48,570
Tối thiểu một và hai là một. Vậy đỉnh một từ một đến hai này, khoảng cách tối thiểu một cộng một vẫn bằng bodheri bằng không. Không có cái nào lớn hơn hai.

4580
00:02:48,700 --> 00:03:02,280
Vậy nên thoái vị, chúng ta xong việc. Đỉnh này bây giờ không thư giãn. Từ đỉnh này đến đỉnh một, ta thấy hai trừ ba đến trừ một. Nhưng ở đây chúng tôi đã tìm thấy một thuật toán bổ sung.

4581
00:03:02,700 --> 00:03:13,950
Chúng tôi không thể di chuyển đến Vertex đã ghé thăm. OK, từ đỉnh không liên quan, chúng ta thấy rằng thuật toán bổ sung này không hoạt động đối với biểu đồ này. Ở đây chúng ta thấy rằng chúng ta sẽ có khoảng cách tối thiểu từ nguồn.

4582
00:03:14,310 --> 00:03:31,620
Vertex là trừ một, nhưng ở đây chúng ta có một. Vì vậy, chúng tôi thấy rằng chúng tôi thấy rõ rằng những cảm giác bổ sung này trên biểu đồ này. Hãy xem cách hoạt động tuyệt vời. Biểu đồ này dành cho phụ nữ chuyển tiếp sẽ đi đến bất kỳ đỉnh nào từ đỉnh nguồn.

4583
00:03:31,620 --> 00:03:45,660
Khoảng cách ban đầu là vô cùng. Đây là nguồn của bạn, đỉnh. Hãy tính trung bình này, nó bằng 0 đối với nguồn. Vertex sẽ được phát triển cùng bạn vì từ nguồn này đến nguồn khác, từ 0 đến một một không cộng một là một.

4584
00:03:45,660 --> 00:03:58,500
Một là nhỏ hơn vô cùng. Bây giờ hãy tính trung bình một từ 0 đến 2 0 0. Vậy hãy RB cái này bằng 0 bây giờ từ một đến hai một hai hai một cộng một bằng hai.

4585
00:03:59,190 --> 00:04:13,560
Hai không nhỏ hơn 0 nên không có người ở. Ở đây chúng ta thấy rằng chúng ta thư giãn ở thời đại này, thời đại này và thời đại này. Đây, ID này, tuổi này và tuổi này. Bây giờ, từ hai đến ba, hai năm cộng hai, thành hai.

4586
00:04:13,560 --> 00:04:24,400
Hãy lấy trung bình vô cực này vì hai là vô cực tiềm ẩn. Bây giờ, từ hai đến một đến trừ ba sẽ thành trừ một. Vì vậy, hãy tính trung bình giếng này với âm một để thư giãn tất cả các cạnh.

4587
00:04:24,720 --> 00:04:38,230
Nhưng hãy tính xem. Vâng, anh hùng. Một. Bây giờ chúng ta hãy thư giãn cả ngày một lần nữa, bởi vì nếu bạn thư giãn cả ngày, bây giờ chỉ cần ba lần từ 0 đến một không cộng một là một, một không nhỏ hơn trừ một.

4588
00:04:38,740 --> 00:04:58,720
Vì vậy sẽ không thay đổi nó. Không hai hai không không không không nhỏ hơn không. Khi đó từ một đến hai trừ một cộng một bằng 0 không không nhỏ hơn 0. Ngay cả từ hai đến ba cộng ba đi đến hai cũng sẽ không thay đổi nó từ hai thành một đến trừ ba điểm đến trừ một đến gần như abit.

4589
00:04:59,170 --> 00:05:12,910
Vì vậy, hãy thư giãn tất cả. Hãy thư giãn cả ngày một lần nữa nhé. Được rồi, vậy là chúng tôi đã thư giãn cả ngày, chỉ hai lần thôi. Bây giờ chúng ta hãy thư giãn. Cái này là một. Vì vậy, chúng tôi đang tung ra số 0, rồi bốn trừ một cộng một.

4590
00:05:13,150 --> 00:05:24,760
Nhanh lên không có người giám sát từ hai đến ba. Hai từ ba đến một là trừ một, nên không căng thẳng. Vì vậy, chúng tôi đã thư giãn tất cả các cạnh ba lần. Vì vậy, chúng tôi đã hoàn thành bây giờ.

4591
00:05:24,760 --> 00:05:37,210
Chúng tôi thấy rằng chúng tôi tìm thấy chất béo ngắn nhất từ ​​​​việc lưu trữ, các phán quyết cho đến tất cả các phán đoán khác. ĐƯỢC RỒI. Đây được gọi là bốn thuật toán Billman. Đây là cách chúng tôi có thể giải quyết nguồn duy nhất đã cho chúng tôi thấy vấn đề đó.

4592
00:05:37,210 --> 00:05:48,160
Không phải Billman dành cho thuật toán sao? Nếu chúng ta lấy bất kỳ nút nào ở đây, giả sử bạn bắt đầu từ ba. Đầu tiên chúng ta có thể thư giãn ở độ tuổi này. Tuổi này, tuổi này. Đây là Antawn.

4593
00:05:48,460 --> 00:06:01,530
Được rồi, chúng ta có thể làm đi làm lại. Chúng ta có thể đi xa hơn. Chúng ta có thể lùi lại nếu chúng ta lùi lại. Hãy xem vẻ ngoài này thích anh ấy như thế nào nhé. Bây giờ, hãy giả sử đây là một loại xoáy vô cực vô cực.

4594
00:06:01,570 --> 00:06:16,300
Được rồi, giả sử tất cả bắt đầu thư giãn từ phía này. T1 Vô cực trừ ba Tiến tới vô cùng vì nếu bạn trừ ba từ vô cực, và đó cũng là vô cực vì nó là một con số khổng lồ nên không có gì thay đổi ở đây.

4595
00:06:16,720 --> 00:06:30,460
Bây giờ từ hai ba. Vì vậy, đây không phải là thư giãn từ hai ba. Chúng ta thấy chúng ta thấy Infinity Plus hai cũng là vô cực nên sẽ không thay đổi từ một thành vô cực cộng một.

4596
00:06:30,490 --> 00:06:42,970
Đó cũng là vô cùng nên sẽ không thay đổi nên không hai không cộng một là một. Vì vậy, bây giờ hãy tính trung bình giá trị này với một từ 0 đến 2 bằng 0. Vì vậy, hãy cập nhật điều này thật tốt, để chúng ta thư giãn tất cả chỉ một lần.

4597
00:06:43,540 --> 00:06:54,990
Bây giờ hãy thư giãn chúng một lần nữa. Ba, hai một. Vì thế bạn không muốn Chin vô cực trừ ba tiến tới vô cùng. Hai thành ba cộng hai đi tích hai. Bây giờ chúng ta hãy làm điều này với hai từ một đến hai.

4598
00:06:55,180 --> 00:07:12,820
Một cộng một là nhanh lên số không. Vì vậy, chúng tôi không phải là từ 0 đến 1. Không sao đâu, hai hai hai không không. Vì vậy, không thay đổi nó ở đây. Hai bạn, ở đây hai bạn một một cộng không là một trong các bạn có số không không có người giám sát cộng với số không không không có người giám sát.

4599
00:07:13,060 --> 00:07:24,330
Thật thoải mái, mặc dù chỉ hai lần. Một cộng một là hai. Bây giờ, hãy thư giãn chúng một lần nữa. Ba hai, một là trừ một. Được rồi, hai trừ ba sẽ bằng trừ một.

4600
00:07:24,680 --> 00:07:37,460
Bây giờ từ hai đến ba, chúng ta cũng thấy ở đây. Vì vậy, hãy gửi nó từ một đến hai trừ một một không và không và tham dự không hai một G2 tham dự tốt. Bạn biết đấy, ngoài ý muốn.

4601
00:07:37,470 --> 00:07:50,360
Được rồi, vậy là chúng ta đã hoàn thành việc thư giãn cho tất cả các lứa tuổi lớn hơn ba lần. Chúng tôi có thể. Chúng ta có thể thư giãn tất cả theo bất kỳ thứ tự nào. Được rồi, ở đây chúng ta có thể thư giãn cả ngày, theo bất kỳ thứ tự nào.

4602
00:07:50,510 --> 00:08:06,140
Nhưng nếu bạn tuân theo một thứ tự nhất định thì bạn phải tuân theo thứ tự đó cho đến hết phần còn lại vì chúng ta phải thư giãn tất cả cái này b trừ một lần phải không? Đây được gọi là Billman vì điều tuyệt vời này là Joe giành chiến thắng cho các công trình thuật toán để chúng ta có thể thư giãn độ tuổi này theo bất kỳ thứ tự nào.

4603
00:08:06,320 --> 00:08:21,630
Nó khác với việc triển khai cấu trúc dữ liệu biểu đồ của bạn. Chúng ta có thể lấy cái này trước, rồi cái này, rồi cái này, rồi cái này hơn cái này. Nhưng bạn phải làm theo khuôn mẫu hoặc thứ tự cho phần còn lại vì bạn phải thư giãn.

4604
00:08:21,650 --> 00:08:32,510
Chúng tôi muốn ghi điểm dựa trên số lượng lợi thế của bạn. Hiểu Billman này cho thuật toán. Bây giờ
chúng ta hãy nói về mức độ lớn của thuật toán để phát hiện chu kỳ âm và cách nó xử lý chu kỳ âm. 

@@@



4605
00:00:00,990 --> 00:00:09,120
Đây rồi, một số chàng trai. Chào mừng bạn quay trở lại với video này, trong video này, bạn sẽ nói về thuật toán Billman Ford, hãy giả sử hoặc đưa lực hấp dẫn này vào cấu trúc.

4606
00:00:09,450 --> 00:00:33,660
Ở đây chúng ta có 2,5 inch. Đây là độ tuổi không một không hai một hai, hai ba và ba một. Trong thuật toán bổ sung này, chúng tôi đã nới lỏng tất cả các cạnh chỉ một lần, nhưng với hàng tỷ, bốn thuật toán sẽ nới lỏng tất cả các cạnh b trừ đi một lần trong đó v là số lợi thế trong biểu đồ đã cho?

4607
00:00:34,680 --> 00:00:45,900
Trong biểu đồ này, số lượng nghệ sĩ là bốn, vậy bốn trừ đi bạn gọi nó là gì, hai đến ba? Vì vậy, bạn sẽ thư giãn tất cả các cạnh ba lần. Hãy xem nó hoạt động như thế nào.

4608
00:00:46,020 --> 00:00:59,460
Đầu tiên chúng ta nói về thuật toán D68 để hiểu rõ hơn. Vì vậy, ban đầu, chúng ta có vô hạn cho tất cả khoảng cách tối thiểu ban đầu để đi đến tất cả các đỉnh từ các bên sắp xếp.

4609
00:00:59,470 --> 00:01:10,890
Đây là từ nguồn. Đỉnh là vô cùng. Bây giờ đây là loại bản án của bạn. Vì vậy, được rồi, chúng ta sẽ giả sử rằng đây là đỉnh của các câu chuyện. Vậy khoảng cách từ đỉnh thứ hai của dãy Vertex được sắp xếp bằng 0.

4610
00:01:11,280 --> 00:01:22,350
Từ phán đoán này đến đỉnh này, khoảng cách bằng 0 cộng với một sẽ bằng một. Vì vậy, bây giờ chúng tôi thực sự thích cạnh này. Từ 0 đến 2, khoảng cách tối thiểu bằng 0 cộng với hai, tức là hai.

4611
00:01:22,530 --> 00:01:39,210
Vì vậy, hãy tính trung bình giá trị này với hai. Vì vậy, đây không phải là thư giãn. Chúng tôi sẽ không xem lại tám điều này nữa. Chúng tôi đang cố gắng di chuyển đến các đỉnh liền kề của anh ấy từ đỉnh này.

4612
00:01:39,300 --> 00:01:55,440
Chúng tôi có khoảng cách tối thiểu. Đó là những gì chúng ta sẽ không xem lại đỉnh này. Bây giờ điều này cũng chỉ là thư giãn. Bây giờ mức tối thiểu ở đây là từ một đến hai, khoảng cách tối thiểu, một cộng một vẫn còn ở đây, cho đến người bản xứ khác được thực hiện ở đây.

4613
00:01:56,280 --> 00:02:09,520
Một hai ba. Chúng ta không thể di chuyển từ một đến ba vì chúng ta có hướng từ ba đến một. Vì vậy, ở đây. Chúng ta đã xong. Đây không phải là một cuộc dạo chơi thư giãn dành cho anh ấy trong hai đến ba giờ.

4614
00:02:09,550 --> 00:02:22,210
Ở đây chúng ta thấy đây là khoảng cách tối thiểu của hai cộng ba phiếu của chúng ta đến năm. Đó là để phát triển với năm. Bây giờ thì không có gì thư giãn cả, được rồi bây giờ năm trừ bốn bằng một.

4615
00:02:22,540 --> 00:02:37,240
Và ở đây chúng ta có giá trị một. Ở đây chúng ta thấy rằng thuật toán bổ sung này hoạt động, nhưng đôi khi thuật toán bổ sung này sẽ không hoạt động. Bây giờ hãy nói về thuật toán Billman 4, được chứ?

4616
00:02:38,200 --> 00:02:56,800
Bây giờ hãy nói về thuật toán Billman 4. Ban đầu, chúng ta sẽ đánh dấu tất cả các đỉnh là vô cùng. ĐƯỢC RỒI. Vì vậy, ở đây chúng tôi sẽ bổ sung thêm cho bạn phát minh để truy cập tất cả các đỉnh từ đỉnh nguồn ban đầu là vô cùng.

4617
00:02:57,040 --> 00:03:08,650
Chúng tôi chỉ ở trong thị trường như vô cùng. Bây giờ, giả sử số 0 là đỉnh nguồn của chúng ta. Trong thuật toán Billman 4, bạn sẽ nới lỏng tất cả các cạnh p trừ một lần của Piglet thành bốn từ Venezuela ba.

4618
00:03:08,800 --> 00:03:23,440
Vì vậy, nó sẽ thư giãn tất cả chỉ ba lần đầu tiên. Không một. OK, vậy khoảng cách từ nguồn của các nghệ sĩ đến đỉnh 0 0 này bởi vì chúng ta nói Vertex từ 0 đến một là một.

4619
00:03:23,560 --> 00:03:35,210
Vậy hãy lấy Abdel cái này vì vô cực lớn hơn một. Vậy bạn có muốn tám không một bây giờ không hai g cộng hai bằng hai hai nhỏ hơn vô cùng.

4620
00:03:35,230 --> 00:03:47,200
Hãy cập nhật cái này và đọc nó với hai. Vì vậy, chúng tôi đã thư giãn h này bây giờ một và hai. Ở đây tôi thấy một và một là hai. Và ở đây chúng tôi có hai giá trị hợp lệ. Vì vậy chúng tôi làm như thế này h.

4621
00:03:47,590 --> 00:03:58,820
Thế thì hai ba hai cộng hai là năm. Năm là ít hơn vô cùng. Vì vậy, hãy cập nhật vô hạn này với năm. Vì vậy, điều này không được nới lỏng bây giờ từ ba đến một.

4622
00:03:59,020 --> 00:04:12,730
Năm trừ bốn bằng một. Vì vậy, ở đây chúng ta có giá trị một. Bây giờ chúng ta thấy rằng chúng ta đã thư giãn tất cả các cạnh một lần. Hãy đếm nó. Chúng tôi đã nhận ra một lần. Hãy thư giãn chúng một lần nữa.

4623
00:04:12,910 --> 00:04:24,550
Bây giờ, không một không cộng một là một. Vì vậy cần phải làm một việc khác ở đây vì một không nhỏ hơn một không hai hai. Vậy bạn có muốn cái này một hai một hai là hai không?

4624
00:04:24,580 --> 00:04:39,850
Không sao đâu. Thế thì hai hoặc ba ở đây chúng ta có hai cộng ba là năm. Rồi ba một bốn hai một năm trừ bốn bằng ở đây một. ĐƯỢC RỒI. Không sao đâu. Vì vậy, chúng tôi đã thư giãn tất cả các cạnh hai lần.

4625
00:04:40,090 --> 00:04:50,440
Bây giờ chúng ta hãy thư giãn chúng. Bây giờ hãy thư giãn chúng một lần nữa. Bây giờ chúng ta hãy thư giãn ở tuổi không một cộng một là một. Vậy thì hãy lăn như thế này tám hai không hai không cộng hai là hai.

4626
00:04:50,860 --> 00:05:04,780
Thế thì tám trong một hai trên cộng một là hai. Rồi hai ba năm năm năm ba một ba một ở đây. Năm trừ bốn. Đó là một. Vậy là chúng ta đã hoàn tất việc thư giãn tất cả các cạnh.

4627
00:05:05,170 --> 00:05:20,920
Bạn có muốn đặt hàng không? Đây có phải là B trừ một lần không? Gần đây anh ấy đã thư giãn, mặc dù đó là ba lần. Vậy là chúng ta đã hoàn tất. Bây giờ chúng ta thấy rằng chúng ta có con đường ngắn nhất từ ​​đỉnh này, nguồn gốc của các hạt tới tất cả các bên khác.

4628
00:05:20,920 --> 00:05:35,010
Con đường ngắn nhất ở đây là con đường ngắn nhất. Cái gì ở đây là hai. Đây là hai cộng ba năm hai cộng ba trừ bốn bằng một. Vì vậy, đường đi ngắn nhất từ ​​đỉnh bốn đến đỉnh này là một.

4629
00:05:35,350 --> 00:05:46,900
Bạn đã hiểu thuật toán Billman 4 hoạt động như thế nào để hiểu rõ hơn chưa? Hãy lấy một ví dụ khác Hãy cộng hoặc cho biểu đồ cấu trúc này ở đây, chúng ta thấy rằng chúng ta có một chu trình âm.

4630
00:05:47,080 --> 00:06:02,130
Hãy xem cách nó xử lý chu kỳ đi chệch hướng và cách phát hiện chu kỳ âm nếu biểu đồ chứa bất kỳ chu kỳ đau buồn nào. Vì vậy, hãy đánh dấu tất cả các đỉnh là vô cùng khoảng cách tối thiểu để ghé thăm bất kỳ đỉnh nào.

4631
00:06:02,140 --> 00:06:17,320
Một loại đỉnh ban đầu là vô cùng. Hãy thay đổi số 0 tương đối này vì đây là đỉnh nguồn của chúng ta. Bây giờ, từ nguồn đến đỉnh này, hãy chạy như thế này là một cái được phát triển với một bây giờ bằng 0 cộng hai bằng hai hai.

4632
00:06:17,530 --> 00:06:30,330
Đó là sau chuyện này. Vâng, với hai. Vâng, đoán xem? Chúng ta có hai cạnh này bây giờ một hai từ một và từ một đến hai cộng một là hai. Thế là thoải mái tám này thì hai ba hai cộng ba là năm.

4633
00:06:30,340 --> 00:06:40,780
Hãy cập nhật giá trị này vì năm nhỏ hơn vô cực, hãy làm như thế này. Ở đây là ba một. Năm trừ 60 sẽ thành trừ một. Vậy chúng ta hãy chạy như thế này nhé.

4634
00:06:40,780 --> 00:06:53,860
Vì vậy, chúng tôi nhận được anh ta trừ một. Vì vậy, chúng tôi đã thư giãn tất cả các cạnh một lần. Hãy đếm bây giờ, hãy thư giãn chúng một lần nữa. Bây giờ không một cộng một là một. Một không nhỏ hơn âm một.

4635
00:06:54,070 --> 00:07:07,070
Bạn có thích cái này h thì không hai không cộng hai là hai. Được thôi, vậy một trừ một là một trừ. Một bằng 0, vì vậy hãy phát triển bằng 0 vì có ít hơn hai.

4636
00:07:07,460 --> 00:07:17,330
Rồi đây hai cây ba cộng, ba, chúng ta nâng cấp cây này lên ba nhé. Thế thì ba trừ sáu bằng trừ ba. Hãy phát triển với âm ba.

4637
00:07:17,810 --> 00:07:34,010
Vì vậy, chúng tôi đã thư giãn tất cả các cạnh hai lần. Bây giờ hãy thư giãn chúng một lần nữa. Hãy coi tám không cộng một là một không nhỏ hơn âm ba không cộng hai bằng hai bằng hai không nhỏ hơn 0 trừ ba cộng một là trừ hai.

4638
00:07:34,010 --> 00:07:49,160
Trừ hai không phải trừ hai là nhỏ hơn 0 bộ trưởng vào cuối năm. Hãy cập nhật số không. Đó là trừ hai, rồi trừ hai ba. Chúng ta hãy tranh luận giá trị này với một, bởi vì một nhỏ hơn ba bây giờ là một và trừ sáu là trừ năm.

4639
00:07:49,180 --> 00:08:03,090
Hãy cập nhật giá trị của nó trừ đi năm. Vì vậy, chúng ta đã nới lỏng tất cả các cạnh ba lần, và ở đây chúng ta có kết quả cho bốn cạnh. Bartok đang ở đây. OK, vậy là chúng ta đã thư giãn tất cả các cạnh.

4640
00:08:03,650 --> 00:08:17,140
B trừ một lần. Anh ấy đã có ba lần nhảy và chúng tôi đã thư giãn tất cả chỉ ba lần. Vậy là chúng ta đã hoàn tất. Bây giờ làm thế nào để phát hiện chu kỳ tiêu cực. Chúng ta ngồi đây. Chúng ta có một chu kỳ âm để dự đoán chu kỳ âm.

4641
00:08:17,350 --> 00:08:33,340
Chúng ta sẽ chạy trong tình yêu. Chúng ta sẽ kiểm tra xem bạn cộng trọng lượng bằng bao nhiêu, giả sử đây là bạn và đây là chữ V. Nếu chúng ta thấy 0 cộng một nhỏ hơn trừ năm, thì tôi sẽ làm gì, tôi sẽ in ra.

4642
00:08:33,670 --> 00:08:43,990
Biểu đồ chứa chu kỳ âm. Tại sao vậy? Ở đây chúng ta có khoảng cách tối thiểu. Vậy từ đây đến đây, chi phí tối thiểu là 0 cộng một. Đó là một.

4643
00:08:44,260 --> 00:09:01,030
ĐƯỢC RỒI. Và ở đây tất cả chúng ta đều có giá trị nhỏ hơn hoặc bằng giá trị này. ĐƯỢC RỒI? Ở đây chúng ta sẽ có khoảng cách tối thiểu, ít đậm đặc hơn hoặc bằng d'Israel nếu chúng ta thấy giá trị này lớn hơn giá trị này.

4644
00:09:01,810 --> 00:09:11,770
Điều đó có nghĩa là chúng ta có một chu kỳ âm. Ở đây chúng ta thấy rằng 0 cộng một là một. Một không nhỏ hơn âm năm. Bây giờ chúng ta hãy chơi công thức này ở đây.

4645
00:09:12,160 --> 00:09:25,990
Không cộng hai không cộng hai không nhỏ hơn trừ hai. Không sao đâu. Nó hoàn toàn ổn. Không, trừ năm một bằng hai trừ bốn. Chúng ta thấy âm bốn nhỏ hơn âm hai.

4646
00:09:26,260 --> 00:09:40,000
Ở đây chúng ta nên có évolue ở đây. Chúng ta phải có một giá trị bằng hoặc nhỏ hơn âm bốn. Nhưng ở đây chúng ta có âm hai bộ lớn hơn âm bốn.

4647
00:09:40,480 --> 00:09:55,450
Vì vậy chúng ta có thể thấy khoảng trống này chứa đựng một chu kỳ âm. Nếu biểu đồ này không chứa chu trình âm thì ở đây chúng ta sẽ có giá trị nhiều nhất là âm bốn hoặc nhỏ hơn âm bốn.

4648
00:09:55,480 --> 00:10:13,570
ĐƯỢC RỒI. Vì chúng ta đang định tuyến ở đây, bởi vì ở đây chúng ta có một chu kỳ âm. Vì thế giá trị giảm dần. ĐƯỢC RỒI. Vì vậy, bạn chúng ta di chuyển từ đây đến đây bằng một tuyến đường, khi đó giá trị này sẽ giảm xuống âm bốn vì chúng ta đã tính giá trị rồi.

4649
00:10:13,750 --> 00:10:25,540
Vì vậy, một lần nữa, hãy xem ở đây đồ thị này chứa một chu trình âm bởi vì trừ năm cộng một bằng hai trừ bốn trừ bốn không lớn hơn hoặc bằng trừ hai.

4650
00:10:25,720 --> 00:10:38,710
Ở đây sẽ có giá trị tối đa trừ đi bốn. Vì vậy, đồ thị này chứa một chu trình âm. Vì vậy tất cả in đồ thị này về đại lượng và chu trình âm cho chu trình âm sẽ không có lời giải cho bài toán nhảy dù cũ.

4651
00:10:39,110 --> 00:10:51,010
Ngoài ra, chúng tôi biết về vấn đề đường đi ngắn nhất từ ​​một nguồn. Hy vọng bạn hiểu các thuật toán thiếu sót của Billman. Bây giờ hãy xem mã giả. Đây là mã giả để giải quyết vấn đề này.

4652
00:10:51,520 --> 00:11:01,520
Chúng tôi có chức năng này. Nó giúp quảng bá biểu đồ và nguồn của bạn. Đây là các đỉnh và cạnh đang tính toán ở đây đang gọi một mũi tên khoảng cách cho so với.

4653
00:11:01,520 --> 00:11:19,000
Trừ khoảng cách tối thiểu từ nguồn đến tất cả các đỉnh khác. Và ở đây chúng ta đang chèn vô cực vào đây. Hoặc như bạn muốn nói đến ràng buộc giá trị tối đa đối với nó, vì vô cực đã chèn số 0 vào nguồn hạt vì khoảng cách tối thiểu từ nguồn đến đỉnh nguồn bằng không.

4654
00:11:19,600 --> 00:11:32,320
Bây giờ chúng tôi đang chạy xa ở đây. Chúng ta đang cạn kiệt tình yêu với b trừ một lần vì chúng ta phải thư giãn với B trừ một lần. Và bên trong đây chúng ta đang chạy vòng lặp này từ 0 đến trừ một.

4655
00:11:32,590 --> 00:11:48,760
Ở đây chúng tôi đang nhận được điểm đến và trọng lượng nguồn và đăng ký nó. Chúng tôi đang bắt đầu tại U.V. và W ở đây chúng tôi đang kiểm tra xem Sense U có bằng số nguyên mà Macksville kết thúc khoảng cách ngụ ý nhỏ hơn khoảng cách bên trong hay đang cập nhật giá trị.

4656
00:11:48,760 --> 00:12:09,670
ĐƯỢC RỒI? Và ở đây chúng ta đang phát hiện chu kỳ âm u v w và đây là hai chu kỳ. Nếu xu hướng này không theo Maxwell và nếu chúng ta thấy khoảng cách u cộng với khoảng cách W bằng, thì chúng ta hãy tính khoảng cách a v, khi đó chúng ta có thể nói một cách đơn giản là đồ thị góc chu kỳ âm và chỉ cần quay về từ hàm.

4657
00:12:10,060 --> 00:12:21,340
Chúng tôi sẽ không có câu trả lời trong trường hợp đó. Nếu không, nó sẽ in khoảng cách r. Nó sẽ có câu trả lời, bạn biết đấy, khoảng cách ari. Và đây là hàm in khoảng cách, OK, từ đỉnh dịch vụ đến tất cả các đỉnh khác.

4658
00:12:22,060 --> 00:12:32,500
Giả sử đây là khoảng cách của bạn và đây là biểu đồ đã cho của bạn. Và ở đây chúng ta có các đỉnh. Bây giờ chúng ta hãy thư giãn tất cả các đỉnh trong vài phút đúng giờ ở đây để cùng chúng ta đến phần ba.

4659
00:12:32,920 --> 00:12:45,880
Ban đầu chúng ta có Vô cực, Vô cực, Vô cực và Vô cực. Khoảng cách tối thiểu để thăm tất cả các đỉnh thuộc loại đỉnh là. Mối quan hệ ở đây cũng vậy, hãy chèn vô cùng.

4660
00:12:46,810 --> 00:13:00,950
Độ dài của mảng khoảng cách này phải bằng. ĐƯỢC RỒI. Độ dài khoảng cách R là cho hết, không có dấu ở đây. Chúng tôi sẽ có chỉ số từ 0 đến 3 vì chúng tôi vẫn chưa loại trừ vi-rút.

4661
00:13:02,000 --> 00:13:12,500
Bây giờ hãy cập nhật khoảng cách đầu tiên ở đây. Hãy cùng bạn vượt qua khoảng cách này. Và nó chỉ là một đại diện ở đây. Chúng tôi chỉ cho bạn thấy. Đó là về số không này.

4662
00:13:12,560 --> 00:13:25,970
Được rồi, bây giờ từ 0 đến một, một cộng 0 là một nhỏ hơn vô cùng. Vì vậy, hãy cập nhật điều này với một. Hãy cập nhật sự kết hợp này với một. Bây giờ từ 0 đến 2.

4663
00:13:26,630 --> 00:13:38,210
Vậy bạn có muốn điều khiển số 0 một từ 0 đến 2 cộng 0 là hai. Hai nhỏ hơn vô cùng, vì vậy hãy lấy trung bình Israel bằng hai. Và ở đây cũng vậy, hãy tính trung bình Israel với hai.

4664
00:13:38,270 --> 00:13:48,710
Cho nên nó liên hệ với tác nhân này bây giờ từ một thành hai, từ một thành hai, một cộng một là hai. Vậy một cộng một của bạn là hai. Hai không nhỏ hơn hai. Vậy thì không phải Anita Dunn ở đây.

4665
00:13:48,710 --> 00:14:01,160
Bây giờ thì đã thoải mái rồi. Hai hoặc ba từ hai đến ba. Hai cộng ba là năm. Hãy thừa nhận điều này. Với 5 chúng ta có vì 5 giống như vô cực. Hãy cập nhật điều này với năm.

4666
00:14:02,140 --> 00:14:17,620
Bây giờ, từ hai thành một, điều này dễ dàng không hề thoải mái đến một trừ một. Hãy sử dụng số trừ của bạn. Và chúng ta thấy ở chỉ số một ở chỉ số một sẽ có một điểm trừ ở đây.

4667
00:14:17,630 --> 00:14:28,330
Hãy tranh luận rằng điều này sẽ dẫn đến âm một. Vì vậy, chúng tôi đã nới lỏng tất cả những điều chỉnh. Vì vậy, hãy theo dõi giá trị ở đây. Được rồi, thật thoải mái một lần. Bây giờ hãy thư giãn chúng một lần nữa.

4668
00:14:28,900 --> 00:14:41,000
Cầu thủ rê bóng pha lê Zorbalas. Một là. Một, nhưng một không ít, và thợ mỏ không phải là Anita Dunn ở đây, Julius vặn vẹo để làm không ít hơn hai cần phải làm ở đây bây giờ một và hai trừ một một bằng không.

4669
00:14:41,180 --> 00:14:52,190
Đó là thổ dân không có hai hoặc ba cây thất nghiệp. Ba. Hãy cập nhật điều này tốt với ba bây giờ ba một hai trừ sáu là trừ ba. Hãy tính trung bình cộng với trừ hai.

4670
00:14:52,370 --> 00:15:07,040
Ở đây chúng ta cũng phải cập nhật giá trị ở đây. Ở đây đầu tiên, chúng tôi không có thay đổi. Những lời bạn không muốn, Angela. Chúng ta có anh em sinh đôi à? Không. Hãy cập nhật điều này. Vâng, với số 0 bây giờ từ 0 đến 3, chúng ta thấy rằng từ 0 đến 3, chúng ta đã phát triển được 3.

4671
00:15:07,310 --> 00:15:20,030
Vì vậy, chúng tôi tính trung bình d'Israel với ba và hai từ ba đến một trừ ba. Hãy tính trung bình của Isabelle với âm ba. Chúng tôi sẽ chỉ cho bạn ở đây sau, tuổi già an nhàn là một cộng một.

4672
00:15:20,060 --> 00:15:34,790
Điều đó có nghĩa là ngay bây giờ, hãy thư giãn chúng một lần nữa. Không một một một không nhỏ hơn trừ ba không hai hai không nhỏ hơn 0 trừ T một trừ hai trừ hai nhỏ hơn 0.

4673
00:15:35,060 --> 00:15:48,150
Vì vậy, hãy tính trung bình Israel với âm hai ở đây tại Chỉ số hai. Tôi đọc Israel trừ hai. Bây giờ, từ hai đến ba trừ hai cộng ba một, hãy làm tốt điều này với một.

4674
00:15:50,440 --> 00:16:09,530
Vậy tôi sẽ ở đây với một người chứ? Không bao giờ đúng với một. Cho phép. Hoặc 12 trừ hai với trừ năm, bởi vì một trừ sáu là trừ năm là trừ năm. Ở đây ở đây cũng sẽ cập nhật với âm năm.

4675
00:16:10,010 --> 00:16:22,510
Vậy là chúng ta đã hoàn tất. Chúng tôi thư giãn toàn bộ không khí chỉ ba lần. Điều đó có nghĩa là xem trừ một lần. Vậy là chúng ta đã xong việc ở đây. Bây giờ điều tôi sắp làm là kiểm tra xem biểu đồ có chứa chu kỳ sáng kiến ​​hay không.

4676
00:16:22,520 --> 00:16:36,470
Chúng tôi sẽ sử dụng công thức này ở đây để thực sự tiến tới các cuộc bầu cử này. Vâng, đây là bạn và đây là lý do tại sao và bạn có kết quả là bao nhiêu với cộng trừ năm bằng trừ bốn ở đây, trừ hai bộ trưởng lớn hơn trừ bốn?

4677
00:16:36,500 --> 00:16:45,920
Vì vậy, biểu đồ này chứa một chu trình gốc vì ở đây chúng ta có thể có điểm trừ tối đa cho những gì chúng ta thấy ở đây, trừ hai. Điều này đã được tính toán rồi nên chúng ta không cần phải lo lắng về điều đó.

4678
00:16:46,040 --> 00:16:54,740
Vì vậy, bạn có thể thấy ở đây biểu đồ này chứa A. Chu kỳ. Vậy là chúng ta đã hoàn tất. Điều này được gọi là Billman cho các thuật toán. Vâng, chúng tôi đã hiểu cách giải quyết vấn đề này.

4679
00:16:55,040 --> 00:17:05,150
Khi nó có chu kỳ âm sẽ không có câu trả lời ở đây. Chúng ta vừa in ra có chứa chu trình âm và bạn sẽ đọc được trên đồ thị không chứa chu trình âm.

4680
00:17:05,410 --> 00:17:15,200
Chúng ta sẽ có khoảng cách này, Ari và chúng ta sẽ in khoảng cách này. Ari dùng chức năng in này đây, OK, chức năng in đơn giản. Điều này được gọi là Billman cho các thuật toán.

4681
00:17:15,210 --> 00:17:27,910
Thuật toán này sẽ mất thời gian phức tạp. BS và tôi sẽ có số cạnh. ĐƯỢC RỒI. Và tất cả đều loại bỏ sự phức tạp về không gian. Hy vọng bạn hiểu Billman về các thuật toán.

4682
00:17:28,150 --> 00:17:35,350
Nếu bạn có bất kỳ câu hỏi nào, ý tôi là, bạn đã có sự hiểu biết tốt về các thuật toán. Hãy
để chúng tôi và cảm ơn vì đã xem video này. Tôi sẽ gặp bạn trong video tiếp theo. 

@@@



4683
00:00:00,750 --> 00:00:15,510
Này, có chuyện gì vậy các bạn? Chào mừng bạn quay trở lại với video này, trong video này, chúng ta sẽ nói về vấn đề pat ngắn nhất của tất cả các cặp. Bài toán khoảng cách ngắn nhất ngang hàng là việc xác định khoảng cách truyền động ngắn nhất giữa mỗi cặp lực trong một đồ thị nhất định.

4684
00:00:16,530 --> 00:00:30,960
Đây được gọi là bài toán pat ngắn nhất thuần túy. Hãy cùng Adam Ohuruogu mô tả cấu trúc này trong phần mô tả cấu trúc này. Chúng tôi đã xác định khoảng cách tối thiểu từ vòng xoáy này đến tất cả các loại virus khác trước tiên có chất lượng kém rằng đây là vòng xoáy nguồn của chúng tôi.

4685
00:00:30,970 --> 00:00:40,260
Sau đó, chúng ta phải coi đây là sản phẩm nguồn của chúng ta từ đỉnh này, khoảng cách tối thiểu đến tất cả các loại virus khác. Khái niệm tiện lợi. Đây là đỉnh nguồn của chúng tôi và đây là đỉnh nguồn của chúng tôi.

4686
00:00:40,290 --> 00:00:58,910
ĐƯỢC RỒI. Vì vậy, nếu chúng ta có cấu trúc trọng lực này, ban đầu bạn là Billy Adam 0 so với Vertex, thì chúng ta có thể di chuyển từ 0 đến 0 và không có miếng đệm. Được rồi, từ 0 đến 1, chúng tôi đã trả 0 một.

4687
00:00:58,920 --> 00:01:14,100
Đây là con đường ngắn nhất. Rồi từ 0 đến 2 không 2, rồi từ năm đến 3, chuyến đi này không hai một hoặc không một ba, nếu chúng ta coi một, là đỉnh nguồn của chúng ta, thì chúng ta có thể.

4688
00:01:14,910 --> 00:01:25,730
Chúng ta không thể di chuyển từ một đến 0 vì từ một đến ba không có phương hướng. Đó là những gì chúng tôi có ở đây. Điều này bây giờ là từ một đến một, không có vòng lặp nào ở đây.

4689
00:01:25,740 --> 00:01:39,240
Không có găng tay kín nên chúng tôi không có phương hướng ở đây. Vì vậy, bây giờ chúng ta không có con đường ngắn nhất từ ​​chỉ đến ngắn nhất. Đường dẫn một ba hai chín bốn ba từ một đến ba.

4690
00:01:39,600 --> 00:01:55,010
Con đường ngắn nhất là trên ba. Nếu chúng tôi muốn thì đó là những câu chuyện của chúng tôi xoáy từ 2.0, không có con đường nào từ hai đến một, các con đường đến một tôn trọng có khoảng cách tối thiểu đến cả hai, không có dư thừa nào cho cả ba.

4691
00:01:55,020 --> 00:02:10,820
Chúng tôi đã phái hai, một và ba. Nếu bạn xem xét. Ba cô con gái phán một ba, hai không. Không có không có kết nối hoặc không có độ tuổi từ một đến ba đến một.

4692
00:02:11,000 --> 00:02:25,490
Đây là phần người có khoảng cách tối thiểu thì về nhà với hai người. Đây là con đường từ ba đến ba. Con đường ngắn nhất không tồn tại nên chúng tôi chỉ thể hiện điều đó bằng cách sử dụng sản phẩm này.

4693
00:02:26,420 --> 00:02:38,060
Vì vậy, nếu chúng ta đưa ra biểu đồ này, chúng ta phải tìm khoảng cách ngắn nhất từ ​​mọi đỉnh đến tất cả các đỉnh khác. ĐƯỢC RỒI? Đây là vấn đề về đường đi ngắn nhất, cao độ nhất.

4694
00:02:38,170 --> 00:02:51,260
Hy vọng bạn hiểu vấn đề này? Bây giờ hãy xem chúng ta có thể giải quyết vấn đề này như thế nào. Trong video tiếp theo, chúng ta sẽ nói
về cách giải quyết vấn đề này bằng cách sử dụng thuật toán bổ sung này và sử dụng Billman cho thuật toán kiện trong video tiếp theo. 

@@@



4695
00:00:00,090 --> 00:00:10,420
Trong video này, bạn sẽ nói về cách sử dụng loại xà phòng này. Tất cả các bài toán vỗ ngắn nhất bằng cách sử dụng thuật toán bổ sung này, chúng tôi đã nói rất chi tiết về thuật toán này.

4696
00:00:10,440 --> 00:00:19,800
Trong video này, bạn sẽ tìm hiểu tổng quan về cách giải quyết tất cả vấn đề gian lận bảo hiểm bằng thuật toán bổ sung này. Hãy xem bạn có gì trong biểu đồ này.

4697
00:00:20,040 --> 00:00:34,350
Đầu tiên, hãy coi đó là nguồn gốc của chúng ta từ con số không. Chúng ta phải tìm đường đi ngắn nhất tới tất cả các đỉnh khác. Ở đây chúng ta có đỉnh nguồn và từ đỉnh nguồn đến tất cả các đỉnh khác.

4698
00:00:34,350 --> 00:00:43,170
ĐƯỢC RỒI? Từ nguồn, bạn có biết con đường ngắn nhất của họ là tối thiểu không? Vậy khoảng cách tối thiểu là 0 từ 0 đến 1? Bạn biết đấy, phần ngắn nhất là một.

4699
00:00:43,470 --> 00:00:54,510
Khoảng cách tối thiểu là năm từ 0 đến 2. Đây là khoảng cách ngắn nhất, nhưng khoảng cách tối thiểu là bốn và từ 0 đến 3, đây là khoảng cách ngắn nhất. Khoảng cách tối thiểu là tám.

4700
00:00:54,970 --> 00:01:09,510
Nếu chúng ta áp dụng ở đây, thuật toán bổ sung sẽ tìm ra đoạn ngắn nhất từ ​​đỉnh nguồn này, sau đó nếu chúng ta coi một là nguồn của mình, thì đỉnh đó sẽ có đoạn ngắn nhất nhưng được liệt kê ở đây.

4701
00:01:09,600 --> 00:01:21,880
OK, vậy nếu bạn coi đây là nguồn của chúng tôi thì Vertex sẽ có đường đi ngắn nhất được liệt kê ở đây. Sau đó, nếu chúng ta coi cây cối là một phạm vi siêu thông minh, chúng ta sẽ nhận được sự ưu ái ngắn nhất.

4702
00:01:21,900 --> 00:01:31,290
Được rồi, bạn là người máy và từ sản phẩm đến tất cả các đỉnh khác. Được rồi, khoảng cách từ đỉnh này đến tất cả các nghệ sĩ khác. Và ở đây chúng ta có đường đi và khoảng cách ngắn nhất.

4703
00:01:32,550 --> 00:01:45,780
Thuật toán bổ sung này sẽ phát huy tác dụng lớn hơn về độ phức tạp của thời gian xếp hàng. Chúng tôi sẽ thêm mã nguồn vào đây. Chúng ta có thể kiểm tra điều đó. Bây giờ chúng ta hãy nói về việc xây dựng thuật toán cho bài toán đường đi ngắn nhất tất cả các cặp.

4704
00:01:46,470 --> 00:02:06,540
Quá trình này là như nhau. Nếu chúng ta tiếp tục tới nguồn, Vertex sẽ có đường đi ngắn nhất được liệt kê ở đây. Nếu bạn cân nhắc khi nào đây là những đỉnh nghiêm trọng và bạn sẽ nhận được điểm ngắn nhất được liệt kê ở đây, thì nếu bạn cũng cân nhắc loại đỉnh của chúng ta có đường đi ngắn nhất này, thì nếu chúng ta xem xét cây, thì đỉnh nguồn của chúng ta sẽ có đường đi ngắn nhất này.

4705
00:02:07,050 --> 00:02:17,280
Sự khác biệt chính giữa thuật toán bổ sung này và thuật toán Billman là nếu một lần lấy nhất định chứa chu trình âm, Blanford có thể phát hiện chu trình âm.

4706
00:02:17,430 --> 00:02:28,530
Nhưng những phần bổ sung này không thể phát hiện ra một chu kỳ tiêu cực. Thuật toán chuyển tiếp Billman sẽ hoạt động theo chiều âm trên đó, nhưng nó sẽ không hoạt động theo chu kỳ âm, nhưng nó đã gây ấn tượng với tôi.

4707
00:02:28,560 --> 00:02:39,870
Hoạt động hoặc có nghĩa là nó hoạt động đối với các trang phủ định, nhưng đối với các chu kỳ tiêu cực. Đơn vị bổ sung này hoạt động giữa Oakland cũng hoạt động tốt, nhưng Pullman Ford có thể phát hiện chu kỳ tiêu cực.

4708
00:02:40,200 --> 00:02:49,550
Anh ấy hiểu cách giải quyết mọi vấn đề ngắn nhất ngang hàng. Việc sử dụng phần bổ sung này và hàng tỷ cho thuật toán Billman cho thuật toán sẽ giảm bớt độ phức tạp về thời gian xếp hàng.

4709
00:02:49,560 --> 00:03:03,460
Nó là gì Số lượng virus trong biểu đồ đã cho chúng ta có ở mã nguồn của Billman cho thuật toán dành cho tất cả người
nhảy dù. Vấn đề đó, chúng tôi sẽ không đi sâu vào nguồn và những lời giải thích mà chúng tôi đã nói rất chi tiết. 

@@@



4710
00:00:01,070 --> 00:00:15,330
Đây nè hai anh em. Chào mừng bạn quay trở lại với video này, chúng ta sẽ nói về thuật toán chuyến bay Urschel. Không, hãy nói về cách hoạt động của thuật toán Floyd Urschel đối với tất cả các vấn đề về khoảng cách ngắn nhất ngang hàng.

4711
00:00:17,700 --> 00:00:31,540
Đó là Adam. Chúng tôi đang cung cấp cho biểu đồ này cạnh này, cấu trúc dữ liệu biểu đồ của chúng tôi. Đồ thị này là đồ thị có hướng có trọng số. Đây là sự thể hiện của biểu đồ này.

4712
00:00:32,340 --> 00:00:55,620
Ở đây chúng tôi không có. Trong góc nhìn chéo này, bạn biết đấy, không không không không không một một không hai hai không ba hai không. Bởi vì nếu nút nguồn bằng 0 và nút đích ở đó bằng 0, thì khoảng cách giữa 0 và 0 bằng 0 vì ở đây chúng ta có bằng chứng rõ ràng.

4713
00:00:56,190 --> 00:01:08,140
Không một bốn không không muốn. Chúng ta có tám bốn không hai. Chúng ta có vô cực vì chúng ta không có bất kỳ cạnh có hướng nào đi từ 0 đến 2. Đó là lý do tại sao chúng ta có vô cực.

4714
00:01:08,560 --> 00:01:26,250
Chúng tôi đang biểu thị vô cùng vì số nguyên tối đa có thể lưu trữ trong 32 bit. Ở đây chúng ta có một do ba. Ta có chữ một, rồi từ một đến 0 vô cùng vì ta không có ID từ 1 đến 0.

4715
00:01:26,610 --> 00:01:37,500
Không có đi là từ một đến không. Đó là những gì chúng tôi có sự vô tận của bạn, v.v. Chúng ta đã hiểu cách biểu diễn lực hấp dẫn này để cấu trúc nó bằng ma trận kề này.

4716
00:01:37,980 --> 00:01:49,830
Bây giờ hãy nói về cách hoạt động của thuật toán Floyd Urschel. Thuật toán Flight Urschel sử dụng khái niệm lập trình động. Bây giờ, hãy xem lại thuật toán.

4717
00:01:50,220 --> 00:02:01,110
Sau đó chúng ta sẽ xem thuật toán này thực sự hoạt động như thế nào. Chúng tôi sẽ đi từng dòng một và sẽ giải thích từng chút thông tin mà bạn cần hiểu.

4718
00:02:01,260 --> 00:02:17,580
Thuật toán Floyd Urschel chúng ta có ở đây ly hợp Floyd này. Ngoài ra bên trong đây chúng ta còn có hai phương thức Floyd và in số liệu. Thuật toán này, hàm Floyd gạch dưới hoặc hiển thị, lấy biểu đồ đã cho làm đầu vào.

4719
00:02:17,790 --> 00:02:33,360
Đồ thị đã cho dưới dạng ma trận kề. Bạn đang tạo Ma trận mới và đây chính là lý do chúng tôi đang chạy vòng lặp for lồng nhau này để sao chép giá trị từ trọng lực sang cấu trúc sang ma trận kề mới này.

4720
00:02:33,930 --> 00:02:50,850
Sau đó, chúng tôi đang chạy dự phòng lồng nhau này để sao chép giá trị vào Ma trận. Chúng tôi đang chạy thuật toán của bạn ở đây. Chúng ta có ba phần phụ được lồng vào nhau và bên trong đây đang xem liệu i k cộng ma trận K có nhỏ hơn ma trận ý tưởng hay không.

4721
00:02:51,330 --> 00:03:03,000
Chúng tôi đang áp dụng công thức này và cuối cùng sẽ in ra Ma trận. Ở đây chúng ta có mã để in Ma Trận. Bây giờ hãy xem thuật toán này thực sự hoạt động như thế nào.

4722
00:03:03,540 --> 00:03:16,460
Đừng nhầm lẫn về nó. Chúng tôi sẽ giải thích từng thông tin của thuật toán này. Giả sử chúng ta đang đưa ra biểu đồ này và biểu đồ này được biểu diễn bằng ma trận kề.

4723
00:03:16,470 --> 00:03:34,350
Đây là ma trận kề. Đó là cà phê. Biểu đồ này cho số liệu này. Vì vậy, mỗi bản sao chúng tôi nhận được ma trận này. Bây giờ, điều đầu tiên, chúng ta sẽ làm gì? Chúng ta sẽ tìm ra nó, pep, điều đó đi qua Vertex zero.

4724
00:03:34,680 --> 00:03:48,750
Vì vậy, đây là những gì sẽ làm. Chúng ta sẽ tìm thấy tất cả. Pierce, được rồi, mọi người đều được ưu tiên trước. Không ba không một không hai thùng một hai một không một ba, v.v.

4725
00:03:49,170 --> 00:04:09,480
Chúng ta sẽ tạo ra mọi thứ ở đây từ biểu đồ này và chúng ta sẽ tìm thấy khoảng cách tối thiểu giữa hai cặp hàng hóa qua Vertex 0 sau khi tìm thấy điểm hài hước nhất có thể là xuyên thủng và Coke để khoảng cách tối thiểu.

4726
00:04:09,840 --> 00:04:29,040
Chúng tôi sẽ làm vậy. Chúng ta sẽ thấy khoảng cách tối thiểu để cây cột đi qua là một, hai và ba. Bây giờ chúng ta hãy tìm khoảng cách tối thiểu cho tất cả các mũi khoan đi qua điểm 0 của Vertex.

4727
00:04:29,520 --> 00:04:50,700
Hãy xem làm thế nào để tìm ra điều đó. Ở đây chúng ta có sự lặp lại. ĐƯỢC RỒI? Gần bằng không. Và ở đây chúng ta có iJie. Chúng tôi có hai cái lồng nhau đầy hiểu biết. Vì vậy, cái này tăng lên đến mức giảm sẽ thực thi không không không một không hai không ba một không một một, v.v. cho đến ba ba.

4728
00:04:51,180 --> 00:05:07,140
Chúng ta hãy xem làm thế nào để tìm hiểu. Đường dẫn khoảng cách tối thiểu đi qua số 0 ở đây số 0 có nghĩa là K, vì vậy chúng ta có thể đặt đường dẫn khoảng cách tối thiểu đi qua số 0. Đầu tiên, chúng ta có số 0.

4729
00:05:07,380 --> 00:05:21,020
Bây giờ chúng ta sẽ kiểm tra xem đống này có đi qua đỉnh 0 không? Ở đây chúng ta có số không và số không và chúng ta thấy điều này. Giá trị bằng không. Ngoài ra, bạn biết đấy, chúng ta sẽ áp dụng công thức này.

4730
00:05:21,050 --> 00:05:32,400
Khoảng cách từ 0 đến 0, nghĩa là từ tôi đến quan tâm và từ K2 G từ 0 đến 0 và 0 hai không. Chúng tôi thấy kỹ thuật số và chúng tôi có giá trị bằng không.

4731
00:05:32,690 --> 00:05:47,750
Đường đi từ 0 đến 0 và từ 0 đến 0 không 0, đó là số không. Và chúng ta thấy rằng giá trị hiện tại ở đây tại số 0 không nhỏ hơn 0. Vì vậy, giá trị này được đánh giá là sai.

4732
00:05:48,020 --> 00:06:03,620
Vì vậy, chúng tôi sẽ cập nhật giá trị này. OK, bây giờ chúng ta hãy chuyển sang ngang hàng tiếp theo. Bạn có biết một cái không? Cặp này có đi đến Vertex zero không? Chúng ta sẽ tìm ra khoảng cách từ 0 đến 0.

4733
00:06:03,650 --> 00:06:21,440
Không có số không và từ số không đến một và có tám số không cộng tám tuổi. Nó không ít hơn tám. Vì vậy, chúng tôi cập nhật giá trị hiện tại này ở đây. Chúng tôi đang tạo ra tất cả những người ngang hàng có thể trải qua quá trình chăm sóc.

4734
00:06:21,830 --> 00:06:34,790
Vì vậy, chúng tôi có khoảng cách tối thiểu. ĐƯỢC RỒI. Đây là một dạng lập trình động vì chúng ta đang sử dụng kết quả tính toán trước đó để tìm kết quả gốc hiện tại của mình.

4735
00:06:35,300 --> 00:06:49,310
Bây giờ bốn không hai không hai không không. Và Judah hai Judah hai là Vô cực Vô cực cộng 0 là Vô cực Vô cực không phải là Vô cực Lisbon. Vì vậy, chúng tôi sẽ trao giá trị này cho phụ nữ.

4736
00:06:49,310 --> 00:07:07,340
Bây giờ chúng ta hãy tiến về phía trước. Ở đây chúng ta có giá trị hiện tại là một và chúng ta có số không ba số không và ba số không và số không. Vì vậy, từ 0 đến 0 0 và từ 0 đến 3, giá trị là một một không là một.

4737
00:07:07,580 --> 00:07:22,190
Vậy một không lớn hơn một. Vì vậy, đạt đến giá trị này, chúng ta hãy tiến về phía trước. Bây giờ chúng ta có thiết bị ngang hàng này một không bốn một không một hai không. Điều đó có nghĩa là từ tôi lấy một về không.

4738
00:07:22,580 --> 00:07:34,900
Chúng tôi thấy rằng không có con đường trực tiếp. Các giá trị Vô cực Vô cực cộng với 0 hai 0 trong việc triển khai lại số 0 không nhỏ hơn vô cùng. Vì vậy, hãy tiến về phía trước ở đây.

4739
00:07:34,910 --> 00:07:49,970
Chúng tôi thấy rằng chúng tôi có giá trị bằng 0 và chúng tôi có ở đây để ngang hàng một và một cho một và một. Chúng ta có giá trị 0 một 0 vô cực rút ra tám trong không gian 3D cộng với tám nó ở dạng đẹp không nhỏ hơn 0.

4740
00:07:50,480 --> 00:08:06,350
Vì vậy, chúng tôi sẽ cập nhật giá trị hiện tại này. Hãy tiến về phía trước. Bây giờ chúng ta có đồng nghiệp này một hai bốn một hai. Chúng ta thấy điều đó từ một hai không từ một hai không Avengers Infinity Infinity cộng với không hai hai không hai hai.

4741
00:08:06,950 --> 00:08:30,230
Chúng ta thấy rằng giá trị là vô cùng. Chúng tôi thấy rằng chúng tôi không thể tìm thấy đường đi ngắn nhất cho thiết bị ngang hàng này tiến về 0. Vì vậy, hãy tiếp tục với điều này, bây giờ chúng ta hãy tiến về phía trước, chúng ta có vô cực của bạn và chúng ta có hai đỉnh này và ba từ một đến 0 từ giá trị số vô cực.

4742
00:08:30,700 --> 00:08:43,280
Vì vậy, nếu chúng ta tìm thấy nó là vô cùng thì không cần phải làm gì ở đây. Hãy tiến về phía trước ở đây. Chúng ta thấy rằng hai không bốn hai không. Chúng tôi thấy nó đi đến số không. Vậy hai bằng không là bốn.

4743
00:08:43,730 --> 00:08:56,750
Và do không không bốn cộng không là bốn và a thấy bốn không lớn hơn bốn. Vì vậy, hãy tiến về phía trước ngay bây giờ. Chúng tôi có sự vô tận của bạn. Bây giờ chúng ta có cái này ngang hàng với một.

4744
00:08:57,200 --> 00:09:18,770
Ở đây chúng ta có thể coi AI là nguồn và là đích. Chúng ta có thể đi từ nguồn này đến Vinayak Tunisia này không? Hãy xem. Hai hai không hai hai không là bốn bốn cộng không hai một không hai một là tám bốn cộng tám là 12.

4745
00:09:19,010 --> 00:09:31,720
Chúng ta có thể viết tới 12 nhỏ hơn vô cùng. Vì vậy, hãy cập nhật điều này. Vâng, chúng tôi ở đây để giúp đỡ. Vâng, chúng ta hãy tiến về phía trước. Chúng ta thấy ở đây chúng ta có hai, hai và bốn hai hai.

4746
00:09:31,750 --> 00:09:43,420
Chúng tôi không có tình yêu ở đây để thăm. Các phán quyết do các phán quyết đến khoảng cách tối thiểu là 0 vì nó bị đảo ngược cùng một nút bây giờ là hai ba từ hai thành không.

4747
00:09:43,450 --> 00:10:01,130
Chúng ta thấy bốn cộng không hai ba không hai ba. Đó là một. Vậy chúng ta có ở đây bốn cộng một. Đó là năm. Hãy cập nhật tốt với năm. Như vậy ở đây chúng ta thấy hai năm nguồn và ba năm đích đến nguồn của mình.

4748
00:10:01,510 --> 00:10:18,810
Ba là một điểm đến và chúng ta có thể truy cập điểm đến này từ nguồn này đến số 0 của Bartok. Vì vậy, chúng tôi tìm ra nếu màu vàng ở đây. Bây giờ chúng ta hãy tiến về phía trước.

4749
00:10:18,970 --> 00:10:32,140
Bây giờ chúng ta có ba không bốn ba không Không. Từ hai đến Jerusalem vô cùng, nên không cần phải làm gì ở đây. Hãy tiến về phía trước ngay bây giờ. Ba hai không ba hai không là vô cùng.

4750
00:10:32,380 --> 00:10:47,020
Không có gì để làm ở đây. Ba hai không hai không là vô cùng. Chúng tôi không có đơn vị đi nào ở đây bây giờ. Bốn hai hai không. Nó lại là vô cực, vì vậy không có gì được thực hiện ở đây.

4751
00:10:47,860 --> 00:11:06,820
Vì vậy, chúng tôi đã xử lý tất cả ở đây có thể đi qua nồi bằng không. Vì vậy, chúng tôi đã xử lý tất cả các thiết bị ngang hàng trong biểu đồ này có thể truy cập đích từ nguồn tại đây.

4752
00:11:07,240 --> 00:11:26,080
Đích là nguồn. Vì vậy, trong biểu đồ này, chúng ta thấy rằng trong biểu đồ này, chúng ta thấy rằng chúng ta có thể chuyển từ nguồn sang khôi phục ngoại trừ 0 hai một hai không một, hai ba và hai về không.

4753
00:11:26,500 --> 00:11:49,720
Bây giờ hãy chọn Vertex ở đây. Bây giờ chúng ta sẽ tìm hiểu tất cả những gì có thể xảy ra ở đây thông qua cái nồi. Bây giờ chúng ta có mã khóa. Hai một bốn ba không không bốn không không không hai một là tám và một hai không một hai không là vô cùng.

4754
00:11:50,200 --> 00:12:01,960
Vậy chúng ta hãy tiếp tục ở đây vì Israel cộng 8 không nhỏ hơn 0. Bây giờ chúng ta có ở đây tám. Chúng ta phải ghé thăm Vertex một điểm từ con số 0.

4755
00:12:02,080 --> 00:12:19,060
Vậy ở đây không hai một là tám và một hai một là không. Vì vậy, chúng tôi thấy rằng chúng tôi có ở đây tám. Vì vậy, nó sẽ không thay đổi điều này. Vâng, chúng ta hãy tiến về phía trước. Không hai một là tám và một hai hai là vô cùng.

4756
00:12:19,060 --> 00:12:30,130
Vì vậy, nó sẽ không thay đổi điều này vì vô cực không phải là Lisbon Infinity Plus 8. Hãy di chuyển. Bây giờ chúng ta có số không hai từ số không đến hai. Chúng ta phải đến thăm nơi này.

4757
00:12:30,400 --> 00:12:42,040
Tám cộng một là chín. Chín nhỏ hơn vô cùng. Vậy nên hãy làm tốt việc này vào lúc chín giờ nhé. Bây giờ chúng ta có hai hai ba. Vì vậy, ở đây chúng ta thấy rằng chúng ta không thể đi từ 0 đến 3 qua một.

4758
00:12:42,340 --> 00:12:57,910
Vì vậy, nó sẽ không xuất hiện tốt ở đây bây giờ. Bây giờ, từ một đến một một hai một không và từ một đến không là vô cùng. Vì vậy, nó không đạt đến giá trị này. Khi đó từ một đến một bằng không một hai một bằng không.

4759
00:12:58,160 --> 00:13:13,580
Vì vậy, sau giá trị này, ở đây chúng ta có một hai một bằng 0 và một phần hai là một. Và đối với quy tắc này, hãy tiến về phía trước và chúng ta có ở đây hai đến một hai hai một.

4760
00:13:13,600 --> 00:13:27,490
Chúng tôi thấy rằng bạn có chuyến đi. Và từ một đến không, từ một đến không vô cùng. Vậy là sau chuyện này, à, bây giờ chúng ta phải từ hai lên một. Từ hai đến một là 12.

4761
00:13:27,730 --> 00:13:47,170
Và từ một đến một là số không. Vậy tại sao không cập nhật giá trị này ngay bây giờ cho bạn biết, đây không chỉ là tìm ra giá trị ở đây. Đây là đường chéo, vì vậy nó sẽ không có bất kỳ giá trị nào ở đây nhỏ hơn 0 bây giờ bốn năm hai hai một hai hai một là 12GB.

4762
00:13:47,980 --> 00:13:56,920
Chúng tôi thấy 2GB lớn hơn 5 nên không có gì để so sánh ở đây. Bây giờ chúng ta có hai trong một bây giờ từ hai một, chúng ta thấy bốn thành một. Chúng ta phải nói với số lớn hơn năm.

4763
00:13:57,850 --> 00:14:10,990
Bây giờ đối với vô cực, chúng ta thấy ba hai một ba hai một là hai và một hai không. Nó là gì? Vô cực. Vì vậy bây giờ hãy tưởng tượng giá trị này cho hai ba hai một là hai.

4764
00:14:11,560 --> 00:14:31,760
Vì vậy, tất cả các giá trị thay đổi bây giờ từ ba thành một, chúng ta thấy từ hai thành một là hai và một hai. Hai từ một đến hai là một đến hai. Một là làm cộng. Một hai, hai một hai hai là một hai cộng một là Theresa, hãy tăng lên 293.

4765
00:14:32,180 --> 00:14:45,680
Hãy tiến về phía trước. Đây là Veloso chéo. Không có giá trị mà Lisbon. Không. Bây giờ chúng ta hãy chuyển sang đỉnh bốn Vertex hai. Chúng tôi phải tìm ra con đường của bạn từ nguồn.

4766
00:14:45,680 --> 00:14:58,120
Điều đó có nghĩa là từ các mục đi qua hai từ 0 đến 0, chúng ta có số 0 ở đây, nên bây giờ không cần làm gì ở đây từ 0 đến 2, từ 0 đến 2 là chín.

4767
00:14:58,460 --> 00:15:13,930
Chúng tôi có tám của bạn. Hãy tiến về phía trước ngay bây giờ. Không hai hai không hai hai là chín, vì vậy nó sẽ không hoạt động bằng 0 do các giá trị chín bây giờ từ một đến hai từ một đến hai.

4768
00:15:14,120 --> 00:15:32,890
Chúng ta thấy chúng ta có L1 một cộng hai hai không hai hai không năm. Vậy một cộng bốn là năm. Ở đây chúng ta thấy rằng chúng ta không thể thăm đỉnh 0 này từ đỉnh một đến đỉnh hai người có khoảng cách tối thiểu ở đây.

4769
00:15:32,900 --> 00:15:46,440
Được rồi, một cộng bốn bằng năm. Vậy hãy cùng RBD phát triển với 5. Hãy tiến về phía trước. Chúng ta không có gì ở đây, nhưng cần phải làm ở đây. Bây giờ chúng ta có ở đây một một hai hai từ một đến hai.

4770
00:15:46,490 --> 00:15:59,510
Chúng ta thấy rằng với một hoặc hai thì chúng ta có một. Vì vậy, bây giờ họ cần phải được thực hiện ở đây ngay bây giờ cho việc này. Vậy một hai hai giá trị một một âm mưu hai đến ba hai hai ba là năm.

4771
00:15:59,540 --> 00:16:11,120
OnePlus năm là sáu. Vì vậy, hãy cập nhật điều này thật tốt, với sáu. Chúng ta thấy rằng từ một đến ba, chúng ta có thể thăm từ một đến ba qua địa điểm này một cộng bốn cộng một.

4772
00:16:11,120 --> 00:16:25,850
Có sáu và chúng ta có ở đây sáu. Hiểu rõ cách thức này thực sự hoạt động. Hãy để tôi đi qua những ví dụ này cho đến cuối. Bây giờ chúng ta hãy tiến về phía trước. Ở đây chúng tôi là bốn từ hai đến không.

4773
00:16:26,330 --> 00:16:43,670
Chúng ta thấy chúng ta có một con đường đi qua hai. Vì vậy, hãy cập nhật tốt điều này với bốn. Chúng ta thấy điều đó từ hai đến hai. Từ hai đến hai là 0 không cộng hai hai không hai hai không là bốn, nên không cần phải làm gì ở đây.

4774
00:16:44,000 --> 00:16:59,350
Bây giờ, từ hai đến hai bằng 0 không cộng hai đến một hai hai một là 12 xu phải được thực hiện ở đây. Và tương tự cho phần còn lại và tương tự cho phần còn lại cho hàng này.

4775
00:16:59,420 --> 00:17:13,790
Được rồi, bây giờ chúng ta hãy tiến về phía trước. Ở đây chúng ta có vô cùng. Chúng ta có ba không bốn ba hai hai bốn hai hai hai ba ba cộng hai hai không hai hai không là bốn hai cộng bốn mươi bảy.

4776
00:17:13,790 --> 00:17:27,770
Hãy phát triển với bảy. Được rồi, từ ba đến 0, chúng tôi lại thấy bạn đi từ 2 đến 0 trên con đường này. Chúng ta thấy rằng chúng ta có thể đi từ hai đến 0 thông qua hai trong đường dẫn này.

4777
00:17:27,980 --> 00:17:43,980
Ba hai một một hai hai hai hai không. ĐƯỢC RỒI. Và đây là sự tổng kết của con đường. Khoảng cách. Anh hai một bốn. Có bảy nốt chúng tôi đã tính cho số 0 và một nốt chúng tôi đang tính cho hai nốt.

4778
00:17:44,000 --> 00:17:56,900
ĐƯỢC RỒI. Chúng tôi đang sử dụng kết quả được tính toán trước để tạo ra giá trị này. Bảy. Vì vậy đây là một chương trình động. Cố gắng liên hệ điều này với kết quả trước đó tôi đã thực hiện và đặt chúng vào bảng.

4779
00:17:57,230 --> 00:18:11,060
Đây là một chút trực quan. Bây giờ chúng ta hãy chuyển tiếp từ hai đến một qua hai ba hai hai hai hai lớn hơn hai ba lần. Bây giờ chúng ta hãy tiến lên từ ba lên hai.

4780
00:18:11,330 --> 00:18:21,390
Có ba ba hai hai ba ba hai. Có ba. Bây giờ chúng ta hãy tiến lên từ hai lên hai, có ba. Vì vậy, đây là số không. Sẽ không thay đổi nó.

4781
00:18:21,440 --> 00:18:37,430
Hãy chuyển sang Vertex thứ ba tiếp theo. Bây giờ chúng ta sẽ tìm ra con đường ngắn nhất tối thiểu từ đây đi qua Vertex ba. Hãy xem trước.

4782
00:18:37,890 --> 00:18:52,700
Không không không. Vì vậy, không cần phải làm gì ở đây. Gần không một không hai ba không đến ba là một và ba hai một hai. Vậy hai cộng một bằng hai ba.

4783
00:18:52,700 --> 00:19:08,350
Hãy cập nhật cái này thành ba, vì ba nhỏ hơn tám. Hãy tiến về phía trước. Sợ ba. Có một và ba hai hai ba hai hai, có ba OnePlus ba Sport.

4784
00:19:08,350 --> 00:19:20,740
Hãy cập nhật điều này được phát triển với bốn. Và ở đây chúng ta thấy rằng từ 0 đến 2, từ 0 đến 2, đi qua 3. Chiếc mũ là một cộng hai cộng một.

4785
00:19:21,370 --> 00:19:35,080
Đó là bốn. Hãy tiến về phía trước. Không hai ba. Đó là một. Vì vậy, nó sẽ không thay đổi nó bây giờ. Một hai không ở đây từ một đến ba từ một đến ba là sáu.

4786
00:19:36,640 --> 00:19:46,740
Sáu lớn hơn năm. Chúng ta hãy tiến về phía trước một lần nữa, sáu lớn hơn 0, chúng ta hãy tiến về phía trước. Hãy tiến về phía trước. Bây giờ chúng ta hãy tiến về phía trước để có được diện mạo mới mẻ này nhé anh ấy.

4787
00:19:47,280 --> 00:19:59,500
Hai hai ba hai hai ba năm tôi đang nắm lấy. Hãy tiến về phía trước ngay bây giờ. Hai đến ba năm năm cộng với hai hai một ba hai một hai năm +3 bảy Hãy làm điều này.

4788
00:19:59,500 --> 00:20:11,310
Vâng, bây giờ là bảy. Hãy tiến về phía trước nó bằng không. Vì vậy nó sẽ không thay đổi. Hãy tiến lên phía trước năm hai đến ba năm. Vì vậy, hãy thay đổi nó. Hãy tiến về phía trước.

4789
00:20:11,320 --> 00:20:29,140
Bảy ba hai ba. Không có không không cộng hai hai không hai hai không bảy, vì vậy nó sẽ không thay đổi nó hai thành ba không hai hai một. Có phải anh chàng này không tin tưởng vào phần còn lại mà chúng ta đã làm?

4790
00:20:29,590 --> 00:20:49,780
Chúng tôi tìm ra điều này. Chúng tôi tìm ra ma trận này. Chà, Kim và ma trận này chứa khoảng cách tối thiểu từ Vertex zero hai tất cả các cơn đau tim khác từ Vertex một đến tất cả các đỉnh khác từ đỉnh đến tất cả các đỉnh khác và từ Warwick đến tất cả các đỉnh khác.

4791
00:20:50,440 --> 00:21:09,760
Đây được gọi là thuật toán chuyến bay urschel. Ở đây chúng ta đang tạo ra tất cả những gì có thể đi qua K và bạn đang tính toán đường đi tối thiểu. Và đây được gọi là thuật toán bay, vì chúng ta đang tạo tất cả ở đây cho tất cả các đỉnh.

4792
00:21:09,910 --> 00:21:26,620
Vì vậy, bạn sẽ có con đường tối thiểu đó. Giải pháp này sẽ giảm gấp 2 lần về độ phức tạp của thời gian xếp hàng và giải pháp này sẽ lớn hơn gấp 2 lần về độ phức tạp của không gian hình vuông để tạo ma trận này.

4793
00:21:26,770 --> 00:21:41,580
Được rồi, và in cái này ra đây. Các số liệu sử dụng chức năng này, in các số liệu để hiểu cách hoạt động của thuật toán còi Floyd, nếu bạn có bất kỳ câu hỏi nào về anh ấy trong tình huống này.

4794
00:21:42,300 --> 00:21:53,700
Hãy cho chúng tôi biết ngay cả khi câu hỏi hiểu điều này kèm theo lời giải thích đã đăng câu hỏi
lên chữ hình nêm. Tôi sẽ vui lòng giúp đỡ. Cảm ơn đã xem video này cũ kiện video tiếp theo. 

@@@



4795
00:00:01,040 --> 00:00:13,770
Chào mừng các bạn quay trở lại với video này, video này các bạn sẽ nói về cây bao trùm tối thiểu, cây bao trùm tối thiểu còn được gọi là. Cây bao trùm tối thiểu.

4796
00:00:15,300 --> 00:00:33,180
Cây bao trùm tối thiểu hoặc cây bao trùm có chiều rộng tối thiểu là một tập hợp con của các độ tuổi hoặc được kết nối, đồ thị hữu hướng, vô hướng kết nối tất cả các xoáy với nhau mà không có bất kỳ chu kỳ nào với tổng số tối thiểu có thể có.

4797
00:00:33,810 --> 00:00:51,230
Nếu bạn đang vẽ đồ thị vô hướng hoặc liên thông, bạn phải tìm ra cây khung nhỏ nhất. Đặc tính của cây bao trùm tối thiểu là cây bao trùm tối thiểu sẽ không có chu trình.

4798
00:00:51,740 --> 00:01:07,100
Chúng ta phải bao gồm tất cả các đỉnh vào cây bao trùm. Ngoài ra, chúng ta có thể nói cây bao trùm tối thiểu là cây bao trùm trong đó tổng chiều rộng của ISS càng nhỏ càng tốt.

4799
00:01:07,820 --> 00:01:28,520
Tổng chiều rộng của nó chỉ cần tối thiểu bằng anh ta. Vì vậy, trong cây bao trùm đó, chúng ta nên bao gồm tất cả các đỉnh và bạn sẽ không có chu trình và bạn sẽ có tổng trọng số của các cạnh càng nhỏ càng tốt.

4800
00:01:29,210 --> 00:01:39,530
Ví dụ: nếu bạn được cho biểu đồ này, cạnh này là biểu đồ liên thông, có trọng số, vô hướng. Cây bao trùm tối thiểu của biểu đồ này là gì? Hãy tìm nó.

4801
00:01:39,950 --> 00:01:56,000
Đầu tiên chúng ta cùng tìm hiểu cây bao trùm. Được rồi, cái này đang mở rộng trên cây này. Bạn biết đấy, tổng trọng lượng của các ngôi nhà thậm chí còn có một chu trình và chúng tôi đã bao gồm tất cả các đỉnh trong cây bao trùm.

4802
00:01:56,600 --> 00:02:10,430
Đây cũng là một cây bao trùm có trọng lượng chỉ bằng tám. Đây cũng là một cây bao trùm. Đây cũng là cây bao trùm. Bây giờ chúng ta thấy rằng ở đây chúng ta có bốn cây bao trùm.

4803
00:02:11,210 --> 00:02:25,130
Cây bao trùm tối thiểu trong cây đang mọc lên này mà chúng ta có với chiều rộng là bảy tuổi là bao nhiêu? Vì vậy, đây là cây bao trùm tối thiểu cho biểu đồ màu xanh lá cây này.

4804
00:02:25,820 --> 00:02:40,980
Nếu bạn được cung cấp biểu đồ này do cấu trúc, chúng ta phải tìm cây khung nhỏ nhất. Cây bao trùm tối thiểu của biểu đồ này là gì? Đây là cây bao trùm tối thiểu mà chúng ta thấy trong cây này.

4805
00:02:41,130 --> 00:02:58,080
Chúng tôi đã bao gồm tất cả các đỉnh trong cây bao trùm tối thiểu này. Chúng ta thấy rằng chúng ta đã bao gồm tất cả các đỉnh và bạn biết đấy, chúng ta có chu kỳ tổng của tổng trọng lượng của nó.

4806
00:02:58,080 --> 00:03:26,790
Đây có phải là một phần của bảy cho cây bao trùm đã cho này không? Và đây là cây bao trùm tối thiểu mà chúng ta có thể tạo ra từ biểu đồ đã cho này. Bây giờ chúng ta hãy
xem ứng dụng của cây bao trùm tối thiểu để tìm các mẫu trong -- là cây bao trùm tối thiểu khổng lồ để thiết kế các mạng như mạng viễn thông, mạng cấp nước và lưới điện. 

@@@



4807
00:00:01,040 --> 00:00:13,070
Trong video này, chúng ta sẽ nói về thuật toán của Cream. Thuật toán của ma cô là gì? Tìm cây bao trùm nhỏ nhất từ ​​một đồ thị đã cho.

4808
00:00:13,760 --> 00:00:26,150
Biểu đồ phải được kết nối. Thuật toán số nguyên tố đồ thị vô hướng có trọng số là một thuật toán tham lam tìm cây khung nhỏ nhất cho đồ thị vô hướng, có trọng số.

4809
00:00:26,690 --> 00:00:43,460
Điều này có nghĩa là nó tìm một tập hợp con của các độ tuổi tạo thành một cây bao gồm mọi đỉnh hoặc tổng trọng số của tất cả các độ tuổi trong cây là nhỏ nhất. Bạn được cho đồ thị vô hướng này làm gì?

4810
00:00:44,390 --> 00:00:58,280
Chúng tôi đã xác định nó là cây bao trùm tối thiểu trong cây. Chúng ta nên bao gồm tất cả những lợi thế và chúng ta nên có. Chúng ta sẽ không có chu kỳ và tổng số.

4811
00:00:58,730 --> 00:01:11,550
Nó sẽ cần phải ở mức tối thiểu. Các bước triển khai thuật toán Pimp như sau. Đầu tiên, khởi tạo cây bao trùm tối thiểu với đỉnh Susan một cách ngẫu nhiên.

4812
00:01:13,300 --> 00:01:34,770
Vì vậy, chúng ta sẽ chọn một xoáy ngẫu nhiên, chúng ta có thể chọn số 0, chúng ta có thể chọn một, v.v. Ở bước thứ hai, chúng ta sẽ tìm tất cả các tác nhân kết nối cây đó với virus mới, tìm mức tối thiểu và thêm nó vào cây và chúng ta sẽ tiếp tục lặp lại.

4813
00:01:34,920 --> 00:01:52,470
Bước hai Đây là bước hai cho đến khi chúng ta có được cây bao trùm tối thiểu. Bây giờ hãy xem thuật toán này hoạt động như thế nào và thuật toán tiền khuếch đại như thế nào. Tìm cây khung nhỏ nhất trong đồ thị rừng, vô hướng cho trước.

4814
00:01:53,910 --> 00:02:05,610
Hãy thêm bạn tranh luận trong biểu đồ này. Đầu tiên, chúng ta sẽ tạo một khu vực trong khu vực này. Chúng tôi sẽ theo dõi Vertex đã chọn. Hãy xem thuật toán này hoạt động như thế nào.

4815
00:02:06,720 --> 00:02:22,400
Chúng tôi đang đi. Chọn những sản phẩm này bằng 0, vì vậy hãy chọn sản phẩm này bằng 0. Chúng tôi chọn các đỉnh bằng 0. Bây giờ ở đây chúng ta sẽ chèn hai. Điều đó có nghĩa là chúng ta đã chọn số 0 của Vertex.

4816
00:02:23,490 --> 00:02:44,030
Bây giờ, chúng ta hãy khám phá độ đi xuống của cơn lốc số 0 này, độ dốc xuống là một và ba. Bây giờ chúng ta sẽ tìm ra mức tối thiểu. Khoảng cách từ xoáy này đến xoáy lân cận, điều đó có nghĩa là độ tuổi có trọng số tối thiểu mà anh ta nhận được là tối thiểu.

4817
00:02:45,190 --> 00:03:01,010
Sau đó là năm, bây giờ tôi sẽ đánh giá điều này. Edge, chúng tôi làm điều đó cho, vì vậy hãy chọn xoáy này. Bây giờ hãy đánh giá tuổi cân nặng tối thiểu này là 4, vì vậy hãy chọn xoáy này ở đây.

4818
00:03:01,490 --> 00:03:18,480
Hãy chọn xoáy này và cắt nó ở đây. Đây là dành cho. Chúng tôi đã chọn những phán quyết này. ĐƯỢC RỒI. Vì vậy, hãy chèn vào đây, đúng. Tại thời điểm này, chúng tôi nói rằng chúng tôi đã chọn hai phán quyết, không và một.

4819
00:03:19,410 --> 00:03:43,280
Bây giờ, hãy tìm tuổi tối thiểu hiện tại bằng 0 hoặc đỉnh này mà chúng ta thấy ở đây. Để già đi từ 0 đến 3 và từ 1 lên 2. Và độ tuổi tối thiểu nó sẽ chọn độ tuổi này, Kiribati X2.

4820
00:03:43,460 --> 00:03:59,690
Vì vậy, hãy chọn VORTEX2 này. Hãy sửa tuổi này ở đây và ở đây. Vấn đề là ở chỗ. Vì vậy, chúng tôi đã chọn những phán quyết này để chèn vào đây, đúng vậy. Chúng tôi đã chọn ở đây phần này, đó là sự thật.

4821
00:04:00,170 --> 00:04:20,090
Vì vậy, hãy chèn true của bạn. Bây giờ chúng ta hãy tìm hiểu chính trị tối thiểu. Đó là quảng cáo của số không. Hoặc một hoặc hai? ĐƯỢC RỒI. Chúng tôi thấy quảng cáo không. Chúng tôi có bốn hai cho một, chúng tôi phải gửi nó bằng 0 và hai cái đã được chọn.

4822
00:04:21,140 --> 00:04:35,870
Ở đây chúng tôi đang đánh dấu các phán quyết đã chọn, vì vậy chúng tôi sẽ không có bất kỳ phán quyết nào trực tiếp ở đây từ hai đến ba. Chúng ta có nó hoặc đến và đi do ba là với năm. Vì vậy, nó giống như độ tuổi này.

4823
00:04:36,200 --> 00:04:50,660
Vậy hãy chọn độ tuổi này và cân nặng kia ở độ tuổi này nữa. Vậy chúng ta hãy kết nối và khán giả đến đây sẽ thấy tổng trọng lượng của độ tuổi bốn cộng một cộng hai ba bảy.

4824
00:04:51,410 --> 00:05:04,280
Và đây là cây bao trùm tối thiểu vì ở đây chúng tôi đã chọn ba cây có tầm vóc. Đúng, trong một cây bao trùm tối thiểu sẽ có số B này trừ một?

4825
00:05:04,460 --> 00:05:25,730
Số lượng virus là bao nhiêu? Ở đây chúng ta thấy rằng chúng ta có bốn hạt, vì vậy trừ một bằng ba. Vì vậy, chúng ta thấy ở đây chúng ta có ba là. Ở đây chúng ta đã tạo một vùng có chiều dài của vùng này là số lượng phán quyết và chúng ta có.

4826
00:05:26,670 --> 00:05:37,710
Tạo mảng này để đánh dấu các sản phẩm đã chọn. Được rồi. Và đây là cách thuật toán của Prima hoạt động để hiểu rõ hơn. Hãy lấy một ví dụ khác.

4827
00:05:38,790 --> 00:05:53,490
Giả sử chúng ta được cung cấp cấu trúc dữ liệu biểu đồ này. Đầu tiên, bạn sẽ làm gì? Chúng ta sẽ tạo ra một mảng. Đánh dấu, chọn xoáy sử dụng mảng này, nên tất cả sẽ không có chút xa cách nào.

4828
00:05:54,980 --> 00:06:09,580
Chúng tôi không thể bỏ qua Luf bằng cách sử dụng mảng này và chúng tôi sẽ theo dõi các phán quyết đã chọn. Hãy chọn vòng xoáy này một cách ngẫu nhiên, bằng không. Nếu chúng ta chọn những phán quyết này một cách ngẫu nhiên thì không.

4829
00:06:11,630 --> 00:06:26,270
Ở đây chúng ta hãy viết ra bản án này. Không. Và ở đây hãy tiếp thị như đã chọn vì chúng tôi đã chọn phán quyết này. Không hoặc không là một và bảy tuổi tối thiểu, hoặc là bốn.

4830
00:06:26,450 --> 00:06:39,620
Vậy hãy chọn phán quyết này. Ở đây chúng tôi đã chọn những phán quyết này. Một. Vì vậy, hãy kết nối ở đây. Đây là mức tối thiểu ở đây. Được rồi, bây giờ chúng ta sẽ đánh dấu.

4831
00:06:40,650 --> 00:06:53,830
Dưới đây là những phán quyết về một lựa chọn. Bây giờ với số 0 và một cho xoáy số 1 này, chúng ta phải cộng phần gốc với bảy bốn. Bạn có biết chúng ta phải thêm phần gốc không?

4832
00:06:54,700 --> 00:07:11,910
Chúng tôi đã chọn cơn lốc liền kề này. Bây giờ, bạn định làm gì? Chúng tôi sẽ chọn độ tuổi tối thiểu cho nó. Ở đây chúng ta thấy tám chẵn và tám ở đây chúng ta sẽ chọn phán quyết này.

4833
00:07:12,350 --> 00:07:27,620
OK, vậy hãy chọn Vertex 7 này, vì ở đây chúng ta có độ tuổi tối thiểu. Tám sẽ bảo vệ đỉnh liền kề từ 0 đến b trừ đi một lần tất cả c.

4834
00:07:27,620 --> 00:07:44,860
Khi vào pseudocode thì ở đây bạn sẽ chọn cái này. Tuổi với trí thông minh. Tám. Được rồi, chúng ta đây, Vertex bảy. Vậy hãy chọn chiếc Vertex 7 này ở đây. Và ở đây chúng ta thấy.

4835
00:07:46,560 --> 00:08:02,490
EJ, tám là bao nhiêu, vậy hãy cộng vào đây, và hãy cộng vào đây, tám bây giờ chúng ta đã chọn bảy để cho phép tiếp thị là đúng. Đúng có nghĩa là được chọn thông qua có nghĩa là được chọn.

4836
00:08:03,240 --> 00:08:21,870
Bây giờ chúng ta có ở đây ba phán quyết này. Chúng ta phải tìm ra cân nặng tuổi tối thiểu mà điều chỉnh ba phán quyết này. Chúng ta ngồi đây. Chúng tôi có một, ở đây chúng tôi có bảy và ở đây bạn có 11, nhưng một đã được chọn và đối với một, chúng tôi có tám.

4837
00:08:22,110 --> 00:08:35,490
Chúng tôi thấy một là tối thiểu. Vì vậy, hãy chọn sáu của bạn. Bây giờ hãy kết nối ở đây và cạnh với mỗi cái. Vì vậy, chúng tôi đã chọn ở đây sáu, vì vậy hãy tiếp thị như đã chọn.

4838
00:08:36,360 --> 00:08:50,800
Bây giờ chúng ta hãy tìm hiểu xem độ tuổi cân nặng tối thiểu đó là sự ra đời của một bảy. Và sáu, ở đây chúng ta thấy có sáu người ở đây. Những phán quyết này, chúng tôi cũng thích nó.

4839
00:08:50,980 --> 00:09:09,000
Và đây là mức tối thiểu. Vì vậy, hãy chọn năm ở đây. Hãy đi nào. Nó cũng đây. Chúng tôi đã chọn ở đây năm, vì vậy hãy đánh dấu năm là đã chọn ở đây. Chỉ mục là nốt hoặc đỉnh.

4840
00:09:09,870 --> 00:09:24,140
Bây giờ chúng ta phải tìm ra độ tuổi tối thiểu đó là độ tuổi một, bảy, sáu và năm. Chúng ta thấy ở đây chúng ta có sự điều chỉnh tối thiểu cho một bảy, sáu năm.

4841
00:09:24,150 --> 00:09:42,660
Đây có phải là cho anh ấy? Vì vậy, hãy chọn Vertex hai này ở đây và cân nặng theo độ tuổi mà chúng ta thấy. Bốn. Hãy kết nối ở đây. Vậy bây giờ, bốn bốn sáu năm bảy một Tối thiểu là bao nhiêu?

4842
00:09:43,990 --> 00:09:57,650
Đó sẽ là trung tâm của vòng xoáy này, một, bảy, sáu, năm và hai năm mà chúng tôi đã chọn nên chúng tôi phải tiếp thị chúng tôi một cách đúng đắn. Và chúng tôi thấy rằng độ tuổi tối thiểu.

4843
00:09:58,310 --> 00:10:16,150
Độ tuổi này là bao nhiêu? Vì vậy hãy chọn ở đây. Tám. Vì vậy, hãy chọn tám của bạn. Và chúng ta sẽ kết nối. Độ tuổi của nó là vậy. Vì vậy chúng tôi đã chọn. Phán quyết thứ tám.

4844
00:10:16,170 --> 00:10:36,290
Vì vậy, hãy. Thị trường như đã chọn, chúng tôi không tiếp thị, sau đó chúng tôi có thể quay lại với lĩnh vực đó một lần nữa và điều đó sẽ cắt giảm chu kỳ của nó. Bây giờ chúng ta cùng tìm hiểu nhé. Phụ tá của. Tám, hai, năm, sáu, bảy một.

4845
00:10:36,530 --> 00:10:50,870
Và đó là mức tối thiểu. Và đối với một, tất cả các liền kề được chọn cho bảy, tất cả các liền kề được chọn cho sáu, tất cả các liền kề được chọn và ở đây cho năm và bốn hai là hỗ trợ bên trái.

4846
00:10:50,870 --> 00:11:07,470
Hai. Chúng tôi có ở đây bảy. Và đối với năm, chúng ta có lớp 10 và 14 để chúng ta chọn ở đây. Vertex ba này. Hãy kết nối ở đây, và hãy cộng vào đây, bảy bảy là như vậy.

4847
00:11:08,480 --> 00:11:27,640
Bây giờ là bảy và năm, bây giờ là bốn, ba và năm, liền kề vẫn ở Fortnite, vì vậy hãy chọn độ tuổi này và chúng tôi đưa ra phán quyết vì vậy hãy chọn vòng xoáy này để chúng ta kết nối với vòng xoáy này và ở đây chúng ta có lợi thế.

4848
00:11:28,040 --> 00:11:47,170
Chín. Ở đây tôi đã chọn ra ba người phải tiếp thị. Là đúng và sau đó chúng tôi đã chọn vì chúng tôi phải tiếp thị là đúng ở đây. Và chúng ta đã hoàn thành. Chúng tôi đã xử lý số 0 trừ ba lần chúng tôi đã đến đây khi chúng tôi đã đi được một lứa tuổi.

4849
00:11:48,350 --> 00:12:02,670
Ở đây bạn có tổng cộng chín phán quyết. Vậy là chín phút trên tám phút của anh ấy. Ở đây chúng ta có tổng cộng tám, có phải một hai ba bốn năm sáu bảy tám là tổng số tuổi không?

4850
00:12:03,390 --> 00:12:15,840
Ba mươi bảy. Và đây là cây bao trùm tối thiểu. Đây là cách thuật toán trước đó hoạt động. Bây giờ chúng ta hãy xem mã giả. Đây là loại mã cho thuật toán tiền khuếch đại.

4851
00:12:16,650 --> 00:12:27,690
Hàm này dùng để đưa ra biểu đồ và virus ở đây hoặc khai báo một biến đủ lớn vô cùng. Và ở đây, khôi phục số nguyên tối đa bạn có thể lưu trữ trong 32 bit.

4852
00:12:28,850 --> 00:12:43,040
Sau đó tuyển dụng ở đây, mảng để tiếp thị các giống đã chọn là chúng tôi có ở đây một số đại lý đã bị trừ một aegis, OK cho loại trà đầy tham vọng.

4853
00:12:43,400 --> 00:12:55,640
Chúng ta biết rằng nếu có VAR thì số của nó phải bằng v trừ một. Ban đầu, chúng tôi chọn hai phần tử đầu tiên có giá trị bằng 0 và thị trường như đã chọn.

4854
00:12:56,750 --> 00:13:10,260
Bằng cách chèn velodrome này vào đây hoặc in. Tuổi hay nó? Ở đây chúng ta có 12, à, dấu gạch dưới mờ, nó nhỏ hơn số trừ một sẽ chạy mã này.

4855
00:13:10,920 --> 00:13:23,340
Đây là phần thân của số 12 này. Chúng ta đang khởi tạo vô cực cho biến tối thiểu này. Và ở đây chúng ta có Exegol hai kỹ thuật số oracle kỹ thuật số và nó sẽ theo dõi.

4856
00:13:24,720 --> 00:13:42,410
Độ tuổi tối thiểu, nó sẽ theo dõi độ tuổi có cân nặng tối thiểu. Bạn phải mặc định cho IndiGo's, bạn có biết tôi sống ở Vantage's, tôi + + bên trong đây, viết kiểm tra nếu được chọn bằng hai nếu tôi được chọn.

4857
00:13:43,910 --> 00:14:01,880
Chà, chúng ta sẽ thực thi vòng lặp bên trong ở đây trong một vòng lặp cho nó. Zikode dưới 40 cam kết không có zip của Elizabeth Vargas và ở đây hoặc kiểm tra xem vòng xoáy có bị bỏ qua hay không thì mới xử lý mã này.

4858
00:14:02,780 --> 00:14:21,070
Và ở đây chúng tôi đang kiểm tra xem ý tưởng của Graaff có phù hợp hay không, bạn biết đấy, điều này đáng để kiểm tra quảng cáo, chỉ vì chúng tôi đang triển khai trọng lực đối với cấu trúc bằng cách sử dụng ma trận kề và ở đây chúng tôi đang kiểm tra xem giá trị tối thiểu có lớn hơn giá trị hiện tại hay không.

4859
00:14:21,080 --> 00:14:43,840
OK, ở đây chúng tôi đang cập nhật ở mức tối thiểu. Và X với tôi và tại sao bạn lại làm vậy? Khi kết thúc quá trình dự phòng này, chúng tôi đang in Aksoy và giá trị hiện tại, đồng thời nhận xét rằng phán quyết mà chúng tôi đã chọn bằng cách đặt sự thật và hiện chúng tôi đang ở trong tù nhấn mạnh nó.

4860
00:14:45,000 --> 00:14:56,760
Đây là thuật toán Prince. Hãy xem điều này thực sự hoạt động như thế nào. Trước tiên hãy giả sử hoặc đưa ra cấu trúc dữ liệu đồ họa này, việc tôi sẽ làm là nó sẽ tạo ra một Boolean Ari.

4861
00:14:57,120 --> 00:15:14,480
Đây là diện tích Boolean của lint 4 vì ở đây chúng ta có 4 đỉnh. Bây giờ chúng ta hãy chạy tốt. Đầu tiên, chúng tôi có công cụ được chèn của bạn. Điều đó có nghĩa là chúng tôi đã chọn nút 0, nghĩa là số 0 của Vertex.

4862
00:15:15,450 --> 00:15:26,550
Bây giờ hãy chạy vòng lặp này nhé, được chứ? Điều này, trong khi về các con số, không bằng ai, điểm ban đầu bằng 0. Nó nhỏ hơn các đỉnh trừ một bốn trừ một bằng ba.

4863
00:15:27,760 --> 00:15:41,140
Vì vậy, có ít hơn ba hãy chạy mã này tối thiểu là colts để phát nổ vô cùng, bạn không thức dậy với ban đầu của bạn? Bây giờ chúng tôi đang phát trực tiếp của bạn ở đây từ cơn lốc số 0 này đến tất cả cơn lốc khác của Addison.

4864
00:15:42,330 --> 00:16:04,980
Ở đây tôi thấy rằng một là không được thăm, và đó là bốn nhỏ hơn vô cùng. Bây giờ chúng ta có Exegol Digital và chúng ta phải đợi lần lặp thứ hai của thùng tình yêu này vì tôi có hai, rồi bốn đến ba người có ghi chú này, nhưng anh ta nhận được bốn và năm, nhưng chúng ta thấy rằng bốn nhỏ hơn năm.

4865
00:16:05,040 --> 00:16:23,440
Vì vậy, chúng tôi sẽ cập nhật X và Y. Bây giờ ở đây nó sẽ in X, Y và Z và ở đây là trọng số. Vì thế. Đầu tiên, chúng tôi chọn số không. Sau đó chúng ta có một phán quyết. Hãy kết nối nó và cộng vào đây, Whit.

4866
00:16:23,670 --> 00:16:38,820
Và chúng tôi chỉ đang in vào anh ấy, và đây chỉ là một cách biểu diễn logic. Không một x y. Và ở đây chúng ta có đồ thị x y. Ở đây chúng ta nên có. Chân đế.

4867
00:16:40,210 --> 00:16:54,460
Bây giờ, hãy đánh dấu một cái là đã truy cập, một cái ở đây. Thế là ghé thăm luôn, không, bây giờ hãy tăng NAM tám bằng một một nhỏ hơn cái này là bao. Đối với một, chúng ta sẽ phải biến nó thành hai như đã truy cập.

4868
00:16:54,790 --> 00:17:06,920
Vì vậy, chúng tôi tìm hiểu ở đây. Hai, bởi vì khu vực không phải là một và nó đã được ghé thăm. OK, điều này đã được truy cập. Và ở đây chúng ta có năm bốn số không và ở đó chúng ta thấy một là tối thiểu.

4869
00:17:07,690 --> 00:17:21,570
Vì vậy, hãy chọn VORTEX2 mà chúng tôi đã chọn trên thị trường. Vì vậy, hãy kết nối nó ở đây. Và trọng lượng là một. Bây giờ, đối với hai, chúng tôi có mức tối thiểu của bạn. Và ở đây chúng ta thấy hai.

4870
00:17:21,840 --> 00:17:36,370
Vì vậy, hãy chọn Vertex ba ở đây và chờ đợi, ở đây chúng ta thấy hai. Vì vậy, ở đây chúng tôi có hai. Và hãy chọn. Và chúng ta đã hoàn thành. Một trong những điều phải trải qua là sự lặp lại.

4871
00:17:37,710 --> 00:17:48,970
Để hiểu rõ hơn, bạn có thể xem qua điều này. Bạn có thể lặp lại tình yêu này. Đây là phạm vi tối thiểu bốn mà bạn có thể xây dựng từ cấu trúc dữ liệu biểu đồ này.

4872
00:17:49,870 --> 00:18:01,750
Thuật toán này chỉ mất độ phức tạp thời gian log VE lớn hơn và nó phản ánh do độ phức tạp về không gian cần xây dựng để xây dựng vùng Boolean.

4873
00:18:02,480 --> 00:18:15,580
Hy vọng bạn hiểu cách hoạt động của thuật toán này để hiểu rõ hơn. Hãy để tôi đi qua một ví dụ khác. Giả sử nó có biểu đồ này vào lúc này, và ở đây chúng ta có diện tích này.

4874
00:18:15,580 --> 00:18:29,220
Đây là khu vực Boolean của chúng tôi. Bây giờ chúng ta có thể kết nối. Ý định với loại thỏa thuận này. Hãy thử nó. Đầu tiên, chúng tôi cũng đã chèn vào đây. Vì vậy, chúng tôi đã chọn ở đây số không.

4875
00:18:29,940 --> 00:18:43,200
Bây giờ là mức tối thiểu. Thế này ổn không? Tôi đoán là chúng ta sẽ thấy nó nằm trong phần sau cho hai, không và bốn bàn thắng thành một. Bạn sẽ tìm thấy nó ở độ tuổi tối thiểu này. Hãy kết nối ở đây.

4876
00:18:43,770 --> 00:19:01,630
Vì vậy, như bạn đã biết, một cái ở đây chúng tôi đã tìm kiếm. Vì vậy, ở đây chúng tôi đã chờ đợi. Bây giờ, hãy tiếp thị một lựa chọn. Bây giờ, tôi chỉ lấy một và số không là. Hai, bảy và bảy.

4877
00:19:01,870 --> 00:19:29,220
Vì vậy, ở đây chúng ta thấy chúng ta có 8, chúng ta có 8, chính là 8 vì chúng ta sẽ lặp từ 0 đến. Tám. Và bạn tìm thấy ở đây người bạn này. Chà, cho trước, sau đó chúng ta sẽ chuyển từ một hai không đến tám, rồi bốn, chúng ta sẽ xử lý nội dung ghi chú này từ 0 đến tám cần tìm để thêm vì bạn sẽ tìm thấy nốt số tám này trước.

4878
00:19:29,490 --> 00:19:49,670
Vậy quy luật này không nhỏ hơn 8 nên bạn sẽ có độ tuổi này. Vậy chúng ta hãy chọn phán quyết thứ bảy ở đây. Và hãy. Vẽ ở đây. Vì vậy, ở đây tám. Bây giờ là bảy và một, đây là mức tối thiểu.

4879
00:19:49,870 --> 00:20:13,040
Xem này, đây là mức tối thiểu, vì vậy hãy vẽ ở đây. Sáu. Tôi đi làm việc đầu tiên ở đây. Được cho sáu tất cả đều có điều này là tối thiểu năm. Được rồi, hãy quay lại khi bạn chọn bảy, chúng tôi phải tiếp thị là đúng khi bạn chọn sáu, nếu thị trường là đúng, khi tôi chọn năm, chúng tôi phải tiếp thị là đúng.

4880
00:20:14,570 --> 00:20:28,570
Và bây giờ chúng ta có từ thứ hai. Bốn. Từ đây chúng ta thấy bây giờ. Từ đây, chúng ta thấy mức tối thiểu được thêm vào ghi chú này. Hai. Vì vậy, hãy kết nối ở đây. Bây giờ, từ những gì chúng ta thấy, chúng ta có tám.

4881
00:20:29,660 --> 00:20:42,990
Với mức lương tối thiểu, điều đó đúng, vì vậy hãy cắt giảm nó ở đây và ở đây, chúng ta sẽ đi sâu vào nó và hãy tuân thủ. Bây giờ từ hai đến. Ba. Tôi đi làm việc đầu tiên ở đây.

4882
00:20:44,650 --> 00:20:57,730
Hai đến ba ở đây, cậu bé của bạn lúc bảy giờ và sau đó là mức tối thiểu. Ồ, tôi xin lỗi. Tôi có hai điểm. Tất cả các phán quyết được lựa chọn là đúng. Chúng tôi đã chọn hai. Vì vậy, hãy tiếp thị như sự thật ở đây.

4883
00:20:57,730 --> 00:21:15,610
Chúng tôi đã chọn tám. Hãy tiếp thị như sự thật. Chúng tôi đã chọn năm thứ ba của thị trường là đúng và ở đây chúng tôi có năm thứ tư. Vì vậy, hãy tiếp thị như sự thật. Và anh ấy hãy kết nối, và chúng ta có ở đây tổng cộng 9, tức là 37.

4884
00:21:15,630 --> 00:21:33,620
ĐƯỢC RỒI. Chín cộng bảy cộng hai cộng hai cộng một cộng tám cộng bốn bằng 37. Chúng tôi nhớ người anh hùng vĩ đại này, Kim. Bốn cộng tám cộng một cộng hai cộng bốn cộng hai cộng bảy cộng chín, anh đi muộn bảy.

4885
00:21:34,520 --> 00:21:50,680
Thuật toán này thực sự làm tôi khó chịu. Anh ấy ghi lại độ phức tạp về thời gian của VE và độ phức tạp của không gian. Obama đã
hiểu. Thuật toán tiền khuếch đại này trong video tiếp theo mà chúng ta nói đến rất quan trọng đối với các thuật toán trước đó. 

@@@



4886
00:00:00,990 --> 00:00:11,100
Này các bạn. Chào mừng bạn quay trở lại với video này, bạn sẽ nói về trang web chung này, một cấu trúc dữ liệu. Cấu trúc dữ liệu của Trang web chung là gì?

4887
00:00:12,030 --> 00:00:28,380
Hai hoặc nhiều tập hợp không có điểm chung nào được gọi là một tập hợp chung. Bạn đã được thiết lập. Nó chỉ bao gồm hai một hai ba và nếu là hai, hãy đến bốn hoặc năm ở giữa hai bộ này, nó là một và là hai.

4888
00:00:28,650 --> 00:00:45,030
Chúng tôi không thấy có gì chung. Vậy hai tập hợp này được gọi là tập hợp chung. Cấu trúc dữ liệu được biểu diễn như thế nào, trang web chung được thể hiện như thế nào trong bộ nhớ máy tính và nó hoạt động như thế nào?

4889
00:00:45,360 --> 00:00:59,100
Vâng, hãy xem mọi thứ trong video này. Chúng ta sẽ xem bộ khớp được thể hiện như thế nào trong bộ nhớ máy tính và cách thức hoạt động của nó. Bây giờ hãy nói về việc áp dụng Nhà nước chung.

4890
00:00:59,710 --> 00:01:12,590
Ở đây chúng ta có hai công dụng của khớp. Điều quan trọng đối với thuật toán sử dụng tập hợp chung là chúng ta có thể phát hiện chu trình trong đồ thị vô hướng bằng cách sử dụng cấu trúc dữ liệu tập hợp chung.

4891
00:01:13,980 --> 00:01:33,480
Quả thực, Doanh cho biết, chúng ta có hai hoạt động tìm kiếm và hoạt động đoàn. Chúng ta sẽ xem phép toán cuối cùng và phép hợp hoạt động như thế nào và bạn sẽ thấy cách phát hiện chu trình trong đồ thị vô hướng bằng cách sử dụng cấu trúc dữ liệu trạng thái chung.

4892
00:01:34,290 --> 00:01:51,780
Bây giờ chúng ta hãy xem biểu diễn của tập hợp chung. Bây giờ hãy nói về cách biểu diễn cấu trúc dữ liệu của tập hợp D. Chúng ta có thể biểu diễn tập hợp khớp bằng cách sử dụng một mảng đơn giản mà tập hợp khớp sử dụng phép gán để xác định được đặt.

4893
00:01:51,960 --> 00:02:07,440
Việc điều chỉnh được xác định bởi mối quan hệ cha mẹ và con cái. Hãy xem. Chúng tôi được tặng bộ này. Chúng ta phải biểu diễn tập hợp này. Bạn bắt đầu học phần này bằng cách sử dụng cấu trúc dữ liệu của tập hợp chung như thế nào?

4894
00:02:08,310 --> 00:02:21,300
Chúng ta sẽ triển khai cấu trúc chung bằng cách sử dụng mảng đơn giản. Đầu tiên, chúng ta sẽ xây dựng một cấu trúc. Đây là cấu trúc chúng ta có thể xây dựng. Cấu trúc này ở đây là cha mẹ của một.

4895
00:02:21,720 --> 00:02:33,240
Và ở đây trên cha này, tối đa và 0 là cha mẹ tuyệt đối của hai. ĐƯỢC RỒI. Ngoài ra, bạn có thể xây dựng cấu trúc này ở đây. Ta thấy cha mẹ lên trên hai là bằng không.

4896
00:02:34,080 --> 00:02:49,500
Và ở đây chúng ta thấy cha mẹ của hai người là một. Cha mẹ của số 0 là đúng. Cha mẹ tuyệt đối của số 0 là một. Vì vậy, chúng ta có thể coi cha mẹ tuyệt đối của hai và cha mẹ tuyệt đối của 0 là một.

4897
00:02:49,950 --> 00:03:05,520
Bây giờ thì thế nào, cấu trúc có thể được biểu diễn bằng một mảng đơn giản. Cấu trúc này có thể được biểu diễn bằng một mảng đơn giản, đại loại như thế này. ĐƯỢC RỒI. Chúng ta có ở đây không không một A. không một hai.

4898
00:03:05,940 --> 00:03:20,880
Làm thế nào nó được thể hiện, chúng tôi có số không. Vậy cha của số 0 là số 0. ĐƯỢC RỒI. Đó là những gì chúng ta có bằng không. Bây giờ ở đây là một, chúng ta thấy rằng cha mẹ của một bằng 0 và khôi phục cha mẹ của một ở đây.

4899
00:03:21,270 --> 00:03:33,300
ĐƯỢC RỒI. Và ở đây chúng tôi đang lưu trữ một. Một người là cha mẹ của hai người. Vì vậy, chúng tôi đang lưu trữ ở đây. Một. Vậy một người là cha mẹ của hai người. Zero là cha mẹ của một thực thể. Là cha mẹ của số không.

4900
00:03:33,660 --> 00:03:44,640
Bây giờ làm thế nào để tìm cha mẹ tuyệt đối của hai. Để tìm cha mẹ tuyệt đối của hai, trước tiên bạn chuyển sang chỉ mục một. Tại Index một, chúng ta có giá trị bằng 0.

4901
00:03:44,820 --> 00:03:59,730
Bây giờ hãy chuyển sang chỉ số 0 và tại chỉ mục chúng ta có số 0. Và chúng ta thấy rằng đây là nút cha tuyệt đối của nút này. Hai. ĐƯỢC RỒI. Ở đây chúng ta có thể coi phần tử đó như trong node.

4902
00:04:01,380 --> 00:04:19,470
Vì vậy, cấu trúc này được thể hiện như thế này. Chúng ta có thể có nhiều cấu trúc khác nhau để biểu diễn một tập hợp. Đây là một biểu diễn hợp lệ của khớp phù hợp với cấu trúc của tập hợp này, trong đó có ba phần tử.

4903
00:04:19,650 --> 00:04:31,950
Bạn không muốn. Đây là cách bộ khớp thể hiện nó bằng cách sử dụng một mảng đơn giản? Bây giờ chúng ta hãy xem biểu diễn của cấu trúc này. Đây là sự đại diện của cấu trúc này.

4904
00:04:32,160 --> 00:04:41,340
Cha của số 0 bằng 0, cha của một bằng 0. Cha mẹ lên tới bằng không. Điều này thật đơn giản ngay bây giờ. Biểu hiện của cấu trúc này là gì?

4905
00:04:41,790 --> 00:04:58,350
Đại diện cho cấu trúc này là gì? Đây là sự đại diện của cấu trúc này. Ở đây chúng ta thấy rằng cha của số 0 là hai và cha của một là một, và cha của hai là một.

4906
00:04:59,280 --> 00:05:19,080
Đây là một cấu trúc nói việc cần làm hợp lệ, rời rạc. Vậy chúng ta có thể biểu diễn tập hợp này như thế này. Oregon đại diện cho một cái gì đó như thế này hoặc chúng ta có thể đại diện cho một cái gì đó như thế này và chúng ta có thể có nhiều cách khác nhau để thể hiện sự khác biệt trong quá trình triển khai của mình.

4907
00:05:19,830 --> 00:05:36,000
Vì vậy, đây là một biểu diễn đơn giản của bộ khớp trong cấu trúc. Bây giờ hãy xem cách biểu diễn của set. Được rồi, bây giờ chúng ta sẽ nói về cách biểu diễn hai tập hợp, chúng ta có tập hợp này là một.

4908
00:05:36,240 --> 00:05:56,820
Bạn biết đấy, một hai và đã đặt là hai ba, bốn năm. Làm cách nào để thiết lập điều này bằng cách sử dụng một Ari? Hãy xem. Làm cách nào để thiết lập điều này bằng cách sử dụng một Ari và chúng tôi đã thực hiện hai thao tác này để thực hiện thao tác tìm phân vùng, hoạt động chống liên kết bằng thao tác tìm này.

4909
00:05:57,000 --> 00:06:14,010
Chúng tôi sẽ kiểm tra hai và năm của chúng tôi trong cùng một bộ. Và sử dụng thao tác hợp này sẽ hợp nhất thành tập S1 và S2. Hãy xem cách chúng ta có thể biểu diễn hai tập hợp này bằng cách sử dụng tập hợp chung trong một cấu trúc.

4910
00:06:14,910 --> 00:06:27,780
Đây là cộng đồng của chúng ta, được chứ? Tất cả điều này được đưa ra tại buổi điều trần về chỉ số, và ở đây chúng tôi đang lưu trữ giá trị của anh ấy ở đây tại chỉ số 0.0. Tại chỉ số một, chúng ta có một đầu ở chỉ số hai.

4911
00:06:27,780 --> 00:06:40,680
Chúng ta phải thêm chỉ số hai vào ba ở mức thiếu kinh nghiệm, bốn ở chỉ số năm chúng ta có năm. Điều này có nghĩa là gì khi bạn có chỉ mục và giá trị giống nhau?

4912
00:06:41,040 --> 00:06:58,440
Nó có nghĩa là phần tử rời rạc nói, OK, chính là nó. Các khớp ngồi ở đây. Chúng tôi có tổng cộng năm, bộ chung. Chúng ta phải xây dựng một tập hợp có ba phần tử này.

4913
00:06:58,500 --> 00:07:12,120
Không một hai. Và sau đó chúng ta phải xây dựng tập hợp này bằng cách sử dụng ba phần tử ba bốn năm. Làm thế nào để làm điều này? OK, bây giờ ở đây chúng ta có tập hợp riêng lẻ hoặc riêng biệt.

4914
00:07:12,600 --> 00:07:28,260
Tất cả các bộ phần bổ sung chúng tôi có ở đây. 2.6 tập số không một hai ba bốn năm trong khu vực này chúng ta có tổng cộng sáu tập hợp không một hai ba bốn năm. Bây giờ hãy xây dựng một tập hợp cho tập hợp này là một.

4915
00:07:29,070 --> 00:07:43,830
Đầu tiên, hãy tham gia cùng chúng tôi thông qua tập hợp số 0 và một cho điều đó. Những gì tôi sẽ làm sẽ thay thế cái này bằng số không. Hãy thay cái này bằng số 0. Vì vậy, ở đây nó có nghĩa là cha của số 0 bằng 0.

4916
00:07:44,310 --> 00:08:01,980
Cha mẹ của một người bằng không. Được rồi, vậy cha của một bằng không. Bây giờ chúng tôi có bộ này trong khu vực này. Bây giờ chúng ta có tổng cộng năm, bộ chung. Bây giờ chúng ta cùng tham gia để kết thúc bộ này nhé.

4917
00:08:02,130 --> 00:08:16,050
Được rồi, chúng ta đã có hai người tham gia vào bộ này. Vậy điều tôi sẽ làm ở đây là chúng ta sẽ thay thế hai cái này bằng một. Vì vậy, ở đây, hãy thêm một. Nó có nghĩa là cha mẹ của hai người là một.

4918
00:08:16,350 --> 00:08:30,870
Vì vậy chúng ta hãy tuân thủ. Vậy chúng ta có được tập hợp này, vậy chúng ta có được cái này đã nối nó. Bây giờ trong lĩnh vực này, chúng tôi có tổng số cho bộ khớp. Đây là một bộ. Bây giờ hãy xây dựng bộ này.

4919
00:08:32,010 --> 00:08:43,230
Bây giờ chúng ta hãy nối phần này để đặt ở đây ba và bốn cho điều đó. Những gì tôi sẽ làm sẽ thay thế bốn bằng ba. Vì vậy, ba là. Cha mẹ ở đây là cha mẹ của bốn đứa con.

4920
00:08:43,800 --> 00:08:56,670
Và ở đây chúng ta thấy đó là cha mẹ của ba đứa trẻ bây giờ. Chúng ta hãy nối bộ năm này vào bộ này. Nếu chúng tôi muốn tham gia vào bộ này thì bạn phải làm gì? Chúng tôi sẽ chỉ thay thế quyền này bằng.

4921
00:08:56,670 --> 00:09:16,050
Bây giờ ở đây chúng ta sẽ thêm năm. Vì vậy, đây là bộ của chúng tôi. Vì vậy trong lưu ý này, chúng ta phải thiết kế nó. Bây giờ chúng ta hãy tìm hiểu. Hai và năm là hai và năm trong cùng một bộ của hai.

4922
00:09:16,200 --> 00:09:27,720
Chúng tôi thấy ở đây chúng tôi có một đối một. Chúng ta có số không bốn. Bạn có biết chúng tôi có ở đây không? Không. Vậy cha mẹ tuyệt đối đang làm gì? Cha mẹ kiêng cữ của hai người bằng không.

4923
00:09:28,680 --> 00:09:42,480
Bây giờ chúng ta hãy tìm ra điều tuyệt vời nhất trong năm điều. Cái. Cha của năm là bốn, vậy cha của bốn là ba. Cha của ba là ba, nên ba là cha tuyệt đối của năm.

4924
00:09:42,840 --> 00:10:03,450
Vì vậy, chúng ta thấy rằng cha mẹ tuyệt đối của năm là ba và cha mẹ vắng mặt của hai là bằng không. Chúng tôi thấy ban nhạc tuyệt đối là khác nhau. Vì vậy, hai và năm không nằm trong cùng một bộ, vì vậy nó sẽ trả về sai hai và năm, nó chỉ nằm trong bộ khác.

4925
00:10:03,990 --> 00:10:17,920
Bây giờ hãy thực hiện thao tác này. Bây giờ hãy hợp nhất tài sản này với tài sản S1 và S2. Làm thế nào để hợp nhất hai bộ này. Được rồi, nếu chúng ta hợp nhất hai tập hợp này thì điều gì sẽ xảy ra?

4926
00:10:18,460 --> 00:10:31,650
Chúng ta sẽ có một lộ trình tuyệt đối để hợp nhất điều này thành tập hợp. Những gì tôi sẽ làm, trước tiên chúng ta sẽ tìm thấy nó là cha mẹ tuyệt đối trong tập hợp này và cha mẹ tuyệt đối trong tập hợp này.

4927
00:10:31,920 --> 00:10:43,140
Cha mẹ tuyệt đối trong tập hợp này bằng 0. Cha mẹ tuyệt đối trong tập hợp này là ba. Bây giờ điều tôi sắp làm là thay thế cha mẹ tuyệt đối ba này bằng số không.

4928
00:10:43,950 --> 00:10:53,100
Vì vậy, chúng tôi đã kết nối điều này và nói điều gì đó như thế này. Bây giờ chúng ta có ở đây một cha mẹ tuyệt đối bằng 0. Vì vậy, hãy tìm ra cha mẹ tuyệt đối của nút này. Bốn.

4929
00:10:53,460 --> 00:11:03,480
Vì vậy, hãy tìm điểm tuyệt đối của nút này đối với cha mẹ của ngành lâm nghiệp, cha mẹ của cây zero zero zero. Vì vậy, nếu tìm thấy cha mẹ tuyệt đối ở đây.

4930
00:11:03,630 --> 00:11:13,020
Vậy số 0 là cha tuyệt đối của bốn. Cha mẹ tuyệt đối của năm là gì? Cha mẹ của năm là cha của bốn là ba. Cha mẹ của ba bằng không.

4931
00:11:13,200 --> 00:11:26,430
Cha mẹ của số 0 là số 0 số 0 là cha mẹ tuyệt đối ở đây. Vì vậy, chúng tôi hợp nhất điều này để thiết lập một cái gì đó như thế này. Chúng tôi chỉ hợp nhất cha mẹ tuyệt đối cho cả hai bộ.

4932
00:11:26,820 --> 00:11:37,710
Nghĩa là nó nổi lên hai tập. Đây được gọi là hoạt động công đoàn. Chúng tôi chỉ đang hành quân để hợp thành một và chúng tôi đang thực hiện tất cả các hoạt động trong lĩnh vực này.

4933
00:11:37,770 --> 00:11:49,230
Đây chỉ là một biểu diễn logic và đây được gọi là những điều cơ bản đã được thực hiện một tập hợp chung. Bây giờ hãy xem cách phát hiện một chu trình bằng cách sử dụng tập hợp khớp cho cấu trúc.

4934
00:11:49,860 --> 00:12:06,000
Bây giờ chúng ta sẽ nói về cách phát hiện chu trình trong việc phát hiện chu trình đồ thị vô hướng chỉ hoạt động trong đồ thị vô hướng cho tập hợp. Chúng ta không thể sử dụng tập hợp để dự đoán chu trình trong đồ thị có hướng.

4935
00:12:06,300 --> 00:12:19,340
Hãy cùng xem hai người được trao tuổi này như thế nào nhé. Và ở đây chúng ta có tuổi, được rồi, chúng ta phải phát hiện xem chúng ta có chu kỳ hay không. Ở đây chúng tôi có mảng này. Đây là sự rời rạc của chúng tôi nói.

4936
00:12:19,350 --> 00:12:33,930
Nó có một cấu trúc. Đây đã là cấu trúc rồi. Chúng tôi đang triển khai bộ khớp bằng cách sử dụng Arrietty để cấu trúc. Chúng ta hãy xem làm thế nào chữ số có thể xoay vòng một biểu đồ được đánh giá thấp đầu tiên ba, 0 và một trong khu vực này có trạng thái chung là 0 một hai ba?

4937
00:12:34,320 --> 00:12:50,910
Chúng ta có số 0 và một điểm tuyệt đối của số 0 mà các cậu bé gấu trúc tuyệt đối mong muốn. Họ khác nhau. Vì vậy, hãy kết nối điều này với chính trị bằng chữ h. Bây giờ hãy thực hiện phép toán hợp cho tập hợp 0 ​​và 1.

4938
00:12:51,420 --> 00:13:03,010
Bây giờ điều tôi sắp làm là thay cái này bằng số 0. Cha mẹ của một người bằng không. Ở đây, cha mẹ của một bằng không. Một cái gì đó như thế này.

4939
00:13:03,510 --> 00:13:16,230
Đây là cha mẹ. Và đây là một. Bây giờ hãy xử lý. Tiếp theo là đây là thời đại hỗn hợp Châu Âu số 0 và số 3 của chúng ta. Cha mẹ tuyệt đối của 0 0, cha mẹ vắng mặt của 3 là 3.

4940
00:13:16,290 --> 00:13:32,700
Vì vậy, họ khác nhau. Ở đây chúng ta thấy rằng chúng ta có hai tập hợp riêng biệt số 0 ràng buộc tuyệt đối số 0 dải cây tuyệt đối. Ba. Vì vậy, chúng tôi sẽ kết nối cái này với Vertex vì chúng tôi thấy nó có hai cha mẹ tuyệt đối khác nhau.

4941
00:13:33,300 --> 00:13:46,860
Bây giờ hãy kết nối cái này với bộ chung Châu Âu. Không A. ba. Vậy số 0 ngẫu nhiên tuyệt đối, số 0 tuyệt đối, dải tuyệt đối của ba là ba. Vì vậy chúng ta sẽ thay thế cây này bằng 0.

4942
00:13:48,120 --> 00:13:59,490
Vậy ở đây họ đang làm gì? Chúng tôi chỉ đang thiết lập số lượng tuyệt đối là ba. Vì vậy, ở đây chúng tôi có ba. Cha mẹ của ba số không, tiền boa cha mẹ trên bằng không.

4943
00:14:00,030 --> 00:14:10,950
Quyền tuyệt đối của cây là bằng không. Bây giờ chúng ta có độ tuổi này là hai tuổi và ba tuổi cho hai người. Chúng ta thấy thương hiệu tuyệt đối là hai bốn ba. Thương hiệu tuyệt đối là số không.

4944
00:14:11,130 --> 00:14:23,040
Vậy ta tìm được hai cha mẹ tuyệt đối khác nhau và số không. Vậy chúng ta sẽ làm gì? Chúng ta sẽ kết nối hai và ba. Vì vậy, hãy kết nối hai phán quyết này với một độ tuổi.

4945
00:14:23,640 --> 00:14:34,560
Bây giờ phán quyết này, OK, bạn đã hiểu điều đó. Hãy thực hiện một hoạt động công đoàn cho hai và ba. Vậy hãy đậu xe từ đây nhé, bạn biết không? Vậy hãy đậu xe từ đây nhé. Hoạt động công đoàn.

4946
00:14:34,860 --> 00:14:46,080
Vì vậy, ở đây, cập nhật cái này cho nó. Ba. Vậy ở đây chúng ta có gốc của hai là ba. Vậy ở đây chúng ta thấy rằng cha của hai là ba. Bây giờ chúng ta hãy chuyển sang giai đoạn tiếp theo.

4947
00:14:46,110 --> 00:14:59,190
Đây là tiếp theo của chúng tôi nó. Chúng ta có một điểm tuyệt đối là 1 bằng 0. Châu Âu bằng không. Và cha mẹ của số không không. Vì vậy, ở đây bạn tìm thấy nó. Cha mẹ tuyệt đối của cha mẹ trung giới bằng không đối với một và đối với hai.

4948
00:14:59,850 --> 00:15:11,760
Đó là một đến ba, cha mẹ của ba số không và số không không. Vậy sự vắng mặt của cha mẹ lên tới bằng không. Chúng tôi phát hiện ra cha mẹ tuyệt đối của một và cha mẹ tuyệt đối của hai không giống nhau.

4949
00:15:11,980 --> 00:15:24,930
Vì vậy, chúng tôi tìm thấy nó là chu kỳ ở đây. Chúng tôi thấy rằng nếu chúng tôi kết nối thì chúng tôi sẽ có một chu kỳ ở đây. Đây là cách chúng ta có thể phát hiện chu trình trong đồ thị vô hướng bằng cách sử dụng tập hợp.

4950
00:15:25,410 --> 00:15:36,720
Bây giờ chúng ta có thể tối ưu hóa độ phức tạp thời gian từ độ phức tạp thời gian tuyến tính đến logarit để triển khai đơn giản SUJATA chung thành cấu trúc, tất cả đều cần độ phức tạp thời gian tuyến tính.

4951
00:15:37,620 --> 00:15:53,430
Điều đó có nghĩa là tất cả đều có độ phức tạp lớn về thời gian và số lượng phần tử trong mảng của chúng ta. Bây giờ làm thế nào chúng ta tối ưu hóa tuyến tính này thành logarit, hãy xem bây giờ chúng ta sẽ sử dụng tính năng nén một phần.

4952
00:15:53,820 --> 00:16:08,490
Hãy xem cách biểu diễn tập hợp chung. Chúng tôi đang sử dụng mối quan hệ cha mẹ và con cái. OK, bây giờ chúng ta sẽ tạo một vùng gồm các nút. Nút này sẽ có hai phần mẹ và Iraq.

4953
00:16:08,700 --> 00:16:20,370
Hãy xem khu vực này của chúng ta thế nào, được chứ? Ở đây chúng ta có cha mẹ và hạng bốn là chỉ mục. Chúng tôi có cha mẹ và xếp hạng ban đầu bằng không. Chúng ta sẽ xem thứ hạng là gì.

4954
00:16:21,150 --> 00:16:35,100
Và ở đây cha mẹ bằng không. Cha mẹ ban đầu có nghĩa là cha mẹ của số 0 không bị ràng buộc bởi một. Và vân vân. Ở đây chúng tôi có tổng cộng sáu bộ riêng biệt. Điều đó có nghĩa là chúng ta có tập rời rạc 2,6.

4955
00:16:36,300 --> 00:16:54,930
Bây giờ chúng ta sẽ kết nối nó với tập 0 và 1. OK, hãy kết nối tất cả các thông số để vận hành. Tìm hoạt động và hoạt động công đoàn đầu tiên. Bây giờ chúng ta hãy biểu diễn điều này để đặt S1 và S2 bằng cách sử dụng diện tích mà chúng ta có ở đây.

4956
00:16:55,380 --> 00:17:07,560
Chỉ số bằng không. Được rồi, và đến đây vào lúc một giờ. Bây giờ bạn định làm gì? Chúng ta có thể kết nối theo cách này hoặc có thể kết nối theo cách này vì chúng ta có thứ hạng sim. Ở đây chúng tôi không có.

4957
00:17:07,590 --> 00:17:23,100
Ở đây chúng tôi không có. Chúng ta sẽ chuyển từ cấp bậc thấp hơn lên cấp bậc cao hơn. Nếu chúng ta nhìn thấy thứ hạng của SIM thì chúng ta sẽ di chuyển theo các hướng năng lượng. Bây giờ điều tôi sắp làm là phát lại số 0 này.

4958
00:17:24,000 --> 00:17:35,160
Vì vậy, ở đây tôi sẽ thay thế cái này bằng số 0. Và tôi sẽ tăng thứ hạng này để nó có thể đi theo hướng mà tôi sẽ đi từ đây đến đây hoặc từ đây đến đây.

4959
00:17:35,550 --> 00:17:51,630
Bây giờ ở đây tôi sẽ chuyển từ 1 về 0. ĐƯỢC RỒI. Theo hướng này. Vì vậy điều tôi sắp làm bây giờ là thay số 1 bằng số 0. Và chúng ta sẽ thay số 0 bằng một điểm thay số 0 bằng một.

4960
00:17:52,230 --> 00:18:07,770
Nó có nghĩa là chúng ta chỉ tăng thứ hạng từ 0 lên 1 vì ở đây chúng ta có cùng thứ hạng. Ở đây chúng tôi đang tăng thứ hạng lên một bởi vì ở đây, bạn biết đấy, là cha mẹ tuyệt đối của một.

4961
00:18:08,730 --> 00:18:25,230
Vì vậy, cha mẹ tuyệt đối lên một bằng không. Nếu bạn muốn kết hợp một bộ khác với bộ này, thì tất cả Sao Hỏa, nguồn gốc tuyệt đối của các bữa ăn sẽ được đặt thành phần phụ thuộc tuyệt đối của bộ này từ cấp thấp hơn đến cấp cao hơn.

4962
00:18:25,380 --> 00:18:36,600
Hãy xem làm thế nào. Bây giờ chúng ta hãy kết nối hai cái với câu nói này, OK, vậy chúng ta sẽ tới Sao Hỏa. Hai người này ở đây chỉ đang thực hiện hoạt động liên minh. OK, bây giờ chúng ta hãy di chuyển cái này để thực hiện bộ này.

4963
00:18:37,050 --> 00:18:47,460
Vì vậy, ở đây chúng ta thấy rằng chúng ta có hạng 0 ở hạng một. Dải tuyệt đối tuyệt đối lên đến điểm tuyệt đối bằng 0. Vì vậy, chúng ta sẽ kết nối hai cái này với số 0 này.

4964
00:18:48,020 --> 00:18:59,900
Vì vậy, nó đại diện cho một cái gì đó như số 0 này và số 1 ở đây. Được rồi, bây giờ sau thời điểm đó, giá trị tăng lên bằng 0. OK, vậy chúng ta sẽ tiến tới cấp độ gốc tuyệt đối. Đó là sự thật.

4965
00:18:59,900 --> 00:19:13,460
Đạt được thiên đường tuyệt đối là tuyệt đối. Nhưng ở đây, chúng ta sẽ thay cái này thành số 0. Vì vậy, ở đây chúng ta sẽ phải làm vậy. Vì vậy, chúng tôi đại diện cho công dân này trong lĩnh vực này và hãy đại diện cho nhóm này.

4966
00:19:13,940 --> 00:19:28,790
Đầu tiên, chúng ta có ở đây ba và bốn. Vậy hãy chuyển cái này sang tập hợp ba và bốn. Chúng tôi có thứ hạng tương tự của bạn. Vậy chúng ta sẽ chuyển từ bốn lên ba. Vì vậy ở đây sẽ tăng thứ hạng ở đây.

4967
00:19:28,820 --> 00:19:41,240
Ba là cha mẹ tuyệt đối của chúng tôi. Vậy hãy thay bốn bằng ba. Bây giờ hãy là ngày 5 tháng 3. Đó là một điểm hay của bộ này là ba. Vì vậy, hãy hợp nhất. Nó là một cái gì đó như thế này.

4968
00:19:41,240 --> 00:19:54,440
Ở đây sẽ thay thế năm cái này bằng ba. Cha mẹ tuyệt đối của năm là ba. Nó đại diện cho cái gì đó giống như ba ở đây bốn và ở bên này là năm.

4969
00:19:55,760 --> 00:20:10,730
Vì vậy, đây là đại diện thiết lập của chúng tôi. Đây là những gì chúng ta có thể đại diện là thiết lập việc sử dụng khu vực này trong khu vực này. Chúng tôi đang lưu trữ trong nút ở mọi chỉ mục mà nút đó phải gán cha mẹ và xếp hạng.

4970
00:20:11,870 --> 00:20:30,240
Bây giờ chúng tôi muốn hợp nhất cái này để đặt ở đây. Chúng tôi muốn sao Hỏa thảo luận về nó. Ngoài ra, hãy tìm nó. Hoạt động này là hai và năm trong cùng một bộ. Khi bạn biểu diễn hai bộ này cho bộ này và bộ hai, bây giờ chúng ta hãy bắt đầu vận hành nhà máy này tại đây.

4971
00:20:30,240 --> 00:20:39,200
Tôi có câu hỏi này ở giờ thứ hai và thứ năm trong cùng một bộ. Hai cho hai. Hãy tìm nó là cha mẹ tuyệt đối của năm 2020 không bốn năm. Cha mẹ tuyệt đối là ba.

4972
00:20:39,680 --> 00:20:49,670
Bây giờ chúng ta sẽ làm gì? Chúng ta sẽ lấy cha mẹ tuyệt đối. Cha mẹ riêng biệt là khác nhau, vì vậy chúng tôi không ở cùng một bộ. Ta thấy cha mẹ tuyệt đối cũng tương tự.

4973
00:20:49,850 --> 00:21:01,700
Nghĩa là hai cái nó chỉ có trong sim đó. Nhưng trong quá trình nó khác nhau, vì bạn thấy nó khác biệt. Cha mẹ tuyệt đối. Không, hãy hợp nhất cái này để thiết lập trật tự cho sao Hỏa.

4974
00:21:01,700 --> 00:21:10,700
Điều này giúp chúng ta tìm ra cha mẹ tuyệt đối, cha mẹ tuyệt đối cho thành phố số 0 này, cha mẹ tuyệt đối cho trạng thái này là ba. Vì vậy, hãy kết nối cha mẹ khẳng định ở đây.

4975
00:21:10,820 --> 00:21:22,100
Chúng ta thấy thứ hạng giống nhau nên có thể kết nối từ hai đến 0 hoặc từ 0 đến ba. Nó được kết nối với một cái gì đó như thế này. Vì vậy, điều tôi sẽ làm ở đây là thay thế cây này bằng số 0.

4976
00:21:22,730 --> 00:21:36,080
Vì vậy, điều tốt nhất tuyệt đối của ba số không. Chúng ta thấy điều đó ở ba điều đầu tiên. Cha mẹ tuyệt đối là gì? Vì vậy, Panda bốn là ba điểm của ba số không và cha mẹ của số không không không là cha mẹ tuyệt đối.

4977
00:21:36,610 --> 00:21:50,780
Bốn năm. Cha mẹ của năm là ba, cha mẹ của cây số 0, dải số 0. Vậy sau cha của năm bằng 0. Vì vậy, bạn đang ở đây, tiêu diệt cha mẹ tuyệt đối hoặc tiêu diệt cha mẹ tuyệt đối.

4978
00:21:51,170 --> 00:22:03,470
Đó có thể là công ty mẹ tuyệt đối, có thể là công ty mẹ tuyệt đối hoặc có thể không phải là công ty mẹ tuyệt đối ở đây hoặc một ngành chỉ là công ty mẹ tuyệt đối. Chúng ta có thể hoặc không thể quản lý cha mẹ tuyệt đối.

4979
00:22:03,710 --> 00:22:18,010
Chúng tôi có thể lưu trữ cha mẹ OK. Đây là cách chúng ta có thể biểu diễn lần lượt bằng cách sử dụng biểu diễn của mình. Ở đây, một nút chuỗi ở mọi chỉ mục. Và ở đây chúng tôi chỉ đang di chuyển.

4980
00:22:18,110 --> 00:22:35,650
Được rồi, vậy là bạn đã xác định được số 0 khi bạn tìm ra số 0. Chúng tôi sẽ cập nhật cây gốc bằng 0. ĐƯỢC RỒI. Và đó được gọi là nén đường dẫn. Nếu bạn muốn tìm điểm tuyệt đối của số năm thì hãy dùng cây ba và cây bốn.

4981
00:22:35,660 --> 00:22:49,370
Chúng ta thấy rằng ở đây chúng ta có số không. Nhưng bạn thì không. Chúng tôi không có. Vì vậy, bạn tìm thấy cha mẹ tuyệt đối này và chúng tôi sẽ thay thế giá trị này bằng 0. Nó có nghĩa là chúng ta tìm ra cha mẹ tuyệt đối ở đây.

4982
00:22:49,850 --> 00:23:02,180
Vì vậy chúng tôi đang giảm bớt. Chúng tôi đang giảm bớt. Và điều này được gọi là hoàn thành con đường. Đừng lo lắng về điều đó. Hiểu được điều này, tôi thực sự khuyến khích bạn kiểm tra mã nguồn.

4983
00:23:02,750 --> 00:23:15,980
Bạn sẽ thấy hoàn thành đường dẫn là gì? Bây giờ chúng ta hãy xem. Làm thế nào nó quay vòng bằng cách sử dụng cách biểu diễn này, sử dụng kiểu biểu diễn này của tập hợp? Giả sử chúng ta có năm độ tuổi này.

4984
00:23:16,640 --> 00:23:30,770
Và ở đây chúng ta có năm Vertex. OK, bây giờ đây là phần chuyển đổi rời rạc của chúng ta sang cấu trúc. Đối với điều này, chúng ta thấy số 0 và một ở đó có số 0 và một gốc tuyệt đối khác nhau.

4985
00:23:30,800 --> 00:23:42,920
Vì vậy, hãy kết nối chúng ngay bây giờ. Hãy để sao Hỏa không và một. Vì vậy điều tôi sắp làm ở đây là tôi sẽ thay cái này bằng số 0. Vì vậy, dải tuyệt đối bằng không.

4986
00:23:43,190 --> 00:23:52,710
Vì vậy, hãy tăng thứ hạng này từ 0 lên một. Bây giờ cái này. Hai và ba, cha mẹ tuyệt đối của hai là hai thương hiệu tuyệt đối của cây. Ba, chúng khác nhau.

4987
00:23:52,890 --> 00:24:07,900
Vì vậy, hãy hợp nhất thành một cái cây. Bây giờ ở đây chúng ta thấy rằng chúng ta có tập hợp hai và ba. Hãy M.B. Chúng tôi muốn hợp nhất chúng, sẽ thay thế cây này bằng hai cây và sẽ tăng lên.

4988
00:24:07,920 --> 00:24:19,040
Điều này sẽ tăng điều này từ 0 lên một. ĐƯỢC RỒI. Bây giờ đây là độ tuổi một và hai tiếp theo của chúng tôi. Điểm tuyệt đối của một là bằng không. Điểm tuyệt đối của hai là hai.

4989
00:24:19,230 --> 00:24:32,820
Vì vậy, họ khác nhau. Vì vậy, hãy hợp nhất một và hai. Và bây giờ chúng ta hãy hành quân tới đây. Được rồi, hãy gọi hàm miễn dịch hoặc phương pháp miễn dịch cho cái này là đặt 0 một và đặt này là 2.

4990
00:24:33,330 --> 00:24:42,990
Được rồi, chúng ta đã đặt cái này lên sao Hỏa. Điều này đối với điểm tuyệt đối của hai là hai cha mẹ tuyệt đối của một bằng không. Vì vậy, chúng ta hãy nắm lấy điều này. Chúng tôi sẽ thay thế cái này bằng nó.

4991
00:24:43,080 --> 00:24:55,620
Không. Vì vậy, chúng ta có thể cần nó ngay bây giờ cho số 8, 0 và 4 này. Thương hiệu tuyệt đối không không. Điểm tuyệt đối của bốn là bốn. Vì vậy, họ khác nhau. Vì vậy, hãy sao Hỏa số 0 và số 4.

4992
00:24:56,070 --> 00:25:13,140
Vì vậy, hãy thay thế cái này bằng số không. ĐƯỢC RỒI. Bởi vì nó có kết nối cấp thấp hơn từ đây đến đây. Vì vậy, khi bạn đặt điểm 0 này bây giờ là bốn, bốn và ba, chúng ta thấy rằng dải tuyệt đối là bốn là dải tuyệt đối của cây.

4993
00:25:14,460 --> 00:25:26,100
Ở đây chúng ta phải làm vậy. Cha của ba bằng cha của hai bằng 0 không 0. Vậy dải tuyệt đối của ba là 0 và dải tuyệt đối là bốn không.

4994
00:25:26,340 --> 00:25:39,480
Vì vậy, chúng tôi thấy rằng ban nhạc tuyệt đối là như nhau. Vì vậy, nếu chúng ta cộng tám, ba và bốn này, nó sẽ tạo thành một chu trình. Vì vậy, chúng tôi tìm thấy nó một chu kỳ ở đây. Đây là những gì chúng ta có thể phát hiện một đồ thị vô hướng đơn vị chu trình.

4995
00:25:39,930 --> 00:25:51,570
Phương pháp này chỉ áp dụng được cho đồ thị có hướng vì trong đồ thị có hướng, chúng ta không thể di chuyển lùi và tiến. Đó là cách chúng ta có thể phát hiện chu trình trong đồ thị vô hướng bằng cấu trúc dữ liệu chung.

4996
00:25:51,960 --> 00:26:06,510
Ở đây chúng ta thấy rằng chúng ta thấy dải cây tuyệt đối bằng không. Nhưng ở đây chúng ta có hai cái rất khó hiểu với số 0 và cái đó được gọi là nén đường dẫn và chúng ta sẽ xem cách thực hiện điều này trong mã nguồn.

4997
00:26:07,140 --> 00:26:19,860
Hy vọng bạn hiểu rằng City đã cấu trúc ở mức rất cao cho thuật toán tội lỗi của Chris. Bạn phải
hiểu thành phố chung, cấu trúc trong câu chuyện tiếp theo mà chúng ta sẽ nói về cách tìm ra nó. 

@@@



4998
00:00:00,840 --> 00:00:09,300
Này, rất nhiều bạn. Chào mừng bạn quay lại với video này. Trong video này, chúng ta sẽ nói về cuộc thi patin ở video trước. Chúng ta đã nói về việc cạnh tranh pat.

4999
00:00:09,570 --> 00:00:22,050
Bây giờ chúng ta hãy nói chi tiết về cuộc thi pat trong video này tại đây. Hãy bắt đầu với bạn. Bạn muốn tìm ra nguồn gốc tuyệt đối của Note 5? ĐƯỢC RỒI.

5000
00:00:22,320 --> 00:00:38,940
Và ở đây chúng ta có cấu trúc của tập hợp rời rạc này để tìm cha mẹ tuyệt đối của ghi chú này. Năm. Chúng ta phải tìm ra nó là cha mẹ, cha mẹ của năm là ba.

5001
00:00:39,990 --> 00:00:54,690
Ba không phải là cha mẹ của năm. Vì vậy, hãy chuyển sang Note ba, cha của ba số 0 và cha của số 0, vậy chúng ta thấy rằng số 0 là cha tuyệt đối của số năm.

5002
00:00:55,380 --> 00:01:11,610
Bây giờ những gì nó sẽ làm sẽ thay thế số 0 này. Nhưng đây này, chúng ta đã có số 0 rồi. Được rồi, bây giờ chúng ta hãy chuyển sang ba ở đây. Được rồi, bây giờ tôi sẽ làm gì đây.

5003
00:01:11,790 --> 00:01:25,120
Tôi sẽ thay thế cây này bằng số 0. Được rồi, hãy thay cây này bằng 0. Bây giờ ở đây chúng ta có cây này. Được rồi, bây giờ trong cấu trúc này, bạn sẽ làm gì?

5004
00:01:25,150 --> 00:01:46,640
Chúng ta sẽ thảo luận về điều này. Chúng ta sẽ kết nối số năm này trực tiếp với số không này. ĐƯỢC RỒI. Vì vậy, bây giờ chúng ta có thể tìm thấy nó năm trong thời gian không đổi nếu chúng ta muốn tìm ra cha tuyệt đối của bốn, trước tiên hãy tìm cây định kiến ​​biểu kiến ​​và cha của ba số không a. không.

5005
00:01:46,660 --> 00:02:00,460
Được rồi, chúng ta hãy xem lại số 0 này và sau đó thay cây này bằng số 0. Hãy thay cây này bằng số 0. Vậy điểm tuyệt đối của 4 bằng 0 dẫn tới mất kết nối.

5006
00:02:00,730 --> 00:02:16,780
Hãy tiến tới số không. Ở đây chúng ta thấy rằng bốn kết nối trực tiếp với số không. Vì vậy chúng ta có thể thoát khỏi bốn năm trong thời gian không đổi. Đây được gọi là nén đệm, vì vậy chúng tôi đã giảm Pap.

5007
00:02:18,070 --> 00:02:35,300
Chúng ta có thể tìm ra nó trong thời gian không đổi. Đây được gọi là cạnh tranh pat. Hy vọng bạn đã hiểu pat hiểu là gì?
Thật vậy, John đã nói với cấu trúc khi anh ấy thực hiện thao tác cuối cùng, thì chúng ta sẽ giảm bớt phần pat như thế này. 

@@@



5008
00:00:00,540 --> 00:00:17,700
Xin chào các bạn, chào mừng các bạn quay trở lại với video này trong video này hoặc sẽ nói về thuật toán Chris Kelts. Bây giờ chúng ta hãy xem làm thế nào để tìm thấy nó. Cây bao trùm tối thiểu sử dụng thuật toán tội lỗi bị nghiền nát Thuật toán kỹ năng tốt tìm thấy cây bao trùm tối thiểu cho đồ thị rừng, vô hướng.

5009
00:00:18,240 --> 00:00:57,380
Đó là một thuật toán tham lam trong lý thuyết đồ thị, giống như Esteve. Nó bổ sung hỗ trợ CNTT thấp nhất tiếp theo sẽ không tạo thành chu trình vào cây bao trùm tối thiểu. Đây là định nghĩa chính thức của thuật toán này, bạn được cung cấp biểu đồ được đánh giá thấp có trọng số này, bạn phải tìm nó bao trùm bạn ở mức tối thiểu từ biểu đồ này mà các bước triển khai thuật toán Crossgates như sau Sắp xếp mọi lứa tuổi, sắp xếp mọi lứa tuổi từ mức lương thấp đến trọng số cao thì lấy tuổi có trọng số thấp nhất cộng vào cây chi tiêu.

5010
00:00:57,620 --> 00:01:10,680
Nếu thêm chu kỳ phân loại độ tuổi thì hãy từ chối độ tuổi này. Chúng tôi có thể phát hiện tâm lý bằng cách sử dụng cấu trúc dữ liệu chung, vì vậy chúng tôi sẽ áp dụng ở đây. Bác sĩ này phẫu thuật khớp để tìm chu kỳ.

5011
00:01:10,700 --> 00:01:24,980
Nếu bạn thấy đó là chu kỳ thì nó sẽ từ chối độ tuổi đó và tiếp tục thêm độ tuổi cho đến khi chúng ta đến được với tất cả các bên. Đây là thuật toán. Được rồi, đây là thuật toán Cross Kelts.

5012
00:01:25,670 --> 00:01:38,420
Bây giờ hãy xem nó hoạt động như thế nào. Giả sử chúng ta đang đưa ra biểu đồ này ở đây. Chúng ta phải biết từ một hai ba bốn, điều này có nguồn gốc. Đây là điểm đến và đây là trọng lượng.

5013
00:01:38,750 --> 00:01:56,510
Bây giờ chúng ta sẽ sắp xếp các độ tuổi theo cân nặng theo thứ tự tăng dần. Vì vậy, chúng tôi sắp xếp độ tuổi theo cân nặng theo thứ tự tăng dần. Một hai bốn năm. Ở đây chúng ta có không một ba hai.

5014
00:01:56,540 --> 00:02:12,880
Ở đây chúng tôi có bốn phán quyết. Bây giờ hãy xử lý cạnh này. Một hai. Hãy kết nối. Được rồi, chúng tôi. Myers, hai phán quyết này có chữ H. Vậy thì nó không dành cho tôi, chu kỳ.

5015
00:02:14,090 --> 00:02:28,610
Sau đó hãy xử lý việc này. Hai và ba. Nó được kết nối. Chúng tôi xem liệu chúng tôi có kết nối cái này với Vertex với độ tuổi mà nó hình thành theo chu kỳ để chúng tôi có thể kết nối nó hay không. Bây giờ hãy xử lý việc này.

5016
00:02:28,730 --> 00:02:40,200
Không một, được kết nối. Nó sẽ không hình thành một chu kỳ. Ở đây chúng tôi có liên quan đến gỗ. Vì vậy, với số 0, hãy cộng vào một bốn hai ba ở đây hai chín bốn không một bốn.

5017
00:02:41,060 --> 00:02:56,840
Bây giờ đối với tám không ba năm, số cũ là năm từ không đến ba. Chúng ta thấy rằng nếu chúng ta thêm tuổi vào đây thì nó sẽ tạo thành chu kỳ. Vì vậy chúng tôi không thể bao gồm độ tuổi này.

5018
00:02:57,050 --> 00:03:15,010
Chúng tôi từ chối thời đại này. Làm thế nào để từ chối một tuổi Và cách phát hiện chu kỳ sẽ phát hiện chu kỳ bằng cách sử dụng cấu trúc dữ liệu chung và bạn sẽ thấy cách tìm chu kỳ đó và cách từ chối.

5019
00:03:15,670 --> 00:03:32,170
Và bạn đi qua từng dòng mã. Bây giờ hãy xem thuật toán Cross Kelts hoạt động như thế nào. Vì các độ tuổi được sắp xếp theo trọng số tăng dần nên ta tìm được cây khung nhỏ nhất, đây là cây khung nhỏ nhất.

5020
00:03:32,500 --> 00:03:42,940
Đây là cách chúng ta có thể tìm ra. Cây khung tối thiểu sử dụng thuật toán Crossgates. Bây giờ chúng ta hãy xem. Bạn đã thực hiện chu kỳ như thế nào và làm thế nào để bạn loại bỏ tám phần tạo thành một chu kỳ?

5021
00:03:44,230 --> 00:04:03,490
Đây có phải là trang web chung của chúng tôi để cấu trúc? Đây là một mảng các nút có ghi chú có hai thuộc tính cha và cấp. Thứ hạng ban đầu bằng 0 và cha mẹ bằng 0 đối với chỉ số 0 đối với chỉ mục một, cha mẹ là một, v.v.

5022
00:04:04,210 --> 00:04:19,330
Ở đây chúng ta có tổng của tập hợp không một hai ba. Bây giờ, hãy xử lý tuổi một hai này. ĐƯỢC RỒI. Ở đây chúng ta thấy một, cha tuyệt đối của một là cha tuyệt đối của hai là hai.

5023
00:04:20,140 --> 00:04:37,210
Bạn sẽ tìm thấy hai cha mẹ tuyệt đối khác nhau, nguồn đầu tiên và đích đến. Điều đó có nghĩa là nó sẽ không hình thành một chu kỳ. Nó rất đơn giản. Được rồi, vậy hãy kết nối một và với hoạt động của đơn vị đóng chai cho hai cái này, cho một và hai.

5024
00:04:38,350 --> 00:04:49,780
Bây giờ tôi sẽ phản đối hai điều này. Và hãy tăng số không này lên một. Bây giờ ở đây chúng tôi có một. Điều đó có nghĩa là chúng ta có cha mẹ tuyệt đối trong tập hợp này.

5025
00:04:50,530 --> 00:05:05,150
Một hai. OK, bây giờ hãy xử lý tám điều này. Chúng tôi có nó hai ba. Cha mẹ tuyệt đối của hai là một cha mẹ tuyệt đối của ba là ba. Ở đây chúng ta thấy cha của hai người là một, và cha của một người là một.

5026
00:05:05,170 --> 00:05:16,600
Vậy một là số tuyệt đối kết hợp với hai, và điểm tuyệt đối của ba là ba, bởi vì ở đây chúng ta có ba. Vậy một và ba không giống nhau. Vì vậy, hãy kết nối ở đây này.

5027
00:05:17,530 --> 00:05:36,170
Vì vậy hãy cộng h hai và ba này tám ở đây. Cái nào? Ở đây chúng tôi có hai. Bây giờ, hãy nối cái này với tập một, hai và ba, điểm tuyệt đối của hai cái này là một và điểm tuyệt đối của ba.

5028
00:05:36,350 --> 00:05:54,200
Ba. Vậy bây giờ chúng ta sẽ làm gì? Chúng tôi sẽ thay thế tweet này bằng một tweet khác. Chúng tôi không cần phải tăng. Xếp hạng ở đây bởi vì chúng tôi đã xếp hạng một ở đây, chúng tôi có hướng đi này.

5029
00:05:55,610 --> 00:06:09,750
Ở đây chúng ta thấy rằng bây giờ một là điểm tuyệt đối của ba. Hãy xử lý tám không một này. Ở đây chúng ta thấy rằng điểm tuyệt đối của số 0 là điểm không tuyệt đối, một điểm là một, chúng khác nhau.

5030
00:06:09,960 --> 00:06:26,280
Vậy hãy để tôi thêm h này. Nó sẽ không tạo thành một chu trình vì liên kết tuyệt đối là khác nhau. Vậy là bây giờ bạn đã có từ dành cho diện tích. Hãy thêm điều này để nói OK.

5031
00:06:26,320 --> 00:06:38,940
Không. Và điều này nói một hai ba. Điểm tuyệt đối của tập hợp này là một phần tử của tập hợp này bằng 0. Vậy là đã được kết nối. Ở đây chúng tôi có một. Vì vậy, sẽ thay thế số 0 này bằng một.

5032
00:06:39,090 --> 00:06:53,900
Bởi vì ở đây chúng tôi có thứ hạng cao hơn. Vậy là chúng ta đã hoàn tất. Bây giờ chúng ta hãy chuyển sang thời đại tiếp theo. Hãy xử lý điểm tuyệt đối của độ tuổi này bằng 0 là một, và điểm tuyệt đối của ba là một.

5033
00:06:53,930 --> 00:07:10,420
Được rồi, vậy chúng ta tìm thấy nó là cha mẹ vắng mặt một và một, chúng ta tìm thấy nó cùng cha mẹ tuyệt đối cho số 0 và ba. Vậy nếu cộng số tuổi này lại sẽ tạo thành một chu kỳ. Chúng ta thấy rõ rằng nếu cộng số tuổi này sẽ tạo thành một chu kỳ.

5034
00:07:10,480 --> 00:07:25,470
Vì vậy sẽ từ chối độ tuổi này và xử lý lại ở đây cho Vertex. Vậy là chúng ta đã hoàn thành. Chúng tôi đã xử lý tất cả các phán quyết trong biểu đồ, vì vậy chúng tôi đã hoàn tất. Đây là cách Chris làm cho thuật toán hoạt động.

5035
00:07:26,080 --> 00:07:40,730
Bây giờ, hãy xem, đó là những gì có thể. Đây là loại mã cho thuật toán Cruz Kelts, hàm này phát triển nghiêm ngặt, không có tham số nào bên trong đây, chúng tôi đang tạo một mảng độ tuổi.

5036
00:07:41,850 --> 00:07:54,160
Những người cho vay được giảm bớt một số lợi thế. Khi đó chúng ta có kết quả bằng 0 của bạn. Bởi vì ban đầu, chúng tôi đã phản đối các lứa tuổi judo của Đại bàng hai không bốn, Đại bàng hai không.

5037
00:07:54,180 --> 00:08:08,790
Tôi đã sống trong một kết quả cộng cộng. Tôi Goldston, bạn đợi ở đây, bạn chỉ thêm tuổi mới vào kết quả đó thôi. Sau đó, ở đây chúng ta sắp xếp các độ tuổi theo thứ tự tăng dần theo trọng lượng của chúng.

5038
00:08:10,300 --> 00:08:34,340
Từ thấp đến cao đều hoạt động, nghĩa là theo thứ tự tăng dần. Sau đó, ở đây chúng ta có tập hợp con này. Tập hợp con này có nghĩa là ở đây chúng ta đang tạo một vùng gồm các nút. Vậy nó là một ghi chú, và ghi chú này có hai thuộc tính cha và một cấp bậc.

5039
00:08:35,060 --> 00:08:50,180
Độ dài của khu vực này là số đỉnh chúng ta có khu vực này, bạn chỉ cần thêm tập hợp con mới. Điều đó có nghĩa là nút mới cho tập hợp con. Sau đó, chúng tôi đang chạy luf này ở đây hoặc chèn.

5040
00:08:51,490 --> 00:09:05,620
Chà, rõ ràng ở Chỉ số V, Giá trị V và thứ hạng ban đầu bằng 0, sau đó chúng tôi đặt lại nó về 0. Và ở đây chúng ta đang chạy cái này một lúc e nhỏ hơn những gì trừ một.

5041
00:09:06,850 --> 00:09:29,580
Vì bạn sẽ có tổng số tác nhân trong cây khung, số lượng virus trừ đi một. Rồi ở đây, hiện tại là đến các quốc gia thời đại mới, hộ tống đến là các chuyến bay hạng A-plus nên chúng ta đang chọn độ tuổi hiện tại và chúng ta sẽ chuyển sang độ tuổi tiếp theo để chọn độ tuổi tiếp theo.

5042
00:09:29,880 --> 00:09:44,610
Bây giờ chúng tôi đang cố gắng tìm nó. X X có nghĩa là cha mẹ tuyệt đối của nguồn của thời đại hiện tại của chúng ta và cha mẹ tuyệt đối của đích đến, chúng ta đang lưu trữ nó vào đây.

5043
00:09:44,610 --> 00:09:57,150
Tại sao biến? Vì vậy, X và Y, nếu X và giá trị nào không bằng nhau thì bạn có thể thêm tuổi đó vào kết quả của chúng tôi mỗi lần chào đón. Chúng tôi đang theo đuổi điều này trong một chiến dịch ở giữa Lối ra Y.

5044
00:09:58,310 --> 00:10:13,970
Ngoại trừ cha mẹ tuyệt đối của nguồn gốc và đích đến của thời đại hiện tại của chúng ta là gì, và chúng ta đang chuyển nó sang thời đại tiếp theo? ĐƯỢC RỒI. Nó sẽ chỉ tới ghi chú tiếp theo ở đây chúng ta có tuổi của anh ấy.

5045
00:10:15,380 --> 00:10:39,220
Rồi chúng ta có tình yêu này bởi chút này sẽ in ra nguồn đích và nó. Đây là hoạt động cuối cùng của chúng tôi. Phải mất hai chính đối diện, và tôi épisodes khó chịu, tôi không biết đi đến tôi chỉ đệ quy gọi đệ quy này và điều kiện này được gọi là nén pad, gọi hàm này một cách đệ quy.

5046
00:10:39,220 --> 00:10:49,960
Nếu tập hợp con tôi không có bản ghi gốc. Tôi nghe nói chúng ta đang gọi hàm này là tìm tập con con hoặc tập con gốc. Chúng tôi đang gọi hàm này một cách đệ quy.

5047
00:10:50,740 --> 00:11:02,290
Điều này được gọi là nén pad. Chúng tôi chỉ gọi đây là nén pad hoặc chỉ giảm phần đệm của chúng tôi. Chúng ta sẽ xem chúng ta đã thấy như thế nào trong video trước đó.

5048
00:11:03,820 --> 00:11:19,000
Tôi nghĩ bạn sẽ đọc anh ấy. Hỗ trợ nó. Tôi là phụ huynh đó. Chúng tôi có phương pháp hợp nhất này. Cần có ba tham số được hỗ trợ X và Y. Ở đây chúng ta có, ngoại trừ x root, hãy tìm tập con x tuyệt đối.

5049
00:11:20,310 --> 00:11:34,350
Cha mẹ của X và ở đây, cha mẹ tuyệt đối của cậu bé. Chúng tôi đang kiểm tra thứ hạng trong cấp độ Tuyệt đối U. Cấp bậc của cha mẹ tuyệt đối của X nhỏ hơn cấp bậc của cha mẹ tuyệt đối của màu trắng.

5050
00:11:34,910 --> 00:11:50,830
Chúng tôi sẽ làm vậy. Sẽ đặt cha mẹ tuyệt đối của một cậu bé thành cha mẹ của tuyến đường tuyệt đối, nếu chúng ta thấy thứ hạng của cha mẹ tuyệt đối của X lớn hơn thứ hạng của cậu bé thương hiệu tuyệt đối.

5051
00:11:51,150 --> 00:12:06,180
Chúng tôi sẽ cập nhật cha mẹ tuyệt đối lên màu trắng với niềm tự hào tuyệt đối về lộ trình cha mẹ nhìn anh ấy. Nếu chúng giống nhau, thì cái này hoặc hài lòng, thì cái này có thể chạy được.

5052
00:12:06,750 --> 00:12:34,530
Chúng tôi đang thiết lập lộ trình thương hiệu tuyệt đối với tư cách là cha mẹ của những cậu bé bị dồn nén. Và ở đây, chúng tôi chỉ tăng thứ hạng của gốc tuyệt đối lên một vì thứ hạng trong lồng này giống nhau, chúng tôi phải khuyến khích xếp hạng cha mẹ tuyệt đối của chúng tôi ở đây và làm điều này với cha mẹ tuyệt đối.

5053
00:12:34,860 --> 00:12:50,070
Cha mẹ tuyệt đối của X sẽ là cấp bậc của cha mẹ tuyệt đối. Bạn đã tăng thứ hạng đang đi xuống. Bây giờ chúng ta hãy xem nó hoạt động như thế nào. Giả sử chúng tôi là bạn trong biểu đồ này và ở đây chúng tôi có độ tuổi này.

5054
00:12:50,220 --> 00:13:04,560
Chúng tôi đã thấy tám điều này. OK, chúng tôi có độ tuổi này, vì vậy chúng tôi sắp xếp nó chỉ dựa trên cân nặng của họ. Đây là tìm kiếm chung của chúng tôi do cấu trúc. Và ở đây chúng ta có bốn nút không một ba hai.

5055
00:13:05,720 --> 00:13:19,670
Vì vậy, chúng tôi đã xây dựng cái này bằng cách sử dụng nó trên anh ta. Đây là một tập hợp con và hiện tại chúng tôi có hai giao diện này ở mức 0 theo yêu cầu của độ tuổi này. Hãy xử lý nó.

5056
00:13:20,720 --> 00:13:35,000
Hãy xử lý thời đại này như nó đã diễn ra theo cách riêng của anh ấy, tuyệt đối dồn nén vào việc anh ấy làm. Chúng khác nhau nên chúng tôi có thể thu thập nó. Họ khác nhau. Chúng ta có thể phát hiện ra rằng find nó sẽ trả về một và nó cũng sẽ đọc chúng.

5057
00:13:36,140 --> 00:13:53,660
Vì vậy, hãy lấy điều kiện này mà chúng ta thấy. Một là không đi đến hai. Vậy chúng ta hãy tiếp tục chia làm hai. Bây giờ hãy thực hiện hoạt động công đoàn. Khi đọc một và hai, chúng ta thấy bản in tuyệt đối của một nằm trên nhãn hiệu tuyệt đối của vòng xoắn hai và chúng ta thấy thứ hạng giống nhau.

5058
00:13:53,660 --> 00:14:08,500
Vì vậy, chúng tôi sẽ áp dụng mã này ở đây nếu chúng tôi áp dụng mã này. Chúng tôi sẽ cập nhật quy tắc tuyệt đối này theo cách này. Đây là lý do tại sao. OK, vậy chúng ta hãy cập nhật cái này và tăng thứ hạng này lên cái gì?

5059
00:14:09,590 --> 00:14:32,010
Bây giờ hãy xử lý độ tuổi này. Được rồi, chúng ta đã xong. Nhưng tuổi này là gì? Bây giờ ở đây chúng ta thấy X bằng hai. Nghe leo thang đến cái tuyệt đối ràng buộc đến đó là người ta nghe một trong những thương hiệu tuyệt đối của mình và thương hiệu tuyệt đối của ba cây muốn không giống nhau.

5060
00:14:32,290 --> 00:14:53,610
Vậy nó sẽ nối cạnh hai và ba, hai và ba này. ĐƯỢC RỒI? Nhanh lên một cái. Vì vậy hãy thêm một. Vì vậy, kết quả tìm thấy này sẽ trả về một cho hai và nó sẽ trả về ba cho ba.

5061
00:14:54,660 --> 00:15:03,740
Được rồi, hãy xem nó được viết như thế nào. Một cho hai. Chúng ta sẽ gọi điều này là khó chịu ở Index hai. Chúng ta có cái gì cơ? Kỷ lục của hai là gì? Vậy chúng ta sẽ gọi bằng cái này ở đây, được chứ?

5062
00:15:04,530 --> 00:15:14,460
Ở đây chúng ta thấy chúng ta có một và một bằng hai một. Vì vậy, nó sẽ trả về một cái và nó sẽ cập nhật cái này. Nhưng ở đây chúng tôi đã có một. Bây giờ chúng ta hãy đọc tiếp.

5063
00:15:15,540 --> 00:15:30,370
ĐƯỢC RỒI? Đây là cách cái này sẽ đọc trong một. Bây giờ chúng ta đã hoàn tất. Được rồi, hãy thêm trợ giúp này vào kết quả này. Điều đó có nghĩa là chúng ta kết nối số tám này và nó là hai. Chúng tôi chỉ đang lưu trữ H theo thứ tự ở đây.

5064
00:15:30,540 --> 00:15:45,870
Kết quả này mọi lúc mọi nơi. Hãy gọi sự kết hợp này là một và ba. Chúng tôi gọi nó. Chúng tôi gọi nó là một trong ba. Ở đây chúng ta thấy tình trạng này. ĐƯỢC RỒI? Tuyệt đối dồn nén lên đến là một thương hiệu tuyệt đối của ba.

5065
00:15:47,720 --> 00:16:02,490
Ba. Vì thế. Ở đây chúng ta thấy thứ hạng bằng một. ĐƯỢC RỒI. Lúc đầu, chúng tôi có hạng một và ở đây, bạn biết đấy, vì vậy. Vì vậy, chúng tôi phải thừa nhận điều này rõ ràng, chúng tôi muốn hãy cập nhật phát triển bằng một.

5066
00:16:03,390 --> 00:16:14,010
Vậy là chúng ta đã hoàn tất. Hãy chuyển sang giai đoạn tiếp theo. Đây là lần tiếp theo của chúng tôi. Nó là số không. Đó là một trong những số không tuyệt đối. Điểm tuyệt đối của một là một.

5067
00:16:15,120 --> 00:16:31,050
Họ khác nhau. Vì vậy, hãy thêm tuổi này vào kết quả của chúng tôi. Được rồi. Điều đó có nghĩa là chúng ta sẽ tạo ra thời đại không và một này. Hãy sửa lại độ tuổi này. Ở đây chúng tôi cũng có những lời kêu gọi quan trọng đối với việc chúng ta hãy gọi sự kết hợp này bằng.

5068
00:16:32,340 --> 00:16:44,970
Bạn biết đấy, và một người ở đây chúng tôi có raggi đi đến một người để phê duyệt việc này, 081 sẽ chuyển từ cấp bậc thấp hơn sang thuê những người như thế này, được chứ? Đây là sự thật tuyệt đối.

5069
00:16:47,460 --> 00:17:03,140
Vì vậy, bây giờ chúng ta đã hoàn thành, hãy chuyển sang thời đại tiếp theo ở đây, điểm 0 đa dạng này là một nhãn hiệu tuyệt đối của cây là một. Chúng là DCIM, vì vậy chúng tôi sẽ chưa thêm S vào kết quả của mình.

5070
00:17:03,150 --> 00:17:15,090
Điều đó có nghĩa là chúng ta không được kết nối bởi vì nếu chúng ta được kết nối, nó sẽ tạo thành một vòng tuần hoàn. Đây là cách chúng ta có thể phát hiện một chu kỳ và đó chỉ là một trò đùa. Chúng tôi không thể từ chối ID tạo thành một chu kỳ.

5071
00:17:16,080 --> 00:17:27,100
Bây giờ chúng tôi đã xử lý bốn phán quyết, vậy là chúng tôi đã hoàn tất. Đây là cách thực hiện. Thuật toán Chris Kelts này hoạt động. Bây giờ, hãy lấy một ví dụ khác để hiểu rõ hơn.

5072
00:17:28,420 --> 00:17:41,860
Hãy xem. Chúng ta đang đưa ra biểu đồ này và chúng ta có độ tuổi ở đây và chúng ta đã sắp xếp độ tuổi theo thứ tự tăng dần. Và chúng ta có diện tích này, đây là diện tích tập hợp con của chúng ta.

5073
00:17:43,300 --> 00:17:56,350
Chúng tôi xây dựng cái này đang sử dụng cái này để anh ấy làm theo. Bây giờ tôi đã đến với bạn. Vậy thì số trừ này là bao nhiêu? Ở đây chúng ta có tổng cộng sáu điểm so với cạnh hiện tại của chúng ta.

5074
00:17:56,350 --> 00:18:09,760
Đây có phải là tám không? Ở đây chúng tôi có sáu bản án. Đây là tuổi hiện tại của bạn. Nhanh lên số không và một số không tuyệt đối. Tuyệt đối bị đốt cháy. Một là một. Họ không giống nhau.

5075
00:18:09,760 --> 00:18:31,100
Vì vậy, hãy kết nối một và không không và một ở đây. Và bây giờ một cái là gì? Hãy kết nối chúng bằng cách sử dụng liên minh này. Phụ huynh cùng trường bắt cóc phụ huynh tại sao lại thế này?

5076
00:18:31,430 --> 00:18:44,600
Đây là điều luôn luôn như vậy, hãy thừa nhận nó. Đó là, bạn biết đấy, và hãy cập nhật điều này với một cái. Nhưng công thức này, vì thứ hạng đều giống nhau. Bây giờ chúng ta hãy chuyển sang phần tiếp theo.

5077
00:18:45,740 --> 00:18:57,980
Đây là tám tiếp theo. Chúng tôi đã thêm hỗ trợ này vào khu vực kết quả này. Được rồi, chúng tôi ở đây chỉ cho bạn thấy cách biểu diễn logic. Bây giờ ở đây chúng tôi có một.

5078
00:18:58,790 --> 00:19:11,630
Số bị đốt cháy tuyệt đối bằng không. Điểm tuyệt đối của ba là ba. Họ không giống nhau. Vì vậy, hãy kết nối một và ba, một và ba. Được rồi, chúng ta đã kết nối ở đây một và ba.

5079
00:19:11,990 --> 00:19:24,200
Oit là một. Bây giờ hãy kết nối một và ba. Đó là điểm của một bằng không. Và đây là ba. Chúng tôi có thứ hạng cao tùy ý bằng không. Nhưng cái này?

5080
00:19:24,370 --> 00:19:39,050
OK, theo phần mềm công thức này thì cha mẹ bằng Xer vì ở đây chúng ta có thứ hạng cao hơn ở đây. Nếu thuê một người, có nghĩa là đây là điều tuyệt đối. Phụ huynh trong bộ này.

5081
00:19:40,160 --> 00:19:57,170
Vì vậy, chúng tôi đã thêm điều này. Đây là ghế ở Detroit. Đây là cách ngồi chung. Vì vậy chúng tôi đã thêm mặt này vào chỗ ngồi này. Bây giờ chúng ta hãy chuyển sang tám phần tiếp theo. Đây là lần tiếp theo của chúng tôi và đối với thương hiệu tuyệt đối là thương hiệu tuyệt đối của bốn là dành cho sự khác biệt.

5082
00:19:57,180 --> 00:20:14,000
Vì vậy, hãy cam kết hai và bốn. Ở đây chúng ta thấy cái gì là một. Vì vậy, hãy thêm vào đây một. Bây giờ hãy gọi sự kết hợp này là hai và bốn. Ở đây chúng ta thấy rằng.

5083
00:20:15,560 --> 00:20:30,100
Tại The Sims Abbott ở đây theo cách này, à, điều đó có nghĩa là nhãn hiệu tuyệt đối của màu trắng với X. Tôi gần như là cha mẹ của X. Tôi sẽ tăng số 0 này từ 0 lên một.

5084
00:20:31,450 --> 00:20:46,480
Vậy là chúng ta đã hoàn tất. Chúng tôi đã thêm lịch sử ngay trong khu vực dành riêng này và chúng tôi chỉ hiển thị cho bạn cách trình bày logic. Bây giờ hãy xử lý việc này. Tám không đến điểm tuyệt đối của không không thương hiệu tuyệt đối, tối đa là hai.

5085
00:20:47,020 --> 00:21:01,870
Vì vậy, chúng ta có thể kết nối ở đây số không và số hai. Hãy kết nối số 0 và số 2 ở đây với số 2. Bây giờ hãy gọi nó là sự kết hợp của số 0 và hai số 0 và hai, chúng ta có cùng thứ hạng.

5086
00:21:02,080 --> 00:21:15,110
Vì vậy, hãy thay thế hai số này bằng 0 và bạn sẽ tăng thứ hạng này từ một lên. ĐẾN. Chúng tôi cũng có Frank ở đây. Nó có nghĩa rằng đây là cha mẹ tuyệt đối của chúng ta đối với trạng thái này.

5087
00:21:15,860 --> 00:21:27,030
Đây không phải là nó, và ở đây chúng ta đã rời rạc. Bây giờ chúng tôi vẫn chưa tham gia lại nó. Hai và ba. Số mở tuyệt đối cho một số 0 vắng mặt cha mẹ của ba là số không.

5088
00:21:27,050 --> 00:21:40,880
Họ quyết định như vậy nếu chúng ta cộng hai và ba thì sẽ tạo thành một chu trình. Chúng ta thấy rõ ở đây tám này thì nó sẽ hình thành một chu kỳ ở đây. Vậy nó không phải lúc thảo luận tám năm này là gì?

5089
00:21:42,540 --> 00:21:55,070
Bây giờ, hãy xử lý việc này. Bây giờ, hãy xử lý độ tuổi này ở đây, được chứ? Chúng ta không cần phải tuân theo công đoàn vì ở đây chúng ta không phải xin công đoàn, vì ở đây chúng ta không có tuổi tác.

5090
00:21:55,410 --> 00:22:05,880
Chúng tôi đã từ chối thời đại này. Bây giờ đây là hiện tại của bạn là ba và bốn. ĐƯỢC RỒI? Bạn có ba và bốn. Dải tuyệt đối của ba số không, dải tuyệt đối của bốn là hai.

5091
00:22:05,940 --> 00:22:21,060
Họ khác nhau. Thực ra không có gì khác biệt. Cha mẹ của bốn bằng cha mẹ của hai không không không. Vì vậy, số 0 này sẽ xuất hiện bằng 0 và sau đó chúng tôi sẽ cập nhật số 0 này thành 0.

5092
00:22:21,450 --> 00:22:32,700
Điều này được gọi là nén hiệp ước và nó sẽ trả về cái này, nó sẽ trả về 0 cho bốn. Vậy chúng ta thấy bốn, ba và bốn. Nếu chúng ta kết nối, nó sẽ tạo thành một vòng tuần hoàn.

5093
00:22:33,390 --> 00:22:47,880
Nó sẽ tạo thành một chu kỳ của anh ta. Nếu bạn kết nối ba và bốn, nó sẽ tạo thành một chu kỳ, vì vậy bạn sẽ bác bỏ tuổi này. Bây giờ chúng ta hãy tiến về phía trước. Bây giờ, hãy xử lý h một và hai ở đây, được chứ?

5094
00:22:48,750 --> 00:23:03,990
Panda tuyệt đối một là thương hiệu tuyệt đối bằng không. Vì vậy hãy bỏ qua độ tuổi này. Hãy tiến về phía trước. Một và bốn thương tuyệt đối của một là số không thương hiệu tuyệt đối của bốn số không mà chúng ta thêm một vào bốn sẽ tạo thành một chu kỳ.

5095
00:23:03,990 --> 00:23:21,660
Chúng tôi cũng thấy rõ điều đó ở độ tuổi này. Quảng cáo muốn thông báo một chu kỳ. Vì vậy, đó là những gì chúng ta bỏ qua thời đại đó. Bạn có thấy cách chúng ta sử dụng bộ khớp để phát hiện chu trình và loại bỏ tám phần tạo thành một chu trình không?

5096
00:23:22,170 --> 00:23:36,040
Hy vọng bạn hiểu. Bây giờ hãy xử lý độ tuổi bốn và năm điểm tuyệt đối của bốn số 0 và dải tuyệt đối của năm là năm. Vì vậy, hãy kết nối cái này với Vertex ở đây.

5097
00:23:36,080 --> 00:23:52,980
Hãy cộng số tuổi này là 4 và 5. Ở đây chúng ta có nó là ba. Bây giờ hãy gọi sự kết hợp này là năm và không. Ở đây chúng ta thấy rằng năm và không điểm tuyệt đối của bốn không dải tuyệt đối của năm là năm.

5098
00:23:53,970 --> 00:24:05,970
Vì vậy, họ khác nhau. Và ở đây chúng ta thấy thứ hạng cao hơn. Đây là thứ hạng cao hơn. Điểm tuyệt đối của việc có thứ hạng cao hơn. Vì vậy, tôi phá vỡ năm điều này với giá trị này.

5099
00:24:05,970 --> 00:24:19,050
Không. Vậy là chúng ta đã hoàn tất. Bây giờ chúng ta hãy chuyển sang phần tiếp theo. Đây là độ tuổi tiếp theo của bạn. Ba. Năm Thương hiệu tuyệt đối của số không thương hiệu tuyệt đối của năm số không. Vì thế chúng cùng slot sẽ không cộng thêm tuổi đó.

5100
00:24:19,650 --> 00:24:33,720
Chúng ta đã xong. Chúng tôi không còn độ tuổi nào ở đây nữa nên chúng tôi đã xử lý tất cả các độ tuổi. Chúng tôi phát hiện ra đây là cây bao trùm. Đây là một cây bao trùm. Chúng tôi tìm thấy nó bằng thuật toán Chris Kilts.

5101
00:24:33,780 --> 00:24:57,870
Đây được gọi là thuật toán Chris Kelts. Ở đây, chúng tôi đang sử dụng cấu trúc dữ liệu chung để phát hiện một chu trình và loại bỏ cấu trúc có thể hình thành một chu trình. Được hiểu rõ, thuật toán quan trọng của Chris và cách chúng tôi đang sử dụng kết hợp với thuật toán Chris Kelts, người đã hiểu thuật toán này sớm vì bạn ghi lại độ phức tạp về thời gian của VE.

5102
00:24:58,170 --> 00:25:17,970
Nhật ký này trước đây là Trang web chung và ở đây chúng tôi có những nhật ký này dành cho một số độ tuổi V cho một số bên. Được rồi, được rồi, ở đây chúng ta cần hiểu độ phức tạp về không gian cho vùng tập hợp con này và cho vùng kết quả này, nơi chúng ta hiểu cách hoạt động của thuật toán xe đẩy ở đây.

5103
00:25:17,970 --> 00:25:32,250
Thuật toán sắp xếp này chỉ lấy e log mỗi lần độ phức tạp, vì vậy chúng ta nên tuân thủ e log e để thuật toán này hoặc lấy tổng e log v cộng e xem độ phức tạp thời gian và độ phức tạp ai hiểu thuật toán của Chris.